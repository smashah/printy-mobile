var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value2) => __defProp(target, "name", { value: value2, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a4, b3) => (typeof require !== "undefined" ? require : a4)[b3]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from4, except, desc) => {
  if (from4 && typeof from4 === "object" || typeof from4 === "function") {
    for (let key of __getOwnPropNames(from4))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from4[key], enumerable: !(desc = __getOwnPropDesc(from4, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedAsync(name) {
  const fn = /* @__PURE__ */ notImplemented(name);
  fn.__promisify__ = () => /* @__PURE__ */ notImplemented(name + ".__promisify__");
  fn.native = fn;
  return fn;
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedAsync, "notImplementedAsync");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance2;
var init_performance = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options) {
        this.name = name;
        this.startTime = options?.startTime || _performanceNow();
        this.detail = options?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type2) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e4) => e4.name !== markName) : this._entries.filter((e4) => e4.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e4) => e4.name !== measureName) : this._entries.filter((e4) => e4.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e4) => e4.entryType !== "resource" || e4.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type2) {
        return this._entries.filter((e4) => e4.name === name && (!type2 || e4.entryType === type2));
      }
      getEntriesByType(type2) {
        return this._entries.filter((e4) => e4.entryType === type2);
      }
      mark(name, options) {
        const entry = new PerformanceMark(name, options);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start2;
        let end2;
        if (typeof startOrMeasureOptions === "string") {
          start2 = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end2 = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start2 = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end2 = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start2,
          detail: {
            start: start2,
            end: end2
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type2, listener, options) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type2, listener, options) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance2 = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// ../../node_modules/.pnpm/@cloudflare+unenv-preset@2.7.10_unenv@2.0.0-rc.24_workerd@1.20251113.0/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "../../node_modules/.pnpm/@cloudflare+unenv-preset@2.7.10_unenv@2.0.0-rc.24_workerd@1.20251113.0/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance2;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// ../../node_modules/.pnpm/@cloudflare+unenv-preset@2.7.10_unenv@2.0.0-rc.24_workerd@1.20251113.0/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "../../node_modules/.pnpm/@cloudflare+unenv-preset@2.7.10_unenv@2.0.0-rc.24_workerd@1.20251113.0/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// ../../node_modules/.pnpm/wrangler@4.49.0_@cloudflare+workers-types@4.20250906.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "../../node_modules/.pnpm/wrangler@4.49.0_@cloudflare+workers-types@4.20250906.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime3) {
      const now = Date.now();
      const seconds = Math.trunc(now / 1e3);
      const nanos = now % 1e3 * 1e6;
      if (startTime3) {
        let diffSeconds = seconds - startTime3[0];
        let diffNanos = nanos - startTime3[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir3, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y3, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env4) {
        return 1;
      }
      hasColors(count3, env4) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value2 = this[prop];
          if (typeof value2 === "function") {
            this[prop] = value2.bind(this);
          }
        }
      }
      // --- event emitter ---
      emitWarning(warning, type2, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type2 ? `${type2}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      // --- stdio (lazy initializers) ---
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      // --- cwd ---
      #cwd = "/";
      chdir(cwd4) {
        this.#cwd = cwd4;
      }
      cwd() {
        return this.#cwd;
      }
      // --- dummy props and getters ---
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      // --- noop methods ---
      ref() {
      }
      unref() {
      }
      // --- unimplemented methods ---
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      // --- attached interfaces ---
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      // --- undefined props ---
      mainModule = void 0;
      domain = void 0;
      // optional
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      // internals
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// ../../node_modules/.pnpm/@cloudflare+unenv-preset@2.7.10_unenv@2.0.0-rc.24_workerd@1.20251113.0/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, workerdProcess, isWorkerdProcessV2, unenvProcess, exit, features, platform, env, hrtime3, nextTick, _channel, _disconnect, _events, _eventsCount, _handleQueue, _maxListeners, _pendingMessage, _send, assert2, disconnect, mainModule, _debugEnd, _debugProcess, _exiting, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _linkedBinding, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, abort, addListener, allowedNodeEnvironmentFlags, arch, argv, argv0, availableMemory, binding, channel, chdir, config, connected, constrainedMemory, cpuUsage, cwd, debugPort, dlopen, domain, emit, emitWarning, eventNames, execArgv, execPath, exitCode, finalization, getActiveResourcesInfo, getegid, geteuid, getgid, getgroups, getMaxListeners, getuid, hasUncaughtExceptionCaptureCallback, initgroups, kill, listenerCount, listeners, loadEnvFile, memoryUsage, moduleLoadList, off, on, once, openStdin, permission, pid, ppid, prependListener, prependOnceListener, rawListeners, reallyExit, ref, release, removeAllListeners, removeListener, report, resourceUsage, send, setegid, seteuid, setgid, setgroups, setMaxListeners, setSourceMapsEnabled, setuid, setUncaughtExceptionCaptureCallback, sourceMapsEnabled, stderr, stdin, stdout, throwDeprecation, title, traceDeprecation, umask, unref, uptime, version, versions, _process, process_default;
var init_process2 = __esm({
  "../../node_modules/.pnpm/@cloudflare+unenv-preset@2.7.10_unenv@2.0.0-rc.24_workerd@1.20251113.0/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    workerdProcess = getBuiltinModule("node:process");
    isWorkerdProcessV2 = globalThis.Cloudflare.compatibilityFlags.enable_nodejs_process_v2;
    unenvProcess = new Process({
      env: globalProcess.env,
      // `hrtime` is only available from workerd process v2
      hrtime: isWorkerdProcessV2 ? workerdProcess.hrtime : hrtime,
      // `nextTick` is available from workerd process v1
      nextTick: workerdProcess.nextTick
    });
    ({ exit, features, platform } = workerdProcess);
    ({
      env: (
        // Always implemented by workerd
        env
      ),
      hrtime: (
        // Only implemented in workerd v2
        hrtime3
      ),
      nextTick: (
        // Always implemented by workerd
        nextTick
      )
    } = unenvProcess);
    ({
      _channel,
      _disconnect,
      _events,
      _eventsCount,
      _handleQueue,
      _maxListeners,
      _pendingMessage,
      _send,
      assert: assert2,
      disconnect,
      mainModule
    } = unenvProcess);
    ({
      _debugEnd: (
        // @ts-expect-error `_debugEnd` is missing typings
        _debugEnd
      ),
      _debugProcess: (
        // @ts-expect-error `_debugProcess` is missing typings
        _debugProcess
      ),
      _exiting: (
        // @ts-expect-error `_exiting` is missing typings
        _exiting
      ),
      _fatalException: (
        // @ts-expect-error `_fatalException` is missing typings
        _fatalException
      ),
      _getActiveHandles: (
        // @ts-expect-error `_getActiveHandles` is missing typings
        _getActiveHandles
      ),
      _getActiveRequests: (
        // @ts-expect-error `_getActiveRequests` is missing typings
        _getActiveRequests
      ),
      _kill: (
        // @ts-expect-error `_kill` is missing typings
        _kill
      ),
      _linkedBinding: (
        // @ts-expect-error `_linkedBinding` is missing typings
        _linkedBinding
      ),
      _preload_modules: (
        // @ts-expect-error `_preload_modules` is missing typings
        _preload_modules
      ),
      _rawDebug: (
        // @ts-expect-error `_rawDebug` is missing typings
        _rawDebug
      ),
      _startProfilerIdleNotifier: (
        // @ts-expect-error `_startProfilerIdleNotifier` is missing typings
        _startProfilerIdleNotifier
      ),
      _stopProfilerIdleNotifier: (
        // @ts-expect-error `_stopProfilerIdleNotifier` is missing typings
        _stopProfilerIdleNotifier
      ),
      _tickCallback: (
        // @ts-expect-error `_tickCallback` is missing typings
        _tickCallback
      ),
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      arch,
      argv,
      argv0,
      availableMemory,
      binding: (
        // @ts-expect-error `binding` is missing typings
        binding
      ),
      channel,
      chdir,
      config,
      connected,
      constrainedMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      domain: (
        // @ts-expect-error `domain` is missing typings
        domain
      ),
      emit,
      emitWarning,
      eventNames,
      execArgv,
      execPath,
      exitCode,
      finalization,
      getActiveResourcesInfo,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getMaxListeners,
      getuid,
      hasUncaughtExceptionCaptureCallback,
      initgroups: (
        // @ts-expect-error `initgroups` is missing typings
        initgroups
      ),
      kill,
      listenerCount,
      listeners,
      loadEnvFile,
      memoryUsage,
      moduleLoadList: (
        // @ts-expect-error `moduleLoadList` is missing typings
        moduleLoadList
      ),
      off,
      on,
      once,
      openStdin: (
        // @ts-expect-error `openStdin` is missing typings
        openStdin
      ),
      permission,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      reallyExit: (
        // @ts-expect-error `reallyExit` is missing typings
        reallyExit
      ),
      ref,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      send,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setMaxListeners,
      setSourceMapsEnabled,
      setuid,
      setUncaughtExceptionCaptureCallback,
      sourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      throwDeprecation,
      title,
      traceDeprecation,
      umask,
      unref,
      uptime,
      version,
      versions
    } = isWorkerdProcessV2 ? workerdProcess : unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// ../../node_modules/.pnpm/wrangler@4.49.0_@cloudflare+workers-types@4.20250906.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "../../node_modules/.pnpm/wrangler@4.49.0_@cloudflare+workers-types@4.20250906.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// ../../node_modules/.pnpm/wrangler@4.49.0_@cloudflare+workers-types@4.20250906.0/node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "../../node_modules/.pnpm/wrangler@4.49.0_@cloudflare+workers-types@4.20250906.0/node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// ../../node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react.production.js
var require_react_production = __commonJS({
  "../../node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react.production.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    __name(getIteratorFn, "getIteratorFn");
    var ReactNoopUpdateQueue = {
      isMounted: /* @__PURE__ */ __name(function() {
        return false;
      }, "isMounted"),
      enqueueForceUpdate: /* @__PURE__ */ __name(function() {
      }, "enqueueForceUpdate"),
      enqueueReplaceState: /* @__PURE__ */ __name(function() {
      }, "enqueueReplaceState"),
      enqueueSetState: /* @__PURE__ */ __name(function() {
      }, "enqueueSetState")
    };
    var assign = Object.assign;
    var emptyObject = {};
    function Component(props, context2, updater) {
      this.props = props;
      this.context = context2;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    __name(Component, "Component");
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    function ComponentDummy() {
    }
    __name(ComponentDummy, "ComponentDummy");
    ComponentDummy.prototype = Component.prototype;
    function PureComponent(props, context2, updater) {
      this.props = props;
      this.context = context2;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    __name(PureComponent, "PureComponent");
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    var isArrayImpl = Array.isArray;
    function noop4() {
    }
    __name(noop4, "noop");
    var ReactSharedInternals = { H: null, A: null, T: null, S: null };
    var hasOwnProperty3 = Object.prototype.hasOwnProperty;
    function ReactElement(type2, key, props) {
      var refProp = props.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type2,
        key,
        ref: void 0 !== refProp ? refProp : null,
        props
      };
    }
    __name(ReactElement, "ReactElement");
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement(oldElement.type, newKey, oldElement.props);
    }
    __name(cloneAndReplaceKey, "cloneAndReplaceKey");
    function isValidElement(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    __name(isValidElement, "isValidElement");
    function escape2(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match2) {
        return escaperLookup[match2];
      });
    }
    __name(escape2, "escape");
    var userProvidedKeyEscapeRegex = /\/+/g;
    function getElementKey(element, index2) {
      return "object" === typeof element && null !== element && null != element.key ? escape2("" + element.key) : index2.toString(36);
    }
    __name(getElementKey, "getElementKey");
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop4, noop4) : (thenable.status = "pending", thenable.then(
            function(fulfilledValue) {
              "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
            },
            function(error3) {
              "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error3);
            }
          )), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    __name(resolveThenable, "resolveThenable");
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type2 = typeof children;
      if ("undefined" === type2 || "boolean" === type2) children = null;
      var invokeCallback = false;
      if (null === children) invokeCallback = true;
      else
        switch (type2) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(
                  invokeCallback(children._payload),
                  array,
                  escapedPrefix,
                  nameSoFar,
                  callback
                );
            }
        }
      if (invokeCallback)
        return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c2) {
          return c2;
        })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
          callback,
          escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
            userProvidedKeyEscapeRegex,
            "$&/"
          ) + "/") + invokeCallback
        )), array.push(callback)), 1;
      invokeCallback = 0;
      var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i2 = 0; i2 < children.length; i2++)
          nameSoFar = children[i2], type2 = nextNamePrefix + getElementKey(nameSoFar, i2), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type2,
            callback
          );
      else if (i2 = getIteratorFn(children), "function" === typeof i2)
        for (children = i2.call(children), i2 = 0; !(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type2 = nextNamePrefix + getElementKey(nameSoFar, i2++), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type2,
            callback
          );
      else if ("object" === type2) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    __name(mapIntoArray, "mapIntoArray");
    function mapChildren(children, func, context2) {
      if (null == children) return children;
      var result = [], count3 = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context2, child, count3++);
      });
      return result;
    }
    __name(mapChildren, "mapChildren");
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function(moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 1, payload._result = moduleObject;
          },
          function(error3) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 2, payload._result = error3;
          }
        );
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status) return payload._result.default;
      throw payload._result;
    }
    __name(lazyInitializer, "lazyInitializer");
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error3) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error3 && null !== error3 && "string" === typeof error3.message ? String(error3.message) : String(error3),
          error: error3
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error3);
        return;
      }
      console.error(error3);
    };
    var Children = {
      map: mapChildren,
      forEach: /* @__PURE__ */ __name(function(children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function() {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      }, "forEach"),
      count: /* @__PURE__ */ __name(function(children) {
        var n5 = 0;
        mapChildren(children, function() {
          n5++;
        });
        return n5;
      }, "count"),
      toArray: /* @__PURE__ */ __name(function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      }, "toArray"),
      only: /* @__PURE__ */ __name(function(children) {
        if (!isValidElement(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }, "only")
    };
    exports.Activity = REACT_ACTIVITY_TYPE;
    exports.Children = Children;
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.__COMPILER_RUNTIME = {
      __proto__: null,
      c: /* @__PURE__ */ __name(function(size) {
        return ReactSharedInternals.H.useMemoCache(size);
      }, "c")
    };
    exports.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    exports.cacheSignal = function() {
      return null;
    };
    exports.cloneElement = function(element, config4, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " + element + "."
        );
      var props = assign({}, element.props), key = element.key;
      if (null != config4)
        for (propName in void 0 !== config4.key && (key = "" + config4.key), config4)
          !hasOwnProperty3.call(config4, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config4.ref || (props[propName] = config4[propName]);
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        for (var childArray = Array(propName), i2 = 0; i2 < propName; i2++)
          childArray[i2] = arguments[i2 + 2];
        props.children = childArray;
      }
      return ReactElement(element.type, key, props);
    };
    exports.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      return defaultValue;
    };
    exports.createElement = function(type2, config4, children) {
      var propName, props = {}, key = null;
      if (null != config4)
        for (propName in void 0 !== config4.key && (key = "" + config4.key), config4)
          hasOwnProperty3.call(config4, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config4[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) props.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), i2 = 0; i2 < childrenLength; i2++)
          childArray[i2] = arguments[i2 + 2];
        props.children = childArray;
      }
      if (type2 && type2.defaultProps)
        for (propName in childrenLength = type2.defaultProps, childrenLength)
          void 0 === props[propName] && (props[propName] = childrenLength[propName]);
      return ReactElement(type2, key, props);
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(render3) {
      return { $$typeof: REACT_FORWARD_REF_TYPE, render: render3 };
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    exports.memo = function(type2, compare9) {
      return {
        $$typeof: REACT_MEMO_TYPE,
        type: type2,
        compare: void 0 === compare9 ? null : compare9
      };
    };
    exports.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop4, reportGlobalError);
      } catch (error3) {
        reportGlobalError(error3);
      } finally {
        null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    };
    exports.unstable_useCacheRefresh = function() {
      return ReactSharedInternals.H.useCacheRefresh();
    };
    exports.use = function(usable) {
      return ReactSharedInternals.H.use(usable);
    };
    exports.useActionState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useActionState(action, initialState, permalink);
    };
    exports.useCallback = function(callback, deps) {
      return ReactSharedInternals.H.useCallback(callback, deps);
    };
    exports.useContext = function(Context2) {
      return ReactSharedInternals.H.useContext(Context2);
    };
    exports.useDebugValue = function() {
    };
    exports.useDeferredValue = function(value2, initialValue) {
      return ReactSharedInternals.H.useDeferredValue(value2, initialValue);
    };
    exports.useEffect = function(create, deps) {
      return ReactSharedInternals.H.useEffect(create, deps);
    };
    exports.useEffectEvent = function(callback) {
      return ReactSharedInternals.H.useEffectEvent(callback);
    };
    exports.useId = function() {
      return ReactSharedInternals.H.useId();
    };
    exports.useImperativeHandle = function(ref2, create, deps) {
      return ReactSharedInternals.H.useImperativeHandle(ref2, create, deps);
    };
    exports.useInsertionEffect = function(create, deps) {
      return ReactSharedInternals.H.useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function(create, deps) {
      return ReactSharedInternals.H.useLayoutEffect(create, deps);
    };
    exports.useMemo = function(create, deps) {
      return ReactSharedInternals.H.useMemo(create, deps);
    };
    exports.useOptimistic = function(passthrough, reducer) {
      return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function(reducer, initialArg, init4) {
      return ReactSharedInternals.H.useReducer(reducer, initialArg, init4);
    };
    exports.useRef = function(initialValue) {
      return ReactSharedInternals.H.useRef(initialValue);
    };
    exports.useState = function(initialState) {
      return ReactSharedInternals.H.useState(initialState);
    };
    exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return ReactSharedInternals.H.useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    exports.useTransition = function() {
      return ReactSharedInternals.H.useTransition();
    };
    exports.version = "19.2.0";
  }
});

// ../../node_modules/.pnpm/react@19.2.0/node_modules/react/index.js
var require_react = __commonJS({
  "../../node_modules/.pnpm/react@19.2.0/node_modules/react/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (true) {
      module.exports = require_react_production();
    } else {
      module.exports = null;
    }
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/npm/inherits.mjs
var inherits_exports = {};
__export(inherits_exports, {
  default: () => inherits_default
});
import { inherits } from "node:util";
var inherits_default;
var init_inherits = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/npm/inherits.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    inherits_default = inherits;
  }
});

// required-unenv-alias:inherits
var require_inherits = __commonJS({
  "required-unenv-alias:inherits"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_inherits();
    module.exports = Object.entries(inherits_exports).filter(([k3]) => k3 !== "default").reduce(
      (cjs, [k3, value2]) => Object.defineProperty(cjs, k3, { value: value2, enumerable: true }),
      "default" in inherits_exports ? inherits_default : {}
    );
  }
});

// node-built-in-modules:events
import libDefault from "events";
var require_events = __commonJS({
  "node-built-in-modules:events"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault;
  }
});

// ../../node_modules/.pnpm/queue@6.0.2/node_modules/queue/index.js
var require_queue = __commonJS({
  "../../node_modules/.pnpm/queue@6.0.2/node_modules/queue/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inherits4 = require_inherits();
    var EventEmitter4 = require_events().EventEmitter;
    module.exports = Queue;
    module.exports.default = Queue;
    function Queue(options) {
      if (!(this instanceof Queue)) {
        return new Queue(options);
      }
      EventEmitter4.call(this);
      options = options || {};
      this.concurrency = options.concurrency || Infinity;
      this.timeout = options.timeout || 0;
      this.autostart = options.autostart || false;
      this.results = options.results || null;
      this.pending = 0;
      this.session = 0;
      this.running = false;
      this.jobs = [];
      this.timers = {};
    }
    __name(Queue, "Queue");
    inherits4(Queue, EventEmitter4);
    var arrayMethods = [
      "pop",
      "shift",
      "indexOf",
      "lastIndexOf"
    ];
    arrayMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        return Array.prototype[method].apply(this.jobs, arguments);
      };
    });
    Queue.prototype.slice = function(begin, end2) {
      this.jobs = this.jobs.slice(begin, end2);
      return this;
    };
    Queue.prototype.reverse = function() {
      this.jobs.reverse();
      return this;
    };
    var arrayAddMethods = [
      "push",
      "unshift",
      "splice"
    ];
    arrayAddMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        var methodResult = Array.prototype[method].apply(this.jobs, arguments);
        if (this.autostart) {
          this.start();
        }
        return methodResult;
      };
    });
    Object.defineProperty(Queue.prototype, "length", {
      get: /* @__PURE__ */ __name(function() {
        return this.pending + this.jobs.length;
      }, "get")
    });
    Queue.prototype.start = function(cb) {
      if (cb) {
        callOnErrorOrEnd.call(this, cb);
      }
      this.running = true;
      if (this.pending >= this.concurrency) {
        return;
      }
      if (this.jobs.length === 0) {
        if (this.pending === 0) {
          done3.call(this);
        }
        return;
      }
      var self2 = this;
      var job = this.jobs.shift();
      var once6 = true;
      var session = this.session;
      var timeoutId = null;
      var didTimeout = false;
      var resultIndex = null;
      var timeout = job.hasOwnProperty("timeout") ? job.timeout : this.timeout;
      function next(err2, result) {
        if (once6 && self2.session === session) {
          once6 = false;
          self2.pending--;
          if (timeoutId !== null) {
            delete self2.timers[timeoutId];
            clearTimeout(timeoutId);
          }
          if (err2) {
            self2.emit("error", err2, job);
          } else if (didTimeout === false) {
            if (resultIndex !== null) {
              self2.results[resultIndex] = Array.prototype.slice.call(arguments, 1);
            }
            self2.emit("success", result, job);
          }
          if (self2.session === session) {
            if (self2.pending === 0 && self2.jobs.length === 0) {
              done3.call(self2);
            } else if (self2.running) {
              self2.start();
            }
          }
        }
      }
      __name(next, "next");
      if (timeout) {
        timeoutId = setTimeout(function() {
          didTimeout = true;
          if (self2.listeners("timeout").length > 0) {
            self2.emit("timeout", next, job);
          } else {
            next();
          }
        }, timeout);
        this.timers[timeoutId] = timeoutId;
      }
      if (this.results) {
        resultIndex = this.results.length;
        this.results[resultIndex] = null;
      }
      this.pending++;
      self2.emit("start", job);
      var promise = job(next);
      if (promise && promise.then && typeof promise.then === "function") {
        promise.then(function(result) {
          return next(null, result);
        }).catch(function(err2) {
          return next(err2 || true);
        });
      }
      if (this.running && this.jobs.length > 0) {
        this.start();
      }
    };
    Queue.prototype.stop = function() {
      this.running = false;
    };
    Queue.prototype.end = function(err2) {
      clearTimers.call(this);
      this.jobs.length = 0;
      this.pending = 0;
      done3.call(this, err2);
    };
    function clearTimers() {
      for (var key in this.timers) {
        var timeoutId = this.timers[key];
        delete this.timers[key];
        clearTimeout(timeoutId);
      }
    }
    __name(clearTimers, "clearTimers");
    function callOnErrorOrEnd(cb) {
      var self2 = this;
      this.on("error", onerror);
      this.on("end", onend3);
      function onerror(err2) {
        self2.end(err2);
      }
      __name(onerror, "onerror");
      function onend3(err2) {
        self2.removeListener("error", onerror);
        self2.removeListener("end", onend3);
        cb(err2, this.results);
      }
      __name(onend3, "onend");
    }
    __name(callOnErrorOrEnd, "callOnErrorOrEnd");
    function done3(err2) {
      this.session++;
      this.running = false;
      this.emit("end", err2);
    }
    __name(done3, "done");
  }
});

// ../../node_modules/.pnpm/is-url@1.2.4/node_modules/is-url/index.js
var require_is_url = __commonJS({
  "../../node_modules/.pnpm/is-url@1.2.4/node_modules/is-url/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = isUrl;
    var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
    var localhostDomainRE = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/;
    var nonLocalhostDomainRE = /^[^\s\.]+\.\S{2,}$/;
    function isUrl(string) {
      if (typeof string !== "string") {
        return false;
      }
      var match2 = string.match(protocolAndDomainRE);
      if (!match2) {
        return false;
      }
      var everythingAfterProtocol = match2[1];
      if (!everythingAfterProtocol) {
        return false;
      }
      if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
        return true;
      }
      return false;
    }
    __name(isUrl, "isUrl");
  }
});

// ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function equal3(a4, b3) {
      if (a4 === b3) return true;
      if (a4 && b3 && typeof a4 == "object" && typeof b3 == "object") {
        if (a4.constructor !== b3.constructor) return false;
        var length2, i2, keys2;
        if (Array.isArray(a4)) {
          length2 = a4.length;
          if (length2 != b3.length) return false;
          for (i2 = length2; i2-- !== 0; )
            if (!equal3(a4[i2], b3[i2])) return false;
          return true;
        }
        if (a4.constructor === RegExp) return a4.source === b3.source && a4.flags === b3.flags;
        if (a4.valueOf !== Object.prototype.valueOf) return a4.valueOf() === b3.valueOf();
        if (a4.toString !== Object.prototype.toString) return a4.toString() === b3.toString();
        keys2 = Object.keys(a4);
        length2 = keys2.length;
        if (length2 !== Object.keys(b3).length) return false;
        for (i2 = length2; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b3, keys2[i2])) return false;
        for (i2 = length2; i2-- !== 0; ) {
          var key = keys2[i2];
          if (!equal3(a4[key], b3[key])) return false;
        }
        return true;
      }
      return a4 !== a4 && b3 !== b3;
    }, "equal");
  }
});

// ../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports.byteLength = byteLength5;
    exports.toByteArray = toByteArray4;
    exports.fromByteArray = fromByteArray4;
    var lookup4 = [];
    var revLookup4 = [];
    var Arr4 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup4[i2] = code[i2];
      revLookup4[code.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup4["-".charCodeAt(0)] = 62;
    revLookup4["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    __name(getLens, "getLens");
    function byteLength5(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(byteLength5, "byteLength");
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(_byteLength, "_byteLength");
    function toByteArray4(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr4(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup4[b64.charCodeAt(i3)] << 18 | revLookup4[b64.charCodeAt(i3 + 1)] << 12 | revLookup4[b64.charCodeAt(i3 + 2)] << 6 | revLookup4[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup4[b64.charCodeAt(i3)] << 2 | revLookup4[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup4[b64.charCodeAt(i3)] << 10 | revLookup4[b64.charCodeAt(i3 + 1)] << 4 | revLookup4[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    __name(toByteArray4, "toByteArray");
    function tripletToBase644(num) {
      return lookup4[num >> 18 & 63] + lookup4[num >> 12 & 63] + lookup4[num >> 6 & 63] + lookup4[num & 63];
    }
    __name(tripletToBase644, "tripletToBase64");
    function encodeChunk4(uint82, start2, end2) {
      var tmp;
      var output = [];
      for (var i3 = start2; i3 < end2; i3 += 3) {
        tmp = (uint82[i3] << 16 & 16711680) + (uint82[i3 + 1] << 8 & 65280) + (uint82[i3 + 2] & 255);
        output.push(tripletToBase644(tmp));
      }
      return output.join("");
    }
    __name(encodeChunk4, "encodeChunk");
    function fromByteArray4(uint82) {
      var tmp;
      var len2 = uint82.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk4(uint82, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint82[len2 - 1];
        parts.push(
          lookup4[tmp >> 2] + lookup4[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint82[len2 - 2] << 8) + uint82[len2 - 1];
        parts.push(
          lookup4[tmp >> 10] + lookup4[tmp >> 4 & 63] + lookup4[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    __name(fromByteArray4, "fromByteArray");
  }
});

// ../../node_modules/.pnpm/tiny-inflate@1.0.3/node_modules/tiny-inflate/index.js
var require_tiny_inflate = __commonJS({
  "../../node_modules/.pnpm/tiny-inflate@1.0.3/node_modules/tiny-inflate/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var TINF_OK = 0;
    var TINF_DATA_ERROR = -3;
    function Tree() {
      this.table = new Uint16Array(16);
      this.trans = new Uint16Array(288);
    }
    __name(Tree, "Tree");
    function Data(source, dest) {
      this.source = source;
      this.sourceIndex = 0;
      this.tag = 0;
      this.bitcount = 0;
      this.dest = dest;
      this.destLen = 0;
      this.ltree = new Tree();
      this.dtree = new Tree();
    }
    __name(Data, "Data");
    var sltree = new Tree();
    var sdtree = new Tree();
    var length_bits = new Uint8Array(30);
    var length_base = new Uint16Array(30);
    var dist_bits = new Uint8Array(30);
    var dist_base = new Uint16Array(30);
    var clcidx = new Uint8Array([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ]);
    var code_tree = new Tree();
    var lengths = new Uint8Array(288 + 32);
    function tinf_build_bits_base(bits, base, delta, first) {
      var i2, sum;
      for (i2 = 0; i2 < delta; ++i2) bits[i2] = 0;
      for (i2 = 0; i2 < 30 - delta; ++i2) bits[i2 + delta] = i2 / delta | 0;
      for (sum = first, i2 = 0; i2 < 30; ++i2) {
        base[i2] = sum;
        sum += 1 << bits[i2];
      }
    }
    __name(tinf_build_bits_base, "tinf_build_bits_base");
    function tinf_build_fixed_trees(lt, dt) {
      var i2;
      for (i2 = 0; i2 < 7; ++i2) lt.table[i2] = 0;
      lt.table[7] = 24;
      lt.table[8] = 152;
      lt.table[9] = 112;
      for (i2 = 0; i2 < 24; ++i2) lt.trans[i2] = 256 + i2;
      for (i2 = 0; i2 < 144; ++i2) lt.trans[24 + i2] = i2;
      for (i2 = 0; i2 < 8; ++i2) lt.trans[24 + 144 + i2] = 280 + i2;
      for (i2 = 0; i2 < 112; ++i2) lt.trans[24 + 144 + 8 + i2] = 144 + i2;
      for (i2 = 0; i2 < 5; ++i2) dt.table[i2] = 0;
      dt.table[5] = 32;
      for (i2 = 0; i2 < 32; ++i2) dt.trans[i2] = i2;
    }
    __name(tinf_build_fixed_trees, "tinf_build_fixed_trees");
    var offs = new Uint16Array(16);
    function tinf_build_tree(t4, lengths2, off4, num) {
      var i2, sum;
      for (i2 = 0; i2 < 16; ++i2) t4.table[i2] = 0;
      for (i2 = 0; i2 < num; ++i2) t4.table[lengths2[off4 + i2]]++;
      t4.table[0] = 0;
      for (sum = 0, i2 = 0; i2 < 16; ++i2) {
        offs[i2] = sum;
        sum += t4.table[i2];
      }
      for (i2 = 0; i2 < num; ++i2) {
        if (lengths2[off4 + i2]) t4.trans[offs[lengths2[off4 + i2]]++] = i2;
      }
    }
    __name(tinf_build_tree, "tinf_build_tree");
    function tinf_getbit(d3) {
      if (!d3.bitcount--) {
        d3.tag = d3.source[d3.sourceIndex++];
        d3.bitcount = 7;
      }
      var bit = d3.tag & 1;
      d3.tag >>>= 1;
      return bit;
    }
    __name(tinf_getbit, "tinf_getbit");
    function tinf_read_bits(d3, num, base) {
      if (!num)
        return base;
      while (d3.bitcount < 24) {
        d3.tag |= d3.source[d3.sourceIndex++] << d3.bitcount;
        d3.bitcount += 8;
      }
      var val = d3.tag & 65535 >>> 16 - num;
      d3.tag >>>= num;
      d3.bitcount -= num;
      return val + base;
    }
    __name(tinf_read_bits, "tinf_read_bits");
    function tinf_decode_symbol(d3, t4) {
      while (d3.bitcount < 24) {
        d3.tag |= d3.source[d3.sourceIndex++] << d3.bitcount;
        d3.bitcount += 8;
      }
      var sum = 0, cur = 0, len = 0;
      var tag = d3.tag;
      do {
        cur = 2 * cur + (tag & 1);
        tag >>>= 1;
        ++len;
        sum += t4.table[len];
        cur -= t4.table[len];
      } while (cur >= 0);
      d3.tag = tag;
      d3.bitcount -= len;
      return t4.trans[sum + cur];
    }
    __name(tinf_decode_symbol, "tinf_decode_symbol");
    function tinf_decode_trees(d3, lt, dt) {
      var hlit, hdist, hclen;
      var i2, num, length2;
      hlit = tinf_read_bits(d3, 5, 257);
      hdist = tinf_read_bits(d3, 5, 1);
      hclen = tinf_read_bits(d3, 4, 4);
      for (i2 = 0; i2 < 19; ++i2) lengths[i2] = 0;
      for (i2 = 0; i2 < hclen; ++i2) {
        var clen = tinf_read_bits(d3, 3, 0);
        lengths[clcidx[i2]] = clen;
      }
      tinf_build_tree(code_tree, lengths, 0, 19);
      for (num = 0; num < hlit + hdist; ) {
        var sym = tinf_decode_symbol(d3, code_tree);
        switch (sym) {
          case 16:
            var prev = lengths[num - 1];
            for (length2 = tinf_read_bits(d3, 2, 3); length2; --length2) {
              lengths[num++] = prev;
            }
            break;
          case 17:
            for (length2 = tinf_read_bits(d3, 3, 3); length2; --length2) {
              lengths[num++] = 0;
            }
            break;
          case 18:
            for (length2 = tinf_read_bits(d3, 7, 11); length2; --length2) {
              lengths[num++] = 0;
            }
            break;
          default:
            lengths[num++] = sym;
            break;
        }
      }
      tinf_build_tree(lt, lengths, 0, hlit);
      tinf_build_tree(dt, lengths, hlit, hdist);
    }
    __name(tinf_decode_trees, "tinf_decode_trees");
    function tinf_inflate_block_data(d3, lt, dt) {
      while (1) {
        var sym = tinf_decode_symbol(d3, lt);
        if (sym === 256) {
          return TINF_OK;
        }
        if (sym < 256) {
          d3.dest[d3.destLen++] = sym;
        } else {
          var length2, dist, offs2;
          var i2;
          sym -= 257;
          length2 = tinf_read_bits(d3, length_bits[sym], length_base[sym]);
          dist = tinf_decode_symbol(d3, dt);
          offs2 = d3.destLen - tinf_read_bits(d3, dist_bits[dist], dist_base[dist]);
          for (i2 = offs2; i2 < offs2 + length2; ++i2) {
            d3.dest[d3.destLen++] = d3.dest[i2];
          }
        }
      }
    }
    __name(tinf_inflate_block_data, "tinf_inflate_block_data");
    function tinf_inflate_uncompressed_block(d3) {
      var length2, invlength;
      var i2;
      while (d3.bitcount > 8) {
        d3.sourceIndex--;
        d3.bitcount -= 8;
      }
      length2 = d3.source[d3.sourceIndex + 1];
      length2 = 256 * length2 + d3.source[d3.sourceIndex];
      invlength = d3.source[d3.sourceIndex + 3];
      invlength = 256 * invlength + d3.source[d3.sourceIndex + 2];
      if (length2 !== (~invlength & 65535))
        return TINF_DATA_ERROR;
      d3.sourceIndex += 4;
      for (i2 = length2; i2; --i2)
        d3.dest[d3.destLen++] = d3.source[d3.sourceIndex++];
      d3.bitcount = 0;
      return TINF_OK;
    }
    __name(tinf_inflate_uncompressed_block, "tinf_inflate_uncompressed_block");
    function tinf_uncompress(source, dest) {
      var d3 = new Data(source, dest);
      var bfinal, btype, res;
      do {
        bfinal = tinf_getbit(d3);
        btype = tinf_read_bits(d3, 2, 0);
        switch (btype) {
          case 0:
            res = tinf_inflate_uncompressed_block(d3);
            break;
          case 1:
            res = tinf_inflate_block_data(d3, sltree, sdtree);
            break;
          case 2:
            tinf_decode_trees(d3, d3.ltree, d3.dtree);
            res = tinf_inflate_block_data(d3, d3.ltree, d3.dtree);
            break;
          default:
            res = TINF_DATA_ERROR;
        }
        if (res !== TINF_OK)
          throw new Error("Data error");
      } while (!bfinal);
      if (d3.destLen < d3.dest.length) {
        if (typeof d3.dest.slice === "function")
          return d3.dest.slice(0, d3.destLen);
        else
          return d3.dest.subarray(0, d3.destLen);
      }
      return d3.dest;
    }
    __name(tinf_uncompress, "tinf_uncompress");
    tinf_build_fixed_trees(sltree, sdtree);
    tinf_build_bits_base(length_bits, length_base, 4, 3);
    tinf_build_bits_base(dist_bits, dist_base, 2, 1);
    length_bits[28] = 0;
    length_base[28] = 258;
    module.exports = tinf_uncompress;
  }
});

// ../../node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/swap.js
var require_swap = __commonJS({
  "../../node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/swap.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isBigEndian2 = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
    var swap4 = /* @__PURE__ */ __name((b3, n5, m3) => {
      let i2 = b3[n5];
      b3[n5] = b3[m3];
      b3[m3] = i2;
    }, "swap");
    var swap324 = /* @__PURE__ */ __name((array) => {
      const len = array.length;
      for (let i2 = 0; i2 < len; i2 += 4) {
        swap4(array, i2, i2 + 3);
        swap4(array, i2 + 1, i2 + 2);
      }
    }, "swap32");
    var swap32LE = /* @__PURE__ */ __name((array) => {
      if (isBigEndian2) {
        swap324(array);
      }
    }, "swap32LE");
    module.exports = {
      swap32LE
    };
  }
});

// ../../node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/index.js
var require_unicode_trie = __commonJS({
  "../../node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inflate2 = require_tiny_inflate();
    var { swap32LE } = require_swap();
    var SHIFT_1 = 6 + 5;
    var SHIFT_2 = 5;
    var SHIFT_1_2 = SHIFT_1 - SHIFT_2;
    var OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
    var INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
    var INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
    var INDEX_SHIFT = 2;
    var DATA_BLOCK_LENGTH = 1 << SHIFT_2;
    var DATA_MASK = DATA_BLOCK_LENGTH - 1;
    var LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
    var LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
    var INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
    var UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
    var UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
    var INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
    var DATA_GRANULARITY = 1 << INDEX_SHIFT;
    var UnicodeTrie = class {
      static {
        __name(this, "UnicodeTrie");
      }
      constructor(data2) {
        const isBuffer4 = typeof data2.readUInt32BE === "function" && typeof data2.slice === "function";
        if (isBuffer4 || data2 instanceof Uint8Array) {
          let uncompressedLength;
          if (isBuffer4) {
            this.highStart = data2.readUInt32LE(0);
            this.errorValue = data2.readUInt32LE(4);
            uncompressedLength = data2.readUInt32LE(8);
            data2 = data2.slice(12);
          } else {
            const view = new DataView(data2.buffer);
            this.highStart = view.getUint32(0, true);
            this.errorValue = view.getUint32(4, true);
            uncompressedLength = view.getUint32(8, true);
            data2 = data2.subarray(12);
          }
          data2 = inflate2(data2, new Uint8Array(uncompressedLength));
          data2 = inflate2(data2, new Uint8Array(uncompressedLength));
          swap32LE(data2);
          this.data = new Uint32Array(data2.buffer);
        } else {
          ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data2);
        }
      }
      get(codePoint) {
        let index2;
        if (codePoint < 0 || codePoint > 1114111) {
          return this.errorValue;
        }
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          index2 = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index2];
        }
        if (codePoint <= 65535) {
          index2 = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index2];
        }
        if (codePoint < this.highStart) {
          index2 = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
          index2 = this.data[index2 + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
          index2 = (index2 << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index2];
        }
        return this.data[this.data.length - DATA_GRANULARITY];
      }
    };
    module.exports = UnicodeTrie;
  }
});

// ../../node_modules/.pnpm/dfa@1.2.0/node_modules/dfa/index.js
var require_dfa = __commonJS({
  "../../node_modules/.pnpm/dfa@1.2.0/node_modules/dfa/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var INITIAL_STATE = 1;
    var FAIL_STATE = 0;
    var StateMachine = class {
      static {
        __name(this, "StateMachine");
      }
      constructor(dfa) {
        this.stateTable = dfa.stateTable;
        this.accepting = dfa.accepting;
        this.tags = dfa.tags;
      }
      /**
       * Returns an iterable object that yields pattern matches over the input sequence.
       * Matches are of the form [startIndex, endIndex, tags].
       */
      match(str) {
        var self2 = this;
        return {
          *[Symbol.iterator]() {
            var state2 = INITIAL_STATE;
            var startRun = null;
            var lastAccepting = null;
            var lastState = null;
            for (var p3 = 0; p3 < str.length; p3++) {
              var c2 = str[p3];
              lastState = state2;
              state2 = self2.stateTable[state2][c2];
              if (state2 === FAIL_STATE) {
                if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
                  yield [startRun, lastAccepting, self2.tags[lastState]];
                }
                state2 = self2.stateTable[INITIAL_STATE][c2];
                startRun = null;
              }
              if (state2 !== FAIL_STATE && startRun == null) {
                startRun = p3;
              }
              if (self2.accepting[state2]) {
                lastAccepting = p3;
              }
              if (state2 === FAIL_STATE) {
                state2 = INITIAL_STATE;
              }
            }
            if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
              yield [startRun, lastAccepting, self2.tags[state2]];
            }
          }
        };
      }
      /**
       * For each match over the input sequence, action functions matching
       * the tag definitions in the input pattern are called with the startIndex,
       * endIndex, and sub-match sequence.
       */
      apply(str, actions) {
        for (var [start2, end2, tags2] of this.match(str)) {
          for (var tag of tags2) {
            if (typeof actions[tag] === "function") {
              actions[tag](start2, end2, str.slice(start2, end2 + 1));
            }
          }
        }
      }
    };
    module.exports = StateMachine;
  }
});

// ../../node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js
var require_clone = __commonJS({
  "../../node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var clone = function() {
      "use strict";
      function _instanceof(obj, type2) {
        return type2 != null && obj instanceof type2;
      }
      __name(_instanceof, "_instanceof");
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_) {
        nativeMap = /* @__PURE__ */ __name(function() {
        }, "nativeMap");
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_) {
        nativeSet = /* @__PURE__ */ __name(function() {
        }, "nativeSet");
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_) {
        nativePromise = /* @__PURE__ */ __name(function() {
        }, "nativePromise");
      }
      function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve3, reject) {
              parent2.then(function(value2) {
                resolve3(_clone(value2, depth2 - 1));
              }, function(err2) {
                reject(_clone(err2, depth2 - 1));
              });
            });
          } else if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index2 = allParents.indexOf(parent2);
            if (index2 != -1) {
              return allChildren[index2];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value2, key) {
              var keyChild = _clone(key, depth2 - 1);
              var valueChild = _clone(value2, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value2) {
              var entryChild = _clone(value2, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i2 in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i2);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i2] = _clone(parent2[i2], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent2);
            for (var i2 = 0; i2 < symbols.length; i2++) {
              var symbol = symbols[i2];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent2[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i2 = 0; i2 < allPropertyNames.length; i2++) {
              var propertyName = allPropertyNames[i2];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        __name(_clone, "_clone");
        return _clone(parent, depth);
      }
      __name(clone2, "clone");
      clone2.clonePrototype = /* @__PURE__ */ __name(function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c2 = /* @__PURE__ */ __name(function() {
        }, "c");
        c2.prototype = parent;
        return new c2();
      }, "clonePrototype");
      function __objToStr(o4) {
        return Object.prototype.toString.call(o4);
      }
      __name(__objToStr, "__objToStr");
      clone2.__objToStr = __objToStr;
      function __isDate(o4) {
        return typeof o4 === "object" && __objToStr(o4) === "[object Date]";
      }
      __name(__isDate, "__isDate");
      clone2.__isDate = __isDate;
      function __isArray(o4) {
        return typeof o4 === "object" && __objToStr(o4) === "[object Array]";
      }
      __name(__isArray, "__isArray");
      clone2.__isArray = __isArray;
      function __isRegExp(o4) {
        return typeof o4 === "object" && __objToStr(o4) === "[object RegExp]";
      }
      __name(__isRegExp, "__isRegExp");
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global) flags += "g";
        if (re.ignoreCase) flags += "i";
        if (re.multiline) flags += "m";
        return flags;
      }
      __name(__getRegExpFlags, "__getRegExpFlags");
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module === "object" && module.exports) {
      module.exports = clone;
    }
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/streams.js
var require_streams = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/streams.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function BrotliInput(buffer) {
      this.buffer = buffer;
      this.pos = 0;
    }
    __name(BrotliInput, "BrotliInput");
    BrotliInput.prototype.read = function(buf, i2, count3) {
      if (this.pos + count3 > this.buffer.length) {
        count3 = this.buffer.length - this.pos;
      }
      for (var p3 = 0; p3 < count3; p3++)
        buf[i2 + p3] = this.buffer[this.pos + p3];
      this.pos += count3;
      return count3;
    };
    exports.BrotliInput = BrotliInput;
    function BrotliOutput(buf) {
      this.buffer = buf;
      this.pos = 0;
    }
    __name(BrotliOutput, "BrotliOutput");
    BrotliOutput.prototype.write = function(buf, count3) {
      if (this.pos + count3 > this.buffer.length)
        throw new Error("Output buffer is not large enough");
      this.buffer.set(buf.subarray(0, count3), this.pos);
      this.pos += count3;
      return count3;
    };
    exports.BrotliOutput = BrotliOutput;
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/bit_reader.js
var require_bit_reader = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/bit_reader.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var BROTLI_READ_SIZE = 4096;
    var BROTLI_IBUF_SIZE = 2 * BROTLI_READ_SIZE + 32;
    var BROTLI_IBUF_MASK = 2 * BROTLI_READ_SIZE - 1;
    var kBitMask = new Uint32Array([
      0,
      1,
      3,
      7,
      15,
      31,
      63,
      127,
      255,
      511,
      1023,
      2047,
      4095,
      8191,
      16383,
      32767,
      65535,
      131071,
      262143,
      524287,
      1048575,
      2097151,
      4194303,
      8388607,
      16777215
    ]);
    function BrotliBitReader(input) {
      this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE);
      this.input_ = input;
      this.reset();
    }
    __name(BrotliBitReader, "BrotliBitReader");
    BrotliBitReader.READ_SIZE = BROTLI_READ_SIZE;
    BrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK;
    BrotliBitReader.prototype.reset = function() {
      this.buf_ptr_ = 0;
      this.val_ = 0;
      this.pos_ = 0;
      this.bit_pos_ = 0;
      this.bit_end_pos_ = 0;
      this.eos_ = 0;
      this.readMoreInput();
      for (var i2 = 0; i2 < 4; i2++) {
        this.val_ |= this.buf_[this.pos_] << 8 * i2;
        ++this.pos_;
      }
      return this.bit_end_pos_ > 0;
    };
    BrotliBitReader.prototype.readMoreInput = function() {
      if (this.bit_end_pos_ > 256) {
        return;
      } else if (this.eos_) {
        if (this.bit_pos_ > this.bit_end_pos_)
          throw new Error("Unexpected end of input " + this.bit_pos_ + " " + this.bit_end_pos_);
      } else {
        var dst = this.buf_ptr_;
        var bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE);
        if (bytes_read < 0) {
          throw new Error("Unexpected end of input");
        }
        if (bytes_read < BROTLI_READ_SIZE) {
          this.eos_ = 1;
          for (var p3 = 0; p3 < 32; p3++)
            this.buf_[dst + bytes_read + p3] = 0;
        }
        if (dst === 0) {
          for (var p3 = 0; p3 < 32; p3++)
            this.buf_[(BROTLI_READ_SIZE << 1) + p3] = this.buf_[p3];
          this.buf_ptr_ = BROTLI_READ_SIZE;
        } else {
          this.buf_ptr_ = 0;
        }
        this.bit_end_pos_ += bytes_read << 3;
      }
    };
    BrotliBitReader.prototype.fillBitWindow = function() {
      while (this.bit_pos_ >= 8) {
        this.val_ >>>= 8;
        this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24;
        ++this.pos_;
        this.bit_pos_ = this.bit_pos_ - 8 >>> 0;
        this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;
      }
    };
    BrotliBitReader.prototype.readBits = function(n_bits) {
      if (32 - this.bit_pos_ < n_bits) {
        this.fillBitWindow();
      }
      var val = this.val_ >>> this.bit_pos_ & kBitMask[n_bits];
      this.bit_pos_ += n_bits;
      return val;
    };
    module.exports = BrotliBitReader;
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/dictionary.bin.js
var require_dictionary_bin = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/dictionary.bin.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = "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";
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/dictionary-browser.js
var require_dictionary_browser = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/dictionary-browser.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var base64 = require_base64_js();
    exports.init = function() {
      var BrotliDecompressBuffer = require_decode().BrotliDecompressBuffer;
      var compressed = base64.toByteArray(require_dictionary_bin());
      return BrotliDecompressBuffer(compressed);
    };
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/dictionary.js
var require_dictionary = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/dictionary.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var data2 = require_dictionary_browser();
    exports.init = function() {
      exports.dictionary = data2.init();
    };
    exports.offsetsByLength = new Uint32Array([
      0,
      0,
      0,
      0,
      0,
      4096,
      9216,
      21504,
      35840,
      44032,
      53248,
      63488,
      74752,
      87040,
      93696,
      100864,
      104704,
      106752,
      108928,
      113536,
      115968,
      118528,
      119872,
      121280,
      122016
    ]);
    exports.sizeBitsByLength = new Uint8Array([
      0,
      0,
      0,
      0,
      10,
      10,
      11,
      11,
      10,
      10,
      10,
      10,
      10,
      9,
      9,
      8,
      7,
      7,
      8,
      7,
      7,
      6,
      6,
      5,
      5
    ]);
    exports.minDictionaryWordLength = 4;
    exports.maxDictionaryWordLength = 24;
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/huffman.js
var require_huffman = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/huffman.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function HuffmanCode(bits, value2) {
      this.bits = bits;
      this.value = value2;
    }
    __name(HuffmanCode, "HuffmanCode");
    exports.HuffmanCode = HuffmanCode;
    var MAX_LENGTH = 15;
    function GetNextKey(key, len) {
      var step = 1 << len - 1;
      while (key & step) {
        step >>= 1;
      }
      return (key & step - 1) + step;
    }
    __name(GetNextKey, "GetNextKey");
    function ReplicateValue(table3, i2, step, end2, code) {
      do {
        end2 -= step;
        table3[i2 + end2] = new HuffmanCode(code.bits, code.value);
      } while (end2 > 0);
    }
    __name(ReplicateValue, "ReplicateValue");
    function NextTableBitSize(count3, len, root_bits) {
      var left = 1 << len - root_bits;
      while (len < MAX_LENGTH) {
        left -= count3[len];
        if (left <= 0) break;
        ++len;
        left <<= 1;
      }
      return len - root_bits;
    }
    __name(NextTableBitSize, "NextTableBitSize");
    exports.BrotliBuildHuffmanTable = function(root_table, table3, root_bits, code_lengths, code_lengths_size) {
      var start_table = table3;
      var code;
      var len;
      var symbol;
      var key;
      var step;
      var low;
      var mask;
      var table_bits;
      var table_size;
      var total_size;
      var sorted;
      var count3 = new Int32Array(MAX_LENGTH + 1);
      var offset2 = new Int32Array(MAX_LENGTH + 1);
      sorted = new Int32Array(code_lengths_size);
      for (symbol = 0; symbol < code_lengths_size; symbol++) {
        count3[code_lengths[symbol]]++;
      }
      offset2[1] = 0;
      for (len = 1; len < MAX_LENGTH; len++) {
        offset2[len + 1] = offset2[len] + count3[len];
      }
      for (symbol = 0; symbol < code_lengths_size; symbol++) {
        if (code_lengths[symbol] !== 0) {
          sorted[offset2[code_lengths[symbol]]++] = symbol;
        }
      }
      table_bits = root_bits;
      table_size = 1 << table_bits;
      total_size = table_size;
      if (offset2[MAX_LENGTH] === 1) {
        for (key = 0; key < total_size; ++key) {
          root_table[table3 + key] = new HuffmanCode(0, sorted[0] & 65535);
        }
        return total_size;
      }
      key = 0;
      symbol = 0;
      for (len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {
        for (; count3[len] > 0; --count3[len]) {
          code = new HuffmanCode(len & 255, sorted[symbol++] & 65535);
          ReplicateValue(root_table, table3 + key, step, table_size, code);
          key = GetNextKey(key, len);
        }
      }
      mask = total_size - 1;
      low = -1;
      for (len = root_bits + 1, step = 2; len <= MAX_LENGTH; ++len, step <<= 1) {
        for (; count3[len] > 0; --count3[len]) {
          if ((key & mask) !== low) {
            table3 += table_size;
            table_bits = NextTableBitSize(count3, len, root_bits);
            table_size = 1 << table_bits;
            total_size += table_size;
            low = key & mask;
            root_table[start_table + low] = new HuffmanCode(table_bits + root_bits & 255, table3 - start_table - low & 65535);
          }
          code = new HuffmanCode(len - root_bits & 255, sorted[symbol++] & 65535);
          ReplicateValue(root_table, table3 + (key >> root_bits), step, table_size, code);
          key = GetNextKey(key, len);
        }
      }
      return total_size;
    };
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/context.js
var require_context = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/context.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports.lookup = new Uint8Array([
      /* CONTEXT_UTF8, last byte. */
      /* ASCII range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      8,
      12,
      16,
      12,
      12,
      20,
      12,
      16,
      24,
      28,
      12,
      12,
      32,
      12,
      36,
      12,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      32,
      32,
      24,
      40,
      28,
      12,
      12,
      48,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      24,
      12,
      28,
      12,
      12,
      12,
      56,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      24,
      12,
      28,
      12,
      0,
      /* UTF8 continuation byte range. */
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      /* UTF8 lead byte range. */
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      /* CONTEXT_UTF8 second last byte. */
      /* ASCII range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      1,
      1,
      1,
      1,
      0,
      /* UTF8 continuation byte range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      /* UTF8 lead byte range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      /* CONTEXT_SIGNED, second last byte. */
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      7,
      /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */
      0,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      56,
      /* CONTEXT_LSB6, last byte. */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      /* CONTEXT_MSB6, last byte. */
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      7,
      7,
      7,
      7,
      8,
      8,
      8,
      8,
      9,
      9,
      9,
      9,
      10,
      10,
      10,
      10,
      11,
      11,
      11,
      11,
      12,
      12,
      12,
      12,
      13,
      13,
      13,
      13,
      14,
      14,
      14,
      14,
      15,
      15,
      15,
      15,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      22,
      22,
      22,
      22,
      23,
      23,
      23,
      23,
      24,
      24,
      24,
      24,
      25,
      25,
      25,
      25,
      26,
      26,
      26,
      26,
      27,
      27,
      27,
      27,
      28,
      28,
      28,
      28,
      29,
      29,
      29,
      29,
      30,
      30,
      30,
      30,
      31,
      31,
      31,
      31,
      32,
      32,
      32,
      32,
      33,
      33,
      33,
      33,
      34,
      34,
      34,
      34,
      35,
      35,
      35,
      35,
      36,
      36,
      36,
      36,
      37,
      37,
      37,
      37,
      38,
      38,
      38,
      38,
      39,
      39,
      39,
      39,
      40,
      40,
      40,
      40,
      41,
      41,
      41,
      41,
      42,
      42,
      42,
      42,
      43,
      43,
      43,
      43,
      44,
      44,
      44,
      44,
      45,
      45,
      45,
      45,
      46,
      46,
      46,
      46,
      47,
      47,
      47,
      47,
      48,
      48,
      48,
      48,
      49,
      49,
      49,
      49,
      50,
      50,
      50,
      50,
      51,
      51,
      51,
      51,
      52,
      52,
      52,
      52,
      53,
      53,
      53,
      53,
      54,
      54,
      54,
      54,
      55,
      55,
      55,
      55,
      56,
      56,
      56,
      56,
      57,
      57,
      57,
      57,
      58,
      58,
      58,
      58,
      59,
      59,
      59,
      59,
      60,
      60,
      60,
      60,
      61,
      61,
      61,
      61,
      62,
      62,
      62,
      62,
      63,
      63,
      63,
      63,
      /* CONTEXT_{M,L}SB6, second last byte, */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.lookupOffsets = new Uint16Array([
      /* CONTEXT_LSB6 */
      1024,
      1536,
      /* CONTEXT_MSB6 */
      1280,
      1536,
      /* CONTEXT_UTF8 */
      0,
      256,
      /* CONTEXT_SIGNED */
      768,
      512
    ]);
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/prefix.js
var require_prefix = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/prefix.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function PrefixCodeRange(offset2, nbits) {
      this.offset = offset2;
      this.nbits = nbits;
    }
    __name(PrefixCodeRange, "PrefixCodeRange");
    exports.kBlockLengthPrefixCode = [
      new PrefixCodeRange(1, 2),
      new PrefixCodeRange(5, 2),
      new PrefixCodeRange(9, 2),
      new PrefixCodeRange(13, 2),
      new PrefixCodeRange(17, 3),
      new PrefixCodeRange(25, 3),
      new PrefixCodeRange(33, 3),
      new PrefixCodeRange(41, 3),
      new PrefixCodeRange(49, 4),
      new PrefixCodeRange(65, 4),
      new PrefixCodeRange(81, 4),
      new PrefixCodeRange(97, 4),
      new PrefixCodeRange(113, 5),
      new PrefixCodeRange(145, 5),
      new PrefixCodeRange(177, 5),
      new PrefixCodeRange(209, 5),
      new PrefixCodeRange(241, 6),
      new PrefixCodeRange(305, 6),
      new PrefixCodeRange(369, 7),
      new PrefixCodeRange(497, 8),
      new PrefixCodeRange(753, 9),
      new PrefixCodeRange(1265, 10),
      new PrefixCodeRange(2289, 11),
      new PrefixCodeRange(4337, 12),
      new PrefixCodeRange(8433, 13),
      new PrefixCodeRange(16625, 24)
    ];
    exports.kInsertLengthPrefixCode = [
      new PrefixCodeRange(0, 0),
      new PrefixCodeRange(1, 0),
      new PrefixCodeRange(2, 0),
      new PrefixCodeRange(3, 0),
      new PrefixCodeRange(4, 0),
      new PrefixCodeRange(5, 0),
      new PrefixCodeRange(6, 1),
      new PrefixCodeRange(8, 1),
      new PrefixCodeRange(10, 2),
      new PrefixCodeRange(14, 2),
      new PrefixCodeRange(18, 3),
      new PrefixCodeRange(26, 3),
      new PrefixCodeRange(34, 4),
      new PrefixCodeRange(50, 4),
      new PrefixCodeRange(66, 5),
      new PrefixCodeRange(98, 5),
      new PrefixCodeRange(130, 6),
      new PrefixCodeRange(194, 7),
      new PrefixCodeRange(322, 8),
      new PrefixCodeRange(578, 9),
      new PrefixCodeRange(1090, 10),
      new PrefixCodeRange(2114, 12),
      new PrefixCodeRange(6210, 14),
      new PrefixCodeRange(22594, 24)
    ];
    exports.kCopyLengthPrefixCode = [
      new PrefixCodeRange(2, 0),
      new PrefixCodeRange(3, 0),
      new PrefixCodeRange(4, 0),
      new PrefixCodeRange(5, 0),
      new PrefixCodeRange(6, 0),
      new PrefixCodeRange(7, 0),
      new PrefixCodeRange(8, 0),
      new PrefixCodeRange(9, 0),
      new PrefixCodeRange(10, 1),
      new PrefixCodeRange(12, 1),
      new PrefixCodeRange(14, 2),
      new PrefixCodeRange(18, 2),
      new PrefixCodeRange(22, 3),
      new PrefixCodeRange(30, 3),
      new PrefixCodeRange(38, 4),
      new PrefixCodeRange(54, 4),
      new PrefixCodeRange(70, 5),
      new PrefixCodeRange(102, 5),
      new PrefixCodeRange(134, 6),
      new PrefixCodeRange(198, 7),
      new PrefixCodeRange(326, 8),
      new PrefixCodeRange(582, 9),
      new PrefixCodeRange(1094, 10),
      new PrefixCodeRange(2118, 24)
    ];
    exports.kInsertRangeLut = [
      0,
      0,
      8,
      8,
      0,
      16,
      8,
      16,
      16
    ];
    exports.kCopyRangeLut = [
      0,
      8,
      0,
      8,
      16,
      0,
      16,
      8,
      16
    ];
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/transform.js
var require_transform = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/transform.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var BrotliDictionary = require_dictionary();
    var kIdentity = 0;
    var kOmitLast1 = 1;
    var kOmitLast2 = 2;
    var kOmitLast3 = 3;
    var kOmitLast4 = 4;
    var kOmitLast5 = 5;
    var kOmitLast6 = 6;
    var kOmitLast7 = 7;
    var kOmitLast8 = 8;
    var kOmitLast9 = 9;
    var kUppercaseFirst = 10;
    var kUppercaseAll = 11;
    var kOmitFirst1 = 12;
    var kOmitFirst2 = 13;
    var kOmitFirst3 = 14;
    var kOmitFirst4 = 15;
    var kOmitFirst5 = 16;
    var kOmitFirst6 = 17;
    var kOmitFirst7 = 18;
    var kOmitFirst9 = 20;
    function Transform3(prefix, transform, suffix) {
      this.prefix = new Uint8Array(prefix.length);
      this.transform = transform;
      this.suffix = new Uint8Array(suffix.length);
      for (var i2 = 0; i2 < prefix.length; i2++)
        this.prefix[i2] = prefix.charCodeAt(i2);
      for (var i2 = 0; i2 < suffix.length; i2++)
        this.suffix[i2] = suffix.charCodeAt(i2);
    }
    __name(Transform3, "Transform");
    var kTransforms = [
      new Transform3("", kIdentity, ""),
      new Transform3("", kIdentity, " "),
      new Transform3(" ", kIdentity, " "),
      new Transform3("", kOmitFirst1, ""),
      new Transform3("", kUppercaseFirst, " "),
      new Transform3("", kIdentity, " the "),
      new Transform3(" ", kIdentity, ""),
      new Transform3("s ", kIdentity, " "),
      new Transform3("", kIdentity, " of "),
      new Transform3("", kUppercaseFirst, ""),
      new Transform3("", kIdentity, " and "),
      new Transform3("", kOmitFirst2, ""),
      new Transform3("", kOmitLast1, ""),
      new Transform3(", ", kIdentity, " "),
      new Transform3("", kIdentity, ", "),
      new Transform3(" ", kUppercaseFirst, " "),
      new Transform3("", kIdentity, " in "),
      new Transform3("", kIdentity, " to "),
      new Transform3("e ", kIdentity, " "),
      new Transform3("", kIdentity, '"'),
      new Transform3("", kIdentity, "."),
      new Transform3("", kIdentity, '">'),
      new Transform3("", kIdentity, "\n"),
      new Transform3("", kOmitLast3, ""),
      new Transform3("", kIdentity, "]"),
      new Transform3("", kIdentity, " for "),
      new Transform3("", kOmitFirst3, ""),
      new Transform3("", kOmitLast2, ""),
      new Transform3("", kIdentity, " a "),
      new Transform3("", kIdentity, " that "),
      new Transform3(" ", kUppercaseFirst, ""),
      new Transform3("", kIdentity, ". "),
      new Transform3(".", kIdentity, ""),
      new Transform3(" ", kIdentity, ", "),
      new Transform3("", kOmitFirst4, ""),
      new Transform3("", kIdentity, " with "),
      new Transform3("", kIdentity, "'"),
      new Transform3("", kIdentity, " from "),
      new Transform3("", kIdentity, " by "),
      new Transform3("", kOmitFirst5, ""),
      new Transform3("", kOmitFirst6, ""),
      new Transform3(" the ", kIdentity, ""),
      new Transform3("", kOmitLast4, ""),
      new Transform3("", kIdentity, ". The "),
      new Transform3("", kUppercaseAll, ""),
      new Transform3("", kIdentity, " on "),
      new Transform3("", kIdentity, " as "),
      new Transform3("", kIdentity, " is "),
      new Transform3("", kOmitLast7, ""),
      new Transform3("", kOmitLast1, "ing "),
      new Transform3("", kIdentity, "\n	"),
      new Transform3("", kIdentity, ":"),
      new Transform3(" ", kIdentity, ". "),
      new Transform3("", kIdentity, "ed "),
      new Transform3("", kOmitFirst9, ""),
      new Transform3("", kOmitFirst7, ""),
      new Transform3("", kOmitLast6, ""),
      new Transform3("", kIdentity, "("),
      new Transform3("", kUppercaseFirst, ", "),
      new Transform3("", kOmitLast8, ""),
      new Transform3("", kIdentity, " at "),
      new Transform3("", kIdentity, "ly "),
      new Transform3(" the ", kIdentity, " of "),
      new Transform3("", kOmitLast5, ""),
      new Transform3("", kOmitLast9, ""),
      new Transform3(" ", kUppercaseFirst, ", "),
      new Transform3("", kUppercaseFirst, '"'),
      new Transform3(".", kIdentity, "("),
      new Transform3("", kUppercaseAll, " "),
      new Transform3("", kUppercaseFirst, '">'),
      new Transform3("", kIdentity, '="'),
      new Transform3(" ", kIdentity, "."),
      new Transform3(".com/", kIdentity, ""),
      new Transform3(" the ", kIdentity, " of the "),
      new Transform3("", kUppercaseFirst, "'"),
      new Transform3("", kIdentity, ". This "),
      new Transform3("", kIdentity, ","),
      new Transform3(".", kIdentity, " "),
      new Transform3("", kUppercaseFirst, "("),
      new Transform3("", kUppercaseFirst, "."),
      new Transform3("", kIdentity, " not "),
      new Transform3(" ", kIdentity, '="'),
      new Transform3("", kIdentity, "er "),
      new Transform3(" ", kUppercaseAll, " "),
      new Transform3("", kIdentity, "al "),
      new Transform3(" ", kUppercaseAll, ""),
      new Transform3("", kIdentity, "='"),
      new Transform3("", kUppercaseAll, '"'),
      new Transform3("", kUppercaseFirst, ". "),
      new Transform3(" ", kIdentity, "("),
      new Transform3("", kIdentity, "ful "),
      new Transform3(" ", kUppercaseFirst, ". "),
      new Transform3("", kIdentity, "ive "),
      new Transform3("", kIdentity, "less "),
      new Transform3("", kUppercaseAll, "'"),
      new Transform3("", kIdentity, "est "),
      new Transform3(" ", kUppercaseFirst, "."),
      new Transform3("", kUppercaseAll, '">'),
      new Transform3(" ", kIdentity, "='"),
      new Transform3("", kUppercaseFirst, ","),
      new Transform3("", kIdentity, "ize "),
      new Transform3("", kUppercaseAll, "."),
      new Transform3("\xC2\xA0", kIdentity, ""),
      new Transform3(" ", kIdentity, ","),
      new Transform3("", kUppercaseFirst, '="'),
      new Transform3("", kUppercaseAll, '="'),
      new Transform3("", kIdentity, "ous "),
      new Transform3("", kUppercaseAll, ", "),
      new Transform3("", kUppercaseFirst, "='"),
      new Transform3(" ", kUppercaseFirst, ","),
      new Transform3(" ", kUppercaseAll, '="'),
      new Transform3(" ", kUppercaseAll, ", "),
      new Transform3("", kUppercaseAll, ","),
      new Transform3("", kUppercaseAll, "("),
      new Transform3("", kUppercaseAll, ". "),
      new Transform3(" ", kUppercaseAll, "."),
      new Transform3("", kUppercaseAll, "='"),
      new Transform3(" ", kUppercaseAll, ". "),
      new Transform3(" ", kUppercaseFirst, '="'),
      new Transform3(" ", kUppercaseAll, "='"),
      new Transform3(" ", kUppercaseFirst, "='")
    ];
    exports.kTransforms = kTransforms;
    exports.kNumTransforms = kTransforms.length;
    function ToUpperCase(p3, i2) {
      if (p3[i2] < 192) {
        if (p3[i2] >= 97 && p3[i2] <= 122) {
          p3[i2] ^= 32;
        }
        return 1;
      }
      if (p3[i2] < 224) {
        p3[i2 + 1] ^= 32;
        return 2;
      }
      p3[i2 + 2] ^= 5;
      return 3;
    }
    __name(ToUpperCase, "ToUpperCase");
    exports.transformDictionaryWord = function(dst, idx, word, len, transform) {
      var prefix = kTransforms[transform].prefix;
      var suffix = kTransforms[transform].suffix;
      var t4 = kTransforms[transform].transform;
      var skip = t4 < kOmitFirst1 ? 0 : t4 - (kOmitFirst1 - 1);
      var i2 = 0;
      var start_idx = idx;
      var uppercase;
      if (skip > len) {
        skip = len;
      }
      var prefix_pos = 0;
      while (prefix_pos < prefix.length) {
        dst[idx++] = prefix[prefix_pos++];
      }
      word += skip;
      len -= skip;
      if (t4 <= kOmitLast9) {
        len -= t4;
      }
      for (i2 = 0; i2 < len; i2++) {
        dst[idx++] = BrotliDictionary.dictionary[word + i2];
      }
      uppercase = idx - len;
      if (t4 === kUppercaseFirst) {
        ToUpperCase(dst, uppercase);
      } else if (t4 === kUppercaseAll) {
        while (len > 0) {
          var step = ToUpperCase(dst, uppercase);
          uppercase += step;
          len -= step;
        }
      }
      var suffix_pos = 0;
      while (suffix_pos < suffix.length) {
        dst[idx++] = suffix[suffix_pos++];
      }
      return idx - start_idx;
    };
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/decode.js
var require_decode = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/decode.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var BrotliInput = require_streams().BrotliInput;
    var BrotliOutput = require_streams().BrotliOutput;
    var BrotliBitReader = require_bit_reader();
    var BrotliDictionary = require_dictionary();
    var HuffmanCode = require_huffman().HuffmanCode;
    var BrotliBuildHuffmanTable = require_huffman().BrotliBuildHuffmanTable;
    var Context2 = require_context();
    var Prefix = require_prefix();
    var Transform3 = require_transform();
    var kDefaultCodeLength = 8;
    var kCodeLengthRepeatCode = 16;
    var kNumLiteralCodes = 256;
    var kNumInsertAndCopyCodes = 704;
    var kNumBlockLengthCodes = 26;
    var kLiteralContextBits = 6;
    var kDistanceContextBits = 2;
    var HUFFMAN_TABLE_BITS = 8;
    var HUFFMAN_TABLE_MASK = 255;
    var HUFFMAN_MAX_TABLE_SIZE = 1080;
    var CODE_LENGTH_CODES = 18;
    var kCodeLengthCodeOrder = new Uint8Array([
      1,
      2,
      3,
      4,
      0,
      5,
      17,
      6,
      16,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15
    ]);
    var NUM_DISTANCE_SHORT_CODES = 16;
    var kDistanceShortCodeIndexOffset = new Uint8Array([
      3,
      2,
      1,
      0,
      3,
      3,
      3,
      3,
      3,
      3,
      2,
      2,
      2,
      2,
      2,
      2
    ]);
    var kDistanceShortCodeValueOffset = new Int8Array([
      0,
      0,
      0,
      0,
      -1,
      1,
      -2,
      2,
      -3,
      3,
      -1,
      1,
      -2,
      2,
      -3,
      3
    ]);
    var kMaxHuffmanTableSize = new Uint16Array([
      256,
      402,
      436,
      468,
      500,
      534,
      566,
      598,
      630,
      662,
      694,
      726,
      758,
      790,
      822,
      854,
      886,
      920,
      952,
      984,
      1016,
      1048,
      1080
    ]);
    function DecodeWindowBits(br) {
      var n5;
      if (br.readBits(1) === 0) {
        return 16;
      }
      n5 = br.readBits(3);
      if (n5 > 0) {
        return 17 + n5;
      }
      n5 = br.readBits(3);
      if (n5 > 0) {
        return 8 + n5;
      }
      return 17;
    }
    __name(DecodeWindowBits, "DecodeWindowBits");
    function DecodeVarLenUint8(br) {
      if (br.readBits(1)) {
        var nbits = br.readBits(3);
        if (nbits === 0) {
          return 1;
        } else {
          return br.readBits(nbits) + (1 << nbits);
        }
      }
      return 0;
    }
    __name(DecodeVarLenUint8, "DecodeVarLenUint8");
    function MetaBlockLength() {
      this.meta_block_length = 0;
      this.input_end = 0;
      this.is_uncompressed = 0;
      this.is_metadata = false;
    }
    __name(MetaBlockLength, "MetaBlockLength");
    function DecodeMetaBlockLength(br) {
      var out = new MetaBlockLength();
      var size_nibbles;
      var size_bytes;
      var i2;
      out.input_end = br.readBits(1);
      if (out.input_end && br.readBits(1)) {
        return out;
      }
      size_nibbles = br.readBits(2) + 4;
      if (size_nibbles === 7) {
        out.is_metadata = true;
        if (br.readBits(1) !== 0)
          throw new Error("Invalid reserved bit");
        size_bytes = br.readBits(2);
        if (size_bytes === 0)
          return out;
        for (i2 = 0; i2 < size_bytes; i2++) {
          var next_byte = br.readBits(8);
          if (i2 + 1 === size_bytes && size_bytes > 1 && next_byte === 0)
            throw new Error("Invalid size byte");
          out.meta_block_length |= next_byte << i2 * 8;
        }
      } else {
        for (i2 = 0; i2 < size_nibbles; ++i2) {
          var next_nibble = br.readBits(4);
          if (i2 + 1 === size_nibbles && size_nibbles > 4 && next_nibble === 0)
            throw new Error("Invalid size nibble");
          out.meta_block_length |= next_nibble << i2 * 4;
        }
      }
      ++out.meta_block_length;
      if (!out.input_end && !out.is_metadata) {
        out.is_uncompressed = br.readBits(1);
      }
      return out;
    }
    __name(DecodeMetaBlockLength, "DecodeMetaBlockLength");
    function ReadSymbol(table3, index2, br) {
      var start_index = index2;
      var nbits;
      br.fillBitWindow();
      index2 += br.val_ >>> br.bit_pos_ & HUFFMAN_TABLE_MASK;
      nbits = table3[index2].bits - HUFFMAN_TABLE_BITS;
      if (nbits > 0) {
        br.bit_pos_ += HUFFMAN_TABLE_BITS;
        index2 += table3[index2].value;
        index2 += br.val_ >>> br.bit_pos_ & (1 << nbits) - 1;
      }
      br.bit_pos_ += table3[index2].bits;
      return table3[index2].value;
    }
    __name(ReadSymbol, "ReadSymbol");
    function ReadHuffmanCodeLengths(code_length_code_lengths, num_symbols, code_lengths, br) {
      var symbol = 0;
      var prev_code_len = kDefaultCodeLength;
      var repeat2 = 0;
      var repeat_code_len = 0;
      var space = 32768;
      var table3 = [];
      for (var i2 = 0; i2 < 32; i2++)
        table3.push(new HuffmanCode(0, 0));
      BrotliBuildHuffmanTable(table3, 0, 5, code_length_code_lengths, CODE_LENGTH_CODES);
      while (symbol < num_symbols && space > 0) {
        var p3 = 0;
        var code_len;
        br.readMoreInput();
        br.fillBitWindow();
        p3 += br.val_ >>> br.bit_pos_ & 31;
        br.bit_pos_ += table3[p3].bits;
        code_len = table3[p3].value & 255;
        if (code_len < kCodeLengthRepeatCode) {
          repeat2 = 0;
          code_lengths[symbol++] = code_len;
          if (code_len !== 0) {
            prev_code_len = code_len;
            space -= 32768 >> code_len;
          }
        } else {
          var extra_bits = code_len - 14;
          var old_repeat;
          var repeat_delta;
          var new_len = 0;
          if (code_len === kCodeLengthRepeatCode) {
            new_len = prev_code_len;
          }
          if (repeat_code_len !== new_len) {
            repeat2 = 0;
            repeat_code_len = new_len;
          }
          old_repeat = repeat2;
          if (repeat2 > 0) {
            repeat2 -= 2;
            repeat2 <<= extra_bits;
          }
          repeat2 += br.readBits(extra_bits) + 3;
          repeat_delta = repeat2 - old_repeat;
          if (symbol + repeat_delta > num_symbols) {
            throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");
          }
          for (var x = 0; x < repeat_delta; x++)
            code_lengths[symbol + x] = repeat_code_len;
          symbol += repeat_delta;
          if (repeat_code_len !== 0) {
            space -= repeat_delta << 15 - repeat_code_len;
          }
        }
      }
      if (space !== 0) {
        throw new Error("[ReadHuffmanCodeLengths] space = " + space);
      }
      for (; symbol < num_symbols; symbol++)
        code_lengths[symbol] = 0;
    }
    __name(ReadHuffmanCodeLengths, "ReadHuffmanCodeLengths");
    function ReadHuffmanCode(alphabet_size, tables, table3, br) {
      var table_size = 0;
      var simple_code_or_skip;
      var code_lengths = new Uint8Array(alphabet_size);
      br.readMoreInput();
      simple_code_or_skip = br.readBits(2);
      if (simple_code_or_skip === 1) {
        var i2;
        var max_bits_counter = alphabet_size - 1;
        var max_bits = 0;
        var symbols = new Int32Array(4);
        var num_symbols = br.readBits(2) + 1;
        while (max_bits_counter) {
          max_bits_counter >>= 1;
          ++max_bits;
        }
        for (i2 = 0; i2 < num_symbols; ++i2) {
          symbols[i2] = br.readBits(max_bits) % alphabet_size;
          code_lengths[symbols[i2]] = 2;
        }
        code_lengths[symbols[0]] = 1;
        switch (num_symbols) {
          case 1:
            break;
          case 3:
            if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[1] === symbols[2]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            break;
          case 2:
            if (symbols[0] === symbols[1]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            code_lengths[symbols[1]] = 1;
            break;
          case 4:
            if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[0] === symbols[3] || symbols[1] === symbols[2] || symbols[1] === symbols[3] || symbols[2] === symbols[3]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            if (br.readBits(1)) {
              code_lengths[symbols[2]] = 3;
              code_lengths[symbols[3]] = 3;
            } else {
              code_lengths[symbols[0]] = 2;
            }
            break;
        }
      } else {
        var i2;
        var code_length_code_lengths = new Uint8Array(CODE_LENGTH_CODES);
        var space = 32;
        var num_codes = 0;
        var huff = [
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(3, 2),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(4, 1),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(3, 2),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(4, 5)
        ];
        for (i2 = simple_code_or_skip; i2 < CODE_LENGTH_CODES && space > 0; ++i2) {
          var code_len_idx = kCodeLengthCodeOrder[i2];
          var p3 = 0;
          var v3;
          br.fillBitWindow();
          p3 += br.val_ >>> br.bit_pos_ & 15;
          br.bit_pos_ += huff[p3].bits;
          v3 = huff[p3].value;
          code_length_code_lengths[code_len_idx] = v3;
          if (v3 !== 0) {
            space -= 32 >> v3;
            ++num_codes;
          }
        }
        if (!(num_codes === 1 || space === 0))
          throw new Error("[ReadHuffmanCode] invalid num_codes or space");
        ReadHuffmanCodeLengths(code_length_code_lengths, alphabet_size, code_lengths, br);
      }
      table_size = BrotliBuildHuffmanTable(tables, table3, HUFFMAN_TABLE_BITS, code_lengths, alphabet_size);
      if (table_size === 0) {
        throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
      }
      return table_size;
    }
    __name(ReadHuffmanCode, "ReadHuffmanCode");
    function ReadBlockLength(table3, index2, br) {
      var code;
      var nbits;
      code = ReadSymbol(table3, index2, br);
      nbits = Prefix.kBlockLengthPrefixCode[code].nbits;
      return Prefix.kBlockLengthPrefixCode[code].offset + br.readBits(nbits);
    }
    __name(ReadBlockLength, "ReadBlockLength");
    function TranslateShortCodes(code, ringbuffer, index2) {
      var val;
      if (code < NUM_DISTANCE_SHORT_CODES) {
        index2 += kDistanceShortCodeIndexOffset[code];
        index2 &= 3;
        val = ringbuffer[index2] + kDistanceShortCodeValueOffset[code];
      } else {
        val = code - NUM_DISTANCE_SHORT_CODES + 1;
      }
      return val;
    }
    __name(TranslateShortCodes, "TranslateShortCodes");
    function MoveToFront(v3, index2) {
      var value2 = v3[index2];
      var i2 = index2;
      for (; i2; --i2) v3[i2] = v3[i2 - 1];
      v3[0] = value2;
    }
    __name(MoveToFront, "MoveToFront");
    function InverseMoveToFrontTransform(v3, v_len) {
      var mtf = new Uint8Array(256);
      var i2;
      for (i2 = 0; i2 < 256; ++i2) {
        mtf[i2] = i2;
      }
      for (i2 = 0; i2 < v_len; ++i2) {
        var index2 = v3[i2];
        v3[i2] = mtf[index2];
        if (index2) MoveToFront(mtf, index2);
      }
    }
    __name(InverseMoveToFrontTransform, "InverseMoveToFrontTransform");
    function HuffmanTreeGroup(alphabet_size, num_htrees) {
      this.alphabet_size = alphabet_size;
      this.num_htrees = num_htrees;
      this.codes = new Array(num_htrees + num_htrees * kMaxHuffmanTableSize[alphabet_size + 31 >>> 5]);
      this.htrees = new Uint32Array(num_htrees);
    }
    __name(HuffmanTreeGroup, "HuffmanTreeGroup");
    HuffmanTreeGroup.prototype.decode = function(br) {
      var i2;
      var table_size;
      var next = 0;
      for (i2 = 0; i2 < this.num_htrees; ++i2) {
        this.htrees[i2] = next;
        table_size = ReadHuffmanCode(this.alphabet_size, this.codes, next, br);
        next += table_size;
      }
    };
    function DecodeContextMap(context_map_size, br) {
      var out = { num_htrees: null, context_map: null };
      var use_rle_for_zeros;
      var max_run_length_prefix = 0;
      var table3;
      var i2;
      br.readMoreInput();
      var num_htrees = out.num_htrees = DecodeVarLenUint8(br) + 1;
      var context_map = out.context_map = new Uint8Array(context_map_size);
      if (num_htrees <= 1) {
        return out;
      }
      use_rle_for_zeros = br.readBits(1);
      if (use_rle_for_zeros) {
        max_run_length_prefix = br.readBits(4) + 1;
      }
      table3 = [];
      for (i2 = 0; i2 < HUFFMAN_MAX_TABLE_SIZE; i2++) {
        table3[i2] = new HuffmanCode(0, 0);
      }
      ReadHuffmanCode(num_htrees + max_run_length_prefix, table3, 0, br);
      for (i2 = 0; i2 < context_map_size; ) {
        var code;
        br.readMoreInput();
        code = ReadSymbol(table3, 0, br);
        if (code === 0) {
          context_map[i2] = 0;
          ++i2;
        } else if (code <= max_run_length_prefix) {
          var reps = 1 + (1 << code) + br.readBits(code);
          while (--reps) {
            if (i2 >= context_map_size) {
              throw new Error("[DecodeContextMap] i >= context_map_size");
            }
            context_map[i2] = 0;
            ++i2;
          }
        } else {
          context_map[i2] = code - max_run_length_prefix;
          ++i2;
        }
      }
      if (br.readBits(1)) {
        InverseMoveToFrontTransform(context_map, context_map_size);
      }
      return out;
    }
    __name(DecodeContextMap, "DecodeContextMap");
    function DecodeBlockType(max_block_type, trees2, tree_type, block_types, ringbuffers, indexes, br) {
      var ringbuffer = tree_type * 2;
      var index2 = tree_type;
      var type_code = ReadSymbol(trees2, tree_type * HUFFMAN_MAX_TABLE_SIZE, br);
      var block_type;
      if (type_code === 0) {
        block_type = ringbuffers[ringbuffer + (indexes[index2] & 1)];
      } else if (type_code === 1) {
        block_type = ringbuffers[ringbuffer + (indexes[index2] - 1 & 1)] + 1;
      } else {
        block_type = type_code - 2;
      }
      if (block_type >= max_block_type) {
        block_type -= max_block_type;
      }
      block_types[tree_type] = block_type;
      ringbuffers[ringbuffer + (indexes[index2] & 1)] = block_type;
      ++indexes[index2];
    }
    __name(DecodeBlockType, "DecodeBlockType");
    function CopyUncompressedBlockToOutput(output, len, pos, ringbuffer, ringbuffer_mask, br) {
      var rb_size = ringbuffer_mask + 1;
      var rb_pos = pos & ringbuffer_mask;
      var br_pos = br.pos_ & BrotliBitReader.IBUF_MASK;
      var nbytes;
      if (len < 8 || br.bit_pos_ + (len << 3) < br.bit_end_pos_) {
        while (len-- > 0) {
          br.readMoreInput();
          ringbuffer[rb_pos++] = br.readBits(8);
          if (rb_pos === rb_size) {
            output.write(ringbuffer, rb_size);
            rb_pos = 0;
          }
        }
        return;
      }
      if (br.bit_end_pos_ < 32) {
        throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");
      }
      while (br.bit_pos_ < 32) {
        ringbuffer[rb_pos] = br.val_ >>> br.bit_pos_;
        br.bit_pos_ += 8;
        ++rb_pos;
        --len;
      }
      nbytes = br.bit_end_pos_ - br.bit_pos_ >> 3;
      if (br_pos + nbytes > BrotliBitReader.IBUF_MASK) {
        var tail = BrotliBitReader.IBUF_MASK + 1 - br_pos;
        for (var x = 0; x < tail; x++)
          ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
        nbytes -= tail;
        rb_pos += tail;
        len -= tail;
        br_pos = 0;
      }
      for (var x = 0; x < nbytes; x++)
        ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
      rb_pos += nbytes;
      len -= nbytes;
      if (rb_pos >= rb_size) {
        output.write(ringbuffer, rb_size);
        rb_pos -= rb_size;
        for (var x = 0; x < rb_pos; x++)
          ringbuffer[x] = ringbuffer[rb_size + x];
      }
      while (rb_pos + len >= rb_size) {
        nbytes = rb_size - rb_pos;
        if (br.input_.read(ringbuffer, rb_pos, nbytes) < nbytes) {
          throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
        }
        output.write(ringbuffer, rb_size);
        len -= nbytes;
        rb_pos = 0;
      }
      if (br.input_.read(ringbuffer, rb_pos, len) < len) {
        throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
      }
      br.reset();
    }
    __name(CopyUncompressedBlockToOutput, "CopyUncompressedBlockToOutput");
    function JumpToByteBoundary(br) {
      var new_bit_pos = br.bit_pos_ + 7 & ~7;
      var pad_bits = br.readBits(new_bit_pos - br.bit_pos_);
      return pad_bits == 0;
    }
    __name(JumpToByteBoundary, "JumpToByteBoundary");
    function BrotliDecompressedSize(buffer) {
      var input = new BrotliInput(buffer);
      var br = new BrotliBitReader(input);
      DecodeWindowBits(br);
      var out = DecodeMetaBlockLength(br);
      return out.meta_block_length;
    }
    __name(BrotliDecompressedSize, "BrotliDecompressedSize");
    exports.BrotliDecompressedSize = BrotliDecompressedSize;
    function BrotliDecompressBuffer(buffer, output_size) {
      var input = new BrotliInput(buffer);
      if (output_size == null) {
        output_size = BrotliDecompressedSize(buffer);
      }
      var output_buffer = new Uint8Array(output_size);
      var output = new BrotliOutput(output_buffer);
      BrotliDecompress(input, output);
      if (output.pos < output.buffer.length) {
        output.buffer = output.buffer.subarray(0, output.pos);
      }
      return output.buffer;
    }
    __name(BrotliDecompressBuffer, "BrotliDecompressBuffer");
    exports.BrotliDecompressBuffer = BrotliDecompressBuffer;
    function BrotliDecompress(input, output) {
      var i2;
      var pos = 0;
      var input_end = 0;
      var window_bits = 0;
      var max_backward_distance;
      var max_distance = 0;
      var ringbuffer_size;
      var ringbuffer_mask;
      var ringbuffer;
      var ringbuffer_end;
      var dist_rb = [16, 15, 11, 4];
      var dist_rb_idx = 0;
      var prev_byte1 = 0;
      var prev_byte2 = 0;
      var hgroup = [new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0)];
      var block_type_trees;
      var block_len_trees;
      var br;
      var kRingBufferWriteAheadSlack = 128 + BrotliBitReader.READ_SIZE;
      br = new BrotliBitReader(input);
      window_bits = DecodeWindowBits(br);
      max_backward_distance = (1 << window_bits) - 16;
      ringbuffer_size = 1 << window_bits;
      ringbuffer_mask = ringbuffer_size - 1;
      ringbuffer = new Uint8Array(ringbuffer_size + kRingBufferWriteAheadSlack + BrotliDictionary.maxDictionaryWordLength);
      ringbuffer_end = ringbuffer_size;
      block_type_trees = [];
      block_len_trees = [];
      for (var x = 0; x < 3 * HUFFMAN_MAX_TABLE_SIZE; x++) {
        block_type_trees[x] = new HuffmanCode(0, 0);
        block_len_trees[x] = new HuffmanCode(0, 0);
      }
      while (!input_end) {
        var meta_block_remaining_len = 0;
        var is_uncompressed;
        var block_length = [1 << 28, 1 << 28, 1 << 28];
        var block_type = [0];
        var num_block_types = [1, 1, 1];
        var block_type_rb = [0, 1, 0, 1, 0, 1];
        var block_type_rb_index = [0];
        var distance_postfix_bits;
        var num_direct_distance_codes;
        var distance_postfix_mask;
        var num_distance_codes;
        var context_map = null;
        var context_modes = null;
        var num_literal_htrees;
        var dist_context_map = null;
        var num_dist_htrees;
        var context_offset = 0;
        var context_map_slice = null;
        var literal_htree_index = 0;
        var dist_context_offset = 0;
        var dist_context_map_slice = null;
        var dist_htree_index = 0;
        var context_lookup_offset1 = 0;
        var context_lookup_offset2 = 0;
        var context_mode;
        var htree_command;
        for (i2 = 0; i2 < 3; ++i2) {
          hgroup[i2].codes = null;
          hgroup[i2].htrees = null;
        }
        br.readMoreInput();
        var _out = DecodeMetaBlockLength(br);
        meta_block_remaining_len = _out.meta_block_length;
        if (pos + meta_block_remaining_len > output.buffer.length) {
          var tmp = new Uint8Array(pos + meta_block_remaining_len);
          tmp.set(output.buffer);
          output.buffer = tmp;
        }
        input_end = _out.input_end;
        is_uncompressed = _out.is_uncompressed;
        if (_out.is_metadata) {
          JumpToByteBoundary(br);
          for (; meta_block_remaining_len > 0; --meta_block_remaining_len) {
            br.readMoreInput();
            br.readBits(8);
          }
          continue;
        }
        if (meta_block_remaining_len === 0) {
          continue;
        }
        if (is_uncompressed) {
          br.bit_pos_ = br.bit_pos_ + 7 & ~7;
          CopyUncompressedBlockToOutput(
            output,
            meta_block_remaining_len,
            pos,
            ringbuffer,
            ringbuffer_mask,
            br
          );
          pos += meta_block_remaining_len;
          continue;
        }
        for (i2 = 0; i2 < 3; ++i2) {
          num_block_types[i2] = DecodeVarLenUint8(br) + 1;
          if (num_block_types[i2] >= 2) {
            ReadHuffmanCode(num_block_types[i2] + 2, block_type_trees, i2 * HUFFMAN_MAX_TABLE_SIZE, br);
            ReadHuffmanCode(kNumBlockLengthCodes, block_len_trees, i2 * HUFFMAN_MAX_TABLE_SIZE, br);
            block_length[i2] = ReadBlockLength(block_len_trees, i2 * HUFFMAN_MAX_TABLE_SIZE, br);
            block_type_rb_index[i2] = 1;
          }
        }
        br.readMoreInput();
        distance_postfix_bits = br.readBits(2);
        num_direct_distance_codes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distance_postfix_bits);
        distance_postfix_mask = (1 << distance_postfix_bits) - 1;
        num_distance_codes = num_direct_distance_codes + (48 << distance_postfix_bits);
        context_modes = new Uint8Array(num_block_types[0]);
        for (i2 = 0; i2 < num_block_types[0]; ++i2) {
          br.readMoreInput();
          context_modes[i2] = br.readBits(2) << 1;
        }
        var _o1 = DecodeContextMap(num_block_types[0] << kLiteralContextBits, br);
        num_literal_htrees = _o1.num_htrees;
        context_map = _o1.context_map;
        var _o2 = DecodeContextMap(num_block_types[2] << kDistanceContextBits, br);
        num_dist_htrees = _o2.num_htrees;
        dist_context_map = _o2.context_map;
        hgroup[0] = new HuffmanTreeGroup(kNumLiteralCodes, num_literal_htrees);
        hgroup[1] = new HuffmanTreeGroup(kNumInsertAndCopyCodes, num_block_types[1]);
        hgroup[2] = new HuffmanTreeGroup(num_distance_codes, num_dist_htrees);
        for (i2 = 0; i2 < 3; ++i2) {
          hgroup[i2].decode(br);
        }
        context_map_slice = 0;
        dist_context_map_slice = 0;
        context_mode = context_modes[block_type[0]];
        context_lookup_offset1 = Context2.lookupOffsets[context_mode];
        context_lookup_offset2 = Context2.lookupOffsets[context_mode + 1];
        htree_command = hgroup[1].htrees[0];
        while (meta_block_remaining_len > 0) {
          var cmd_code;
          var range_idx;
          var insert_code;
          var copy_code;
          var insert_length;
          var copy_length;
          var distance_code;
          var distance;
          var context2;
          var j;
          var copy_dst;
          br.readMoreInput();
          if (block_length[1] === 0) {
            DecodeBlockType(
              num_block_types[1],
              block_type_trees,
              1,
              block_type,
              block_type_rb,
              block_type_rb_index,
              br
            );
            block_length[1] = ReadBlockLength(block_len_trees, HUFFMAN_MAX_TABLE_SIZE, br);
            htree_command = hgroup[1].htrees[block_type[1]];
          }
          --block_length[1];
          cmd_code = ReadSymbol(hgroup[1].codes, htree_command, br);
          range_idx = cmd_code >> 6;
          if (range_idx >= 2) {
            range_idx -= 2;
            distance_code = -1;
          } else {
            distance_code = 0;
          }
          insert_code = Prefix.kInsertRangeLut[range_idx] + (cmd_code >> 3 & 7);
          copy_code = Prefix.kCopyRangeLut[range_idx] + (cmd_code & 7);
          insert_length = Prefix.kInsertLengthPrefixCode[insert_code].offset + br.readBits(Prefix.kInsertLengthPrefixCode[insert_code].nbits);
          copy_length = Prefix.kCopyLengthPrefixCode[copy_code].offset + br.readBits(Prefix.kCopyLengthPrefixCode[copy_code].nbits);
          prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
          prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
          for (j = 0; j < insert_length; ++j) {
            br.readMoreInput();
            if (block_length[0] === 0) {
              DecodeBlockType(
                num_block_types[0],
                block_type_trees,
                0,
                block_type,
                block_type_rb,
                block_type_rb_index,
                br
              );
              block_length[0] = ReadBlockLength(block_len_trees, 0, br);
              context_offset = block_type[0] << kLiteralContextBits;
              context_map_slice = context_offset;
              context_mode = context_modes[block_type[0]];
              context_lookup_offset1 = Context2.lookupOffsets[context_mode];
              context_lookup_offset2 = Context2.lookupOffsets[context_mode + 1];
            }
            context2 = Context2.lookup[context_lookup_offset1 + prev_byte1] | Context2.lookup[context_lookup_offset2 + prev_byte2];
            literal_htree_index = context_map[context_map_slice + context2];
            --block_length[0];
            prev_byte2 = prev_byte1;
            prev_byte1 = ReadSymbol(hgroup[0].codes, hgroup[0].htrees[literal_htree_index], br);
            ringbuffer[pos & ringbuffer_mask] = prev_byte1;
            if ((pos & ringbuffer_mask) === ringbuffer_mask) {
              output.write(ringbuffer, ringbuffer_size);
            }
            ++pos;
          }
          meta_block_remaining_len -= insert_length;
          if (meta_block_remaining_len <= 0) break;
          if (distance_code < 0) {
            var context2;
            br.readMoreInput();
            if (block_length[2] === 0) {
              DecodeBlockType(
                num_block_types[2],
                block_type_trees,
                2,
                block_type,
                block_type_rb,
                block_type_rb_index,
                br
              );
              block_length[2] = ReadBlockLength(block_len_trees, 2 * HUFFMAN_MAX_TABLE_SIZE, br);
              dist_context_offset = block_type[2] << kDistanceContextBits;
              dist_context_map_slice = dist_context_offset;
            }
            --block_length[2];
            context2 = (copy_length > 4 ? 3 : copy_length - 2) & 255;
            dist_htree_index = dist_context_map[dist_context_map_slice + context2];
            distance_code = ReadSymbol(hgroup[2].codes, hgroup[2].htrees[dist_htree_index], br);
            if (distance_code >= num_direct_distance_codes) {
              var nbits;
              var postfix;
              var offset2;
              distance_code -= num_direct_distance_codes;
              postfix = distance_code & distance_postfix_mask;
              distance_code >>= distance_postfix_bits;
              nbits = (distance_code >> 1) + 1;
              offset2 = (2 + (distance_code & 1) << nbits) - 4;
              distance_code = num_direct_distance_codes + (offset2 + br.readBits(nbits) << distance_postfix_bits) + postfix;
            }
          }
          distance = TranslateShortCodes(distance_code, dist_rb, dist_rb_idx);
          if (distance < 0) {
            throw new Error("[BrotliDecompress] invalid distance");
          }
          if (pos < max_backward_distance && max_distance !== max_backward_distance) {
            max_distance = pos;
          } else {
            max_distance = max_backward_distance;
          }
          copy_dst = pos & ringbuffer_mask;
          if (distance > max_distance) {
            if (copy_length >= BrotliDictionary.minDictionaryWordLength && copy_length <= BrotliDictionary.maxDictionaryWordLength) {
              var offset2 = BrotliDictionary.offsetsByLength[copy_length];
              var word_id = distance - max_distance - 1;
              var shift = BrotliDictionary.sizeBitsByLength[copy_length];
              var mask = (1 << shift) - 1;
              var word_idx = word_id & mask;
              var transform_idx = word_id >> shift;
              offset2 += word_idx * copy_length;
              if (transform_idx < Transform3.kNumTransforms) {
                var len = Transform3.transformDictionaryWord(ringbuffer, copy_dst, offset2, copy_length, transform_idx);
                copy_dst += len;
                pos += len;
                meta_block_remaining_len -= len;
                if (copy_dst >= ringbuffer_end) {
                  output.write(ringbuffer, ringbuffer_size);
                  for (var _x = 0; _x < copy_dst - ringbuffer_end; _x++)
                    ringbuffer[_x] = ringbuffer[ringbuffer_end + _x];
                }
              } else {
                throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
              }
            } else {
              throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
            }
          } else {
            if (distance_code > 0) {
              dist_rb[dist_rb_idx & 3] = distance;
              ++dist_rb_idx;
            }
            if (copy_length > meta_block_remaining_len) {
              throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
            }
            for (j = 0; j < copy_length; ++j) {
              ringbuffer[pos & ringbuffer_mask] = ringbuffer[pos - distance & ringbuffer_mask];
              if ((pos & ringbuffer_mask) === ringbuffer_mask) {
                output.write(ringbuffer, ringbuffer_size);
              }
              ++pos;
              --meta_block_remaining_len;
            }
          }
          prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
          prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
        }
        pos &= 1073741823;
      }
      output.write(ringbuffer, pos & ringbuffer_mask);
    }
    __name(BrotliDecompress, "BrotliDecompress");
    exports.BrotliDecompress = BrotliDecompress;
    BrotliDictionary.init();
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/decompress.js
var require_decompress = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/decompress.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = require_decode().BrotliDecompressBuffer;
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function ZStream2() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    __name(ZStream2, "ZStream");
    module.exports = ZStream2;
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    __name(_has, "_has");
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p3 in source) {
          if (_has(source, p3)) {
            obj[p3] = source[p3];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: /* @__PURE__ */ __name(function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i2 = 0; i2 < len; i2++) {
          dest[dest_offs + i2] = src[src_offs + i2];
        }
      }, "arraySet"),
      // Join array of chunks to single array.
      flattenChunks: /* @__PURE__ */ __name(function(chunks) {
        var i2, l4, len, pos, chunk, result;
        len = 0;
        for (i2 = 0, l4 = chunks.length; i2 < l4; i2++) {
          len += chunks[i2].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i2 = 0, l4 = chunks.length; i2 < l4; i2++) {
          chunk = chunks[i2];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }, "flattenChunks")
    };
    var fnUntyped = {
      arraySet: /* @__PURE__ */ __name(function(dest, src, src_offs, len, dest_offs) {
        for (var i2 = 0; i2 < len; i2++) {
          dest[dest_offs + i2] = src[src_offs + i2];
        }
      }, "arraySet"),
      // Join array of chunks to single array.
      flattenChunks: /* @__PURE__ */ __name(function(chunks) {
        return [].concat.apply([], chunks);
      }, "flattenChunks")
    };
    exports.setTyped = function(on4) {
      if (on4) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var utils2 = require_common();
    var Z_FIXED2 = 4;
    var Z_BINARY2 = 0;
    var Z_TEXT2 = 1;
    var Z_UNKNOWN2 = 2;
    function zero2(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    __name(zero2, "zero");
    var STORED_BLOCK2 = 0;
    var STATIC_TREES2 = 1;
    var DYN_TREES2 = 2;
    var MIN_MATCH2 = 3;
    var MAX_MATCH2 = 258;
    var LENGTH_CODES2 = 29;
    var LITERALS2 = 256;
    var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
    var D_CODES2 = 30;
    var BL_CODES2 = 19;
    var HEAP_SIZE2 = 2 * L_CODES2 + 1;
    var MAX_BITS2 = 15;
    var Buf_size2 = 16;
    var MAX_BL_BITS2 = 7;
    var END_BLOCK2 = 256;
    var REP_3_62 = 16;
    var REPZ_3_102 = 17;
    var REPZ_11_1382 = 18;
    var extra_lbits2 = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits2 = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits2 = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN2 = 512;
    var static_ltree2 = new Array((L_CODES2 + 2) * 2);
    zero2(static_ltree2);
    var static_dtree2 = new Array(D_CODES2 * 2);
    zero2(static_dtree2);
    var _dist_code2 = new Array(DIST_CODE_LEN2);
    zero2(_dist_code2);
    var _length_code2 = new Array(MAX_MATCH2 - MIN_MATCH2 + 1);
    zero2(_length_code2);
    var base_length2 = new Array(LENGTH_CODES2);
    zero2(base_length2);
    var base_dist2 = new Array(D_CODES2);
    zero2(base_dist2);
    function StaticTreeDesc2(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    __name(StaticTreeDesc2, "StaticTreeDesc");
    var static_l_desc2;
    var static_d_desc2;
    var static_bl_desc2;
    function TreeDesc2(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    __name(TreeDesc2, "TreeDesc");
    function d_code2(dist) {
      return dist < 256 ? _dist_code2[dist] : _dist_code2[256 + (dist >>> 7)];
    }
    __name(d_code2, "d_code");
    function put_short2(s4, w) {
      s4.pending_buf[s4.pending++] = w & 255;
      s4.pending_buf[s4.pending++] = w >>> 8 & 255;
    }
    __name(put_short2, "put_short");
    function send_bits2(s4, value2, length2) {
      if (s4.bi_valid > Buf_size2 - length2) {
        s4.bi_buf |= value2 << s4.bi_valid & 65535;
        put_short2(s4, s4.bi_buf);
        s4.bi_buf = value2 >> Buf_size2 - s4.bi_valid;
        s4.bi_valid += length2 - Buf_size2;
      } else {
        s4.bi_buf |= value2 << s4.bi_valid & 65535;
        s4.bi_valid += length2;
      }
    }
    __name(send_bits2, "send_bits");
    function send_code2(s4, c2, tree) {
      send_bits2(
        s4,
        tree[c2 * 2],
        tree[c2 * 2 + 1]
        /*.Len*/
      );
    }
    __name(send_code2, "send_code");
    function bi_reverse2(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    __name(bi_reverse2, "bi_reverse");
    function bi_flush2(s4) {
      if (s4.bi_valid === 16) {
        put_short2(s4, s4.bi_buf);
        s4.bi_buf = 0;
        s4.bi_valid = 0;
      } else if (s4.bi_valid >= 8) {
        s4.pending_buf[s4.pending++] = s4.bi_buf & 255;
        s4.bi_buf >>= 8;
        s4.bi_valid -= 8;
      }
    }
    __name(bi_flush2, "bi_flush");
    function gen_bitlen2(s4, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n5, m3;
      var bits;
      var xbits;
      var f4;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS2; bits++) {
        s4.bl_count[bits] = 0;
      }
      tree[s4.heap[s4.heap_max] * 2 + 1] = 0;
      for (h = s4.heap_max + 1; h < HEAP_SIZE2; h++) {
        n5 = s4.heap[h];
        bits = tree[tree[n5 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n5 * 2 + 1] = bits;
        if (n5 > max_code) {
          continue;
        }
        s4.bl_count[bits]++;
        xbits = 0;
        if (n5 >= base) {
          xbits = extra[n5 - base];
        }
        f4 = tree[n5 * 2];
        s4.opt_len += f4 * (bits + xbits);
        if (has_stree) {
          s4.static_len += f4 * (stree[n5 * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s4.bl_count[bits] === 0) {
          bits--;
        }
        s4.bl_count[bits]--;
        s4.bl_count[bits + 1] += 2;
        s4.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n5 = s4.bl_count[bits];
        while (n5 !== 0) {
          m3 = s4.heap[--h];
          if (m3 > max_code) {
            continue;
          }
          if (tree[m3 * 2 + 1] !== bits) {
            s4.opt_len += (bits - tree[m3 * 2 + 1]) * tree[m3 * 2];
            tree[m3 * 2 + 1] = bits;
          }
          n5--;
        }
      }
    }
    __name(gen_bitlen2, "gen_bitlen");
    function gen_codes2(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS2 + 1);
      var code = 0;
      var bits;
      var n5;
      for (bits = 1; bits <= MAX_BITS2; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n5 = 0; n5 <= max_code; n5++) {
        var len = tree[n5 * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n5 * 2] = bi_reverse2(next_code[len]++, len);
      }
    }
    __name(gen_codes2, "gen_codes");
    function tr_static_init2() {
      var n5;
      var bits;
      var length2;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS2 + 1);
      length2 = 0;
      for (code = 0; code < LENGTH_CODES2 - 1; code++) {
        base_length2[code] = length2;
        for (n5 = 0; n5 < 1 << extra_lbits2[code]; n5++) {
          _length_code2[length2++] = code;
        }
      }
      _length_code2[length2 - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist2[code] = dist;
        for (n5 = 0; n5 < 1 << extra_dbits2[code]; n5++) {
          _dist_code2[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES2; code++) {
        base_dist2[code] = dist << 7;
        for (n5 = 0; n5 < 1 << extra_dbits2[code] - 7; n5++) {
          _dist_code2[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS2; bits++) {
        bl_count[bits] = 0;
      }
      n5 = 0;
      while (n5 <= 143) {
        static_ltree2[n5 * 2 + 1] = 8;
        n5++;
        bl_count[8]++;
      }
      while (n5 <= 255) {
        static_ltree2[n5 * 2 + 1] = 9;
        n5++;
        bl_count[9]++;
      }
      while (n5 <= 279) {
        static_ltree2[n5 * 2 + 1] = 7;
        n5++;
        bl_count[7]++;
      }
      while (n5 <= 287) {
        static_ltree2[n5 * 2 + 1] = 8;
        n5++;
        bl_count[8]++;
      }
      gen_codes2(static_ltree2, L_CODES2 + 1, bl_count);
      for (n5 = 0; n5 < D_CODES2; n5++) {
        static_dtree2[n5 * 2 + 1] = 5;
        static_dtree2[n5 * 2] = bi_reverse2(n5, 5);
      }
      static_l_desc2 = new StaticTreeDesc2(static_ltree2, extra_lbits2, LITERALS2 + 1, L_CODES2, MAX_BITS2);
      static_d_desc2 = new StaticTreeDesc2(static_dtree2, extra_dbits2, 0, D_CODES2, MAX_BITS2);
      static_bl_desc2 = new StaticTreeDesc2(new Array(0), extra_blbits2, 0, BL_CODES2, MAX_BL_BITS2);
    }
    __name(tr_static_init2, "tr_static_init");
    function init_block2(s4) {
      var n5;
      for (n5 = 0; n5 < L_CODES2; n5++) {
        s4.dyn_ltree[n5 * 2] = 0;
      }
      for (n5 = 0; n5 < D_CODES2; n5++) {
        s4.dyn_dtree[n5 * 2] = 0;
      }
      for (n5 = 0; n5 < BL_CODES2; n5++) {
        s4.bl_tree[n5 * 2] = 0;
      }
      s4.dyn_ltree[END_BLOCK2 * 2] = 1;
      s4.opt_len = s4.static_len = 0;
      s4.last_lit = s4.matches = 0;
    }
    __name(init_block2, "init_block");
    function bi_windup2(s4) {
      if (s4.bi_valid > 8) {
        put_short2(s4, s4.bi_buf);
      } else if (s4.bi_valid > 0) {
        s4.pending_buf[s4.pending++] = s4.bi_buf;
      }
      s4.bi_buf = 0;
      s4.bi_valid = 0;
    }
    __name(bi_windup2, "bi_windup");
    function copy_block2(s4, buf, len, header) {
      bi_windup2(s4);
      if (header) {
        put_short2(s4, len);
        put_short2(s4, ~len);
      }
      utils2.arraySet(s4.pending_buf, s4.window, buf, len, s4.pending);
      s4.pending += len;
    }
    __name(copy_block2, "copy_block");
    function smaller2(tree, n5, m3, depth) {
      var _n2 = n5 * 2;
      var _m2 = m3 * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n5] <= depth[m3];
    }
    __name(smaller2, "smaller");
    function pqdownheap2(s4, tree, k3) {
      var v3 = s4.heap[k3];
      var j = k3 << 1;
      while (j <= s4.heap_len) {
        if (j < s4.heap_len && smaller2(tree, s4.heap[j + 1], s4.heap[j], s4.depth)) {
          j++;
        }
        if (smaller2(tree, v3, s4.heap[j], s4.depth)) {
          break;
        }
        s4.heap[k3] = s4.heap[j];
        k3 = j;
        j <<= 1;
      }
      s4.heap[k3] = v3;
    }
    __name(pqdownheap2, "pqdownheap");
    function compress_block2(s4, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s4.last_lit !== 0) {
        do {
          dist = s4.pending_buf[s4.d_buf + lx * 2] << 8 | s4.pending_buf[s4.d_buf + lx * 2 + 1];
          lc = s4.pending_buf[s4.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code2(s4, lc, ltree);
          } else {
            code = _length_code2[lc];
            send_code2(s4, code + LITERALS2 + 1, ltree);
            extra = extra_lbits2[code];
            if (extra !== 0) {
              lc -= base_length2[code];
              send_bits2(s4, lc, extra);
            }
            dist--;
            code = d_code2(dist);
            send_code2(s4, code, dtree);
            extra = extra_dbits2[code];
            if (extra !== 0) {
              dist -= base_dist2[code];
              send_bits2(s4, dist, extra);
            }
          }
        } while (lx < s4.last_lit);
      }
      send_code2(s4, END_BLOCK2, ltree);
    }
    __name(compress_block2, "compress_block");
    function build_tree2(s4, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n5, m3;
      var max_code = -1;
      var node;
      s4.heap_len = 0;
      s4.heap_max = HEAP_SIZE2;
      for (n5 = 0; n5 < elems; n5++) {
        if (tree[n5 * 2] !== 0) {
          s4.heap[++s4.heap_len] = max_code = n5;
          s4.depth[n5] = 0;
        } else {
          tree[n5 * 2 + 1] = 0;
        }
      }
      while (s4.heap_len < 2) {
        node = s4.heap[++s4.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s4.depth[node] = 0;
        s4.opt_len--;
        if (has_stree) {
          s4.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n5 = s4.heap_len >> 1; n5 >= 1; n5--) {
        pqdownheap2(s4, tree, n5);
      }
      node = elems;
      do {
        n5 = s4.heap[
          1
          /*SMALLEST*/
        ];
        s4.heap[
          1
          /*SMALLEST*/
        ] = s4.heap[s4.heap_len--];
        pqdownheap2(
          s4,
          tree,
          1
          /*SMALLEST*/
        );
        m3 = s4.heap[
          1
          /*SMALLEST*/
        ];
        s4.heap[--s4.heap_max] = n5;
        s4.heap[--s4.heap_max] = m3;
        tree[node * 2] = tree[n5 * 2] + tree[m3 * 2];
        s4.depth[node] = (s4.depth[n5] >= s4.depth[m3] ? s4.depth[n5] : s4.depth[m3]) + 1;
        tree[n5 * 2 + 1] = tree[m3 * 2 + 1] = node;
        s4.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap2(
          s4,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s4.heap_len >= 2);
      s4.heap[--s4.heap_max] = s4.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen2(s4, desc);
      gen_codes2(tree, max_code, s4.bl_count);
    }
    __name(build_tree2, "build_tree");
    function scan_tree2(s4, tree, max_code) {
      var n5;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count3 = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n5 = 0; n5 <= max_code; n5++) {
        curlen = nextlen;
        nextlen = tree[(n5 + 1) * 2 + 1];
        if (++count3 < max_count && curlen === nextlen) {
          continue;
        } else if (count3 < min_count) {
          s4.bl_tree[curlen * 2] += count3;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s4.bl_tree[curlen * 2]++;
          }
          s4.bl_tree[REP_3_62 * 2]++;
        } else if (count3 <= 10) {
          s4.bl_tree[REPZ_3_102 * 2]++;
        } else {
          s4.bl_tree[REPZ_11_1382 * 2]++;
        }
        count3 = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    __name(scan_tree2, "scan_tree");
    function send_tree2(s4, tree, max_code) {
      var n5;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count3 = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n5 = 0; n5 <= max_code; n5++) {
        curlen = nextlen;
        nextlen = tree[(n5 + 1) * 2 + 1];
        if (++count3 < max_count && curlen === nextlen) {
          continue;
        } else if (count3 < min_count) {
          do {
            send_code2(s4, curlen, s4.bl_tree);
          } while (--count3 !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code2(s4, curlen, s4.bl_tree);
            count3--;
          }
          send_code2(s4, REP_3_62, s4.bl_tree);
          send_bits2(s4, count3 - 3, 2);
        } else if (count3 <= 10) {
          send_code2(s4, REPZ_3_102, s4.bl_tree);
          send_bits2(s4, count3 - 3, 3);
        } else {
          send_code2(s4, REPZ_11_1382, s4.bl_tree);
          send_bits2(s4, count3 - 11, 7);
        }
        count3 = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    __name(send_tree2, "send_tree");
    function build_bl_tree2(s4) {
      var max_blindex;
      scan_tree2(s4, s4.dyn_ltree, s4.l_desc.max_code);
      scan_tree2(s4, s4.dyn_dtree, s4.d_desc.max_code);
      build_tree2(s4, s4.bl_desc);
      for (max_blindex = BL_CODES2 - 1; max_blindex >= 3; max_blindex--) {
        if (s4.bl_tree[bl_order2[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s4.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    __name(build_bl_tree2, "build_bl_tree");
    function send_all_trees2(s4, lcodes, dcodes, blcodes) {
      var rank2;
      send_bits2(s4, lcodes - 257, 5);
      send_bits2(s4, dcodes - 1, 5);
      send_bits2(s4, blcodes - 4, 4);
      for (rank2 = 0; rank2 < blcodes; rank2++) {
        send_bits2(s4, s4.bl_tree[bl_order2[rank2] * 2 + 1], 3);
      }
      send_tree2(s4, s4.dyn_ltree, lcodes - 1);
      send_tree2(s4, s4.dyn_dtree, dcodes - 1);
    }
    __name(send_all_trees2, "send_all_trees");
    function detect_data_type2(s4) {
      var black_mask = 4093624447;
      var n5;
      for (n5 = 0; n5 <= 31; n5++, black_mask >>>= 1) {
        if (black_mask & 1 && s4.dyn_ltree[n5 * 2] !== 0) {
          return Z_BINARY2;
        }
      }
      if (s4.dyn_ltree[9 * 2] !== 0 || s4.dyn_ltree[10 * 2] !== 0 || s4.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT2;
      }
      for (n5 = 32; n5 < LITERALS2; n5++) {
        if (s4.dyn_ltree[n5 * 2] !== 0) {
          return Z_TEXT2;
        }
      }
      return Z_BINARY2;
    }
    __name(detect_data_type2, "detect_data_type");
    var static_init_done2 = false;
    function _tr_init2(s4) {
      if (!static_init_done2) {
        tr_static_init2();
        static_init_done2 = true;
      }
      s4.l_desc = new TreeDesc2(s4.dyn_ltree, static_l_desc2);
      s4.d_desc = new TreeDesc2(s4.dyn_dtree, static_d_desc2);
      s4.bl_desc = new TreeDesc2(s4.bl_tree, static_bl_desc2);
      s4.bi_buf = 0;
      s4.bi_valid = 0;
      init_block2(s4);
    }
    __name(_tr_init2, "_tr_init");
    function _tr_stored_block2(s4, buf, stored_len, last2) {
      send_bits2(s4, (STORED_BLOCK2 << 1) + (last2 ? 1 : 0), 3);
      copy_block2(s4, buf, stored_len, true);
    }
    __name(_tr_stored_block2, "_tr_stored_block");
    function _tr_align2(s4) {
      send_bits2(s4, STATIC_TREES2 << 1, 3);
      send_code2(s4, END_BLOCK2, static_ltree2);
      bi_flush2(s4);
    }
    __name(_tr_align2, "_tr_align");
    function _tr_flush_block2(s4, buf, stored_len, last2) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s4.level > 0) {
        if (s4.strm.data_type === Z_UNKNOWN2) {
          s4.strm.data_type = detect_data_type2(s4);
        }
        build_tree2(s4, s4.l_desc);
        build_tree2(s4, s4.d_desc);
        max_blindex = build_bl_tree2(s4);
        opt_lenb = s4.opt_len + 3 + 7 >>> 3;
        static_lenb = s4.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block2(s4, buf, stored_len, last2);
      } else if (s4.strategy === Z_FIXED2 || static_lenb === opt_lenb) {
        send_bits2(s4, (STATIC_TREES2 << 1) + (last2 ? 1 : 0), 3);
        compress_block2(s4, static_ltree2, static_dtree2);
      } else {
        send_bits2(s4, (DYN_TREES2 << 1) + (last2 ? 1 : 0), 3);
        send_all_trees2(s4, s4.l_desc.max_code + 1, s4.d_desc.max_code + 1, max_blindex + 1);
        compress_block2(s4, s4.dyn_ltree, s4.dyn_dtree);
      }
      init_block2(s4);
      if (last2) {
        bi_windup2(s4);
      }
    }
    __name(_tr_flush_block2, "_tr_flush_block");
    function _tr_tally2(s4, dist, lc) {
      s4.pending_buf[s4.d_buf + s4.last_lit * 2] = dist >>> 8 & 255;
      s4.pending_buf[s4.d_buf + s4.last_lit * 2 + 1] = dist & 255;
      s4.pending_buf[s4.l_buf + s4.last_lit] = lc & 255;
      s4.last_lit++;
      if (dist === 0) {
        s4.dyn_ltree[lc * 2]++;
      } else {
        s4.matches++;
        dist--;
        s4.dyn_ltree[(_length_code2[lc] + LITERALS2 + 1) * 2]++;
        s4.dyn_dtree[d_code2(dist) * 2]++;
      }
      return s4.last_lit === s4.lit_bufsize - 1;
    }
    __name(_tr_tally2, "_tr_tally");
    exports._tr_init = _tr_init2;
    exports._tr_stored_block = _tr_stored_block2;
    exports._tr_flush_block = _tr_flush_block2;
    exports._tr_tally = _tr_tally2;
    exports._tr_align = _tr_align2;
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function adler322(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s22 = adler >>> 16 & 65535 | 0, n5 = 0;
      while (len !== 0) {
        n5 = len > 2e3 ? 2e3 : len;
        len -= n5;
        do {
          s1 = s1 + buf[pos++] | 0;
          s22 = s22 + s1 | 0;
        } while (--n5);
        s1 %= 65521;
        s22 %= 65521;
      }
      return s1 | s22 << 16 | 0;
    }
    __name(adler322, "adler32");
    module.exports = adler322;
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function makeTable2() {
      var c2, table3 = [];
      for (var n5 = 0; n5 < 256; n5++) {
        c2 = n5;
        for (var k3 = 0; k3 < 8; k3++) {
          c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
        }
        table3[n5] = c2;
      }
      return table3;
    }
    __name(makeTable2, "makeTable");
    var crcTable2 = makeTable2();
    function crc322(crc, buf, len, pos) {
      var t4 = crcTable2, end2 = pos + len;
      crc ^= -1;
      for (var i2 = pos; i2 < end2; i2++) {
        crc = crc >>> 8 ^ t4[(crc ^ buf[i2]) & 255];
      }
      return crc ^ -1;
    }
    __name(crc322, "crc32");
    module.exports = crc322;
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var utils2 = require_common();
    var trees2 = require_trees();
    var adler322 = require_adler32();
    var crc322 = require_crc32();
    var msg2 = require_messages();
    var Z_NO_FLUSH2 = 0;
    var Z_PARTIAL_FLUSH2 = 1;
    var Z_FULL_FLUSH2 = 3;
    var Z_FINISH2 = 4;
    var Z_BLOCK2 = 5;
    var Z_OK2 = 0;
    var Z_STREAM_END2 = 1;
    var Z_STREAM_ERROR2 = -2;
    var Z_DATA_ERROR2 = -3;
    var Z_BUF_ERROR2 = -5;
    var Z_DEFAULT_COMPRESSION2 = -1;
    var Z_FILTERED2 = 1;
    var Z_HUFFMAN_ONLY2 = 2;
    var Z_RLE2 = 3;
    var Z_FIXED2 = 4;
    var Z_DEFAULT_STRATEGY2 = 0;
    var Z_UNKNOWN2 = 2;
    var Z_DEFLATED2 = 8;
    var MAX_MEM_LEVEL2 = 9;
    var MAX_WBITS2 = 15;
    var DEF_MEM_LEVEL2 = 8;
    var LENGTH_CODES2 = 29;
    var LITERALS2 = 256;
    var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
    var D_CODES2 = 30;
    var BL_CODES2 = 19;
    var HEAP_SIZE2 = 2 * L_CODES2 + 1;
    var MAX_BITS2 = 15;
    var MIN_MATCH2 = 3;
    var MAX_MATCH2 = 258;
    var MIN_LOOKAHEAD2 = MAX_MATCH2 + MIN_MATCH2 + 1;
    var PRESET_DICT2 = 32;
    var INIT_STATE2 = 42;
    var EXTRA_STATE2 = 69;
    var NAME_STATE2 = 73;
    var COMMENT_STATE2 = 91;
    var HCRC_STATE2 = 103;
    var BUSY_STATE2 = 113;
    var FINISH_STATE2 = 666;
    var BS_NEED_MORE2 = 1;
    var BS_BLOCK_DONE2 = 2;
    var BS_FINISH_STARTED2 = 3;
    var BS_FINISH_DONE2 = 4;
    var OS_CODE2 = 3;
    function err2(strm, errorCode) {
      strm.msg = msg2[errorCode];
      return errorCode;
    }
    __name(err2, "err");
    function rank2(f4) {
      return (f4 << 1) - (f4 > 4 ? 9 : 0);
    }
    __name(rank2, "rank");
    function zero2(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    __name(zero2, "zero");
    function flush_pending2(strm) {
      var s4 = strm.state;
      var len = s4.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils2.arraySet(strm.output, s4.pending_buf, s4.pending_out, len, strm.next_out);
      strm.next_out += len;
      s4.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s4.pending -= len;
      if (s4.pending === 0) {
        s4.pending_out = 0;
      }
    }
    __name(flush_pending2, "flush_pending");
    function flush_block_only2(s4, last2) {
      trees2._tr_flush_block(s4, s4.block_start >= 0 ? s4.block_start : -1, s4.strstart - s4.block_start, last2);
      s4.block_start = s4.strstart;
      flush_pending2(s4.strm);
    }
    __name(flush_block_only2, "flush_block_only");
    function put_byte2(s4, b3) {
      s4.pending_buf[s4.pending++] = b3;
    }
    __name(put_byte2, "put_byte");
    function putShortMSB2(s4, b3) {
      s4.pending_buf[s4.pending++] = b3 >>> 8 & 255;
      s4.pending_buf[s4.pending++] = b3 & 255;
    }
    __name(putShortMSB2, "putShortMSB");
    function read_buf2(strm, buf, start2, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils2.arraySet(buf, strm.input, strm.next_in, len, start2);
      if (strm.state.wrap === 1) {
        strm.adler = adler322(strm.adler, buf, len, start2);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc322(strm.adler, buf, len, start2);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    __name(read_buf2, "read_buf");
    function longest_match2(s4, cur_match) {
      var chain_length = s4.max_chain_length;
      var scan = s4.strstart;
      var match2;
      var len;
      var best_len = s4.prev_length;
      var nice_match = s4.nice_match;
      var limit = s4.strstart > s4.w_size - MIN_LOOKAHEAD2 ? s4.strstart - (s4.w_size - MIN_LOOKAHEAD2) : 0;
      var _win = s4.window;
      var wmask = s4.w_mask;
      var prev = s4.prev;
      var strend = s4.strstart + MAX_MATCH2;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s4.prev_length >= s4.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s4.lookahead) {
        nice_match = s4.lookahead;
      }
      do {
        match2 = cur_match;
        if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match2++;
        do {
        } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
        len = MAX_MATCH2 - (strend - scan);
        scan = strend - MAX_MATCH2;
        if (len > best_len) {
          s4.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s4.lookahead) {
        return best_len;
      }
      return s4.lookahead;
    }
    __name(longest_match2, "longest_match");
    function fill_window2(s4) {
      var _w_size = s4.w_size;
      var p3, n5, m3, more, str;
      do {
        more = s4.window_size - s4.lookahead - s4.strstart;
        if (s4.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD2)) {
          utils2.arraySet(s4.window, s4.window, _w_size, _w_size, 0);
          s4.match_start -= _w_size;
          s4.strstart -= _w_size;
          s4.block_start -= _w_size;
          n5 = s4.hash_size;
          p3 = n5;
          do {
            m3 = s4.head[--p3];
            s4.head[p3] = m3 >= _w_size ? m3 - _w_size : 0;
          } while (--n5);
          n5 = _w_size;
          p3 = n5;
          do {
            m3 = s4.prev[--p3];
            s4.prev[p3] = m3 >= _w_size ? m3 - _w_size : 0;
          } while (--n5);
          more += _w_size;
        }
        if (s4.strm.avail_in === 0) {
          break;
        }
        n5 = read_buf2(s4.strm, s4.window, s4.strstart + s4.lookahead, more);
        s4.lookahead += n5;
        if (s4.lookahead + s4.insert >= MIN_MATCH2) {
          str = s4.strstart - s4.insert;
          s4.ins_h = s4.window[str];
          s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[str + 1]) & s4.hash_mask;
          while (s4.insert) {
            s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[str + MIN_MATCH2 - 1]) & s4.hash_mask;
            s4.prev[str & s4.w_mask] = s4.head[s4.ins_h];
            s4.head[s4.ins_h] = str;
            str++;
            s4.insert--;
            if (s4.lookahead + s4.insert < MIN_MATCH2) {
              break;
            }
          }
        }
      } while (s4.lookahead < MIN_LOOKAHEAD2 && s4.strm.avail_in !== 0);
    }
    __name(fill_window2, "fill_window");
    function deflate_stored2(s4, flush) {
      var max_block_size = 65535;
      if (max_block_size > s4.pending_buf_size - 5) {
        max_block_size = s4.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s4.lookahead <= 1) {
          fill_window2(s4);
          if (s4.lookahead === 0 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s4.lookahead === 0) {
            break;
          }
        }
        s4.strstart += s4.lookahead;
        s4.lookahead = 0;
        var max_start = s4.block_start + max_block_size;
        if (s4.strstart === 0 || s4.strstart >= max_start) {
          s4.lookahead = s4.strstart - max_start;
          s4.strstart = max_start;
          flush_block_only2(s4, false);
          if (s4.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
        if (s4.strstart - s4.block_start >= s4.w_size - MIN_LOOKAHEAD2) {
          flush_block_only2(s4, false);
          if (s4.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s4.insert = 0;
      if (flush === Z_FINISH2) {
        flush_block_only2(s4, true);
        if (s4.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s4.strstart > s4.block_start) {
        flush_block_only2(s4, false);
        if (s4.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_NEED_MORE2;
    }
    __name(deflate_stored2, "deflate_stored");
    function deflate_fast2(s4, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s4.lookahead < MIN_LOOKAHEAD2) {
          fill_window2(s4);
          if (s4.lookahead < MIN_LOOKAHEAD2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s4.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s4.lookahead >= MIN_MATCH2) {
          s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + MIN_MATCH2 - 1]) & s4.hash_mask;
          hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
          s4.head[s4.ins_h] = s4.strstart;
        }
        if (hash_head !== 0 && s4.strstart - hash_head <= s4.w_size - MIN_LOOKAHEAD2) {
          s4.match_length = longest_match2(s4, hash_head);
        }
        if (s4.match_length >= MIN_MATCH2) {
          bflush = trees2._tr_tally(s4, s4.strstart - s4.match_start, s4.match_length - MIN_MATCH2);
          s4.lookahead -= s4.match_length;
          if (s4.match_length <= s4.max_lazy_match && s4.lookahead >= MIN_MATCH2) {
            s4.match_length--;
            do {
              s4.strstart++;
              s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + MIN_MATCH2 - 1]) & s4.hash_mask;
              hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
              s4.head[s4.ins_h] = s4.strstart;
            } while (--s4.match_length !== 0);
            s4.strstart++;
          } else {
            s4.strstart += s4.match_length;
            s4.match_length = 0;
            s4.ins_h = s4.window[s4.strstart];
            s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + 1]) & s4.hash_mask;
          }
        } else {
          bflush = trees2._tr_tally(s4, 0, s4.window[s4.strstart]);
          s4.lookahead--;
          s4.strstart++;
        }
        if (bflush) {
          flush_block_only2(s4, false);
          if (s4.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s4.insert = s4.strstart < MIN_MATCH2 - 1 ? s4.strstart : MIN_MATCH2 - 1;
      if (flush === Z_FINISH2) {
        flush_block_only2(s4, true);
        if (s4.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s4.last_lit) {
        flush_block_only2(s4, false);
        if (s4.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    __name(deflate_fast2, "deflate_fast");
    function deflate_slow2(s4, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s4.lookahead < MIN_LOOKAHEAD2) {
          fill_window2(s4);
          if (s4.lookahead < MIN_LOOKAHEAD2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s4.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s4.lookahead >= MIN_MATCH2) {
          s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + MIN_MATCH2 - 1]) & s4.hash_mask;
          hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
          s4.head[s4.ins_h] = s4.strstart;
        }
        s4.prev_length = s4.match_length;
        s4.prev_match = s4.match_start;
        s4.match_length = MIN_MATCH2 - 1;
        if (hash_head !== 0 && s4.prev_length < s4.max_lazy_match && s4.strstart - hash_head <= s4.w_size - MIN_LOOKAHEAD2) {
          s4.match_length = longest_match2(s4, hash_head);
          if (s4.match_length <= 5 && (s4.strategy === Z_FILTERED2 || s4.match_length === MIN_MATCH2 && s4.strstart - s4.match_start > 4096)) {
            s4.match_length = MIN_MATCH2 - 1;
          }
        }
        if (s4.prev_length >= MIN_MATCH2 && s4.match_length <= s4.prev_length) {
          max_insert = s4.strstart + s4.lookahead - MIN_MATCH2;
          bflush = trees2._tr_tally(s4, s4.strstart - 1 - s4.prev_match, s4.prev_length - MIN_MATCH2);
          s4.lookahead -= s4.prev_length - 1;
          s4.prev_length -= 2;
          do {
            if (++s4.strstart <= max_insert) {
              s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + MIN_MATCH2 - 1]) & s4.hash_mask;
              hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
              s4.head[s4.ins_h] = s4.strstart;
            }
          } while (--s4.prev_length !== 0);
          s4.match_available = 0;
          s4.match_length = MIN_MATCH2 - 1;
          s4.strstart++;
          if (bflush) {
            flush_block_only2(s4, false);
            if (s4.strm.avail_out === 0) {
              return BS_NEED_MORE2;
            }
          }
        } else if (s4.match_available) {
          bflush = trees2._tr_tally(s4, 0, s4.window[s4.strstart - 1]);
          if (bflush) {
            flush_block_only2(s4, false);
          }
          s4.strstart++;
          s4.lookahead--;
          if (s4.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        } else {
          s4.match_available = 1;
          s4.strstart++;
          s4.lookahead--;
        }
      }
      if (s4.match_available) {
        bflush = trees2._tr_tally(s4, 0, s4.window[s4.strstart - 1]);
        s4.match_available = 0;
      }
      s4.insert = s4.strstart < MIN_MATCH2 - 1 ? s4.strstart : MIN_MATCH2 - 1;
      if (flush === Z_FINISH2) {
        flush_block_only2(s4, true);
        if (s4.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s4.last_lit) {
        flush_block_only2(s4, false);
        if (s4.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    __name(deflate_slow2, "deflate_slow");
    function deflate_rle2(s4, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s4.window;
      for (; ; ) {
        if (s4.lookahead <= MAX_MATCH2) {
          fill_window2(s4);
          if (s4.lookahead <= MAX_MATCH2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s4.lookahead === 0) {
            break;
          }
        }
        s4.match_length = 0;
        if (s4.lookahead >= MIN_MATCH2 && s4.strstart > 0) {
          scan = s4.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s4.strstart + MAX_MATCH2;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s4.match_length = MAX_MATCH2 - (strend - scan);
            if (s4.match_length > s4.lookahead) {
              s4.match_length = s4.lookahead;
            }
          }
        }
        if (s4.match_length >= MIN_MATCH2) {
          bflush = trees2._tr_tally(s4, 1, s4.match_length - MIN_MATCH2);
          s4.lookahead -= s4.match_length;
          s4.strstart += s4.match_length;
          s4.match_length = 0;
        } else {
          bflush = trees2._tr_tally(s4, 0, s4.window[s4.strstart]);
          s4.lookahead--;
          s4.strstart++;
        }
        if (bflush) {
          flush_block_only2(s4, false);
          if (s4.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s4.insert = 0;
      if (flush === Z_FINISH2) {
        flush_block_only2(s4, true);
        if (s4.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s4.last_lit) {
        flush_block_only2(s4, false);
        if (s4.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    __name(deflate_rle2, "deflate_rle");
    function deflate_huff2(s4, flush) {
      var bflush;
      for (; ; ) {
        if (s4.lookahead === 0) {
          fill_window2(s4);
          if (s4.lookahead === 0) {
            if (flush === Z_NO_FLUSH2) {
              return BS_NEED_MORE2;
            }
            break;
          }
        }
        s4.match_length = 0;
        bflush = trees2._tr_tally(s4, 0, s4.window[s4.strstart]);
        s4.lookahead--;
        s4.strstart++;
        if (bflush) {
          flush_block_only2(s4, false);
          if (s4.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s4.insert = 0;
      if (flush === Z_FINISH2) {
        flush_block_only2(s4, true);
        if (s4.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s4.last_lit) {
        flush_block_only2(s4, false);
        if (s4.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    __name(deflate_huff2, "deflate_huff");
    function Config2(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    __name(Config2, "Config");
    var configuration_table2;
    configuration_table2 = [
      /*      good lazy nice chain */
      new Config2(0, 0, 0, 0, deflate_stored2),
      /* 0 store only */
      new Config2(4, 4, 8, 4, deflate_fast2),
      /* 1 max speed, no lazy matches */
      new Config2(4, 5, 16, 8, deflate_fast2),
      /* 2 */
      new Config2(4, 6, 32, 32, deflate_fast2),
      /* 3 */
      new Config2(4, 4, 16, 16, deflate_slow2),
      /* 4 lazy matches */
      new Config2(8, 16, 32, 32, deflate_slow2),
      /* 5 */
      new Config2(8, 16, 128, 128, deflate_slow2),
      /* 6 */
      new Config2(8, 32, 128, 256, deflate_slow2),
      /* 7 */
      new Config2(32, 128, 258, 1024, deflate_slow2),
      /* 8 */
      new Config2(32, 258, 258, 4096, deflate_slow2)
      /* 9 max compression */
    ];
    function lm_init2(s4) {
      s4.window_size = 2 * s4.w_size;
      zero2(s4.head);
      s4.max_lazy_match = configuration_table2[s4.level].max_lazy;
      s4.good_match = configuration_table2[s4.level].good_length;
      s4.nice_match = configuration_table2[s4.level].nice_length;
      s4.max_chain_length = configuration_table2[s4.level].max_chain;
      s4.strstart = 0;
      s4.block_start = 0;
      s4.lookahead = 0;
      s4.insert = 0;
      s4.match_length = s4.prev_length = MIN_MATCH2 - 1;
      s4.match_available = 0;
      s4.ins_h = 0;
    }
    __name(lm_init2, "lm_init");
    function DeflateState2() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED2;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils2.Buf16(HEAP_SIZE2 * 2);
      this.dyn_dtree = new utils2.Buf16((2 * D_CODES2 + 1) * 2);
      this.bl_tree = new utils2.Buf16((2 * BL_CODES2 + 1) * 2);
      zero2(this.dyn_ltree);
      zero2(this.dyn_dtree);
      zero2(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils2.Buf16(MAX_BITS2 + 1);
      this.heap = new utils2.Buf16(2 * L_CODES2 + 1);
      zero2(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils2.Buf16(2 * L_CODES2 + 1);
      zero2(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    __name(DeflateState2, "DeflateState");
    function deflateResetKeep2(strm) {
      var s4;
      if (!strm || !strm.state) {
        return err2(strm, Z_STREAM_ERROR2);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN2;
      s4 = strm.state;
      s4.pending = 0;
      s4.pending_out = 0;
      if (s4.wrap < 0) {
        s4.wrap = -s4.wrap;
      }
      s4.status = s4.wrap ? INIT_STATE2 : BUSY_STATE2;
      strm.adler = s4.wrap === 2 ? 0 : 1;
      s4.last_flush = Z_NO_FLUSH2;
      trees2._tr_init(s4);
      return Z_OK2;
    }
    __name(deflateResetKeep2, "deflateResetKeep");
    function deflateReset2(strm) {
      var ret = deflateResetKeep2(strm);
      if (ret === Z_OK2) {
        lm_init2(strm.state);
      }
      return ret;
    }
    __name(deflateReset2, "deflateReset");
    function deflateSetHeader2(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR2;
      }
      strm.state.gzhead = head;
      return Z_OK2;
    }
    __name(deflateSetHeader2, "deflateSetHeader");
    function deflateInit22(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR2;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION2) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL2 || method !== Z_DEFLATED2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED2) {
        return err2(strm, Z_STREAM_ERROR2);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s4 = new DeflateState2();
      strm.state = s4;
      s4.strm = strm;
      s4.wrap = wrap;
      s4.gzhead = null;
      s4.w_bits = windowBits;
      s4.w_size = 1 << s4.w_bits;
      s4.w_mask = s4.w_size - 1;
      s4.hash_bits = memLevel + 7;
      s4.hash_size = 1 << s4.hash_bits;
      s4.hash_mask = s4.hash_size - 1;
      s4.hash_shift = ~~((s4.hash_bits + MIN_MATCH2 - 1) / MIN_MATCH2);
      s4.window = new utils2.Buf8(s4.w_size * 2);
      s4.head = new utils2.Buf16(s4.hash_size);
      s4.prev = new utils2.Buf16(s4.w_size);
      s4.lit_bufsize = 1 << memLevel + 6;
      s4.pending_buf_size = s4.lit_bufsize * 4;
      s4.pending_buf = new utils2.Buf8(s4.pending_buf_size);
      s4.d_buf = 1 * s4.lit_bufsize;
      s4.l_buf = (1 + 2) * s4.lit_bufsize;
      s4.level = level;
      s4.strategy = strategy;
      s4.method = method;
      return deflateReset2(strm);
    }
    __name(deflateInit22, "deflateInit2");
    function deflateInit3(strm, level) {
      return deflateInit22(strm, level, Z_DEFLATED2, MAX_WBITS2, DEF_MEM_LEVEL2, Z_DEFAULT_STRATEGY2);
    }
    __name(deflateInit3, "deflateInit");
    function deflate2(strm, flush) {
      var old_flush, s4;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK2 || flush < 0) {
        return strm ? err2(strm, Z_STREAM_ERROR2) : Z_STREAM_ERROR2;
      }
      s4 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s4.status === FINISH_STATE2 && flush !== Z_FINISH2) {
        return err2(strm, strm.avail_out === 0 ? Z_BUF_ERROR2 : Z_STREAM_ERROR2);
      }
      s4.strm = strm;
      old_flush = s4.last_flush;
      s4.last_flush = flush;
      if (s4.status === INIT_STATE2) {
        if (s4.wrap === 2) {
          strm.adler = 0;
          put_byte2(s4, 31);
          put_byte2(s4, 139);
          put_byte2(s4, 8);
          if (!s4.gzhead) {
            put_byte2(s4, 0);
            put_byte2(s4, 0);
            put_byte2(s4, 0);
            put_byte2(s4, 0);
            put_byte2(s4, 0);
            put_byte2(s4, s4.level === 9 ? 2 : s4.strategy >= Z_HUFFMAN_ONLY2 || s4.level < 2 ? 4 : 0);
            put_byte2(s4, OS_CODE2);
            s4.status = BUSY_STATE2;
          } else {
            put_byte2(
              s4,
              (s4.gzhead.text ? 1 : 0) + (s4.gzhead.hcrc ? 2 : 0) + (!s4.gzhead.extra ? 0 : 4) + (!s4.gzhead.name ? 0 : 8) + (!s4.gzhead.comment ? 0 : 16)
            );
            put_byte2(s4, s4.gzhead.time & 255);
            put_byte2(s4, s4.gzhead.time >> 8 & 255);
            put_byte2(s4, s4.gzhead.time >> 16 & 255);
            put_byte2(s4, s4.gzhead.time >> 24 & 255);
            put_byte2(s4, s4.level === 9 ? 2 : s4.strategy >= Z_HUFFMAN_ONLY2 || s4.level < 2 ? 4 : 0);
            put_byte2(s4, s4.gzhead.os & 255);
            if (s4.gzhead.extra && s4.gzhead.extra.length) {
              put_byte2(s4, s4.gzhead.extra.length & 255);
              put_byte2(s4, s4.gzhead.extra.length >> 8 & 255);
            }
            if (s4.gzhead.hcrc) {
              strm.adler = crc322(strm.adler, s4.pending_buf, s4.pending, 0);
            }
            s4.gzindex = 0;
            s4.status = EXTRA_STATE2;
          }
        } else {
          var header = Z_DEFLATED2 + (s4.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s4.strategy >= Z_HUFFMAN_ONLY2 || s4.level < 2) {
            level_flags = 0;
          } else if (s4.level < 6) {
            level_flags = 1;
          } else if (s4.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s4.strstart !== 0) {
            header |= PRESET_DICT2;
          }
          header += 31 - header % 31;
          s4.status = BUSY_STATE2;
          putShortMSB2(s4, header);
          if (s4.strstart !== 0) {
            putShortMSB2(s4, strm.adler >>> 16);
            putShortMSB2(s4, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s4.status === EXTRA_STATE2) {
        if (s4.gzhead.extra) {
          beg = s4.pending;
          while (s4.gzindex < (s4.gzhead.extra.length & 65535)) {
            if (s4.pending === s4.pending_buf_size) {
              if (s4.gzhead.hcrc && s4.pending > beg) {
                strm.adler = crc322(strm.adler, s4.pending_buf, s4.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s4.pending;
              if (s4.pending === s4.pending_buf_size) {
                break;
              }
            }
            put_byte2(s4, s4.gzhead.extra[s4.gzindex] & 255);
            s4.gzindex++;
          }
          if (s4.gzhead.hcrc && s4.pending > beg) {
            strm.adler = crc322(strm.adler, s4.pending_buf, s4.pending - beg, beg);
          }
          if (s4.gzindex === s4.gzhead.extra.length) {
            s4.gzindex = 0;
            s4.status = NAME_STATE2;
          }
        } else {
          s4.status = NAME_STATE2;
        }
      }
      if (s4.status === NAME_STATE2) {
        if (s4.gzhead.name) {
          beg = s4.pending;
          do {
            if (s4.pending === s4.pending_buf_size) {
              if (s4.gzhead.hcrc && s4.pending > beg) {
                strm.adler = crc322(strm.adler, s4.pending_buf, s4.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s4.pending;
              if (s4.pending === s4.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s4.gzindex < s4.gzhead.name.length) {
              val = s4.gzhead.name.charCodeAt(s4.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte2(s4, val);
          } while (val !== 0);
          if (s4.gzhead.hcrc && s4.pending > beg) {
            strm.adler = crc322(strm.adler, s4.pending_buf, s4.pending - beg, beg);
          }
          if (val === 0) {
            s4.gzindex = 0;
            s4.status = COMMENT_STATE2;
          }
        } else {
          s4.status = COMMENT_STATE2;
        }
      }
      if (s4.status === COMMENT_STATE2) {
        if (s4.gzhead.comment) {
          beg = s4.pending;
          do {
            if (s4.pending === s4.pending_buf_size) {
              if (s4.gzhead.hcrc && s4.pending > beg) {
                strm.adler = crc322(strm.adler, s4.pending_buf, s4.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s4.pending;
              if (s4.pending === s4.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s4.gzindex < s4.gzhead.comment.length) {
              val = s4.gzhead.comment.charCodeAt(s4.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte2(s4, val);
          } while (val !== 0);
          if (s4.gzhead.hcrc && s4.pending > beg) {
            strm.adler = crc322(strm.adler, s4.pending_buf, s4.pending - beg, beg);
          }
          if (val === 0) {
            s4.status = HCRC_STATE2;
          }
        } else {
          s4.status = HCRC_STATE2;
        }
      }
      if (s4.status === HCRC_STATE2) {
        if (s4.gzhead.hcrc) {
          if (s4.pending + 2 > s4.pending_buf_size) {
            flush_pending2(strm);
          }
          if (s4.pending + 2 <= s4.pending_buf_size) {
            put_byte2(s4, strm.adler & 255);
            put_byte2(s4, strm.adler >> 8 & 255);
            strm.adler = 0;
            s4.status = BUSY_STATE2;
          }
        } else {
          s4.status = BUSY_STATE2;
        }
      }
      if (s4.pending !== 0) {
        flush_pending2(strm);
        if (strm.avail_out === 0) {
          s4.last_flush = -1;
          return Z_OK2;
        }
      } else if (strm.avail_in === 0 && rank2(flush) <= rank2(old_flush) && flush !== Z_FINISH2) {
        return err2(strm, Z_BUF_ERROR2);
      }
      if (s4.status === FINISH_STATE2 && strm.avail_in !== 0) {
        return err2(strm, Z_BUF_ERROR2);
      }
      if (strm.avail_in !== 0 || s4.lookahead !== 0 || flush !== Z_NO_FLUSH2 && s4.status !== FINISH_STATE2) {
        var bstate = s4.strategy === Z_HUFFMAN_ONLY2 ? deflate_huff2(s4, flush) : s4.strategy === Z_RLE2 ? deflate_rle2(s4, flush) : configuration_table2[s4.level].func(s4, flush);
        if (bstate === BS_FINISH_STARTED2 || bstate === BS_FINISH_DONE2) {
          s4.status = FINISH_STATE2;
        }
        if (bstate === BS_NEED_MORE2 || bstate === BS_FINISH_STARTED2) {
          if (strm.avail_out === 0) {
            s4.last_flush = -1;
          }
          return Z_OK2;
        }
        if (bstate === BS_BLOCK_DONE2) {
          if (flush === Z_PARTIAL_FLUSH2) {
            trees2._tr_align(s4);
          } else if (flush !== Z_BLOCK2) {
            trees2._tr_stored_block(s4, 0, 0, false);
            if (flush === Z_FULL_FLUSH2) {
              zero2(s4.head);
              if (s4.lookahead === 0) {
                s4.strstart = 0;
                s4.block_start = 0;
                s4.insert = 0;
              }
            }
          }
          flush_pending2(strm);
          if (strm.avail_out === 0) {
            s4.last_flush = -1;
            return Z_OK2;
          }
        }
      }
      if (flush !== Z_FINISH2) {
        return Z_OK2;
      }
      if (s4.wrap <= 0) {
        return Z_STREAM_END2;
      }
      if (s4.wrap === 2) {
        put_byte2(s4, strm.adler & 255);
        put_byte2(s4, strm.adler >> 8 & 255);
        put_byte2(s4, strm.adler >> 16 & 255);
        put_byte2(s4, strm.adler >> 24 & 255);
        put_byte2(s4, strm.total_in & 255);
        put_byte2(s4, strm.total_in >> 8 & 255);
        put_byte2(s4, strm.total_in >> 16 & 255);
        put_byte2(s4, strm.total_in >> 24 & 255);
      } else {
        putShortMSB2(s4, strm.adler >>> 16);
        putShortMSB2(s4, strm.adler & 65535);
      }
      flush_pending2(strm);
      if (s4.wrap > 0) {
        s4.wrap = -s4.wrap;
      }
      return s4.pending !== 0 ? Z_OK2 : Z_STREAM_END2;
    }
    __name(deflate2, "deflate");
    function deflateEnd2(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      status = strm.state.status;
      if (status !== INIT_STATE2 && status !== EXTRA_STATE2 && status !== NAME_STATE2 && status !== COMMENT_STATE2 && status !== HCRC_STATE2 && status !== BUSY_STATE2 && status !== FINISH_STATE2) {
        return err2(strm, Z_STREAM_ERROR2);
      }
      strm.state = null;
      return status === BUSY_STATE2 ? err2(strm, Z_DATA_ERROR2) : Z_OK2;
    }
    __name(deflateEnd2, "deflateEnd");
    function deflateSetDictionary2(strm, dictionary) {
      var dictLength = dictionary.length;
      var s4;
      var str, n5;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      s4 = strm.state;
      wrap = s4.wrap;
      if (wrap === 2 || wrap === 1 && s4.status !== INIT_STATE2 || s4.lookahead) {
        return Z_STREAM_ERROR2;
      }
      if (wrap === 1) {
        strm.adler = adler322(strm.adler, dictionary, dictLength, 0);
      }
      s4.wrap = 0;
      if (dictLength >= s4.w_size) {
        if (wrap === 0) {
          zero2(s4.head);
          s4.strstart = 0;
          s4.block_start = 0;
          s4.insert = 0;
        }
        tmpDict = new utils2.Buf8(s4.w_size);
        utils2.arraySet(tmpDict, dictionary, dictLength - s4.w_size, s4.w_size, 0);
        dictionary = tmpDict;
        dictLength = s4.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window2(s4);
      while (s4.lookahead >= MIN_MATCH2) {
        str = s4.strstart;
        n5 = s4.lookahead - (MIN_MATCH2 - 1);
        do {
          s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[str + MIN_MATCH2 - 1]) & s4.hash_mask;
          s4.prev[str & s4.w_mask] = s4.head[s4.ins_h];
          s4.head[s4.ins_h] = str;
          str++;
        } while (--n5);
        s4.strstart = str;
        s4.lookahead = MIN_MATCH2 - 1;
        fill_window2(s4);
      }
      s4.strstart += s4.lookahead;
      s4.block_start = s4.strstart;
      s4.insert = s4.lookahead;
      s4.lookahead = 0;
      s4.match_length = s4.prev_length = MIN_MATCH2 - 1;
      s4.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s4.wrap = wrap;
      return Z_OK2;
    }
    __name(deflateSetDictionary2, "deflateSetDictionary");
    exports.deflateInit = deflateInit3;
    exports.deflateInit2 = deflateInit22;
    exports.deflateReset = deflateReset2;
    exports.deflateResetKeep = deflateResetKeep2;
    exports.deflateSetHeader = deflateSetHeader2;
    exports.deflate = deflate2;
    exports.deflateEnd = deflateEnd2;
    exports.deflateSetDictionary = deflateSetDictionary2;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var BAD2 = 30;
    var TYPE2 = 12;
    module.exports = /* @__PURE__ */ __name(function inflate_fast3(strm, start2) {
      var state2;
      var _in;
      var last2;
      var _out;
      var beg;
      var end2;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from4;
      var from_source;
      var input, output;
      state2 = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last2 = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start2 - strm.avail_out);
      end2 = _out + (strm.avail_out - 257);
      dmax = state2.dmax;
      wsize = state2.wsize;
      whave = state2.whave;
      wnext = state2.wnext;
      s_window = state2.window;
      hold = state2.hold;
      bits = state2.bits;
      lcode = state2.lencode;
      dcode = state2.distcode;
      lmask = (1 << state2.lenbits) - 1;
      dmask = (1 << state2.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state2.mode = BAD2;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state2.sane) {
                            strm.msg = "invalid distance too far back";
                            state2.mode = BAD2;
                            break top;
                          }
                        }
                        from4 = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from4 += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from4 += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from4++];
                              } while (--op);
                              from4 = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from4 += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from4++];
                          output[_out++] = from_source[from4++];
                          output[_out++] = from_source[from4++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from4++];
                          if (len > 1) {
                            output[_out++] = from_source[from4++];
                          }
                        }
                      } else {
                        from4 = _out - dist;
                        do {
                          output[_out++] = output[from4++];
                          output[_out++] = output[from4++];
                          output[_out++] = output[from4++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from4++];
                          if (len > 1) {
                            output[_out++] = output[from4++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state2.mode = BAD2;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state2.mode = TYPE2;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state2.mode = BAD2;
                break top;
              }
              break;
            }
        } while (_in < last2 && _out < end2);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
      strm.avail_out = _out < end2 ? 257 + (end2 - _out) : 257 - (_out - end2);
      state2.hold = hold;
      state2.bits = bits;
      return;
    }, "inflate_fast");
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var utils2 = require_common();
    var MAXBITS2 = 15;
    var ENOUGH_LENS2 = 852;
    var ENOUGH_DISTS2 = 592;
    var CODES2 = 0;
    var LENS2 = 1;
    var DISTS2 = 2;
    var lbase2 = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext2 = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase2 = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext2 = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = /* @__PURE__ */ __name(function inflate_table3(type2, lens, lens_index, codes2, table3, table_index, work, opts2) {
      var bits = opts2.bits;
      var len = 0;
      var sym = 0;
      var min2 = 0, max2 = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill4;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end2;
      var count3 = new utils2.Buf16(MAXBITS2 + 1);
      var offs = new utils2.Buf16(MAXBITS2 + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS2; len++) {
        count3[len] = 0;
      }
      for (sym = 0; sym < codes2; sym++) {
        count3[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max2 = MAXBITS2; max2 >= 1; max2--) {
        if (count3[max2] !== 0) {
          break;
        }
      }
      if (root > max2) {
        root = max2;
      }
      if (max2 === 0) {
        table3[table_index++] = 1 << 24 | 64 << 16 | 0;
        table3[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts2.bits = 1;
        return 0;
      }
      for (min2 = 1; min2 < max2; min2++) {
        if (count3[min2] !== 0) {
          break;
        }
      }
      if (root < min2) {
        root = min2;
      }
      left = 1;
      for (len = 1; len <= MAXBITS2; len++) {
        left <<= 1;
        left -= count3[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type2 === CODES2 || max2 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS2; len++) {
        offs[len + 1] = offs[len] + count3[len];
      }
      for (sym = 0; sym < codes2; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type2 === CODES2) {
        base = extra = work;
        end2 = 19;
      } else if (type2 === LENS2) {
        base = lbase2;
        base_index -= 257;
        extra = lext2;
        extra_index -= 257;
        end2 = 256;
      } else {
        base = dbase2;
        extra = dext2;
        end2 = -1;
      }
      huff = 0;
      sym = 0;
      len = min2;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type2 === LENS2 && used > ENOUGH_LENS2 || type2 === DISTS2 && used > ENOUGH_DISTS2) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end2) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end2) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill4 = 1 << curr;
        min2 = fill4;
        do {
          fill4 -= incr;
          table3[next + (huff >> drop) + fill4] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill4 !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count3[len] === 0) {
          if (len === max2) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min2;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max2) {
            left -= count3[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type2 === LENS2 && used > ENOUGH_LENS2 || type2 === DISTS2 && used > ENOUGH_DISTS2) {
            return 1;
          }
          low = huff & mask;
          table3[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table3[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts2.bits = root;
      return 0;
    }, "inflate_table");
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var utils2 = require_common();
    var adler322 = require_adler32();
    var crc322 = require_crc32();
    var inflate_fast3 = require_inffast();
    var inflate_table3 = require_inftrees();
    var CODES2 = 0;
    var LENS2 = 1;
    var DISTS2 = 2;
    var Z_FINISH2 = 4;
    var Z_BLOCK2 = 5;
    var Z_TREES2 = 6;
    var Z_OK2 = 0;
    var Z_STREAM_END2 = 1;
    var Z_NEED_DICT2 = 2;
    var Z_STREAM_ERROR2 = -2;
    var Z_DATA_ERROR2 = -3;
    var Z_MEM_ERROR2 = -4;
    var Z_BUF_ERROR2 = -5;
    var Z_DEFLATED2 = 8;
    var HEAD2 = 1;
    var FLAGS2 = 2;
    var TIME2 = 3;
    var OS2 = 4;
    var EXLEN2 = 5;
    var EXTRA2 = 6;
    var NAME2 = 7;
    var COMMENT2 = 8;
    var HCRC2 = 9;
    var DICTID2 = 10;
    var DICT2 = 11;
    var TYPE2 = 12;
    var TYPEDO2 = 13;
    var STORED2 = 14;
    var COPY_2 = 15;
    var COPY2 = 16;
    var TABLE2 = 17;
    var LENLENS2 = 18;
    var CODELENS2 = 19;
    var LEN_2 = 20;
    var LEN2 = 21;
    var LENEXT2 = 22;
    var DIST2 = 23;
    var DISTEXT2 = 24;
    var MATCH2 = 25;
    var LIT2 = 26;
    var CHECK2 = 27;
    var LENGTH2 = 28;
    var DONE2 = 29;
    var BAD2 = 30;
    var MEM2 = 31;
    var SYNC2 = 32;
    var ENOUGH_LENS2 = 852;
    var ENOUGH_DISTS2 = 592;
    var MAX_WBITS2 = 15;
    var DEF_WBITS2 = MAX_WBITS2;
    function zswap322(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    __name(zswap322, "zswap32");
    function InflateState2() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils2.Buf16(320);
      this.work = new utils2.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    __name(InflateState2, "InflateState");
    function inflateResetKeep2(strm) {
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      strm.total_in = strm.total_out = state2.total = 0;
      strm.msg = "";
      if (state2.wrap) {
        strm.adler = state2.wrap & 1;
      }
      state2.mode = HEAD2;
      state2.last = 0;
      state2.havedict = 0;
      state2.dmax = 32768;
      state2.head = null;
      state2.hold = 0;
      state2.bits = 0;
      state2.lencode = state2.lendyn = new utils2.Buf32(ENOUGH_LENS2);
      state2.distcode = state2.distdyn = new utils2.Buf32(ENOUGH_DISTS2);
      state2.sane = 1;
      state2.back = -1;
      return Z_OK2;
    }
    __name(inflateResetKeep2, "inflateResetKeep");
    function inflateReset3(strm) {
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      state2.wsize = 0;
      state2.whave = 0;
      state2.wnext = 0;
      return inflateResetKeep2(strm);
    }
    __name(inflateReset3, "inflateReset");
    function inflateReset22(strm, windowBits) {
      var wrap;
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR2;
      }
      if (state2.window !== null && state2.wbits !== windowBits) {
        state2.window = null;
      }
      state2.wrap = wrap;
      state2.wbits = windowBits;
      return inflateReset3(strm);
    }
    __name(inflateReset22, "inflateReset2");
    function inflateInit22(strm, windowBits) {
      var ret;
      var state2;
      if (!strm) {
        return Z_STREAM_ERROR2;
      }
      state2 = new InflateState2();
      strm.state = state2;
      state2.window = null;
      ret = inflateReset22(strm, windowBits);
      if (ret !== Z_OK2) {
        strm.state = null;
      }
      return ret;
    }
    __name(inflateInit22, "inflateInit2");
    function inflateInit3(strm) {
      return inflateInit22(strm, DEF_WBITS2);
    }
    __name(inflateInit3, "inflateInit");
    var virgin2 = true;
    var lenfix2;
    var distfix2;
    function fixedtables2(state2) {
      if (virgin2) {
        var sym;
        lenfix2 = new utils2.Buf32(512);
        distfix2 = new utils2.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state2.lens[sym++] = 8;
        }
        while (sym < 256) {
          state2.lens[sym++] = 9;
        }
        while (sym < 280) {
          state2.lens[sym++] = 7;
        }
        while (sym < 288) {
          state2.lens[sym++] = 8;
        }
        inflate_table3(LENS2, state2.lens, 0, 288, lenfix2, 0, state2.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state2.lens[sym++] = 5;
        }
        inflate_table3(DISTS2, state2.lens, 0, 32, distfix2, 0, state2.work, { bits: 5 });
        virgin2 = false;
      }
      state2.lencode = lenfix2;
      state2.lenbits = 9;
      state2.distcode = distfix2;
      state2.distbits = 5;
    }
    __name(fixedtables2, "fixedtables");
    function updatewindow2(strm, src, end2, copy5) {
      var dist;
      var state2 = strm.state;
      if (state2.window === null) {
        state2.wsize = 1 << state2.wbits;
        state2.wnext = 0;
        state2.whave = 0;
        state2.window = new utils2.Buf8(state2.wsize);
      }
      if (copy5 >= state2.wsize) {
        utils2.arraySet(state2.window, src, end2 - state2.wsize, state2.wsize, 0);
        state2.wnext = 0;
        state2.whave = state2.wsize;
      } else {
        dist = state2.wsize - state2.wnext;
        if (dist > copy5) {
          dist = copy5;
        }
        utils2.arraySet(state2.window, src, end2 - copy5, dist, state2.wnext);
        copy5 -= dist;
        if (copy5) {
          utils2.arraySet(state2.window, src, end2 - copy5, copy5, 0);
          state2.wnext = copy5;
          state2.whave = state2.wsize;
        } else {
          state2.wnext += dist;
          if (state2.wnext === state2.wsize) {
            state2.wnext = 0;
          }
          if (state2.whave < state2.wsize) {
            state2.whave += dist;
          }
        }
      }
      return 0;
    }
    __name(updatewindow2, "updatewindow");
    function inflate2(strm, flush) {
      var state2;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy5;
      var from4;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils2.Buf8(4);
      var opts2;
      var n5;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if (state2.mode === TYPE2) {
        state2.mode = TYPEDO2;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state2.hold;
      bits = state2.bits;
      _in = have;
      _out = left;
      ret = Z_OK2;
      inf_leave:
        for (; ; ) {
          switch (state2.mode) {
            case HEAD2:
              if (state2.wrap === 0) {
                state2.mode = TYPEDO2;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state2.wrap & 2 && hold === 35615) {
                state2.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state2.mode = FLAGS2;
                break;
              }
              state2.flags = 0;
              if (state2.head) {
                state2.head.done = false;
              }
              if (!(state2.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state2.mode = BAD2;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED2) {
                strm.msg = "unknown compression method";
                state2.mode = BAD2;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state2.wbits === 0) {
                state2.wbits = len;
              } else if (len > state2.wbits) {
                strm.msg = "invalid window size";
                state2.mode = BAD2;
                break;
              }
              state2.dmax = 1 << len;
              strm.adler = state2.check = 1;
              state2.mode = hold & 512 ? DICTID2 : TYPE2;
              hold = 0;
              bits = 0;
              break;
            case FLAGS2:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.flags = hold;
              if ((state2.flags & 255) !== Z_DEFLATED2) {
                strm.msg = "unknown compression method";
                state2.mode = BAD2;
                break;
              }
              if (state2.flags & 57344) {
                strm.msg = "unknown header flags set";
                state2.mode = BAD2;
                break;
              }
              if (state2.head) {
                state2.head.text = hold >> 8 & 1;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = TIME2;
            /* falls through */
            case TIME2:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state2.head) {
                state2.head.time = hold;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state2.check = crc322(state2.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = OS2;
            /* falls through */
            case OS2:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state2.head) {
                state2.head.xflags = hold & 255;
                state2.head.os = hold >> 8;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = EXLEN2;
            /* falls through */
            case EXLEN2:
              if (state2.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.length = hold;
                if (state2.head) {
                  state2.head.extra_len = hold;
                }
                if (state2.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state2.check = crc322(state2.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state2.head) {
                state2.head.extra = null;
              }
              state2.mode = EXTRA2;
            /* falls through */
            case EXTRA2:
              if (state2.flags & 1024) {
                copy5 = state2.length;
                if (copy5 > have) {
                  copy5 = have;
                }
                if (copy5) {
                  if (state2.head) {
                    len = state2.head.extra_len - state2.length;
                    if (!state2.head.extra) {
                      state2.head.extra = new Array(state2.head.extra_len);
                    }
                    utils2.arraySet(
                      state2.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy5,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state2.flags & 512) {
                    state2.check = crc322(state2.check, input, copy5, next);
                  }
                  have -= copy5;
                  next += copy5;
                  state2.length -= copy5;
                }
                if (state2.length) {
                  break inf_leave;
                }
              }
              state2.length = 0;
              state2.mode = NAME2;
            /* falls through */
            case NAME2:
              if (state2.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy5 = 0;
                do {
                  len = input[next + copy5++];
                  if (state2.head && len && state2.length < 65536) {
                    state2.head.name += String.fromCharCode(len);
                  }
                } while (len && copy5 < have);
                if (state2.flags & 512) {
                  state2.check = crc322(state2.check, input, copy5, next);
                }
                have -= copy5;
                next += copy5;
                if (len) {
                  break inf_leave;
                }
              } else if (state2.head) {
                state2.head.name = null;
              }
              state2.length = 0;
              state2.mode = COMMENT2;
            /* falls through */
            case COMMENT2:
              if (state2.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy5 = 0;
                do {
                  len = input[next + copy5++];
                  if (state2.head && len && state2.length < 65536) {
                    state2.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy5 < have);
                if (state2.flags & 512) {
                  state2.check = crc322(state2.check, input, copy5, next);
                }
                have -= copy5;
                next += copy5;
                if (len) {
                  break inf_leave;
                }
              } else if (state2.head) {
                state2.head.comment = null;
              }
              state2.mode = HCRC2;
            /* falls through */
            case HCRC2:
              if (state2.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state2.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state2.head) {
                state2.head.hcrc = state2.flags >> 9 & 1;
                state2.head.done = true;
              }
              strm.adler = state2.check = 0;
              state2.mode = TYPE2;
              break;
            case DICTID2:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state2.check = zswap322(hold);
              hold = 0;
              bits = 0;
              state2.mode = DICT2;
            /* falls through */
            case DICT2:
              if (state2.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state2.hold = hold;
                state2.bits = bits;
                return Z_NEED_DICT2;
              }
              strm.adler = state2.check = 1;
              state2.mode = TYPE2;
            /* falls through */
            case TYPE2:
              if (flush === Z_BLOCK2 || flush === Z_TREES2) {
                break inf_leave;
              }
            /* falls through */
            case TYPEDO2:
              if (state2.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state2.mode = CHECK2;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state2.mode = STORED2;
                  break;
                case 1:
                  fixedtables2(state2);
                  state2.mode = LEN_2;
                  if (flush === Z_TREES2) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state2.mode = TABLE2;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state2.mode = BAD2;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED2:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state2.mode = BAD2;
                break;
              }
              state2.length = hold & 65535;
              hold = 0;
              bits = 0;
              state2.mode = COPY_2;
              if (flush === Z_TREES2) {
                break inf_leave;
              }
            /* falls through */
            case COPY_2:
              state2.mode = COPY2;
            /* falls through */
            case COPY2:
              copy5 = state2.length;
              if (copy5) {
                if (copy5 > have) {
                  copy5 = have;
                }
                if (copy5 > left) {
                  copy5 = left;
                }
                if (copy5 === 0) {
                  break inf_leave;
                }
                utils2.arraySet(output, input, next, copy5, put);
                have -= copy5;
                next += copy5;
                left -= copy5;
                put += copy5;
                state2.length -= copy5;
                break;
              }
              state2.mode = TYPE2;
              break;
            case TABLE2:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state2.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state2.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state2.nlen > 286 || state2.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state2.mode = BAD2;
                break;
              }
              state2.have = 0;
              state2.mode = LENLENS2;
            /* falls through */
            case LENLENS2:
              while (state2.have < state2.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.lens[order[state2.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state2.have < 19) {
                state2.lens[order[state2.have++]] = 0;
              }
              state2.lencode = state2.lendyn;
              state2.lenbits = 7;
              opts2 = { bits: state2.lenbits };
              ret = inflate_table3(CODES2, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts2);
              state2.lenbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state2.mode = BAD2;
                break;
              }
              state2.have = 0;
              state2.mode = CODELENS2;
            /* falls through */
            case CODELENS2:
              while (state2.have < state2.nlen + state2.ndist) {
                for (; ; ) {
                  here = state2.lencode[hold & (1 << state2.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state2.lens[state2.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n5 = here_bits + 2;
                    while (bits < n5) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state2.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state2.mode = BAD2;
                      break;
                    }
                    len = state2.lens[state2.have - 1];
                    copy5 = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n5 = here_bits + 3;
                    while (bits < n5) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy5 = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n5 = here_bits + 7;
                    while (bits < n5) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy5 = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state2.have + copy5 > state2.nlen + state2.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state2.mode = BAD2;
                    break;
                  }
                  while (copy5--) {
                    state2.lens[state2.have++] = len;
                  }
                }
              }
              if (state2.mode === BAD2) {
                break;
              }
              if (state2.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state2.mode = BAD2;
                break;
              }
              state2.lenbits = 9;
              opts2 = { bits: state2.lenbits };
              ret = inflate_table3(LENS2, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts2);
              state2.lenbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state2.mode = BAD2;
                break;
              }
              state2.distbits = 6;
              state2.distcode = state2.distdyn;
              opts2 = { bits: state2.distbits };
              ret = inflate_table3(DISTS2, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts2);
              state2.distbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state2.mode = BAD2;
                break;
              }
              state2.mode = LEN_2;
              if (flush === Z_TREES2) {
                break inf_leave;
              }
            /* falls through */
            case LEN_2:
              state2.mode = LEN2;
            /* falls through */
            case LEN2:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state2.hold = hold;
                state2.bits = bits;
                inflate_fast3(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state2.hold;
                bits = state2.bits;
                if (state2.mode === TYPE2) {
                  state2.back = -1;
                }
                break;
              }
              state2.back = 0;
              for (; ; ) {
                here = state2.lencode[hold & (1 << state2.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state2.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state2.back += here_bits;
              state2.length = here_val;
              if (here_op === 0) {
                state2.mode = LIT2;
                break;
              }
              if (here_op & 32) {
                state2.back = -1;
                state2.mode = TYPE2;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state2.mode = BAD2;
                break;
              }
              state2.extra = here_op & 15;
              state2.mode = LENEXT2;
            /* falls through */
            case LENEXT2:
              if (state2.extra) {
                n5 = state2.extra;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.length += hold & (1 << state2.extra) - 1;
                hold >>>= state2.extra;
                bits -= state2.extra;
                state2.back += state2.extra;
              }
              state2.was = state2.length;
              state2.mode = DIST2;
            /* falls through */
            case DIST2:
              for (; ; ) {
                here = state2.distcode[hold & (1 << state2.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state2.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state2.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state2.mode = BAD2;
                break;
              }
              state2.offset = here_val;
              state2.extra = here_op & 15;
              state2.mode = DISTEXT2;
            /* falls through */
            case DISTEXT2:
              if (state2.extra) {
                n5 = state2.extra;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.offset += hold & (1 << state2.extra) - 1;
                hold >>>= state2.extra;
                bits -= state2.extra;
                state2.back += state2.extra;
              }
              if (state2.offset > state2.dmax) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD2;
                break;
              }
              state2.mode = MATCH2;
            /* falls through */
            case MATCH2:
              if (left === 0) {
                break inf_leave;
              }
              copy5 = _out - left;
              if (state2.offset > copy5) {
                copy5 = state2.offset - copy5;
                if (copy5 > state2.whave) {
                  if (state2.sane) {
                    strm.msg = "invalid distance too far back";
                    state2.mode = BAD2;
                    break;
                  }
                }
                if (copy5 > state2.wnext) {
                  copy5 -= state2.wnext;
                  from4 = state2.wsize - copy5;
                } else {
                  from4 = state2.wnext - copy5;
                }
                if (copy5 > state2.length) {
                  copy5 = state2.length;
                }
                from_source = state2.window;
              } else {
                from_source = output;
                from4 = put - state2.offset;
                copy5 = state2.length;
              }
              if (copy5 > left) {
                copy5 = left;
              }
              left -= copy5;
              state2.length -= copy5;
              do {
                output[put++] = from_source[from4++];
              } while (--copy5);
              if (state2.length === 0) {
                state2.mode = LEN2;
              }
              break;
            case LIT2:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state2.length;
              left--;
              state2.mode = LEN2;
              break;
            case CHECK2:
              if (state2.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state2.total += _out;
                if (_out) {
                  strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
                  state2.flags ? crc322(state2.check, output, _out, put - _out) : adler322(state2.check, output, _out, put - _out);
                }
                _out = left;
                if ((state2.flags ? hold : zswap322(hold)) !== state2.check) {
                  strm.msg = "incorrect data check";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state2.mode = LENGTH2;
            /* falls through */
            case LENGTH2:
              if (state2.wrap && state2.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state2.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state2.mode = DONE2;
            /* falls through */
            case DONE2:
              ret = Z_STREAM_END2;
              break inf_leave;
            case BAD2:
              ret = Z_DATA_ERROR2;
              break inf_leave;
            case MEM2:
              return Z_MEM_ERROR2;
            case SYNC2:
            /* falls through */
            default:
              return Z_STREAM_ERROR2;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state2.hold = hold;
      state2.bits = bits;
      if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD2 && (state2.mode < CHECK2 || flush !== Z_FINISH2)) {
        if (updatewindow2(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state2.mode = MEM2;
          return Z_MEM_ERROR2;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state2.total += _out;
      if (state2.wrap && _out) {
        strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state2.flags ? crc322(state2.check, output, _out, strm.next_out - _out) : adler322(state2.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE2 ? 128 : 0) + (state2.mode === LEN_2 || state2.mode === COPY_2 ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH2) && ret === Z_OK2) {
        ret = Z_BUF_ERROR2;
      }
      return ret;
    }
    __name(inflate2, "inflate");
    function inflateEnd2(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      var state2 = strm.state;
      if (state2.window) {
        state2.window = null;
      }
      strm.state = null;
      return Z_OK2;
    }
    __name(inflateEnd2, "inflateEnd");
    function inflateGetHeader2(strm, head) {
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if ((state2.wrap & 2) === 0) {
        return Z_STREAM_ERROR2;
      }
      state2.head = head;
      head.done = false;
      return Z_OK2;
    }
    __name(inflateGetHeader2, "inflateGetHeader");
    function inflateSetDictionary2(strm, dictionary) {
      var dictLength = dictionary.length;
      var state2;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if (state2.wrap !== 0 && state2.mode !== DICT2) {
        return Z_STREAM_ERROR2;
      }
      if (state2.mode === DICT2) {
        dictid = 1;
        dictid = adler322(dictid, dictionary, dictLength, 0);
        if (dictid !== state2.check) {
          return Z_DATA_ERROR2;
        }
      }
      ret = updatewindow2(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state2.mode = MEM2;
        return Z_MEM_ERROR2;
      }
      state2.havedict = 1;
      return Z_OK2;
    }
    __name(inflateSetDictionary2, "inflateSetDictionary");
    exports.inflateReset = inflateReset3;
    exports.inflateReset2 = inflateReset22;
    exports.inflateResetKeep = inflateResetKeep2;
    exports.inflateInit = inflateInit3;
    exports.inflateInit2 = inflateInit22;
    exports.inflate = inflate2;
    exports.inflateEnd = inflateEnd2;
    exports.inflateGetHeader = inflateGetHeader2;
    exports.inflateSetDictionary = inflateSetDictionary2;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node-built-in-modules:crypto
import libDefault2 from "crypto";
var require_crypto = __commonJS({
  "node-built-in-modules:crypto"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault2;
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/core.js
var require_core = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/core.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS2 = CryptoJS2 || function(Math2, undefined2) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof __require === "function") {
          try {
            crypto = require_crypto();
          } catch (err2) {
          }
        }
        var cryptoSecureRandomInt = /* @__PURE__ */ __name(function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err2) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err2) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, "cryptoSecureRandomInt");
        var create = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          __name(F, "F");
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base2 = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: /* @__PURE__ */ __name(function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            }, "extend"),
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: /* @__PURE__ */ __name(function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            }, "create"),
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: /* @__PURE__ */ __name(function() {
            }, "init"),
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: /* @__PURE__ */ __name(function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            }, "mixIn"),
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: /* @__PURE__ */ __name(function() {
              return this.init.prototype.extend(this);
            }, "clone")
          };
        }();
        var WordArray = C_lib.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: /* @__PURE__ */ __name(function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          }, "init"),
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: /* @__PURE__ */ __name(function(encoder) {
            return (encoder || Hex).stringify(this);
          }, "toString"),
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: /* @__PURE__ */ __name(function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i2 = 0; i2 < thatSigBytes; i2++) {
                var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          }, "concat"),
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: /* @__PURE__ */ __name(function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          }, "clamp"),
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: /* @__PURE__ */ __name(function() {
            var clone = Base2.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          }, "clone"),
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: /* @__PURE__ */ __name(function(nBytes) {
            var words = [];
            for (var i2 = 0; i2 < nBytes; i2 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }, "random")
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: /* @__PURE__ */ __name(function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          }, "stringify"),
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: /* @__PURE__ */ __name(function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
              words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }, "parse")
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: /* @__PURE__ */ __name(function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          }, "stringify"),
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: /* @__PURE__ */ __name(function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i2 = 0; i2 < latin1StrLength; i2++) {
              words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }, "parse")
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: /* @__PURE__ */ __name(function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e4) {
              throw new Error("Malformed UTF-8 data");
            }
          }, "stringify"),
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: /* @__PURE__ */ __name(function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }, "parse")
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base2.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: /* @__PURE__ */ __name(function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          }, "reset"),
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: /* @__PURE__ */ __name(function(data2) {
            if (typeof data2 == "string") {
              data2 = Utf8.parse(data2);
            }
            this._data.concat(data2);
            this._nDataBytes += data2.sigBytes;
          }, "_append"),
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: /* @__PURE__ */ __name(function(doFlush) {
            var processedWords;
            var data2 = this._data;
            var dataWords = data2.words;
            var dataSigBytes = data2.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset2 = 0; offset2 < nWordsReady; offset2 += blockSize) {
                this._doProcessBlock(dataWords, offset2);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data2.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          }, "_process"),
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: /* @__PURE__ */ __name(function() {
            var clone = Base2.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          }, "clone"),
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base2.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: /* @__PURE__ */ __name(function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          }, "init"),
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: /* @__PURE__ */ __name(function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          }, "reset"),
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: /* @__PURE__ */ __name(function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          }, "update"),
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: /* @__PURE__ */ __name(function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          }, "finalize"),
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: /* @__PURE__ */ __name(function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          }, "_createHelper"),
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: /* @__PURE__ */ __name(function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }, "_createHmacHelper")
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS2;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/md5.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i2 = 0; i2 < 64; i2++) {
            T[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
          }
        })();
        var MD52 = C_algo.MD5 = Hasher.extend({
          _doReset: /* @__PURE__ */ __name(function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          }, "_doReset"),
          _doProcessBlock: /* @__PURE__ */ __name(function(M, offset2) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset2 + i2;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset2 + 0];
            var M_offset_1 = M[offset2 + 1];
            var M_offset_2 = M[offset2 + 2];
            var M_offset_3 = M[offset2 + 3];
            var M_offset_4 = M[offset2 + 4];
            var M_offset_5 = M[offset2 + 5];
            var M_offset_6 = M[offset2 + 6];
            var M_offset_7 = M[offset2 + 7];
            var M_offset_8 = M[offset2 + 8];
            var M_offset_9 = M[offset2 + 9];
            var M_offset_10 = M[offset2 + 10];
            var M_offset_11 = M[offset2 + 11];
            var M_offset_12 = M[offset2 + 12];
            var M_offset_13 = M[offset2 + 13];
            var M_offset_14 = M[offset2 + 14];
            var M_offset_15 = M[offset2 + 15];
            var a4 = H[0];
            var b3 = H[1];
            var c2 = H[2];
            var d3 = H[3];
            a4 = FF(a4, b3, c2, d3, M_offset_0, 7, T[0]);
            d3 = FF(d3, a4, b3, c2, M_offset_1, 12, T[1]);
            c2 = FF(c2, d3, a4, b3, M_offset_2, 17, T[2]);
            b3 = FF(b3, c2, d3, a4, M_offset_3, 22, T[3]);
            a4 = FF(a4, b3, c2, d3, M_offset_4, 7, T[4]);
            d3 = FF(d3, a4, b3, c2, M_offset_5, 12, T[5]);
            c2 = FF(c2, d3, a4, b3, M_offset_6, 17, T[6]);
            b3 = FF(b3, c2, d3, a4, M_offset_7, 22, T[7]);
            a4 = FF(a4, b3, c2, d3, M_offset_8, 7, T[8]);
            d3 = FF(d3, a4, b3, c2, M_offset_9, 12, T[9]);
            c2 = FF(c2, d3, a4, b3, M_offset_10, 17, T[10]);
            b3 = FF(b3, c2, d3, a4, M_offset_11, 22, T[11]);
            a4 = FF(a4, b3, c2, d3, M_offset_12, 7, T[12]);
            d3 = FF(d3, a4, b3, c2, M_offset_13, 12, T[13]);
            c2 = FF(c2, d3, a4, b3, M_offset_14, 17, T[14]);
            b3 = FF(b3, c2, d3, a4, M_offset_15, 22, T[15]);
            a4 = GG(a4, b3, c2, d3, M_offset_1, 5, T[16]);
            d3 = GG(d3, a4, b3, c2, M_offset_6, 9, T[17]);
            c2 = GG(c2, d3, a4, b3, M_offset_11, 14, T[18]);
            b3 = GG(b3, c2, d3, a4, M_offset_0, 20, T[19]);
            a4 = GG(a4, b3, c2, d3, M_offset_5, 5, T[20]);
            d3 = GG(d3, a4, b3, c2, M_offset_10, 9, T[21]);
            c2 = GG(c2, d3, a4, b3, M_offset_15, 14, T[22]);
            b3 = GG(b3, c2, d3, a4, M_offset_4, 20, T[23]);
            a4 = GG(a4, b3, c2, d3, M_offset_9, 5, T[24]);
            d3 = GG(d3, a4, b3, c2, M_offset_14, 9, T[25]);
            c2 = GG(c2, d3, a4, b3, M_offset_3, 14, T[26]);
            b3 = GG(b3, c2, d3, a4, M_offset_8, 20, T[27]);
            a4 = GG(a4, b3, c2, d3, M_offset_13, 5, T[28]);
            d3 = GG(d3, a4, b3, c2, M_offset_2, 9, T[29]);
            c2 = GG(c2, d3, a4, b3, M_offset_7, 14, T[30]);
            b3 = GG(b3, c2, d3, a4, M_offset_12, 20, T[31]);
            a4 = HH(a4, b3, c2, d3, M_offset_5, 4, T[32]);
            d3 = HH(d3, a4, b3, c2, M_offset_8, 11, T[33]);
            c2 = HH(c2, d3, a4, b3, M_offset_11, 16, T[34]);
            b3 = HH(b3, c2, d3, a4, M_offset_14, 23, T[35]);
            a4 = HH(a4, b3, c2, d3, M_offset_1, 4, T[36]);
            d3 = HH(d3, a4, b3, c2, M_offset_4, 11, T[37]);
            c2 = HH(c2, d3, a4, b3, M_offset_7, 16, T[38]);
            b3 = HH(b3, c2, d3, a4, M_offset_10, 23, T[39]);
            a4 = HH(a4, b3, c2, d3, M_offset_13, 4, T[40]);
            d3 = HH(d3, a4, b3, c2, M_offset_0, 11, T[41]);
            c2 = HH(c2, d3, a4, b3, M_offset_3, 16, T[42]);
            b3 = HH(b3, c2, d3, a4, M_offset_6, 23, T[43]);
            a4 = HH(a4, b3, c2, d3, M_offset_9, 4, T[44]);
            d3 = HH(d3, a4, b3, c2, M_offset_12, 11, T[45]);
            c2 = HH(c2, d3, a4, b3, M_offset_15, 16, T[46]);
            b3 = HH(b3, c2, d3, a4, M_offset_2, 23, T[47]);
            a4 = II(a4, b3, c2, d3, M_offset_0, 6, T[48]);
            d3 = II(d3, a4, b3, c2, M_offset_7, 10, T[49]);
            c2 = II(c2, d3, a4, b3, M_offset_14, 15, T[50]);
            b3 = II(b3, c2, d3, a4, M_offset_5, 21, T[51]);
            a4 = II(a4, b3, c2, d3, M_offset_12, 6, T[52]);
            d3 = II(d3, a4, b3, c2, M_offset_3, 10, T[53]);
            c2 = II(c2, d3, a4, b3, M_offset_10, 15, T[54]);
            b3 = II(b3, c2, d3, a4, M_offset_1, 21, T[55]);
            a4 = II(a4, b3, c2, d3, M_offset_8, 6, T[56]);
            d3 = II(d3, a4, b3, c2, M_offset_15, 10, T[57]);
            c2 = II(c2, d3, a4, b3, M_offset_6, 15, T[58]);
            b3 = II(b3, c2, d3, a4, M_offset_13, 21, T[59]);
            a4 = II(a4, b3, c2, d3, M_offset_4, 6, T[60]);
            d3 = II(d3, a4, b3, c2, M_offset_11, 10, T[61]);
            c2 = II(c2, d3, a4, b3, M_offset_2, 15, T[62]);
            b3 = II(b3, c2, d3, a4, M_offset_9, 21, T[63]);
            H[0] = H[0] + a4 | 0;
            H[1] = H[1] + b3 | 0;
            H[2] = H[2] + c2 | 0;
            H[3] = H[3] + d3 | 0;
          }, "_doProcessBlock"),
          _doFinalize: /* @__PURE__ */ __name(function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i2 = 0; i2 < 4; i2++) {
              var H_i = H[i2];
              H[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          }, "_doFinalize"),
          clone: /* @__PURE__ */ __name(function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }, "clone")
        });
        function FF(a4, b3, c2, d3, x, s4, t4) {
          var n5 = a4 + (b3 & c2 | ~b3 & d3) + x + t4;
          return (n5 << s4 | n5 >>> 32 - s4) + b3;
        }
        __name(FF, "FF");
        function GG(a4, b3, c2, d3, x, s4, t4) {
          var n5 = a4 + (b3 & d3 | c2 & ~d3) + x + t4;
          return (n5 << s4 | n5 >>> 32 - s4) + b3;
        }
        __name(GG, "GG");
        function HH(a4, b3, c2, d3, x, s4, t4) {
          var n5 = a4 + (b3 ^ c2 ^ d3) + x + t4;
          return (n5 << s4 | n5 >>> 32 - s4) + b3;
        }
        __name(HH, "HH");
        function II(a4, b3, c2, d3, x, s4, t4) {
          var n5 = a4 + (c2 ^ (b3 | ~d3)) + x + t4;
          return (n5 << s4 | n5 >>> 32 - s4) + b3;
        }
        __name(II, "II");
        C.MD5 = Hasher._createHelper(MD52);
        C.HmacMD5 = Hasher._createHmacHelper(MD52);
      })(Math);
      return CryptoJS2.MD5;
    });
  }
});

// ../../node_modules/.pnpm/base64-js@0.0.8/node_modules/base64-js/lib/b64.js
var require_b64 = __commonJS({
  "../../node_modules/.pnpm/base64-js@0.0.8/node_modules/base64-js/lib/b64.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var lookup4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    (function(exports2) {
      "use strict";
      var Arr4 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var PLUS = "+".charCodeAt(0);
      var SLASH = "/".charCodeAt(0);
      var NUMBER = "0".charCodeAt(0);
      var LOWER = "a".charCodeAt(0);
      var UPPER = "A".charCodeAt(0);
      var PLUS_URL_SAFE = "-".charCodeAt(0);
      var SLASH_URL_SAFE = "_".charCodeAt(0);
      function decode2(elt) {
        var code = elt.charCodeAt(0);
        if (code === PLUS || code === PLUS_URL_SAFE)
          return 62;
        if (code === SLASH || code === SLASH_URL_SAFE)
          return 63;
        if (code < NUMBER)
          return -1;
        if (code < NUMBER + 10)
          return code - NUMBER + 26 + 26;
        if (code < UPPER + 26)
          return code - UPPER;
        if (code < LOWER + 26)
          return code - LOWER + 26;
      }
      __name(decode2, "decode");
      function b64ToByteArray(b64) {
        var i2, j, l4, tmp, placeHolders, arr;
        if (b64.length % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var len = b64.length;
        placeHolders = "=" === b64.charAt(len - 2) ? 2 : "=" === b64.charAt(len - 1) ? 1 : 0;
        arr = new Arr4(b64.length * 3 / 4 - placeHolders);
        l4 = placeHolders > 0 ? b64.length - 4 : b64.length;
        var L = 0;
        function push(v3) {
          arr[L++] = v3;
        }
        __name(push, "push");
        for (i2 = 0, j = 0; i2 < l4; i2 += 4, j += 3) {
          tmp = decode2(b64.charAt(i2)) << 18 | decode2(b64.charAt(i2 + 1)) << 12 | decode2(b64.charAt(i2 + 2)) << 6 | decode2(b64.charAt(i2 + 3));
          push((tmp & 16711680) >> 16);
          push((tmp & 65280) >> 8);
          push(tmp & 255);
        }
        if (placeHolders === 2) {
          tmp = decode2(b64.charAt(i2)) << 2 | decode2(b64.charAt(i2 + 1)) >> 4;
          push(tmp & 255);
        } else if (placeHolders === 1) {
          tmp = decode2(b64.charAt(i2)) << 10 | decode2(b64.charAt(i2 + 1)) << 4 | decode2(b64.charAt(i2 + 2)) >> 2;
          push(tmp >> 8 & 255);
          push(tmp & 255);
        }
        return arr;
      }
      __name(b64ToByteArray, "b64ToByteArray");
      function uint8ToBase64(uint82) {
        var i2, extraBytes = uint82.length % 3, output = "", temp, length2;
        function encode(num) {
          return lookup4.charAt(num);
        }
        __name(encode, "encode");
        function tripletToBase644(num) {
          return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(num & 63);
        }
        __name(tripletToBase644, "tripletToBase64");
        for (i2 = 0, length2 = uint82.length - extraBytes; i2 < length2; i2 += 3) {
          temp = (uint82[i2] << 16) + (uint82[i2 + 1] << 8) + uint82[i2 + 2];
          output += tripletToBase644(temp);
        }
        switch (extraBytes) {
          case 1:
            temp = uint82[uint82.length - 1];
            output += encode(temp >> 2);
            output += encode(temp << 4 & 63);
            output += "==";
            break;
          case 2:
            temp = (uint82[uint82.length - 2] << 8) + uint82[uint82.length - 1];
            output += encode(temp >> 10);
            output += encode(temp >> 4 & 63);
            output += encode(temp << 2 & 63);
            output += "=";
            break;
        }
        return output;
      }
      __name(uint8ToBase64, "uint8ToBase64");
      exports2.toByteArray = b64ToByteArray;
      exports2.fromByteArray = uint8ToBase64;
    })(typeof exports === "undefined" ? exports.base64js = {} : exports);
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/x64-core.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        var X64Word = C_x64.Word = Base2.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: /* @__PURE__ */ __name(function(high, low) {
            this.high = high;
            this.low = low;
          }, "init")
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        var X64WordArray = C_x64.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: /* @__PURE__ */ __name(function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          }, "init"),
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: /* @__PURE__ */ __name(function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i2 = 0; i2 < x64WordsLength; i2++) {
              var x64Word = x64Words[i2];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          }, "toX32"),
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: /* @__PURE__ */ __name(function() {
            var clone = Base2.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i2 = 0; i2 < wordsLength; i2++) {
              words[i2] = words[i2].clone();
            }
            return clone;
          }, "clone")
        });
      })();
      return CryptoJS2;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i2 = 0; i2 < typedArrayByteLength; i2++) {
              words[i2 >>> 2] |= typedArray[i2] << 24 - i2 % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS2.lib.WordArray;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/enc-utf16.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: /* @__PURE__ */ __name(function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 2) {
              var codePoint = words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          }, "stringify"),
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: /* @__PURE__ */ __name(function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i2 = 0; i2 < utf16StrLength; i2++) {
              words[i2 >>> 1] |= utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }, "parse")
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: /* @__PURE__ */ __name(function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 2) {
              var codePoint = swapEndian(words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          }, "stringify"),
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: /* @__PURE__ */ __name(function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i2 = 0; i2 < utf16StrLength; i2++) {
              words[i2 >>> 1] |= swapEndian(utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }, "parse")
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
        __name(swapEndian, "swapEndian");
      })();
      return CryptoJS2.enc.Utf16;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/enc-base64.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: /* @__PURE__ */ __name(function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          }, "stringify"),
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: /* @__PURE__ */ __name(function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          }, "parse"),
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
        __name(parseLoop, "parseLoop");
      })();
      return CryptoJS2.enc.Base64;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/enc-base64url.js
var require_enc_base64url = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/enc-base64url.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64url = C_enc.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: /* @__PURE__ */ __name(function(wordArray, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          }, "stringify"),
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: /* @__PURE__ */ __name(function(base64Str, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var base64StrLength = base64Str.length;
            var map = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          }, "parse"),
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
        __name(parseLoop, "parseLoop");
      })();
      return CryptoJS2.enc.Base64url;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha1.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: /* @__PURE__ */ __name(function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          }, "_doReset"),
          _doProcessBlock: /* @__PURE__ */ __name(function(M, offset2) {
            var H = this._hash.words;
            var a4 = H[0];
            var b3 = H[1];
            var c2 = H[2];
            var d3 = H[3];
            var e4 = H[4];
            for (var i2 = 0; i2 < 80; i2++) {
              if (i2 < 16) {
                W[i2] = M[offset2 + i2] | 0;
              } else {
                var n5 = W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16];
                W[i2] = n5 << 1 | n5 >>> 31;
              }
              var t4 = (a4 << 5 | a4 >>> 27) + e4 + W[i2];
              if (i2 < 20) {
                t4 += (b3 & c2 | ~b3 & d3) + 1518500249;
              } else if (i2 < 40) {
                t4 += (b3 ^ c2 ^ d3) + 1859775393;
              } else if (i2 < 60) {
                t4 += (b3 & c2 | b3 & d3 | c2 & d3) - 1894007588;
              } else {
                t4 += (b3 ^ c2 ^ d3) - 899497514;
              }
              e4 = d3;
              d3 = c2;
              c2 = b3 << 30 | b3 >>> 2;
              b3 = a4;
              a4 = t4;
            }
            H[0] = H[0] + a4 | 0;
            H[1] = H[1] + b3 | 0;
            H[2] = H[2] + c2 | 0;
            H[3] = H[3] + d3 | 0;
            H[4] = H[4] + e4 | 0;
          }, "_doProcessBlock"),
          _doFinalize: /* @__PURE__ */ __name(function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          }, "_doFinalize"),
          clone: /* @__PURE__ */ __name(function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }, "clone")
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS2.SHA1;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha256.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n6) {
            var sqrtN = Math2.sqrt(n6);
            for (var factor2 = 2; factor2 <= sqrtN; factor2++) {
              if (!(n6 % factor2)) {
                return false;
              }
            }
            return true;
          }
          __name(isPrime, "isPrime");
          function getFractionalBits(n6) {
            return (n6 - (n6 | 0)) * 4294967296 | 0;
          }
          __name(getFractionalBits, "getFractionalBits");
          var n5 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n5)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n5, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n5, 1 / 3));
              nPrime++;
            }
            n5++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: /* @__PURE__ */ __name(function() {
            this._hash = new WordArray.init(H.slice(0));
          }, "_doReset"),
          _doProcessBlock: /* @__PURE__ */ __name(function(M, offset2) {
            var H2 = this._hash.words;
            var a4 = H2[0];
            var b3 = H2[1];
            var c2 = H2[2];
            var d3 = H2[3];
            var e4 = H2[4];
            var f4 = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i2 = 0; i2 < 64; i2++) {
              if (i2 < 16) {
                W[i2] = M[offset2 + i2] | 0;
              } else {
                var gamma0x = W[i2 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i2 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i2] = gamma0 + W[i2 - 7] + gamma1 + W[i2 - 16];
              }
              var ch = e4 & f4 ^ ~e4 & g;
              var maj = a4 & b3 ^ a4 & c2 ^ b3 & c2;
              var sigma0 = (a4 << 30 | a4 >>> 2) ^ (a4 << 19 | a4 >>> 13) ^ (a4 << 10 | a4 >>> 22);
              var sigma1 = (e4 << 26 | e4 >>> 6) ^ (e4 << 21 | e4 >>> 11) ^ (e4 << 7 | e4 >>> 25);
              var t1 = h + sigma1 + ch + K[i2] + W[i2];
              var t22 = sigma0 + maj;
              h = g;
              g = f4;
              f4 = e4;
              e4 = d3 + t1 | 0;
              d3 = c2;
              c2 = b3;
              b3 = a4;
              a4 = t1 + t22 | 0;
            }
            H2[0] = H2[0] + a4 | 0;
            H2[1] = H2[1] + b3 | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d3 | 0;
            H2[4] = H2[4] + e4 | 0;
            H2[5] = H2[5] + f4 | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          }, "_doProcessBlock"),
          _doFinalize: /* @__PURE__ */ __name(function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          }, "_doFinalize"),
          clone: /* @__PURE__ */ __name(function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }, "clone")
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS2.SHA256;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha224.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: /* @__PURE__ */ __name(function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          }, "_doReset"),
          _doFinalize: /* @__PURE__ */ __name(function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }, "_doFinalize")
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS2.SHA224;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha512.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        __name(X64Word_create, "X64Word_create");
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i2 = 0; i2 < 80; i2++) {
            W[i2] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: /* @__PURE__ */ __name(function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          }, "_doReset"),
          _doProcessBlock: /* @__PURE__ */ __name(function(M, offset2) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i2 = 0; i2 < 80; i2++) {
              var Wil;
              var Wih;
              var Wi = W[i2];
              if (i2 < 16) {
                Wih = Wi.high = M[offset2 + i2 * 2] | 0;
                Wil = Wi.low = M[offset2 + i2 * 2 + 1] | 0;
              } else {
                var gamma0x = W[i2 - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i2 - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i2 - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i2 - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i2];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          }, "_doProcessBlock"),
          _doFinalize: /* @__PURE__ */ __name(function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          }, "_doFinalize"),
          clone: /* @__PURE__ */ __name(function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }, "clone"),
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS2.SHA512;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha384.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: /* @__PURE__ */ __name(function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          }, "_doReset"),
          _doFinalize: /* @__PURE__ */ __name(function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }, "_doFinalize")
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS2.SHA384;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha3.js
var require_sha3 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha3.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y3 = 0;
          for (var t4 = 0; t4 < 24; t4++) {
            RHO_OFFSETS[x + 5 * y3] = (t4 + 1) * (t4 + 2) / 2 % 64;
            var newX = y3 % 5;
            var newY = (2 * x + 3 * y3) % 5;
            x = newX;
            y3 = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y3 = 0; y3 < 5; y3++) {
              PI_INDEXES[x + 5 * y3] = y3 + (2 * x + 3 * y3) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i2 = 0; i2 < 24; i2++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i2] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i2 = 0; i2 < 25; i2++) {
            T[i2] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: /* @__PURE__ */ __name(function() {
            var state2 = this._state = [];
            for (var i2 = 0; i2 < 25; i2++) {
              state2[i2] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          }, "_doReset"),
          _doProcessBlock: /* @__PURE__ */ __name(function(M, offset2) {
            var state2 = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i2 = 0; i2 < nBlockSizeLanes; i2++) {
              var M2i = M[offset2 + 2 * i2];
              var M2i1 = M[offset2 + 2 * i2 + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state2[i2];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y3 = 0; y3 < 5; y3++) {
                  var lane = state2[x + 5 * y3];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y3 = 0; y3 < 5; y3++) {
                  var lane = state2[x + 5 * y3];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state2[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state2[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y3 = 0; y3 < 5; y3++) {
                  var laneIndex = x + 5 * y3;
                  var lane = state2[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y3];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y3];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state2[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          }, "_doProcessBlock"),
          _doFinalize: /* @__PURE__ */ __name(function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            var state2 = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i2 = 0; i2 < outputLengthLanes; i2++) {
              var lane = state2[i2];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          }, "_doFinalize"),
          clone: /* @__PURE__ */ __name(function() {
            var clone = Hasher.clone.call(this);
            var state2 = clone._state = this._state.slice(0);
            for (var i2 = 0; i2 < 25; i2++) {
              state2[i2] = state2[i2].clone();
            }
            return clone;
          }, "clone")
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS2.SHA3;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/ripemd160.js
var require_ripemd160 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/ripemd160.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: /* @__PURE__ */ __name(function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          }, "_doReset"),
          _doProcessBlock: /* @__PURE__ */ __name(function(M, offset2) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset2 + i2;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t4;
            for (var i2 = 0; i2 < 80; i2 += 1) {
              t4 = al + M[offset2 + zl[i2]] | 0;
              if (i2 < 16) {
                t4 += f1(bl, cl, dl) + hl[0];
              } else if (i2 < 32) {
                t4 += f22(bl, cl, dl) + hl[1];
              } else if (i2 < 48) {
                t4 += f32(bl, cl, dl) + hl[2];
              } else if (i2 < 64) {
                t4 += f4(bl, cl, dl) + hl[3];
              } else {
                t4 += f5(bl, cl, dl) + hl[4];
              }
              t4 = t4 | 0;
              t4 = rotl(t4, sl[i2]);
              t4 = t4 + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t4;
              t4 = ar + M[offset2 + zr[i2]] | 0;
              if (i2 < 16) {
                t4 += f5(br, cr, dr) + hr[0];
              } else if (i2 < 32) {
                t4 += f4(br, cr, dr) + hr[1];
              } else if (i2 < 48) {
                t4 += f32(br, cr, dr) + hr[2];
              } else if (i2 < 64) {
                t4 += f22(br, cr, dr) + hr[3];
              } else {
                t4 += f1(br, cr, dr) + hr[4];
              }
              t4 = t4 | 0;
              t4 = rotl(t4, sr[i2]);
              t4 = t4 + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t4;
            }
            t4 = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t4;
          }, "_doProcessBlock"),
          _doFinalize: /* @__PURE__ */ __name(function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i2 = 0; i2 < 5; i2++) {
              var H_i = H[i2];
              H[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          }, "_doFinalize"),
          clone: /* @__PURE__ */ __name(function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }, "clone")
        });
        function f1(x, y3, z) {
          return x ^ y3 ^ z;
        }
        __name(f1, "f1");
        function f22(x, y3, z) {
          return x & y3 | ~x & z;
        }
        __name(f22, "f2");
        function f32(x, y3, z) {
          return (x | ~y3) ^ z;
        }
        __name(f32, "f3");
        function f4(x, y3, z) {
          return x & z | y3 & ~z;
        }
        __name(f4, "f4");
        function f5(x, y3, z) {
          return x ^ (y3 | ~z);
        }
        __name(f5, "f5");
        function rotl(x, n5) {
          return x << n5 | x >>> 32 - n5;
        }
        __name(rotl, "rotl");
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS2.RIPEMD160;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/hmac.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC = C_algo.HMAC = Base2.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: /* @__PURE__ */ __name(function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i2 = 0; i2 < hasherBlockSize; i2++) {
              oKeyWords[i2] ^= 1549556828;
              iKeyWords[i2] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          }, "init"),
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: /* @__PURE__ */ __name(function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          }, "reset"),
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: /* @__PURE__ */ __name(function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          }, "update"),
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: /* @__PURE__ */ __name(function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }, "finalize")
        });
      })();
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pbkdf2.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: Base2.extend({
            keySize: 128 / 32,
            hasher: SHA256,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: /* @__PURE__ */ __name(function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          }, "init"),
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: /* @__PURE__ */ __name(function(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i2 = 1; i2 < iterations; i2++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }, "compute")
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.PBKDF2;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/evpkdf.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD52 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base2.extend({
            keySize: 128 / 32,
            hasher: MD52,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: /* @__PURE__ */ __name(function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          }, "init"),
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: /* @__PURE__ */ __name(function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i2 = 1; i2 < iterations; i2++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }, "compute")
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.EvpKDF;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/cipher-core.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.lib.Cipher || function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base2.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: /* @__PURE__ */ __name(function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          }, "createEncryptor"),
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: /* @__PURE__ */ __name(function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          }, "createDecryptor"),
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: /* @__PURE__ */ __name(function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          }, "init"),
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: /* @__PURE__ */ __name(function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          }, "reset"),
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: /* @__PURE__ */ __name(function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          }, "process"),
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: /* @__PURE__ */ __name(function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          }, "finalize"),
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            __name(selectCipherStrategy, "selectCipherStrategy");
            return function(cipher) {
              return {
                encrypt: /* @__PURE__ */ __name(function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                }, "encrypt"),
                decrypt: /* @__PURE__ */ __name(function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }, "decrypt")
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: /* @__PURE__ */ __name(function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          }, "_doFinalize"),
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base2.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: /* @__PURE__ */ __name(function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          }, "createEncryptor"),
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: /* @__PURE__ */ __name(function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          }, "createDecryptor"),
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: /* @__PURE__ */ __name(function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }, "init")
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: /* @__PURE__ */ __name(function(words, offset2) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset2, blockSize);
              cipher.encryptBlock(words, offset2);
              this._prevBlock = words.slice(offset2, offset2 + blockSize);
            }, "processBlock")
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: /* @__PURE__ */ __name(function(words, offset2) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset2, offset2 + blockSize);
              cipher.decryptBlock(words, offset2);
              xorBlock.call(this, words, offset2, blockSize);
              this._prevBlock = thisBlock;
            }, "processBlock")
          });
          function xorBlock(words, offset2, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined2;
            } else {
              block = this._prevBlock;
            }
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset2 + i2] ^= block[i2];
            }
          }
          __name(xorBlock, "xorBlock");
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: /* @__PURE__ */ __name(function(data2, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i2 = 0; i2 < nPaddingBytes; i2 += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data2.concat(padding);
          }, "pad"),
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: /* @__PURE__ */ __name(function(data2) {
            var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
            data2.sigBytes -= nPaddingBytes;
          }, "unpad")
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: /* @__PURE__ */ __name(function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          }, "reset"),
          _doProcessBlock: /* @__PURE__ */ __name(function(words, offset2) {
            this._mode.processBlock(words, offset2);
          }, "_doProcessBlock"),
          _doFinalize: /* @__PURE__ */ __name(function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          }, "_doFinalize"),
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base2.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: /* @__PURE__ */ __name(function(cipherParams) {
            this.mixIn(cipherParams);
          }, "init"),
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: /* @__PURE__ */ __name(function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }, "toString")
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: /* @__PURE__ */ __name(function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          }, "stringify"),
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: /* @__PURE__ */ __name(function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }, "parse")
        };
        var SerializableCipher = C_lib.SerializableCipher = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base2.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: /* @__PURE__ */ __name(function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          }, "encrypt"),
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: /* @__PURE__ */ __name(function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          }, "decrypt"),
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: /* @__PURE__ */ __name(function(ciphertext, format3) {
            if (typeof ciphertext == "string") {
              return format3.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }, "_parse")
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: /* @__PURE__ */ __name(function(password, keySize, ivSize, salt, hasher) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            if (!hasher) {
              var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            } else {
              var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
            }
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }, "execute")
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: /* @__PURE__ */ __name(function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          }, "encrypt"),
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: /* @__PURE__ */ __name(function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }, "decrypt")
        });
      }();
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-cfb.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CFB = function() {
        var CFB = CryptoJS2.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: /* @__PURE__ */ __name(function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset2, blockSize, cipher);
            this._prevBlock = words.slice(offset2, offset2 + blockSize);
          }, "processBlock")
        });
        CFB.Decryptor = CFB.extend({
          processBlock: /* @__PURE__ */ __name(function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset2, offset2 + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset2, blockSize, cipher);
            this._prevBlock = thisBlock;
          }, "processBlock")
        });
        function generateKeystreamAndEncrypt(words, offset2, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i2 = 0; i2 < blockSize; i2++) {
            words[offset2 + i2] ^= keystream[i2];
          }
        }
        __name(generateKeystreamAndEncrypt, "generateKeystreamAndEncrypt");
        return CFB;
      }();
      return CryptoJS2.mode.CFB;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ctr.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CTR = function() {
        var CTR = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: /* @__PURE__ */ __name(function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset2 + i2] ^= keystream[i2];
            }
          }, "processBlock")
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS2.mode.CTR;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS2.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b22 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b22 === 255) {
                b22 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b22;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b22 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        __name(incWord, "incWord");
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        __name(incCounter, "incCounter");
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: /* @__PURE__ */ __name(function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset2 + i2] ^= keystream[i2];
            }
          }, "processBlock")
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS2.mode.CTRGladman;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ofb.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.OFB = function() {
        var OFB = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: /* @__PURE__ */ __name(function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset2 + i2] ^= keystream[i2];
            }
          }, "processBlock")
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS2.mode.OFB;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ecb.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.ECB = function() {
        var ECB = CryptoJS2.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: /* @__PURE__ */ __name(function(words, offset2) {
            this._cipher.encryptBlock(words, offset2);
          }, "processBlock")
        });
        ECB.Decryptor = ECB.extend({
          processBlock: /* @__PURE__ */ __name(function(words, offset2) {
            this._cipher.decryptBlock(words, offset2);
          }, "processBlock")
        });
        return ECB;
      }();
      return CryptoJS2.mode.ECB;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-ansix923.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.AnsiX923 = {
        pad: /* @__PURE__ */ __name(function(data2, blockSize) {
          var dataSigBytes = data2.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data2.clamp();
          data2.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data2.sigBytes += nPaddingBytes;
        }, "pad"),
        unpad: /* @__PURE__ */ __name(function(data2) {
          var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
          data2.sigBytes -= nPaddingBytes;
        }, "unpad")
      };
      return CryptoJS2.pad.Ansix923;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-iso10126.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.Iso10126 = {
        pad: /* @__PURE__ */ __name(function(data2, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
          data2.concat(CryptoJS2.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS2.lib.WordArray.create([nPaddingBytes << 24], 1));
        }, "pad"),
        unpad: /* @__PURE__ */ __name(function(data2) {
          var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
          data2.sigBytes -= nPaddingBytes;
        }, "unpad")
      };
      return CryptoJS2.pad.Iso10126;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-iso97971.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.Iso97971 = {
        pad: /* @__PURE__ */ __name(function(data2, blockSize) {
          data2.concat(CryptoJS2.lib.WordArray.create([2147483648], 1));
          CryptoJS2.pad.ZeroPadding.pad(data2, blockSize);
        }, "pad"),
        unpad: /* @__PURE__ */ __name(function(data2) {
          CryptoJS2.pad.ZeroPadding.unpad(data2);
          data2.sigBytes--;
        }, "unpad")
      };
      return CryptoJS2.pad.Iso97971;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.ZeroPadding = {
        pad: /* @__PURE__ */ __name(function(data2, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data2.clamp();
          data2.sigBytes += blockSizeBytes - (data2.sigBytes % blockSizeBytes || blockSizeBytes);
        }, "pad"),
        unpad: /* @__PURE__ */ __name(function(data2) {
          var dataWords = data2.words;
          var i2 = data2.sigBytes - 1;
          for (var i2 = data2.sigBytes - 1; i2 >= 0; i2--) {
            if (dataWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255) {
              data2.sigBytes = i2 + 1;
              break;
            }
          }
        }, "unpad")
      };
      return CryptoJS2.pad.ZeroPadding;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-nopadding.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.NoPadding = {
        pad: /* @__PURE__ */ __name(function() {
        }, "pad"),
        unpad: /* @__PURE__ */ __name(function() {
        }, "unpad")
      };
      return CryptoJS2.pad.NoPadding;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/format-hex.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        var HexFormatter = C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: /* @__PURE__ */ __name(function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          }, "stringify"),
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: /* @__PURE__ */ __name(function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }, "parse")
        };
      })();
      return CryptoJS2.format.Hex;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/aes.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d3 = [];
          for (var i2 = 0; i2 < 256; i2++) {
            if (i2 < 128) {
              d3[i2] = i2 << 1;
            } else {
              d3[i2] = i2 << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i2 = 0; i2 < 256; i2++) {
            var sx2 = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx2 = sx2 >>> 8 ^ sx2 & 255 ^ 99;
            SBOX[x] = sx2;
            INV_SBOX[sx2] = x;
            var x2 = d3[x];
            var x4 = d3[x2];
            var x8 = d3[x4];
            var t4 = d3[sx2] * 257 ^ sx2 * 16843008;
            SUB_MIX_0[x] = t4 << 24 | t4 >>> 8;
            SUB_MIX_1[x] = t4 << 16 | t4 >>> 16;
            SUB_MIX_2[x] = t4 << 8 | t4 >>> 24;
            SUB_MIX_3[x] = t4;
            var t4 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx2] = t4 << 24 | t4 >>> 8;
            INV_SUB_MIX_1[sx2] = t4 << 16 | t4 >>> 16;
            INV_SUB_MIX_2[sx2] = t4 << 8 | t4 >>> 24;
            INV_SUB_MIX_3[sx2] = t4;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d3[d3[d3[x8 ^ x2]]];
              xi ^= d3[d3[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: /* @__PURE__ */ __name(function() {
            var t4;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t4 = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t4 = t4 << 8 | t4 >>> 24;
                  t4 = SBOX[t4 >>> 24] << 24 | SBOX[t4 >>> 16 & 255] << 16 | SBOX[t4 >>> 8 & 255] << 8 | SBOX[t4 & 255];
                  t4 ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t4 = SBOX[t4 >>> 24] << 24 | SBOX[t4 >>> 16 & 255] << 16 | SBOX[t4 >>> 8 & 255] << 8 | SBOX[t4 & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t4;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t4 = keySchedule[ksRow];
              } else {
                var t4 = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t4;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t4 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t4 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t4 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t4 & 255]];
              }
            }
          }, "_doReset"),
          encryptBlock: /* @__PURE__ */ __name(function(M, offset2) {
            this._doCryptBlock(M, offset2, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          }, "encryptBlock"),
          decryptBlock: /* @__PURE__ */ __name(function(M, offset2) {
            var t4 = M[offset2 + 1];
            M[offset2 + 1] = M[offset2 + 3];
            M[offset2 + 3] = t4;
            this._doCryptBlock(M, offset2, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t4 = M[offset2 + 1];
            M[offset2 + 1] = M[offset2 + 3];
            M[offset2 + 3] = t4;
          }, "decryptBlock"),
          _doCryptBlock: /* @__PURE__ */ __name(function(M, offset2, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M[offset2] ^ keySchedule[0];
            var s1 = M[offset2 + 1] ^ keySchedule[1];
            var s22 = M[offset2 + 2] ^ keySchedule[2];
            var s32 = M[offset2 + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s22 >>> 8 & 255] ^ SUB_MIX_32[s32 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s22 >>> 16 & 255] ^ SUB_MIX_22[s32 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t22 = SUB_MIX_02[s22 >>> 24] ^ SUB_MIX_12[s32 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t32 = SUB_MIX_02[s32 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s22 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s22 = t22;
              s32 = t32;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s22 >>> 8 & 255] << 8 | SBOX2[s32 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s22 >>> 16 & 255] << 16 | SBOX2[s32 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t22 = (SBOX2[s22 >>> 24] << 24 | SBOX2[s32 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t32 = (SBOX2[s32 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s22 & 255]) ^ keySchedule[ksRow++];
            M[offset2] = t0;
            M[offset2 + 1] = t1;
            M[offset2 + 2] = t22;
            M[offset2 + 3] = t32;
          }, "_doCryptBlock"),
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS2.AES;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/tripledes.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: /* @__PURE__ */ __name(function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i2 = 0; i2 < 56; i2++) {
              var keyBitPos = PC1[i2] - 1;
              keyBits[i2] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i2 = 0; i2 < 24; i2++) {
                subKey[i2 / 6 | 0] |= keyBits[(PC2[i2] - 1 + bitShift) % 28] << 31 - i2 % 6;
                subKey[4 + (i2 / 6 | 0)] |= keyBits[28 + (PC2[i2 + 24] - 1 + bitShift) % 28] << 31 - i2 % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i2 = 1; i2 < 7; i2++) {
                subKey[i2] = subKey[i2] >>> (i2 - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i2 = 0; i2 < 16; i2++) {
              invSubKeys[i2] = subKeys[15 - i2];
            }
          }, "_doReset"),
          encryptBlock: /* @__PURE__ */ __name(function(M, offset2) {
            this._doCryptBlock(M, offset2, this._subKeys);
          }, "encryptBlock"),
          decryptBlock: /* @__PURE__ */ __name(function(M, offset2) {
            this._doCryptBlock(M, offset2, this._invSubKeys);
          }, "decryptBlock"),
          _doCryptBlock: /* @__PURE__ */ __name(function(M, offset2, subKeys) {
            this._lBlock = M[offset2];
            this._rBlock = M[offset2 + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f4 = 0;
              for (var i2 = 0; i2 < 8; i2++) {
                f4 |= SBOX_P[i2][((rBlock ^ subKey[i2]) & SBOX_MASK[i2]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f4;
            }
            var t4 = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t4;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset2] = this._lBlock;
            M[offset2 + 1] = this._rBlock;
          }, "_doCryptBlock"),
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset2, mask) {
          var t4 = (this._lBlock >>> offset2 ^ this._rBlock) & mask;
          this._rBlock ^= t4;
          this._lBlock ^= t4 << offset2;
        }
        __name(exchangeLR, "exchangeLR");
        function exchangeRL(offset2, mask) {
          var t4 = (this._rBlock >>> offset2 ^ this._lBlock) & mask;
          this._lBlock ^= t4;
          this._rBlock ^= t4 << offset2;
        }
        __name(exchangeRL, "exchangeRL");
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: /* @__PURE__ */ __name(function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          }, "_doReset"),
          encryptBlock: /* @__PURE__ */ __name(function(M, offset2) {
            this._des1.encryptBlock(M, offset2);
            this._des2.decryptBlock(M, offset2);
            this._des3.encryptBlock(M, offset2);
          }, "encryptBlock"),
          decryptBlock: /* @__PURE__ */ __name(function(M, offset2) {
            this._des3.decryptBlock(M, offset2);
            this._des2.encryptBlock(M, offset2);
            this._des1.decryptBlock(M, offset2);
          }, "decryptBlock"),
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS2.TripleDES;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/rc4.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: /* @__PURE__ */ __name(function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S3 = this._S = [];
            for (var i2 = 0; i2 < 256; i2++) {
              S3[i2] = i2;
            }
            for (var i2 = 0, j = 0; i2 < 256; i2++) {
              var keyByteIndex = i2 % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S3[i2] + keyByte) % 256;
              var t4 = S3[i2];
              S3[i2] = S3[j];
              S3[j] = t4;
            }
            this._i = this._j = 0;
          }, "_doReset"),
          _doProcessBlock: /* @__PURE__ */ __name(function(M, offset2) {
            M[offset2] ^= generateKeystreamWord.call(this);
          }, "_doProcessBlock"),
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S3 = this._S;
          var i2 = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n5 = 0; n5 < 4; n5++) {
            i2 = (i2 + 1) % 256;
            j = (j + S3[i2]) % 256;
            var t4 = S3[i2];
            S3[i2] = S3[j];
            S3[j] = t4;
            keystreamWord |= S3[(S3[i2] + S3[j]) % 256] << 24 - n5 * 8;
          }
          this._i = i2;
          this._j = j;
          return keystreamWord;
        }
        __name(generateKeystreamWord, "generateKeystreamWord");
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: /* @__PURE__ */ __name(function() {
            RC4._doReset.call(this);
            for (var i2 = this.cfg.drop; i2 > 0; i2--) {
              generateKeystreamWord.call(this);
            }
          }, "_doReset")
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS2.RC4;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/rabbit.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S3 = [];
        var C_ = [];
        var G2 = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: /* @__PURE__ */ __name(function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i2 = 0; i2 < 4; i2++) {
              K[i2] = (K[i2] << 8 | K[i2] >>> 24) & 16711935 | (K[i2] << 24 | K[i2] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i2 = 0; i2 < 4; i2++) {
              nextState.call(this);
            }
            for (var i2 = 0; i2 < 8; i2++) {
              C2[i2] ^= X[i2 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i3 = i22 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i22;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i22;
              C2[7] ^= i3;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
            }
          }, "_doReset"),
          _doProcessBlock: /* @__PURE__ */ __name(function(M, offset2) {
            var X = this._X;
            nextState.call(this);
            S3[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S3[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S3[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S3[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i2 = 0; i2 < 4; i2++) {
              S3[i2] = (S3[i2] << 8 | S3[i2] >>> 24) & 16711935 | (S3[i2] << 24 | S3[i2] >>> 8) & 4278255360;
              M[offset2 + i2] ^= S3[i2];
            }
          }, "_doProcessBlock"),
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i2 = 0; i2 < 8; i2++) {
            C_[i2] = C2[i2];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i2 = 0; i2 < 8; i2++) {
            var gx = X[i2] + C2[i2];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i2] = gh ^ gl;
          }
          X[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        __name(nextState, "nextState");
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS2.Rabbit;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S3 = [];
        var C_ = [];
        var G2 = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: /* @__PURE__ */ __name(function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i2 = 0; i2 < 4; i2++) {
              nextState.call(this);
            }
            for (var i2 = 0; i2 < 8; i2++) {
              C2[i2] ^= X[i2 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i3 = i22 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i22;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i22;
              C2[7] ^= i3;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
            }
          }, "_doReset"),
          _doProcessBlock: /* @__PURE__ */ __name(function(M, offset2) {
            var X = this._X;
            nextState.call(this);
            S3[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S3[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S3[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S3[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i2 = 0; i2 < 4; i2++) {
              S3[i2] = (S3[i2] << 8 | S3[i2] >>> 24) & 16711935 | (S3[i2] << 24 | S3[i2] >>> 8) & 4278255360;
              M[offset2 + i2] ^= S3[i2];
            }
          }, "_doProcessBlock"),
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i2 = 0; i2 < 8; i2++) {
            C_[i2] = C2[i2];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i2 = 0; i2 < 8; i2++) {
            var gx = X[i2] + C2[i2];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i2] = gh ^ gl;
          }
          X[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        __name(nextState, "nextState");
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS2.RabbitLegacy;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/blowfish.js
var require_blowfish = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/blowfish.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        const N = 16;
        const ORIG_P = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ];
        const ORIG_S = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var BLOWFISH_CTX = {
          pbox: [],
          sbox: []
        };
        function F(ctx, x) {
          let a4 = x >> 24 & 255;
          let b3 = x >> 16 & 255;
          let c2 = x >> 8 & 255;
          let d3 = x & 255;
          let y3 = ctx.sbox[0][a4] + ctx.sbox[1][b3];
          y3 = y3 ^ ctx.sbox[2][c2];
          y3 = y3 + ctx.sbox[3][d3];
          return y3;
        }
        __name(F, "F");
        function BlowFish_Encrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i2 = 0; i2 < N; ++i2) {
            Xl = Xl ^ ctx.pbox[i2];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[N];
          Xl = Xl ^ ctx.pbox[N + 1];
          return { left: Xl, right: Xr };
        }
        __name(BlowFish_Encrypt, "BlowFish_Encrypt");
        function BlowFish_Decrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i2 = N + 1; i2 > 1; --i2) {
            Xl = Xl ^ ctx.pbox[i2];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[1];
          Xl = Xl ^ ctx.pbox[0];
          return { left: Xl, right: Xr };
        }
        __name(BlowFish_Decrypt, "BlowFish_Decrypt");
        function BlowFishInit(ctx, key, keysize) {
          for (let Row = 0; Row < 4; Row++) {
            ctx.sbox[Row] = [];
            for (let Col = 0; Col < 256; Col++) {
              ctx.sbox[Row][Col] = ORIG_S[Row][Col];
            }
          }
          let keyIndex = 0;
          for (let index2 = 0; index2 < N + 2; index2++) {
            ctx.pbox[index2] = ORIG_P[index2] ^ key[keyIndex];
            keyIndex++;
            if (keyIndex >= keysize) {
              keyIndex = 0;
            }
          }
          let Data1 = 0;
          let Data2 = 0;
          let res = 0;
          for (let i2 = 0; i2 < N + 2; i2 += 2) {
            res = BlowFish_Encrypt(ctx, Data1, Data2);
            Data1 = res.left;
            Data2 = res.right;
            ctx.pbox[i2] = Data1;
            ctx.pbox[i2 + 1] = Data2;
          }
          for (let i2 = 0; i2 < 4; i2++) {
            for (let j = 0; j < 256; j += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.sbox[i2][j] = Data1;
              ctx.sbox[i2][j + 1] = Data2;
            }
          }
          return true;
        }
        __name(BlowFishInit, "BlowFishInit");
        var Blowfish = C_algo.Blowfish = BlockCipher.extend({
          _doReset: /* @__PURE__ */ __name(function() {
            if (this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
          }, "_doReset"),
          encryptBlock: /* @__PURE__ */ __name(function(M, offset2) {
            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset2], M[offset2 + 1]);
            M[offset2] = res.left;
            M[offset2 + 1] = res.right;
          }, "encryptBlock"),
          decryptBlock: /* @__PURE__ */ __name(function(M, offset2) {
            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset2], M[offset2 + 1]);
            M[offset2] = res.left;
            M[offset2 + 1] = res.right;
          }, "decryptBlock"),
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        C.Blowfish = BlockCipher._createHelper(Blowfish);
      })();
      return CryptoJS2.Blowfish;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_enc_base64url(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha3(), require_ripemd160(), require_hmac(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy(), require_blowfish());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy", "./blowfish"], factory);
      } else {
        root.CryptoJS = factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      return CryptoJS2;
    });
  }
});

// ../../node_modules/.pnpm/abs-svg-path@0.1.1/node_modules/abs-svg-path/index.js
var require_abs_svg_path = __commonJS({
  "../../node_modules/.pnpm/abs-svg-path@0.1.1/node_modules/abs-svg-path/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = absolutize;
    function absolutize(path) {
      var startX = 0;
      var startY = 0;
      var x = 0;
      var y3 = 0;
      return path.map(function(seg) {
        seg = seg.slice();
        var type2 = seg[0];
        var command = type2.toUpperCase();
        if (type2 != command) {
          seg[0] = command;
          switch (type2) {
            case "a":
              seg[6] += x;
              seg[7] += y3;
              break;
            case "v":
              seg[1] += y3;
              break;
            case "h":
              seg[1] += x;
              break;
            default:
              for (var i2 = 1; i2 < seg.length; ) {
                seg[i2++] += x;
                seg[i2++] += y3;
              }
          }
        }
        switch (command) {
          case "Z":
            x = startX;
            y3 = startY;
            break;
          case "H":
            x = seg[1];
            break;
          case "V":
            y3 = seg[1];
            break;
          case "M":
            x = startX = seg[1];
            y3 = startY = seg[2];
            break;
          default:
            x = seg[seg.length - 2];
            y3 = seg[seg.length - 1];
        }
        return seg;
      });
    }
    __name(absolutize, "absolutize");
  }
});

// ../../node_modules/.pnpm/parse-svg-path@0.1.2/node_modules/parse-svg-path/index.js
var require_parse_svg_path = __commonJS({
  "../../node_modules/.pnpm/parse-svg-path@0.1.2/node_modules/parse-svg-path/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = parse3;
    var length2 = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
    var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function parse3(path) {
      var data2 = [];
      path.replace(segment, function(_, command, args) {
        var type2 = command.toLowerCase();
        args = parseValues(args);
        if (type2 == "m" && args.length > 2) {
          data2.push([command].concat(args.splice(0, 2)));
          type2 = "l";
          command = command == "m" ? "l" : "L";
        }
        while (true) {
          if (args.length == length2[type2]) {
            args.unshift(command);
            return data2.push(args);
          }
          if (args.length < length2[type2]) throw new Error("malformed path data");
          data2.push([command].concat(args.splice(0, length2[type2])));
        }
      });
      return data2;
    }
    __name(parse3, "parse");
    var number3 = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function parseValues(args) {
      var numbers = args.match(number3);
      return numbers ? numbers.map(Number) : [];
    }
    __name(parseValues, "parseValues");
  }
});

// ../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// ../../node_modules/.pnpm/is-arrayish@0.3.2/node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "../../node_modules/.pnpm/is-arrayish@0.3.2/node_modules/is-arrayish/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    }, "isArrayish");
  }
});

// ../../node_modules/.pnpm/simple-swizzle@0.2.2/node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "../../node_modules/.pnpm/simple-swizzle@0.2.2/node_modules/simple-swizzle/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isArrayish = require_is_arrayish();
    var concat5 = Array.prototype.concat;
    var slice5 = Array.prototype.slice;
    var swizzle = module.exports = /* @__PURE__ */ __name(function swizzle2(args) {
      var results = [];
      for (var i2 = 0, len = args.length; i2 < len; i2++) {
        var arg = args[i2];
        if (isArrayish(arg)) {
          results = concat5.call(results, slice5.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    }, "swizzle");
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// ../../node_modules/.pnpm/color-string@1.9.1/node_modules/color-string/index.js
var require_color_string = __commonJS({
  "../../node_modules/.pnpm/color-string@1.9.1/node_modules/color-string/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty3 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty3.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match2;
      var i2;
      var hexAlpha;
      if (match2 = string.match(hex)) {
        hexAlpha = match2[2];
        match2 = match2[1];
        for (i2 = 0; i2 < 3; i2++) {
          var i22 = i2 * 2;
          rgb[i2] = parseInt(match2.slice(i22, i22 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match2 = string.match(abbr)) {
        match2 = match2[1];
        hexAlpha = match2[3];
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = parseInt(match2[i2] + match2[i2], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match2 = string.match(rgba)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = parseInt(match2[i2 + 1], 0);
        }
        if (match2[4]) {
          if (match2[5]) {
            rgb[3] = parseFloat(match2[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match2[4]);
          }
        }
      } else if (match2 = string.match(per)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = Math.round(parseFloat(match2[i2 + 1]) * 2.55);
        }
        if (match2[4]) {
          if (match2[5]) {
            rgb[3] = parseFloat(match2[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match2[4]);
          }
        }
      } else if (match2 = string.match(keyword)) {
        if (match2[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty3.call(colorNames, match2[1])) {
          return null;
        }
        rgb = colorNames[match2[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i2 = 0; i2 < 3; i2++) {
        rgb[i2] = clamp(rgb[i2], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match2 = string.match(hsl);
      if (match2) {
        var alpha = parseFloat(match2[4]);
        var h = (parseFloat(match2[1]) % 360 + 360) % 360;
        var s4 = clamp(parseFloat(match2[2]), 0, 100);
        var l4 = clamp(parseFloat(match2[3]), 0, 100);
        var a4 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s4, l4, a4];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match2 = string.match(hwb);
      if (match2) {
        var alpha = parseFloat(match2[4]);
        var h = (parseFloat(match2[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match2[2]), 0, 100);
        var b3 = clamp(parseFloat(match2[3]), 0, 100);
        var a4 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b3, a4];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r5 = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b3 = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r5 + "%, " + g + "%, " + b3 + "%)" : "rgba(" + r5 + "%, " + g + "%, " + b3 + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a4 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a4 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a4 + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min2, max2) {
      return Math.min(Math.max(min2, num), max2);
    }
    __name(clamp, "clamp");
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
    __name(hexDouble, "hexDouble");
  }
});

// ../../node_modules/.pnpm/media-engine@1.0.3/node_modules/media-engine/src/queries.js
var require_queries = __commonJS({
  "../../node_modules/.pnpm/media-engine@1.0.3/node_modules/media-engine/src/queries.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function MaxHeight(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value >= options.height;
      };
    }
    __name(MaxHeight, "MaxHeight");
    function MinHeight(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value < options.height;
      };
    }
    __name(MinHeight, "MinHeight");
    function MaxWidth(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value >= options.width;
      };
    }
    __name(MaxWidth, "MaxWidth");
    function MinWidth(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value < options.width;
      };
    }
    __name(MinWidth, "MinWidth");
    function Orientation(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value === options.orientation;
      };
    }
    __name(Orientation, "Orientation");
    module.exports = /* @__PURE__ */ __name(function Query(type2, value2) {
      switch (type2) {
        case "max-height":
          return new MaxHeight(value2);
        case "min-height":
          return new MinHeight(value2);
        case "max-width":
          return new MaxWidth(value2);
        case "min-width":
          return new MinWidth(value2);
        case "orientation":
          return new Orientation(value2);
        default:
          throw new Error(value2);
      }
    }, "Query");
  }
});

// ../../node_modules/.pnpm/media-engine@1.0.3/node_modules/media-engine/src/operators.js
var require_operators = __commonJS({
  "../../node_modules/.pnpm/media-engine@1.0.3/node_modules/media-engine/src/operators.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function And(left, right) {
      this.left = left;
      this.right = right;
      this.match = function(options) {
        return left.match(options) && right.match(options);
      };
    }
    __name(And, "And");
    function Or(left, right) {
      this.left = left;
      this.right = right;
      this.match = function(options) {
        return left.match(options) || right.match(options);
      };
    }
    __name(Or, "Or");
    module.exports = /* @__PURE__ */ __name(function Operator(type2, left, right) {
      switch (type2) {
        case "and":
          return new And(left, right);
        case ",":
          return new Or(left, right);
        default:
          throw new Error(value);
      }
    }, "Operator");
  }
});

// ../../node_modules/.pnpm/media-engine@1.0.3/node_modules/media-engine/src/parser.js
var require_parser = __commonJS({
  "../../node_modules/.pnpm/media-engine@1.0.3/node_modules/media-engine/src/parser.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Query = require_queries();
    var Operator = require_operators();
    var NUMBERS = /[0-9]/;
    var LETTERS = /[a-z|\-]/i;
    var WHITESPACE = /\s/;
    var COLON = /:/;
    var COMMA = /,/;
    var AND = /and$/;
    var AT = /@/;
    function tokenizer(input) {
      var current = 0;
      var tokens = [];
      while (current < input.length) {
        var char = input[current];
        if (AT.test(char)) {
          char = input[++current];
          while (LETTERS.test(char) && char !== void 0) {
            char = input[++current];
          }
        }
        if (WHITESPACE.test(char) || char === ")" || char === "(") {
          current++;
          continue;
        }
        if (COLON.test(char) || COMMA.test(char)) {
          current++;
          tokens.push({ type: "operator", value: char });
          continue;
        }
        if (NUMBERS.test(char)) {
          var value2 = "";
          while (NUMBERS.test(char)) {
            value2 += char;
            char = input[++current];
          }
          tokens.push({ type: "number", value: value2 });
          continue;
        }
        if (LETTERS.test(char)) {
          var value2 = "";
          while (LETTERS.test(char) && char !== void 0) {
            value2 += char;
            char = input[++current];
          }
          if (AND.test(value2)) {
            tokens.push({ type: "operator", value: value2 });
          } else {
            tokens.push({ type: "literal", value: value2 });
          }
          continue;
        }
        throw new TypeError(
          "Tokenizer: I dont know what this character is: " + char
        );
      }
      return tokens;
    }
    __name(tokenizer, "tokenizer");
    function parser(tokens) {
      var output = [];
      var stack = [];
      while (tokens.length > 0) {
        var token = tokens.shift();
        if (token.type === "number" || token.type === "literal") {
          output.push(token);
          continue;
        }
        if (token.type === "operator") {
          if (COLON.test(token.value)) {
            token = { type: "query", key: output.pop(), value: tokens.shift() };
            output.push(token);
            continue;
          }
          while (stack.length > 0) {
            output.unshift(stack.pop());
          }
          stack.push(token);
        }
      }
      while (stack.length > 0) {
        output.unshift(stack.pop());
      }
      function walk() {
        var head = output.shift();
        if (head.type === "number") {
          return parseInt(head.value);
        }
        if (head.type === "literal") {
          return head.value;
        }
        if (head.type === "operator") {
          var l4 = walk();
          var r5 = walk();
          return Operator(head.value, l4, r5);
        }
        if (head.type === "query") {
          var l4 = head.key.value;
          var r5 = head.value.value;
          return Query(l4, r5);
        }
      }
      __name(walk, "walk");
      return walk();
    }
    __name(parser, "parser");
    module.exports = {
      parse: /* @__PURE__ */ __name(function(query) {
        var tokens = tokenizer(query);
        var ast = parser(tokens);
        return ast;
      }, "parse")
    };
  }
});

// ../../node_modules/.pnpm/media-engine@1.0.3/node_modules/media-engine/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/media-engine@1.0.3/node_modules/media-engine/src/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Parser = require_parser();
    module.exports = function(queries, options) {
      var result = {};
      Object.keys(queries).forEach(function(query) {
        if (Parser.parse(query).match(options)) {
          Object.assign(result, queries[query]);
        }
      });
      return result;
    };
  }
});

// ../../node_modules/.pnpm/hsl-to-rgb-for-reals@1.1.1/node_modules/hsl-to-rgb-for-reals/converter.js
var require_converter = __commonJS({
  "../../node_modules/.pnpm/hsl-to-rgb-for-reals@1.1.1/node_modules/hsl-to-rgb-for-reals/converter.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var hslToRgb = /* @__PURE__ */ __name(function(hue, saturation, lightness) {
      if (hue == void 0) {
        return [0, 0, 0];
      }
      var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
      var huePrime = hue / 60;
      var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
      huePrime = Math.floor(huePrime);
      var red;
      var green;
      var blue;
      if (huePrime === 0) {
        red = chroma;
        green = secondComponent;
        blue = 0;
      } else if (huePrime === 1) {
        red = secondComponent;
        green = chroma;
        blue = 0;
      } else if (huePrime === 2) {
        red = 0;
        green = chroma;
        blue = secondComponent;
      } else if (huePrime === 3) {
        red = 0;
        green = secondComponent;
        blue = chroma;
      } else if (huePrime === 4) {
        red = secondComponent;
        green = 0;
        blue = chroma;
      } else if (huePrime === 5) {
        red = chroma;
        green = 0;
        blue = secondComponent;
      }
      var lightnessAdjustment = lightness - chroma / 2;
      red += lightnessAdjustment;
      green += lightnessAdjustment;
      blue += lightnessAdjustment;
      return [
        Math.abs(Math.round(red * 255)),
        Math.abs(Math.round(green * 255)),
        Math.abs(Math.round(blue * 255))
      ];
    }, "hslToRgb");
    module.exports = hslToRgb;
  }
});

// ../../node_modules/.pnpm/hsl-to-hex@1.0.0/node_modules/hsl-to-hex/index.js
var require_hsl_to_hex = __commonJS({
  "../../node_modules/.pnpm/hsl-to-hex@1.0.0/node_modules/hsl-to-hex/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var toRgb = require_converter();
    function max2(val, n5) {
      return val > n5 ? n5 : val;
    }
    __name(max2, "max");
    function min2(val, n5) {
      return val < n5 ? n5 : val;
    }
    __name(min2, "min");
    function cycle(val) {
      val = max2(val, 1e7);
      val = min2(val, -1e7);
      while (val < 0) {
        val += 360;
      }
      while (val > 359) {
        val -= 360;
      }
      return val;
    }
    __name(cycle, "cycle");
    function hsl(hue, saturation, luminosity) {
      hue = cycle(hue);
      saturation = min2(max2(saturation, 100), 0);
      luminosity = min2(max2(luminosity, 100), 0);
      saturation /= 100;
      luminosity /= 100;
      var rgb = toRgb(hue, saturation, luminosity);
      return "#" + rgb.map(function(n5) {
        return (256 + n5).toString(16).substr(-2);
      }).join("");
    }
    __name(hsl, "hsl");
    module.exports = hsl;
  }
});

// ../../node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/parse.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var openParentheses = "(".charCodeAt(0);
    var closeParentheses = ")".charCodeAt(0);
    var singleQuote = "'".charCodeAt(0);
    var doubleQuote = '"'.charCodeAt(0);
    var backslash = "\\".charCodeAt(0);
    var slash = "/".charCodeAt(0);
    var comma = ",".charCodeAt(0);
    var colon = ":".charCodeAt(0);
    var star = "*".charCodeAt(0);
    var uLower = "u".charCodeAt(0);
    var uUpper = "U".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var isUnicodeRange = /^[a-f0-9?-]+$/i;
    module.exports = function(input) {
      var tokens = [];
      var value2 = input;
      var next, quote, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
      var pos = 0;
      var code = value2.charCodeAt(pos);
      var max2 = value2.length;
      var stack = [{ nodes: tokens }];
      var balanced = 0;
      var parent;
      var name = "";
      var before = "";
      var after = "";
      while (pos < max2) {
        if (code <= 32) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          token = value2.slice(pos, next);
          prev = tokens[tokens.length - 1];
          if (code === closeParentheses && balanced) {
            after = token;
          } else if (prev && prev.type === "div") {
            prev.after = token;
            prev.sourceEndIndex += token.length;
          } else if (code === comma || code === colon || code === slash && value2.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
            before = token;
          } else {
            tokens.push({
              type: "space",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        } else if (code === singleQuote || code === doubleQuote) {
          next = pos;
          quote = code === singleQuote ? "'" : '"';
          token = {
            type: "string",
            sourceIndex: pos,
            quote
          };
          do {
            escape2 = false;
            next = value2.indexOf(quote, next + 1);
            if (~next) {
              escapePos = next;
              while (value2.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape2 = !escape2;
              }
            } else {
              value2 += quote;
              next = value2.length - 1;
              token.unclosed = true;
            }
          } while (escape2);
          token.value = value2.slice(pos + 1, next);
          token.sourceEndIndex = token.unclosed ? next : next + 1;
          tokens.push(token);
          pos = next + 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash && value2.charCodeAt(pos + 1) === star) {
          next = value2.indexOf("*/", pos);
          token = {
            type: "comment",
            sourceIndex: pos,
            sourceEndIndex: next + 2
          };
          if (next === -1) {
            token.unclosed = true;
            next = value2.length;
            token.sourceEndIndex = next;
          }
          token.value = value2.slice(pos + 2, next);
          tokens.push(token);
          pos = next + 2;
          code = value2.charCodeAt(pos);
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
          token = value2[pos];
          tokens.push({
            type: "word",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token
          });
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash || code === comma || code === colon) {
          token = value2[pos];
          tokens.push({
            type: "div",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token,
            before,
            after: ""
          });
          before = "";
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (openParentheses === code) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          parenthesesOpenPos = pos;
          token = {
            type: "function",
            sourceIndex: pos - name.length,
            value: name,
            before: value2.slice(parenthesesOpenPos + 1, next)
          };
          pos = next;
          if (name === "url" && code !== singleQuote && code !== doubleQuote) {
            next -= 1;
            do {
              escape2 = false;
              next = value2.indexOf(")", next + 1);
              if (~next) {
                escapePos = next;
                while (value2.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape2 = !escape2;
                }
              } else {
                value2 += ")";
                next = value2.length - 1;
                token.unclosed = true;
              }
            } while (escape2);
            whitespacePos = next;
            do {
              whitespacePos -= 1;
              code = value2.charCodeAt(whitespacePos);
            } while (code <= 32);
            if (parenthesesOpenPos < whitespacePos) {
              if (pos !== whitespacePos + 1) {
                token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: whitespacePos + 1,
                    value: value2.slice(pos, whitespacePos + 1)
                  }
                ];
              } else {
                token.nodes = [];
              }
              if (token.unclosed && whitespacePos + 1 !== next) {
                token.after = "";
                token.nodes.push({
                  type: "space",
                  sourceIndex: whitespacePos + 1,
                  sourceEndIndex: next,
                  value: value2.slice(whitespacePos + 1, next)
                });
              } else {
                token.after = value2.slice(whitespacePos + 1, next);
                token.sourceEndIndex = next;
              }
            } else {
              token.after = "";
              token.nodes = [];
            }
            pos = next + 1;
            token.sourceEndIndex = token.unclosed ? next : pos;
            code = value2.charCodeAt(pos);
            tokens.push(token);
          } else {
            balanced += 1;
            token.after = "";
            token.sourceEndIndex = pos + 1;
            tokens.push(token);
            stack.push(token);
            tokens = token.nodes = [];
            parent = token;
          }
          name = "";
        } else if (closeParentheses === code && balanced) {
          pos += 1;
          code = value2.charCodeAt(pos);
          parent.after = after;
          parent.sourceEndIndex += after.length;
          after = "";
          balanced -= 1;
          stack[stack.length - 1].sourceEndIndex = pos;
          stack.pop();
          parent = stack[balanced];
          tokens = parent.nodes;
        } else {
          next = pos;
          do {
            if (code === backslash) {
              next += 1;
            }
            next += 1;
            code = value2.charCodeAt(next);
          } while (next < max2 && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
          token = value2.slice(pos, next);
          if (openParentheses === code) {
            name = token;
          } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
            tokens.push({
              type: "unicode-range",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          } else {
            tokens.push({
              type: "word",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        }
      }
      for (pos = stack.length - 1; pos; pos -= 1) {
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value2.length;
      }
      return stack[0].nodes;
    };
  }
});

// ../../node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/unit.js
var require_unit = __commonJS({
  "../../node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/unit.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var minus = "-".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var dot = ".".charCodeAt(0);
    var exp = "e".charCodeAt(0);
    var EXP = "E".charCodeAt(0);
    function likeNumber(value2) {
      var code = value2.charCodeAt(0);
      var nextCode;
      if (code === plus || code === minus) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        var nextNextCode = value2.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code === dot) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code >= 48 && code <= 57) {
        return true;
      }
      return false;
    }
    __name(likeNumber, "likeNumber");
    module.exports = function(value2) {
      var pos = 0;
      var length2 = value2.length;
      var code;
      var nextCode;
      var nextNextCode;
      if (length2 === 0 || !likeNumber(value2)) {
        return false;
      }
      code = value2.charCodeAt(pos);
      if (code === plus || code === minus) {
        pos++;
      }
      while (pos < length2) {
        code = value2.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
      code = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while (pos < length2) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      code = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      nextNextCode = value2.charCodeAt(pos + 2);
      if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while (pos < length2) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      return {
        number: value2.slice(0, pos),
        unit: value2.slice(pos)
      };
    };
  }
});

// ../../node_modules/.pnpm/hyphen@1.13.0/node_modules/hyphen/hyphen.js
var require_hyphen = __commonJS({
  "../../node_modules/.pnpm/hyphen@1.13.0/node_modules/hyphen/hyphen.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.createHyphenator = factory();
      }
    })(exports, function() {
      function createTextReader(setup) {
        var char1 = "";
        var char2 = "";
        var i2 = 0;
        var verifier = setup();
        return function(text) {
          while (i2 < text.length) {
            char1 = text.charAt(i2++);
            char2 = text.charAt(i2);
            var verified = verifier(char1, char2);
            if (verified !== void 0) {
              return verified;
            }
          }
        };
      }
      __name(createTextReader, "createTextReader");
      var isNotLetter = RegExp.prototype.test.bind(
        /\s|(?![\'])[\!-\@\[-\`\{-\~\u2013-\u203C]/
      );
      function createHTMLVerifier() {
        var skip = false;
        return function(accumulate, chars) {
          if (skip) {
            if (chars[0] === ">") {
              accumulate();
              skip = false;
            }
          } else if (chars[0] === "<" && (!isNotLetter(chars[1]) || chars[1] === "/")) {
            skip = true;
          }
          return skip;
        };
      }
      __name(createHTMLVerifier, "createHTMLVerifier");
      function createHyphenCharVerifier(hyphenChar) {
        var skip = false;
        return function(accumulate, chars) {
          if (skip) {
            if (!isNotLetter(chars[0]) && isNotLetter(chars[1])) {
              accumulate();
              skip = false;
            }
          } else if (!isNotLetter(chars[0]) && chars[1] === hyphenChar) {
            skip = true;
          }
          return skip;
        };
      }
      __name(createHyphenCharVerifier, "createHyphenCharVerifier");
      function createHyphenationVerifier(verifiers, minWordLength) {
        return function() {
          var accum0 = "";
          var accum = "";
          function accumulate() {
            accum0 += accum;
            accum = "";
          }
          __name(accumulate, "accumulate");
          function resolveWith(value2) {
            accum0 = "";
            accum = "";
            return value2;
          }
          __name(resolveWith, "resolveWith");
          return function(char1, char2) {
            accum += char1;
            var skip = verifiers.reduce(function(skip2, verify) {
              return skip2 || verify(accumulate, [char1, char2]);
            }, false);
            if (!skip) {
              if (isNotLetter(char1) && !isNotLetter(char2)) {
                accumulate();
              }
              if (!isNotLetter(char1) && isNotLetter(char2)) {
                if (accum.length >= minWordLength) {
                  return resolveWith([accum0, accum]);
                } else {
                  accumulate();
                }
              }
            }
            if (char2 === "") {
              if (accum.length < minWordLength || skip) {
                accumulate();
              }
              return resolveWith([accum0, accum]);
            }
          };
        };
      }
      __name(createHyphenationVerifier, "createHyphenationVerifier");
      function levelsToMarkers(levels) {
        var markers = [];
        for (var i2 = 0; i2 < levels.length; i2++)
          if ((levels[i2] & 1) === 1) markers.push(i2);
        return markers;
      }
      __name(levelsToMarkers, "levelsToMarkers");
      function insertChar(text, hyphenChar, markers) {
        if (markers.length === 0) {
          return text;
        }
        var resultText = [text.slice(0, markers[0])];
        if (markers.length > 1)
          for (var i2 = 0, j = 1; j < markers.length; i2++, j++) {
            resultText.push(text.slice(markers[i2], markers[j]));
          }
        resultText.push(text.slice(markers[markers.length - 1]));
        return resultText.join(hyphenChar);
      }
      __name(insertChar, "insertChar");
      function markersFromExceptionsDefinition(exceptionsList) {
        return exceptionsList.reduce(function(markersDict, definition) {
          var i2 = 0, markers = [];
          while ((i2 = definition.indexOf("-", i2 + 1)) > -1) {
            markers.push(i2);
          }
          markersDict[definition.toLocaleLowerCase().replace(/\-/g, "")] = markers;
          return markersDict;
        }, {});
      }
      __name(markersFromExceptionsDefinition, "markersFromExceptionsDefinition");
      function createCharIterator(str) {
        var i2 = 0;
        function nextChar() {
          return str[i2++];
        }
        __name(nextChar, "nextChar");
        return nextChar;
      }
      __name(createCharIterator, "createCharIterator");
      function createStringSlicer(str) {
        var i2 = 0, slice5 = str;
        function next() {
          slice5 = str.slice(i2++);
          if (slice5.length < 3) {
            return;
          }
          return slice5;
        }
        __name(next, "next");
        function isFirstCharacter() {
          return i2 === 2;
        }
        __name(isFirstCharacter, "isFirstCharacter");
        return [next, isFirstCharacter];
      }
      __name(createStringSlicer, "createStringSlicer");
      function hyphenateWord(text, loweredText, levelsTable, patternTrie) {
        var levels = new Array(text.length + 1), loweredText = ("." + loweredText + ".").split(""), wordSlice, letter, triePtr, trieNode, patternLevelsIndex, patternLevels, patternEntityIndex = -1, slicer, nextSlice, isFirstCharacter, nextLetter;
        for (var i2 = levels.length; i2--; ) levels[i2] = 0;
        slicer = createStringSlicer(loweredText);
        nextSlice = slicer[0];
        isFirstCharacter = slicer[1];
        while (wordSlice = nextSlice()) {
          patternEntityIndex++;
          if (isFirstCharacter()) {
            patternEntityIndex--;
          }
          triePtr = patternTrie;
          nextLetter = createCharIterator(wordSlice);
          while (letter = nextLetter()) {
            if ((trieNode = triePtr[letter]) === void 0) {
              break;
            }
            triePtr = {};
            patternLevelsIndex = -1;
            switch (Object.prototype.toString.call(trieNode)) {
              case "[object Array]":
                triePtr = trieNode[0];
                patternLevelsIndex = trieNode[1];
                break;
              case "[object Object]":
                triePtr = trieNode;
                break;
              case "[object Number]":
                patternLevelsIndex = trieNode;
                break;
            }
            if (patternLevelsIndex < 0) {
              continue;
            }
            if (!levelsTable[patternLevelsIndex].splice) {
              levelsTable[patternLevelsIndex] = levelsTable[patternLevelsIndex].slice("");
            }
            patternLevels = levelsTable[patternLevelsIndex];
            for (var k3 = 0; k3 < patternLevels.length; k3++)
              levels[patternEntityIndex + k3] = Math.max(
                patternLevels[k3],
                levels[patternEntityIndex + k3]
              );
          }
        }
        levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;
        return levelsToMarkers(levels);
      }
      __name(hyphenateWord, "hyphenateWord");
      function start2(text, levelsTable, patterns, cache2, markersDict, hyphenChar, skipHTML, minWordLength, isAsync) {
        function done3() {
          resolveNewText(newText);
        }
        __name(done3, "done");
        var newText = "", fragments, readText = createTextReader(
          createHyphenationVerifier(
            (skipHTML ? [createHTMLVerifier()] : []).concat(
              createHyphenCharVerifier(hyphenChar)
            ),
            minWordLength
          )
        ), resolveNewText = /* @__PURE__ */ __name(function() {
        }, "resolveNewText");
        function nextTick4() {
          var loopStart = /* @__PURE__ */ new Date();
          while ((!isAsync || /* @__PURE__ */ new Date() - loopStart < 10) && (fragments = readText(text))) {
            if (fragments[1]) {
              var cacheKey = fragments[1].length ? "~" + fragments[1] : "";
              if (!Object.prototype.hasOwnProperty.call(cache2, cacheKey)) {
                var loweredWord = fragments[1].toLocaleLowerCase();
                if (!Object.prototype.hasOwnProperty.call(markersDict, loweredWord))
                  markersDict[loweredWord] = hyphenateWord(
                    fragments[1],
                    loweredWord,
                    levelsTable,
                    patterns
                  );
                cache2[cacheKey] = insertChar(
                  fragments[1],
                  hyphenChar,
                  markersDict[loweredWord]
                );
              }
              fragments[1] = cache2[cacheKey];
            }
            newText += fragments[0] + fragments[1];
          }
          if (!fragments) {
            done3();
          } else {
            setTimeout(nextTick4);
          }
        }
        __name(nextTick4, "nextTick");
        if (isAsync) {
          setTimeout(nextTick4);
          return new Promise(function(resolve3) {
            resolveNewText = resolve3;
          });
        } else {
          nextTick4();
          return newText;
        }
      }
      __name(start2, "start");
      var SETTING_DEFAULT_ASYNC = false;
      var SETTING_DEFAULT_EXCEPTIONS = [];
      var SETTING_DEFAULT_HTML = true;
      var SETTING_DEFAULT_HYPH_CHAR = "\xAD";
      var SETTING_DEFAULT_MIN_WORD_LENGTH = 5;
      var SETTING_NAME_ASYNC = "async";
      var SETTING_NAME_EXCEPTIONS = "exceptions";
      var SETTING_NAME_HTML = "html";
      var SETTING_NAME_HYPH_CHAR = "hyphenChar";
      var SETTING_NAME_MIN_WORD_LENGTH = "minWordLength";
      var _global = typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : false ? void 0 : {};
      function extend(target, source) {
        target = target || {};
        for (var key in source) {
          target[key] = source[key];
        }
        return target;
      }
      __name(extend, "extend");
      function validateArray(value2) {
        return value2 instanceof Array;
      }
      __name(validateArray, "validateArray");
      function keyOrDefault(object, key, defaultValue, test) {
        if (key in object && (test ? test(object[key]) : true)) {
          return object[key];
        }
        return defaultValue;
      }
      __name(keyOrDefault, "keyOrDefault");
      function exceptionsFromDefinition(exceptionsList, hyphenChar) {
        return exceptionsList.reduce(function(exceptions, exception) {
          exceptions["~" + exception.replace(/\-/g, "")] = exception.replace(
            /\-/g,
            hyphenChar
          );
          return exceptions;
        }, {});
      }
      __name(exceptionsFromDefinition, "exceptionsFromDefinition");
      function createHyphenator(patternsDefinition, options) {
        options = options || {};
        var asyncMode = keyOrDefault(
          options,
          SETTING_NAME_ASYNC,
          SETTING_DEFAULT_ASYNC
        ), caches = {}, markersDict = {}, exceptions = {}, hyphenChar = keyOrDefault(
          options,
          SETTING_NAME_HYPH_CHAR,
          SETTING_DEFAULT_HYPH_CHAR
        ), levelsTable = patternsDefinition[0].split(","), patterns = JSON.parse(patternsDefinition[1]), minWordLength = keyOrDefault(
          options,
          SETTING_NAME_MIN_WORD_LENGTH,
          SETTING_DEFAULT_MIN_WORD_LENGTH
        ) >> 0, skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML), userExceptions = keyOrDefault(
          options,
          SETTING_NAME_EXCEPTIONS,
          SETTING_DEFAULT_EXCEPTIONS,
          validateArray
        );
        var cacheKey = hyphenChar + minWordLength;
        exceptions[cacheKey] = {};
        if (patternsDefinition[2]) {
          exceptions[cacheKey] = exceptionsFromDefinition(
            patternsDefinition[2],
            hyphenChar
          );
          markersDict = markersFromExceptionsDefinition(patternsDefinition[2]);
        }
        if (userExceptions && userExceptions.length) {
          exceptions[cacheKey] = extend(
            exceptions[cacheKey],
            exceptionsFromDefinition(userExceptions, hyphenChar)
          );
          markersDict = extend(
            markersDict,
            markersFromExceptionsDefinition(userExceptions)
          );
        }
        caches[cacheKey] = extend({}, exceptions[cacheKey]);
        if (asyncMode && !("Promise" in _global)) {
          throw new Error(
            "Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode"
          );
        }
        return function(text, options2) {
          options2 = options2 || {};
          var localHyphenChar = keyOrDefault(
            options2,
            SETTING_NAME_HYPH_CHAR,
            hyphenChar
          ), localMinWordLength = keyOrDefault(options2, SETTING_NAME_MIN_WORD_LENGTH, minWordLength) >> 0, localUserExceptions = keyOrDefault(
            options2,
            SETTING_NAME_EXCEPTIONS,
            SETTING_DEFAULT_EXCEPTIONS,
            validateArray
          ), cacheKey2 = localHyphenChar + localMinWordLength;
          if (!exceptions[cacheKey2] && patternsDefinition[2]) {
            exceptions[cacheKey2] = exceptionsFromDefinition(
              patternsDefinition[2],
              localHyphenChar
            );
            caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);
          }
          if (localUserExceptions && localUserExceptions.length) {
            exceptions[cacheKey2] = extend(
              exceptions[cacheKey2],
              exceptionsFromDefinition(localUserExceptions, localHyphenChar)
            );
            markersDict = extend(
              markersDict,
              markersFromExceptionsDefinition(localUserExceptions)
            );
            caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);
          }
          return start2(
            text,
            levelsTable,
            patterns,
            caches[cacheKey2],
            markersDict,
            localHyphenChar,
            skipHTML,
            localMinWordLength,
            asyncMode
          );
        };
      }
      __name(createHyphenator, "createHyphenator");
      return createHyphenator;
    });
  }
});

// ../../node_modules/.pnpm/hyphen@1.13.0/node_modules/hyphen/patterns/en-us.js
var require_en_us = __commonJS({
  "../../node_modules/.pnpm/hyphen@1.13.0/node_modules/hyphen/patterns/en-us.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.hyphenationPatternsEnUs = factory();
      }
    })(exports, function() {
      return [
        "0004,004,001,003,005,0005,00005,000005,0002,002,0000005,0003,00003,00505,00034,0001,00055,00004,4,05,0055,04,42,03,02,2,404,3,044,01,0505,55,5,045,041,0033,000004,22,00504,5504,0042,1,21,41,402,405,4004,43,23,000054,303,3005,022,5004,000003,252,45,25,2004,000505,054,403,401,3002,0025,144,432,00054,34,12,234,0022,014,0304,012,143,503,0403,101,052,414,212,011,043,00002,0041,0024,05005,03003,00102,0404,04303,01004,0034,025,0044,00404,00025,0103,042,0205,412,104,54,344,433,5005,253,055,0402,3004,0043,204,505,454,0000004,00303,04004,552,201,4005,0255,52,444,14,44,02004,033,05004,00045,00013,0021,0405,00044,0054,50055,000303,00001,304,0204,11,301,232,122,00305,504,000043,0104,00052,000045,50004,0023,00033,00032,00202,5003,202,0401,0000505,214,102,032,000161,004101,00501,00301,0036,0052,00023,006101,006,00401,000521,0014,0063,00012,000501,000006,000604,000601,005001,005005,0010305,00006,003012,003005,0003011,0061,013,000021,000022,000105,00211,00062,00051,000112,006013,000011,0200306,1021,0050001,003003,2102,305,000015,01030005,000035,001011,00021,16330001,0234,030006,5020001,000001,00016,0031,021,21431,002305,0350014,0000012,000063,00101,106,105,00435,00063,0300061,00041,100306,003602,023,0503,0010011,10003,1005,30011,00031,0001001,0000061,0030003,30305,001201,0301,5000101,500101,00015,000401,000065,000016,0000402,0500002,000205,030201,500301,00014,5001,000002,00030011,01034,0300006,030213,00400304,050001,05003,000311,0634,00061,0006,00000604,00050013,00213,0030001,100003,000033,30002,00003632,0003004,050003,0000021,006303,0000006,00005005,30451,03001,00231,00056,00011,6,001001,00500001,03005,503005,0000010001,1002,003001,001065,300001,32011,32,0000003,0213001,0500053,021005,10001,0000011,0001041,0020016,100032,50011,0606,5002,3001,03002,0015001,0102,00003001,000000033,0000001,300101,300015,0101003,00000101,0100501,0101,0010033,00000362,000014,0005001,031",
        '{".":{"a":{"c":{"h":0},"d":{"d":{"e":{"r":1}}},"f":{"t":2},"l":{"t":3},"m":{"a":{"t":4}},"n":{"c":4,"g":0,"i":{"m":5},"t":[{"e":3,"i":{"s":6}},0]},"r":{"s":4,"t":{"i":{"e":1},"y":1}},"s":{"c":3,"p":2,"s":2,"t":{"e":{"r":7}}},"t":{"o":{"m":6}},"u":{"d":2},"v":{"i":1},"w":{"n":0}},"b":{"a":{"g":1,"n":{"a":4},"s":{"e":0}},"e":{"r":[{"a":4},0],"s":{"m":3,"t":{"o":4}}},"r":{"i":8},"u":{"t":{"t":{"i":0}}}},"c":{"a":{"m":{"p":{"e":0}},"n":{"c":5},"p":{"a":{"b":6}},"r":{"o":{"l":5}},"t":1},"e":{"l":{"a":1}},"h":[{"i":{"l":{"l":{"i":7}}}},1],"i":[{"t":{"r":5}},9],"o":{"e":3,"r":[{"n":{"e":{"r":5}}},1],"n":{"g":{"r":5}}}},"d":{"e":{"m":{"o":{"i":1}},"o":3,"r":{"a":3,"i":[{"v":{"a":4}},3]},"s":{"c":0}},"i":{"c":{"t":{"i":{"o":10}}}},"o":{"t":1},"u":{"c":1,"m":{"b":6}},"r":{"i":{"v":67}}},"e":{"a":{"r":{"t":{"h":7}},"s":{"i":11}},"b":1,"e":{"r":0},"g":9,"l":{"d":4,"e":{"m":3}},"n":{"a":{"m":12},"g":3,"s":3},"q":{"u":{"i":{"t":13}}},"r":{"r":{"i":1}},"s":3,"u":[{"l":{"e":{"r":1}}},3],"y":{"e":5},"t":{"h":{"y":{"l":162}}},"v":[{"e":{"r":{"s":{"i":{"b":158}}}}},9]},"f":{"e":{"s":11},"o":{"r":{"m":{"e":{"r":5}}}}},"g":{"a":[{"s":{"o":{"m":163}}},9],"e":[{"n":{"t":14},"o":{"g":4,"m":{"e":1},"t":164}},9],"i":{"a":4,"b":1},"o":{"r":1}},"h":{"a":{"n":{"d":{"i":6},"k":5}},"e":[{"r":{"o":{"i":6,"e":3}},"s":11,"t":11,"m":{"o":165},"p":{"a":166}},9],"i":{"b":3,"e":{"r":3}},"o":{"n":{"e":{"y":5},"o":11},"v":5}},"i":{"d":{"l":1,"o":{"l":12}},"m":{"m":3,"p":{"i":{"n":4}}},"n":[{"c":{"i":3},"e":8,"k":9,"s":3,"u":{"t":167}},2],"r":{"r":4},"s":{"i":1}},"j":{"u":{"r":3}},"l":{"a":{"c":{"y":1},"m":1,"t":{"e":{"r":5},"h":6}},"e":[{"g":{"e":5},"n":0,"p":5,"v":15,"i":{"c":{"e":{"s":170}}}},9],"i":{"g":[{"a":5},1],"n":9,"o":3,"t":1}},"m":{"a":{"g":{"a":16},"l":{"o":5},"n":{"a":5},"r":{"t":{"i":5}}},"e":[{"r":{"c":11},"t":{"e":{"r":4},"a":{"l":{"a":0}}},"g":{"a":{"l":171}}},9],"i":{"s":[{"t":{"i":6},"e":{"r":{"s":173}}},15],"m":{"i":{"c":172}}},"o":{"n":{"e":11},"r":{"o":3}},"u":{"t":{"a":[{"b":6},4]}}},"n":{"i":{"c":1},"e":{"o":{"f":174}},"o":{"e":{"t":{"h":15}},"n":{"e":{"m":175}}}},"o":{"d":[{"d":5},9],"f":{"t":{"e":4}},"r":{"a":{"t":{"o":4}},"c":3,"d":2,"t":3},"s":[{"t":{"l":1}},3],"t":{"h":11},"u":{"t":11}},"p":{"e":{"d":{"a":{"l":5}},"t":{"e":4,"i":{"t":4}}},"i":{"e":1,"o":{"n":5},"t":9},"r":{"e":{"m":11,"a":{"m":15}}},"o":{"l":{"y":{"s":137}},"s":{"t":{"a":{"m":137}}}}},"r":{"a":{"c":1,"n":{"t":0},"t":{"i":{"o":{"n":{"a":7}}}},"v":{"e":{"n":{"o":176}}}},"e":{"e":[{"c":173},8],"m":{"i":{"t":4}},"s":[{"t":{"a":{"t":4}}},8]},"i":{"g":1,"t":{"u":5}},"o":{"q":1,"s":{"t":5},"w":{"d":5}},"u":{"d":1}},"s":{"c":{"i":{"e":11}},"e":{"l":{"f":6,"l":6},"n":9,"r":{"i":{"e":4}},"m":{"i":[{"c":0,"d":177,"p":36,"r":36,"s":178,"v":36},6]}},"h":9,"i":[{"n":{"g":17}},9],"t":[{"a":{"b":{"l":5}}},1],"y":9,"p":{"h":{"i":{"n":179}},"i":{"n":{"o":137}}}},"t":{"a":[{"p":{"e":{"s":{"t":{"r":180}}}}},1],"e":[{"n":{"a":{"n":5}},"l":{"e":{"g":{"r":3}}}},1],"h":9,"i":[{"l":0,"m":{"o":16},"n":{"g":17,"k":5}},9],"o":{"n":{"a":0},"p":[{"i":5,"o":{"g":170}},1],"u":{"s":5},"q":9},"r":{"i":{"b":{"u":{"t":6}}}}},"u":{"n":{"a":[{"t":{"t":144}},2],"c":{"e":3},"d":{"e":{"r":7}},"e":[{"r":{"r":181}},2],"k":4,"o":4,"u":3},"p":3,"r":{"e":11},"s":{"a":4}},"v":{"e":{"n":{"d":{"e":0}},"r":{"a":4}},"i":{"c":{"a":{"r":151}}}},"w":{"i":{"l":{"i":5}},"e":{"b":{"l":131}}},"y":{"e":1},"k":{"i":{"l":{"n":{"i":168}}},"o":{"r":{"t":{"e":169}}}}},"a":{"b":{".":18,"a":{"l":19,"n":19},"e":[{"r":{"d":4}},8],"i":{"a":5,"t":{"a":{"b":13}}},"l":{"a":{"t":4}},"o":{"l":{"i":{"z":20,"c":19}}},"r":[{"o":{"g":4}},18],"u":{"l":3}},"c":{"a":{"r":[{"d":4,"o":4},21],"b":{"l":24}},"e":{"o":{"u":19},"r":2},"h":{"e":{"t":19}},"i":[{"e":23,"n":2,"o":23},22],"r":{"o":{"b":4}},"t":{"i":{"f":5}},"u":{"l":3,"m":1}},"d":[{"d":{"i":{"n":1}},"e":{"r":{".":4}},"i":[{"a":23,"c":{"a":3},"e":{"r":0},"o":23,"t":23,"u":19},25],"l":{"e":1},"o":{"w":3},"r":{"a":{"n":4}},"s":{"u":1},"u":[{"c":23,"m":4},18]},24],"e":{"r":[{"i":{"e":17}},1]},"f":[{"f":[{"i":{"s":{"h":170}}},0]},24],"g":{"a":{"b":21,"n":0},"e":{"l":{"l":4},"o":0,"u":18},"i":2,"l":26,"n":2,"o":[{"g":27,"n":{"i":3}},24],"u":{"e":{"r":19},"l":4},"y":21},"h":{"a":23,"e":23,"l":1,"o":23},"i":[{"a":19,"c":{".":23},"l":{"y":4},"n":[{"i":{"n":5},"o":5},28],"t":{"e":{"n":5}}},9],"j":29,"k":{"e":{"n":2}},"l":{"a":{"b":4,"d":3,"r":21},"d":{"i":18},"e":[{"n":{"d":3,"t":{"i":21}},"o":30},25],"i":[{"a":{".":1},"e":0},2],"l":{"e":{"v":4},"i":{"c":18}},"m":18,"o":{"g":{".":19}},"y":{".":21,"s":[{"t":31},18],"t":32,"z":27}},"m":{"a":[{"b":4,"g":3,"r":{"a":5},"s":{"c":4},"t":{"i":{"s":21},"o":33}},18],"e":{"r":{"a":4},"n":{"t":{"a":{"b":182}}}},"i":{"c":3,"f":4,"l":{"y":4},"n":[{"o":0},2]},"o":[{"n":19,"r":{"i":6}},24],"p":{"e":{"n":5}}},"n":[{"a":{"g":{"e":3},"l":{"y":[{"s":183},27]},"r":[{"c":3,"i":17},23],"t":{"i":23}},"d":[{"e":{"s":17},"i":{"s":3},"l":2,"o":{"w":1}},18],"e":{"e":19,"n":23,"s":{"t":{".":4}},"u":23},"g":[{"i":{"e":5},"l":2},25],"i":{"c":34,"e":{"s":23},"f":35,"m":{"e":1,"i":19},"n":{"e":19},"o":3,"p":23,"s":{"h":3},"t":3,"u":23},"k":{"l":{"i":1}},"n":{"i":{"z":32}},"o":[{"t":[{"h":7},4],"a":{"c":148}},0],"s":{"a":9,"c":{"o":1},"n":1,"p":[{"o":11},9],"t":1,"u":{"r":1},"g":{"r":5},"v":11},"t":{"a":{"l":36},"i":{"e":1,"d":137,"n":184,"r":{"e":137}},"o":18,"r":9,"w":1},"u":{"a":3,"l":3,"r":19}},24],"o":18,"p":{"a":{"r":17,"t":4},"e":{"r":{"o":4},"a":{"b":{"l":{"e":132}}}},"h":{"e":{"r":23},"i":18},"i":{"l":{"l":{"a":[{"r":4},21]}},"n":3,"t":{"a":3,"u":23}},"l":24,"o":{"c":6,"l":{"a":4},"r":{"i":6},"s":{"t":12}},"s":{"e":{"s":5}},"u":23},"q":{"u":{"e":6}},"r":[{"a":{"c":{"t":3},"d":{"e":19,"i":{"s":4}},"l":3,"m":{"e":{"t":{"e":19}}},"n":{"g":17},"p":11,"t":[{"i":{"o":19,"v":4}},1],"u":19,"v":38,"w":17},"b":{"a":{"l":36}},"c":{"h":{"a":{"n":1},"e":{"t":185}}},"d":{"i":{"n":{"e":4}},"r":1},"e":{"a":{"s":4},"e":23,"n":{"t":3},"s":{"s":19}},"f":{"i":1,"l":1},"i":[{"a":{"l":4,"n":3},"e":{"t":23},"m":1,"n":{"a":{"t":4}},"o":3,"z":9},2],"m":{"i":9},"o":{"d":20,"n":{"i":19},"o":23},"p":9,"q":3,"r":{"e":17,"a":{"n":{"g":{"e":9}}}},"s":{"a":1,"h":9}},37],"s":{".":18,"a":{"b":1,"n":{"t":3}},"h":{"i":17},"i":{"a":{".":19},"b":23,"c":23,"t":39},"k":{"i":11},"l":1,"o":{"c":21},"p":{"h":4},"s":{"h":1},"t":{"e":{"n":3},"r":2},"u":{"r":{"a":6}},"y":{"m":{"p":{"t":{"o":{"t":4}}}}}},"t":{"a":[{"b":{"l":3},"c":4,"l":{"o":3},"p":4},24],"e":{"c":[{"h":4},5],"g":{"o":3},"n":{".":3},"r":{"a":3,"n":[{"a":19},6]},"s":{"t":3},"v":4},"h":[{"e":{"m":5,"n":19,"r":{"o":{"s":186}}},"o":[{"m":5},1]},18],"i":{".":18,"a":19,"b":20,"c":2,"f":3,"o":{"n":{"a":{"r":7}}},"t":{"u":3}},"o":{"g":21,"m":[{"i":{"z":4}},24],"p":21,"s":21},"r":[{"o":{"p":4}},29],"s":{"k":1},"t":{"a":{"g":1},"e":[{"s":{".":170}},4],"h":1},"u":[{"a":4,"e":4,"l":3,"r":{"a":3}},24],"y":24},"u":{"b":1,"g":{"h":[{"t":{"l":17}},12],"u":3},"l":[{"i":{"f":13}},40],"n":{"d":5},"r":3,"s":{"i":{"b":4}},"t":{"e":{"n":5},"h":2}},"v":{"a":[{"g":3,"n":19},24],"e":{"n":{"o":0},"r":{"a":3,"n":4,"y":4}},"i":[{"e":{"r":0},"g":3,"o":{"u":3}},2],"o":{"c":4,"r":29}},"w":{"a":{"y":27},"i":3,"l":{"y":1},"s":0},"x":{"i":{"c":1,"d":1}},"y":{"a":{"l":4},"e":0,"s":0},"z":{"i":{"e":{"r":0}},"z":{"i":5}}},"b":{"a":{".":32,"d":{"g":{"e":{"r":5}}},"g":{"e":1},"l":{"a":15},"n":{"d":{"a":{"g":5}},"e":0,"i":11},"r":{"b":{"i":7},"i":{"a":17},"o":{"n":{"i":{"e":187}}}},"s":{"s":{"i":0}},"t":[{"h":{"y":2}},41],"z":1,"c":{"k":{"e":{"r":{".":84}}}}},"b":[{"e":[{"r":23},24],"i":{"n":{"a":0},"t":0}},42],"d":43,"e":{".":18,"a":{"k":17,"t":12},"d":[{"a":3,"e":3,"i":3},44],"g":{"i":3,"u":4},"l":[{"i":2,"o":3},41],"m":45,"n":{"i":{"g":4},"u":4},"s":[{"p":3,"t":{"r":4}},46],"t":[{"i":{"z":5},"r":4,"w":3},27],"w":3,"y":{"o":4},"v":{"i":{"e":9}}},"f":25,"h":47,"i":{"b":9,"d":[{"i":{"f":167}},1],"e":[{"n":4,"r":1},27],"f":48,"l":[{"i":{"z":3},"l":{"a":{"b":8}}},41],"n":{"a":{"r":49},"d":0,"e":{"t":4}},"o":{"g":{"r":3},"u":4,"m":5,"r":{"b":2,"h":15}},"t":[{"i":{"o":50,"v":{"e":188}},"r":3,"u":{"a":51},"z":19},9]},"j":29,"k":1,"l":[{"a":{"t":{"h":7},"n":{"d":189}},"e":{".":21,"n":17,"s":{"p":32}},"i":{"s":23,"n":{"d":189}},"o":[{"n":{"d":190}},21],"u":{"n":{"t":17}}},52],"m":43,"n":[{"e":{"g":5}},47],"o":{"d":[{"i":11},27],"e":1,"l":{"i":{"c":11}},"m":{"b":{"i":0}},"n":{"a":[{"t":5},0]},"o":27,"r":{".":32,"a":43,"d":5,"e":32,"i":32,"n":{"o":191}},"s":53,"t":{"a":19,"h":6,"o":1,"u":{"l":192}},"u":{"n":{"d":54}}},"p":18,"r":{"i":{"t":18},"o":{"t":{"h":54}},"u":{"s":{"q":17}}},"s":[{"o":{"r":17}},55],"t":[{"l":1,"o":21,"r":23},25],"u":{"f":{"f":{"e":{"r":0}}},"g":{"a":1},"l":{"i":3},"m":{"i":17},"n":[{"t":{"i":17}},1],"r":{"e":3},"s":{"i":{"e":[{"r":193,"s":193},5]},"s":{"e":17,"i":{"n":{"g":17}}},"t":32},"t":{"a":18,"i":{"o":27},"o":19,"e":{"d":{".":8}},"t":{"e":{"d":0}}}},"v":29,"w":56,"y":{".":32,"s":0}},"c":{"a":[{"b":{"i":{"n":11},"l":2},"c":{"h":17},"d":{"e":{"n":4,"m":194}},"g":46,"h":57,"l":{"a":{"t":3},"l":{"a":0,"i":{"n":6}},"o":18},"n":{"d":5,"e":0,"i":{"c":0,"s":5,"z":11},"t":{"y":0},"y":17},"p":{"e":{"r":4}},"r":{"o":{"m":5}},"s":{"t":{"e":{"r":6},"i":{"g":5}},"y":18},"t":{"h":1,"i":{"v":18},"a":{"s":195}},"v":{"a":{"l":5}}},41],"c":[{"h":{"a":6},"i":{"a":0},"o":{"m":{"p":{"a":10}},"n":17,"u":{"t":12}}},23],"e":{".":25,"d":{".":18,"e":{"n":18}},"i":27,"l":{".":32,"l":27},"n":[{"c":27,"e":58,"i":18,"t":27},41],"p":27,"r":{"a":{"m":4}},"s":{"a":18,"s":{"i":[{"b":59},27]},"t":5},"t":[{"a":60},0],"w":0},"h":[{".":18,"a":{"b":61,"n":{"i":{"c":32,"s":20}}},"e":[{"a":{"p":54},"d":18,"l":{"o":5},"m":{"i":27},"n":{"e":4},"r":{".":3,"s":3}},8],"i":{"n":[{"e":{".":32,"s":{"s":4}},"i":32},62],"o":32,"t":27,"z":8,"e":{"v":{"o":6}}},"o":63,"t":{"i":1},"s":{".":18,"h":{"u":11}}},25],"i":[{"a":[{"b":64,"r":5},27],"c":4,"e":{"r":18},"f":{"i":{"c":{".":32}}},"i":18,"l":{"a":1,"i":27},"m":25,"n":[{"a":[{"t":27},21],"e":{"m":11},"g":[{".":19},29],"o":32,"q":8},25],"o":{"n":17},"p":{"e":18,"h":3,"i":{"c":18}},"s":{"t":{"a":18,"i":18}},"t":[{"i":{"z":11}},42],"z":32,"g":{"a":{"r":152}}},41],"k":[{"i":3},2],"l":[{"a":{"r":[{"a":{"t":{"i":{"o":19}}},"e":32},18]},"e":{"m":0,"a":{"r":0}},"i":{"c":18,"m":17},"y":0},65],"n":19,"o":[{"a":{"g":4},"e":8,"g":[{"r":1},25],"i":[{"n":{"c":3}},0],"l":{"i":5,"o":[{"r":11},32]},"m":{"e":{"r":5}},"n":{"a":0,"e":21,"g":11,"t":5},"p":{"a":3,"i":{"c":11},"l":1,"h":{"o":{"n":196}}},"r":{"b":18,"o":{"n":12}},"s":{"e":0},"v":[{"e":17},15],"w":{"a":5},"z":{"e":5,"i":4},"u":{"s":{"t":{"i":84}}}},41],"q":29,"r":{"a":{"s":{"t":6},"t":{".":32,"i":{"c":32}}},"e":{"a":{"t":11},"d":32,"t":{"a":47},"v":0},"i":[{"f":5,"n":21,"s":17,"t":{"i":[{"e":11},32]}},8],"o":{"p":{"l":0,"o":6},"s":{"e":17},"c":{"o":{"d":197}},"e":{"c":{"o":148}}},"u":{"d":0}},"s":66,"t":[{"a":{"b":0,"n":{"g":4,"t":19}},"e":[{"r":23},24],"i":{"c":{"u":21},"m":{"i":12}},"u":{"r":0},"w":21,"r":{"o":{"m":{"e":{"c":198}}}}},42],"u":{"d":5,"f":21,"i":[{"t":{"y":4}},21],"l":{"i":32,"t":{"i":{"s":0},"u":27}},"m":{"a":9,"e":23,"i":1},"n":27,"p":{"i":3,"y":4},"r":{"a":{"b":67,"n":{"c":{"e":199}}},"i":{"a":4}},"s":[{"s":{"i":17}},41],"t":[{"i":{"e":1,"v":56},"r":18},68]},"y":41,"z":{"e":0}},"d":{"a":[{".":32,"b":70,"c":{"h":17},"f":18,"g":25,"m":71,"n":{"g":11},"r":{"d":6,"k":6,"y":18},"t":[{"i":{"v":18},"o":18,"a":{"b":137}},27],"v":[{"e":5},53],"y":32,"l":{"o":{"n":{"e":48}}}},69],"b":29,"c":19,"d":[{"a":{"b":20},"i":{"b":94}},72],"e":{".":25,"a":{"f":6,"l":{"s":{".":1}}},"b":{"i":{"t":5},"o":{"n":1}},"c":{"a":{"n":36},"i":{"l":1},"o":{"m":4},"l":{"a":{"r":200},"i":{"n":{"a":64}}}},"d":42,"e":{".":18},"i":{"f":4},"l":{"i":{"e":17,"q":16},"o":4},"m":[{".":32,"i":{"c":[{".":5},27],"l":4},"o":{"n":{"s":1},"r":7,"s":9}},21],"n":[{"a":{"r":1},"o":3,"t":{"i":{"f":7}},"u":3},41],"p":[{"a":3,"i":17,"u":9},2],"q":23,"r":{"h":21,"m":32,"n":{"i":{"z":6}},"s":5},"s":[{".":24,"c":2,"o":64,"t":{"i":11,"r":3},"u":1,"i":{"c":11}},8],"t":[{"o":9,"i":{"c":9}},2],"v":[{"i":{"l":11}},2],"y":18,"f":{"i":{"n":{"i":{"t":{"i":201}}}}}},"f":43,"g":{"a":21,"e":{"t":73},"i":2,"y":24},"h":74,"i":{".":32,"a":[{"b":5},75],"c":{"a":{"m":1,"i":{"d":15}},"e":21,"t":27},"d":27,"e":{"n":76},"f":[{"f":{"r":{"a":5}}},29],"g":{"e":3},"l":{"a":{"t":{"o":1}}},"n":[{"a":41,"e":{".":27},"i":[{"z":4},32]},29],"o":[{"g":5},41],"p":{"l":1},"r":[{"e":[{"n":9,"r":9},2],"t":{"i":6}},8],"s":[{"i":32,"t":77},15],"t":{"i":24},"v":78,"m":{"e":{"t":{"h":{"y":141}}}}},"j":29,"k":79,"l":{"a":56,"e":{".":27,"d":27,"s":{".":27,"s":18},"a":{"d":42}},"o":48,"u":56,"y":25,"i":{"e":202}},"m":29,"n":80,"o":[{".":27,"d":{"e":4},"e":32,"f":57,"g":21,"l":{"a":1,"i":17,"o":{"r":4}},"m":{"i":{"z":5}},"n":{"a":{"t":3},"i":17},"o":{"d":11},"p":{"p":0},"r":21,"s":27,"u":{"t":56},"v":1,"x":27,"w":{"o":{"r":{"d":203}}}},41],"p":29,"r":[{"a":{"g":{"o":{"n":6}},"i":18},"e":[{"a":{"r":6},"n":[{"a":{"l":204}},32]},0],"i":{"b":0,"l":17,"f":{"t":{"a":189}},"p":{"l":{"e":{"g":205}}}},"o":{"p":0,"w":18,"m":{"e":{"d":206}}},"u":{"p":{"l":{"i":32}}},"y":18},41],"s":[{"p":1,"w":21,"y":21},81],"t":{"h":24,"a":{"b":23}},"u":[{"a":[{"l":{".":9}},82],"c":[{"a":29,"e":{"r":5},"t":{".":18,"s":18}},9],"e":{"l":4},"g":1,"l":{"e":23},"m":{"b":{"e":0}},"n":1,"p":[{"e":1},18],"o":{"p":{"o":{"l":207}}}},41],"v":29,"w":29,"y":[{"n":32,"s":{"e":1,"p":5}},24]},"e":{"a":{"b":72,"c":{"t":23},"d":[{"i":{"e":5}},15],"g":{"e":[{"r":4},1]},"l":[{"e":{"r":5},"o":{"u":11}},1],"m":{"e":{"r":11}},"n":{"d":19,"i":{"e":{"s":111}}},"r":{"a":11,"c":0,"e":{"s":5},"i":{"c":0,"l":0},"k":5,"t":[{"e":12},8]},"s":{"p":4,"s":23,"t":12},"t":[{"e":{"n":5},"h":{"i":12},"i":{"f":19},"u":83},9],"v":[{"e":{"n":11},"i":5,"o":5},9]},"b":[{"e":{"l":{".":21,"s":21},"n":21},"i":{"t":21},"r":23},42],"c":{"a":{"d":21,"n":{"c":6}},"c":{"a":6},"e":[{"s":{"s":{"a":4}}},29],"i":[{"b":21,"f":{"i":{"c":{"a":{"t":4}},"e":4},"y":4},"m":3,"t":[{"e":19},0]},9],"l":{"a":{"m":21},"u":{"s":21}},"o":{"l":24,"m":{"m":21,"p":{"e":21}},"n":{"c":21},"r":[{"a":3,"o":5},24]},"r":[{"e":{"m":21}},29],"t":{"a":{"n":1},"e":1},"u":[{"l":[{"a":3},21]},29],"h":{"a":{"s":23}}},"d":{"a":37,"d":61,"e":{"r":34,"s":0},"i":[{"a":23,"b":3,"c":{"a":3},"m":3,"t":2,"z":5},18],"o":[{"l":21,"n":84},18],"r":{"i":21},"u":{"l":[{"o":4,"i":{"n":{"g":2}}},21]},"g":{"l":15}},"e":{"c":9,"d":{"i":11},"f":9,"l":{"i":11,"y":1},"m":9,"n":{"a":1},"p":85,"s":[{"t":17},86],"t":{"y":1},"x":19},"f":[{"e":{"r":{"e":83}},"f":41,"i":{"c":[{"i":32},21],"l":17,"n":{"e":23,"i":{"t":{"e":20}}},"t":27},"o":{"r":{"e":{"s":6}}},"u":{"s":{"e":{".":21}}}},29],"g":{"a":{"l":18},"e":{"r":17},"i":{"b":4,"c":1,"n":{"g":4},"t":87},"n":4,"o":{".":21,"s":21},"u":{"l":2,"r":19},"y":32},"h":[{"e":{"r":17}},72],"i":[{"c":19,"d":4,"g":[{"l":4},8],"m":{"b":23},"n":{"f":23,"g":29,"s":{"t":19}},"r":{"d":0},"t":{"e":11,"h":3,"y":19}},9],"j":[{"u":{"d":[{"i":4},21]}},29],"k":{"i":{"n":0},"l":{"a":1}},"l":{"a":[{".":21,"c":21,"n":{"d":17},"t":{"i":{"v":4}},"w":21,"x":{"a":36}},29],"e":{"a":23,"b":{"r":{"a":4}},"c":32,"d":21,"g":{"a":3},"n":19,"r":34,"s":29},"f":9,"i":[{"b":{"e":23},"c":{".":33,"a":3},"e":{"r":23},"g":{"i":{"b":4}},"m":19,"n":{"g":83},"o":23,"s":[{"h":4},24],"v":88,"t":{"i":{"s":208}}},9],"l":{"a":[{"b":1},18],"o":17},"o":{"c":19,"g":4,"p":{".":3},"a":29},"s":{"h":9},"t":{"a":1},"u":{"d":19,"g":4}},"m":{"a":{"c":21,"g":21,"n":[{"a":4},19]},"b":4,"e":[{"l":24,"t":21},29],"i":{"c":{"a":3},"e":0,"g":{"r":{"a":4}},"n":[{"e":4,"i":35},89],"s":[{"h":4,"s":19},21],"z":3},"n":{"i":{"z":32}},"o":{"g":0,"n":{"i":{"o":7}}},"p":{"i":3},"u":{"l":[{"a":4},21],"n":11},"y":23},"n":{"a":{"m":{"o":4},"n":{"t":21}},"c":{"h":{"e":{"r":17}}},"d":{"i":{"c":3,"x":2}},"e":{"a":19,"e":19,"m":3,"r":{"o":4},"s":{"i":4,"t":4},"t":{"r":3},"w":23},"i":{"c":{"s":4},"e":19,"l":19,"o":23,"s":{"h":3},"t":3,"u":19,"z":32},"n":18,"o":[{"g":0,"s":21,"v":3},18],"s":{"w":1},"t":{"a":{"g":{"e":5}},"h":{"e":{"s":18}}},"u":{"a":3,"f":4},"y":{".":23},"z":61},"o":{"f":19,"g":[{"r":{"a":{"p":3}}},9],"i":90,"l":23,"p":{"a":{"r":11}},"r":[{"e":3,"o":{"l":4}},29],"s":0,"t":[{"o":1},21],"u":{"t":19},"w":19},"p":{"a":[{"i":23,"n":{"c":4}},24],"e":{"l":19,"n":{"t":23},"t":{"i":{"t":{"i":{"o":4}}}}},"h":{"e":17},"l":{"i":21},"o":29,"r":{"e":{"c":[{"a":4},21],"d":21,"h":3},"o":[{"b":21},23]},"s":{"h":1},"t":{"i":{"b":13}},"u":{"t":[{"a":4},21]},"i":{"n":{"e":{"p":{"h":209}}}}},"q":[{"u":{"i":{"l":12,"s":91}}},29],"r":{"a":[{"b":0,"n":{"d":18},"r":3,"t":{"i":{".":18}}},2],"b":[{"l":1},25],"c":{"h":[{"e":1},3]},"e":{".":25,"a":{"l":23},"c":{"o":5},"i":{"n":11},"l":{".":4},"m":{"o":3},"n":{"a":4,"c":{"e":4},"e":18,"t":3},"q":0,"s":{"s":4,"t":3},"t":17},"h":2,"i":[{"a":[{"n":{".":210}},92],"c":{"k":32},"e":{"n":23,"r":0},"n":{"e":3},"o":29,"t":18,"u":1,"v":[{"a":21},0]},2],"m":93,"n":{"i":{"s":1,"t":18,"z":32},"o":3},"o":[{"b":4,"c":19,"r":0,"u":2},25],"s":[{"e":{"t":3}},2],"t":{"e":{"r":11},"l":18,"w":3},"u":[{"t":0},18],"w":{"a":{"u":32}}},"s":{"a":[{"g":{"e":{".":21,"s":21}}},72],"c":[{"a":[{"n":4},24],"r":23,"u":4},9],"e":[{"c":[{"r":4},24],"n":{"c":4},"r":{"t":{".":21,"s":21},"v":{"a":21}}},74],"h":[{"a":23,"e":{"n":5}},18],"i":[{"c":24,"d":[{"e":{"n":4}},24],"g":{"n":{"a":4}},"m":94,"n":95,"s":{"t":{"e":17}},"u":0},29],"k":{"i":{"n":19}},"m":{"i":1},"o":{"l":[{"u":3},24],"n":[{"a":4},24]},"p":[{"e":{"r":3},"i":{"r":{"a":4}},"r":{"e":1},"a":{"c":{"i":211}}},29],"s":[{"i":{"b":96}},25],"t":{"a":{"n":36},"i":{"g":3,"m":4},"o":[{"n":23},44],"r":[{"o":19,"u":{"c":10}},25]},"u":{"r":[{"r":4},24]},"w":1},"t":{"a":{"b":0},"e":{"n":{"d":17},"o":23},"h":{"o":{"d":54},"y":{"l":{"e":{"n":{"e":162}}}}},"i":{"c":2,"d":{"e":19},"n":[{"o":0},17],"r":19,"t":{"i":{"o":19,"v":4}}},"n":18,"o":{"n":{"a":4}},"r":{"a":23,"e":23,"i":{"c":3,"f":4},"o":{"g":3,"s":4}},"u":{"a":3},"y":{"m":4},"z":4},"u":[{"n":19,"p":23,"r":{"o":3},"s":0,"t":{"e":17,"i":{"l":6},"r":4},"c":{"l":{"i":{"d":212}}}},18],"v":{"a":{"p":97,"s":[{"t":4},24]},"e":{"a":19,"l":{"l":3,"o":12},"n":{"g":19,"i":17},"r":[{"b":19},2]},"i":[{"d":3,"l":0,"n":21,"v":0},29],"o":{"c":19},"u":19},"w":{"a":[{"g":21},29],"e":{"e":19},"h":23,"i":{"l":6,"n":{"g":3},"t":23}},"x":{"p":41},"y":{"c":32,"e":{".":32},"s":0}},"f":{"a":[{"b":{"l":3,"r":11},"c":{"e":1},"g":18,"i":{"n":17},"l":{"l":{"e":6}},"m":{"a":26,"i":{"s":5}},"r":[{"t":{"h":5}},32],"t":{"a":3,"h":{"e":3},"o":18},"u":{"l":{"t":7}}},41],"b":56,"d":18,"e":{".":18,"a":{"s":17,"t":{"h":54}},"b":[{"r":{"u":{"a":15}}},1],"c":{"a":18,"t":32},"d":25,"l":{"i":3},"m":{"o":1},"n":{"d":[{"e":6},8]},"r":[{"r":32,"m":{"i":{"o":213}}},15],"v":0},"f":[{"e":{"s":21},"i":{"e":21,"n":{".":19},"s":94},"l":{"y":21},"y":24},43],"h":18,"i":[{"a":3,"c":{".":48,"a":{"l":47,"n":23,"t":{"e":18}},"e":{"n":23,"r":3},"i":[{"a":32,"e":32},0],"s":18,"u":3,"h":27},"d":{"e":{"l":4}},"g":{"h":{"t":7}},"l":{"i":5,"l":{"i":{"n":6}},"y":18},"n":[{"a":32,"d":97,"e":9,"g":98,"n":0},25],"s":{"t":{"i":0}},"t":{"t":{"e":{"d":{".":5}}}}},41],"l":[{"e":{"s":{"s":19}},"i":{"n":17},"o":{"r":{"e":11},"w":{"e":{"r":{".":84}}}},"y":100,"a":{"g":{"e":{"l":214}}},"u":{"o":{"r":27}}},99],"m":18,"n":18,"o":[{"n":[{"d":{"e":0},"t":0},32],"r":[{"a":{"t":4,"y":5},"e":{"t":6},"i":0,"t":{"a":6}},9],"s":5},41],"p":56,"r":{"a":{"t":0},"e":{"a":19,"s":{"c":6}},"i":[{"l":17},8],"o":{"l":6}},"s":48,"t":[{"o":21,"y":24},25],"u":[{"e":{"l":4},"g":18,"m":{"i":{"n":1}},"n":{"e":4},"r":{"i":3},"s":{"i":17,"s":0},"t":{"a":18}},27],"y":41},"g":{"a":[{"f":0,"l":{".":32,"i":27,"o":3},"m":[{"e":{"t":4},"o":19},25],"n":{"i":{"s":5,"z":[{"a":6},3]},"o":18},"r":{"n":67},"s":{"s":17},"t":{"h":12,"i":{"v":18}},"z":18},41],"b":23,"d":1,"e":{".":25,"d":25,"e":{"z":17},"l":{"i":{"n":0,"s":4,"z":4},"y":18},"n":[{"a":{"t":1},"i":{"z":4},"o":18,"y":18,"c":{"y":{".":8}}},41],"o":[{"m":3,"d":215},41],"r":{"y":21},"s":{"i":32},"t":{"h":6,"o":18,"y":1,"i":{"c":{".":8}}},"v":1},"g":[{"e":[{"r":23},24],"l":{"u":6},"o":0},101],"h":{"i":{"n":3},"o":{"u":{"t":4}},"t":{"o":1,"w":{"e":15}}},"i":{".":32,"a":[{"r":5},102],"c":[{"i":{"a":32},"o":21},29],"e":{"n":6,"s":{".":32}},"l":0,"m":{"e":{"n":23}},"n":{".":68,"g":{"e":5},"s":103},"o":32,"r":[{"l":0},27],"s":{"l":23},"u":1,"v":32,"z":27},"l":[{"a":[{"d":{"i":6},"s":32},0],"e":[{"a":{"d":29}},41],"i":{"b":0,"g":23,"s":{"h":43}},"o":[{"r":11,"b":{"i":{"n":106}}},27]},9],"m":[{"y":21},29],"n":{"a":[{".":21,"c":69},1],"e":{"t":{"t":17,"i":{"s":{"m":137}}}},"i":[{"n":24,"o":21},29],"o":[{"n":21,"m":{"o":5},"r":{".":216,"e":{"s":{"p":24}}}},29]},"o":[{".":27,"b":5,"e":32,"g":104,"i":{"s":3},"n":[{"a":105,"d":{"o":7},"i":[{"z":{"a":217}},3]},8],"o":32,"r":{"i":{"z":4},"o":{"u":5}},"s":{".":32},"v":15},41],"p":23,"r":[{"a":{"d":{"a":18},"i":21,"n":84,"p":{"h":{".":32,"e":{"r":[{".":7},19]},"i":{"c":32},"y":18}},"y":18},"e":{"n":0,"s":{"s":{".":18}}},"i":{"t":18,"e":{"v":213}},"o":21,"u":{"f":17}},41],"s":[{"t":{"e":19}},9],"t":{"h":11},"u":{"a":[{"r":{"d":27}},1],"e":25,"i":{"t":106},"n":27,"s":27,"t":[{"a":{"n":29}},26]},"w":23,"y":[{"n":107,"r":{"a":4}},41]},"h":{"a":{"b":{"l":73},"c":{"h":17},"e":{"m":0,"t":0},"g":{"u":19},"l":{"a":[{"m":12},3]},"m":1,"n":{"c":{"i":0,"y":0},"d":{".":32},"g":[{"e":{"r":6},"o":6},0],"i":{"z":108},"k":0,"t":{"e":0}},"p":{"l":11,"t":5,"a":{"r":{"r":218}}},"r":{"a":{"n":3,"s":4},"d":[{"e":12},8],"l":{"e":0},"p":{"e":{"n":6}},"t":{"e":{"r":5}}},"s":{"s":5},"u":{"n":17},"z":[{"a":11},32],"i":{"r":{"s":137}},"t":{"c":{"h":213}}},"b":29,"e":{"a":{"d":41,"r":27},"c":{"a":{"n":1,"t":19}},"d":[{"o":13},21],"l":{"i":93,"l":{"i":{"s":0},"y":0},"o":19},"m":{"p":0},"n":[{"a":[{"t":5},17]},9],"o":{"r":5},"p":5,"r":{"a":[{"p":12},21],"b":{"a":0},"e":{"a":6},"n":23,"o":{"u":19},"y":23},"s":[{"p":64},29],"t":[{"e":{"d":0}},1],"u":0,"x":{"a":168}},"f":29,"h":29,"i":{"a":{"n":4},"c":{"o":1},"g":{"h":6},"l":109,"m":{"e":{"r":36}},"n":{"a":21},"o":{"n":{"e":17}},"p":[{"e":{"l":{"a":219}}},1],"r":{"l":0,"o":3,"p":0,"r":0},"s":{"e":{"l":11},"s":0},"t":{"h":{"e":{"r":6}},"e":{"s":{"i":{"d":12}}}},"v":9},"k":18,"l":[{"a":{"n":17},"o":[{"r":{"i":11}},24]},80],"m":[{"e":{"t":17}},43],"n":[{"a":{"u":{"z":12}}},42],"o":{"d":{"i":{"z":19},"s":19},"g":[{"e":17},1],"l":{"a":{"r":5},"e":110},"m":{"a":1,"e":12},"n":{"a":0,"y":4},"o":{"d":27,"n":17},"r":{"a":{"t":5},"i":{"s":4,"c":{".":187}},"t":{"e":12},"u":4},"s":{"e":[{"n":4},0],"p":15},"u":{"s":[{"e":54},41]},"v":{"e":{"l":5}}},"p":56,"r":[{"e":{"e":6},"o":{"n":{"i":{"z":5}},"p":{"o":11}}},26],"s":[{"h":21},101],"t":{"a":{"r":21},"e":{"n":2,"s":4,"o":{"u":216}},"y":21},"u":{"g":1,"m":{"i":{"n":1}},"n":{"k":{"e":5},"t":0},"s":{"t":14},"t":1},"w":[{"a":{"r":{"t":21}}},29],"y":{"p":{"e":3,"h":3,"o":{"t":{"h":{"a":137}}}},"s":9}},"i":{"a":[{"l":24,"m":[{"e":{"t":{"e":5}}},0],"n":[{"c":18,"i":11,"t":46},24],"p":{"e":4},"s":{"s":17},"t":{"i":{"v":21},"r":{"i":{"c":1}},"u":21}},42],"b":{"e":[{"r":{"a":3,"t":4}},0],"i":{"a":4,"n":3,"t":{".":4,"e":4}},"l":[{"i":3},29],"o":19,"r":[{"i":94},29],"u":{"n":19}},"c":{"a":{"m":18,"p":32,"r":[{".":21,"a":21},18],"s":6,"y":21},"c":{"u":17},"e":{"o":18},"h":18,"i":[{"d":19,"n":{"a":4},"p":[{"a":3},24]},25],"l":{"y":21},"o":{"c":94},"r":[{"a":32,"y":21},43],"t":{"e":1,"u":[{"a":111},84]},"u":{"l":{"a":3},"m":1,"o":4,"r":23}},"d":[{"a":{"i":21,"n":{"c":4}},"d":4,"e":{"a":{"l":11},"s":0},"i":[{"a":{"n":4,"r":0},"e":19,"o":[{"u":5,"s":1},3],"t":2,"u":4},24],"l":{"e":23},"o":{"m":21,"w":3},"r":21,"u":[{"o":4},24]},25],"e":[{"d":{"e":0},"g":{"a":113},"l":{"d":12},"n":{"a":67,"e":0,"n":19,"t":{"i":23}},"r":{".":29},"s":{"c":23,"t":29},"t":23},112],"f":{".":18,"e":{"r":{"o":4}},"f":{"e":{"n":5},"r":1},"i":{"c":{".":18},"e":23},"l":23,"t":18,"a":{"c":{"e":{"t":137}}}},"g":[{"a":{"b":5},"e":{"r":{"a":3}},"h":{"t":{"i":12}},"i":[{"b":23,"l":3,"n":3,"t":3},18],"l":28,"o":[{"r":3,"t":4},24],"r":{"e":19},"u":{"i":5,"r":2},"n":{"i":{"t":[{"e":{"r":213}},0]}}},25],"h":23,"i":114,"j":[{"k":21},23],"k":18,"l":{"a":[{"b":93,"d":{"e":21},"m":94,"r":{"a":5}},29],"e":{"g":23,"r":2,"v":17},"f":4,"i":[{"a":3,"b":9,"o":3,"s":{"t":1},"t":25,"z":9},2],"l":{"a":{"b":5}},"n":18,"o":{"q":3},"t":{"y":1},"u":{"r":4},"v":3},"m":{"a":{"g":[{"e":3},21],"r":{"y":5}},"e":{"n":{"t":{"a":{"r":10}}},"t":18},"i":[{"d":{"a":4},"l":{"e":5},"n":{"i":19},"t":18},2],"n":{"i":1},"o":{"n":23},"u":[{"l":{"a":3}},24],"p":{"e":{"d":{"a":201}}}},"n":{".":25,"a":{"u":83,"v":18},"c":{"e":{"l":36,"r":3}},"d":[{"l":{"i":{"n":{"g":4}}}},18],"e":[{"e":23,"r":{"a":{"r":17}},"s":{"s":19}},25],"g":{"a":18,"e":[{"n":4},18],"i":18,"l":{"i":{"n":{"g":4}}},"o":18,"u":18},"i":[{".":19,"a":21,"o":3,"s":2,"t":{"e":{".":19,"l":{"y":{".":19}}},"i":{"o":32},"y":3}},25],"k":18,"l":18,"n":25,"o":[{"c":90,"s":0,"t":21},42],"s":[{"e":3,"u":{"r":{"a":7}}},25],"t":{".":25,"h":112},"u":[{"s":19},2],"y":18,"f":{"r":{"a":{"s":220}}}},"o":[{".":18,"g":{"e":17,"r":9},"l":29,"m":1,"n":{"a":{"t":11},"e":{"r":{"y":0}},"i":11},"p":{"h":4},"r":{"i":11},"s":21,"t":{"h":4,"i":19,"o":1},"u":{"r":21}},25],"p":[{"e":0,"h":{"r":{"a":{"s":115}}},"i":[{"c":1},3],"r":{"e":96},"u":{"l":3}},25],"q":{"u":{"a":23,"e":{"f":4},"i":{"d":3,"t":116}}},"r":[{"a":[{"b":0,"c":21},29],"d":{"e":5},"e":{"d":{"e":0},"f":21,"l":117,"s":21},"g":{"i":4},"i":[{"d":{"e":5},"s":1,"t":{"u":11},"z":118},2],"m":{"i":{"n":1}},"o":{"g":0,"n":{".":32}},"u":{"l":4},"r":{"e":{"v":{"o":{"c":221}}}}},18],"s":{".":25,"a":{"g":4,"r":3,"s":6},"c":[{"h":3},119],"e":[{"r":3},18],"f":27,"h":{"a":{"n":4},"o":{"n":3,"p":5}},"i":{"b":3,"d":0,"s":19,"t":{"i":{"v":4}}},"k":26,"l":{"a":{"n":36}},"m":{"s":18},"o":[{"m":{"e":{"r":5}}},24],"p":[{"i":9,"y":1},2],"s":[{"a":{"l":1},"e":{"n":36,"s":1}},62],"t":{"a":{".":1},"e":2,"i":2,"l":{"y":0},"r":{"a":{"l":18}}},"u":[{"s":4},24]},"t":{"a":{".":18,"b":{"i":0},"g":21,"m":120,"n":23,"t":23},"e":[{"r":{"a":3,"i":19},"s":[{"i":{"m":{"a":29}}},1]},25],"h":[{"i":{"l":148}},25],"i":[{"a":18,"c":[{"a":3,"k":31},22],"g":3,"l":{"l":4},"m":24,"o":25,"s":[{"m":21},18],"n":{"e":{"r":{"a":{"r":158}}}}},29],"o":{"m":121,"n":18},"r":{"a":{"m":21},"y":4},"t":18,"u":{"a":{"t":3},"d":19,"l":3},"z":{".":18}},"u":29,"v":[{"e":{"l":{"l":3},"n":{".":3},"r":{".":83,"s":{".":21}}},"i":{"l":{".":4},"o":4,"t":2},"o":{"r":{"e":19,"o":35},"t":83}},25],"w":56,"x":{"o":1},"y":18,"z":{"a":{"r":18},"i":0,"o":{"n":{"t":32}}}},"j":{"a":[{"c":{"q":0},"p":[{"a":{"n":{"e":{"s":220}}}},1],"n":{"u":{"a":12}}},32],"e":[{"r":{"s":5,"e":{"m":222}},"s":{"t":{"i":{"e":18},"y":18}},"w":11},41],"o":{"p":1},"u":{"d":{"g":32}}},"k":{"a":{".":27,"b":23,"g":19,"i":{"s":17},"l":0},"b":29,"e":{"d":24,"e":41,"g":1,"l":{"i":[{"n":{"g":223}},4]},"n":{"d":73},"r":29,"s":[{"t":{".":23}},0],"t":{"y":1}},"f":23,"h":1,"i":[{".":32,"c":122,"l":{"l":21,"o":6},"m":21,"n":{".":21,"d":{"e":0},"e":{"s":{"s":19},"t":{"i":{"c":224}}},"g":0},"p":1,"s":[{"h":19},0]},29],"k":1,"l":[{"e":{"y":18},"y":18},29],"m":29,"n":{"e":{"s":19},"o":69},"o":{"r":4,"s":{"h":17},"u":23,"v":{"i":{"a":{"n":41}}}},"r":{"o":{"n":5}},"s":[{"c":21,"l":1,"y":21,"h":{"a":23}},101],"t":19,"w":29},"l":{"a":{"b":{"i":{"c":11},"o":21},"c":{"i":[{"e":225},17]},"d":{"e":21,"y":3},"g":{"n":0},"m":{"o":11},"n":{"d":[{"l":0},27],"e":{"t":5},"t":{"e":0}},"r":{"g":0,"i":11,"c":{"e":{"n":176}}},"s":{"e":0},"t":{"a":{"n":4},"e":{"l":{"i":18}},"i":{"v":18}},"v":[{"a":95},18],"i":{"n":{"e":{"s":{"s":226}}}}},"b":[{"i":{"n":17}},42],"c":[{"e":0,"i":23,"h":{"a":{"i":23},"i":{"l":{"d":227}}}},101],"d":[{"e":[{"r":{"e":1,"i":1}},24],"i":[{"s":4},0],"r":[{"i":21},23]},25],"e":{"a":[{"d":{"e":{"r":{".":183}}},"s":{"a":228}},9],"b":{"i":1},"f":{"t":6},"g":{".":32,"g":32,"e":{"n":{"d":{"r":{"e":230}}}}},"m":{"a":{"t":[{"i":{"c":5}},1]}},"n":{".":18,"c":27,"e":{".":32},"t":41,"o":{"i":{"d":78}}},"p":{"h":3,"r":1},"r":{"a":{"b":6},"e":0,"g":27,"i":68,"o":21},"s":[{"c":{"o":4},"q":32,"s":[{".":32},27]},8],"v":{"a":23,"e":{"r":{".":0,"a":0,"s":0}}},"y":[{"e":18},27],"c":{"t":{"a":{"b":229}}}},"f":[{"r":19},25],"g":[{"a":[{"r":12},19],"e":{"s":21},"o":11},80],"h":48,"i":{"a":{"g":1,"m":9,"r":{"i":{"z":6}},"s":1,"t":{"o":1}},"b":{"i":4},"c":{"i":{"o":32},"o":{"r":1},"s":18,"t":{".":18},"u":21,"y":23},"d":{"a":23,"e":{"r":5},"i":27},"f":{"e":{"r":11},"f":21,"l":1},"g":{"a":{"t":{"e":32}},"h":27,"r":{"a":1}},"k":27,"l":123,"m":{"b":{"l":0},"i":11,"o":1,"p":90},"n":{"a":21,"e":[{"a":11},124],"i":11,"k":{"e":{"r":6}}},"o":{"g":4},"q":125,"s":{"p":0},"t":[{".":24,"i":{"c":{"a":32,"s":108}},"h":{"o":{"g":204}}},29],"v":{"e":{"r":11}},"z":29},"j":18,"k":{"a":[{"l":23,"t":0},11]},"l":[{"a":{"w":21},"e":[{"a":19,"c":23,"g":23,"l":23,"n":73,"t":73},24],"i":[{"n":[{"a":19},126],"s":{"h":231}},9],"o":[{"q":{"u":{"i":10}},"u":{"t":4},"w":19},1],"f":{"l":2}},29],"m":[{"e":{"t":19},"i":{"n":{"g":3}},"o":{"d":21,"n":[{"e":{"l":{"l":232}}},17]}},25],"n":81,"o":{".":27,"b":{"a":{"l":5},"o":{"t":{"o":233}}},"c":{"i":1},"f":18,"g":{"i":{"c":27},"o":19,"u":27,"e":{"s":{".":9}}},"m":{"e":{"r":11}},"n":{"g":32,"i":[{"z":127},0]},"o":{"d":6},"p":{"e":{".":32},"i":11,"m":23},"r":{"a":[{"t":{"o":1}},17],"i":{"e":4},"o":{"u":5}},"s":{".":32,"e":{"t":5},"o":{"p":{"h":{"i":{"z":32},"y":32}}},"t":0},"t":{"a":1},"u":{"n":{"d":6},"t":25},"v":18,"a":{"d":{"e":{"d":{".":17},"r":{".":183}}}}},"p":[{"a":{"b":5},"h":{"a":23,"i":19},"i":{"n":{"g":4},"t":23},"l":21,"r":19},25],"r":43,"s":[{"c":21,"e":24,"i":{"e":21}},81],"t":[{"a":{"g":4,"n":{"e":7}},"e":[{"n":17,"r":{"a":36},"a":23},29],"h":{"i":[{"l":{"y":148}},11]},"i":{"e":{"s":{".":19}},"s":17},"r":29,"u":[{"r":{"a":12}},8]},18],"u":{"a":4,"b":{"r":3},"c":{"h":17,"i":3},"e":{"n":3,"p":15},"f":0,"i":{"d":4},"m":{"a":1,"i":32,"n":{".":19,"i":{"a":32}},"b":{"i":{"a":{".":235}}}},"o":[{"r":11},3],"p":18,"s":{"s":17,"t":{"e":11}},"t":41,"n":{"k":{"e":{"r":234}}}},"v":{"e":{"n":19,"t":128}},"w":42,"y":[{"a":18,"b":18,"m":{"e":4},"n":{"o":3},"s":[{"e":19,"t":{"y":{"r":4}}},58],"g":{"a":{"m":{"i":236}}}},41]},"m":{"a":[{"b":25,"c":{"a":9,"h":{"i":{"n":{"e":4}}},"l":1},"g":{"i":{"n":5},"n":32},"h":25,"i":{"d":6},"l":{"d":18,"i":{"g":3,"n":4},"l":{"i":0},"t":{"y":0},"a":{"p":222}},"n":{"i":{"a":32,"s":5,"z":11},".":24,"u":{"s":{"c":237}}},"p":[{"h":{"r":{"o":244}}},18],"r":{"i":{"n":{"e":{".":4}},"z":4},"l":{"y":0},"v":11,"g":{"i":{"n":238}}},"s":{"c":{"e":4},"e":0,"t":15},"t":{"e":32,"h":12,"i":{"s":3,"z":{"a":18}}}},41],"b":[{"a":{"t":129},"i":{"l":19,"n":{"g":83},"v":0}},43],"c":56,"e":{".":18,"d":[{".":18,"i":{"a":32,"e":3,"c":[{"i":{"n":152}},84],"o":{"c":239}},"y":108},25],"g":[{"r":{"a":{"n":240}}},9],"l":{"o":{"n":5},"t":0},"m":[{"o":130},9],"n":[{"a":[{"c":5},0],"d":{"e":0},"e":18,"i":0,"s":[{"u":7},17],"t":[{"e":0},27],".":24},41],"o":{"n":4},"r":{"s":{"a":19}},"s":[{"t":{"i":27}},25],"t":{"a":[{"l":11},1],"e":2,"h":{"i":4},"r":[{"i":{"c":32,"e":4},"y":3},21]},"v":1},"f":43,"h":25,"i":{".":32,"a":3,"d":{"a":[{"b":241},0],"g":0},"g":0,"l":{"i":{"a":27,"e":108,"t":{"a":27}},"l":[{"a":{"g":208},"i":{"l":{"i":59}}},21]},"n":{"a":0,"d":27,"e":{"e":19},"g":{"l":[{"i":5,"y":19},21]},"t":0,"u":[{"t":{"e":{"r":242,"s":{"t":242}}}},21],"i":{"s":{".":174}}},"o":{"t":17},"s":[{"e":{"r":{".":0}},"l":5,"t":{"i":0,"r":{"y":19}}},24],"t":{"h":18},"z":24},"k":18,"l":43,"m":[{"a":{"r":{"y":5},"b":243}},29],"n":[{"a":1,"i":{"n":21},"o":1},43],"o":[{"c":{"r":[{"a":{"t":[{"i":{"z":32}},245]}},18]},"d":131,"g":{"o":1},"i":{"s":[{"e":5},84]},"k":18,"l":{"e":{"s":{"t":4},"c":246}},"m":{"e":3},"n":{"e":{"t":5,"y":{"l":247}},"g":{"e":5},"i":{"a":12,"s":{"m":0,"t":0},"z":3},"o":{"l":36,"c":{"h":12},"e":{"n":171},"s":249},"y":{".":3}},"r":[{"a":{".":18},"o":{"n":{"i":{"s":248}}}},9],"s":[{"e":{"y":4},"p":3},8],"t":{"h":[{"e":{"t":250}},12]},"u":{"f":19,"s":[{"i":{"n":98}},27]},"v":9,"e":{"l":{"a":{"s":167}}}},41],"p":[{"a":{"r":{"a":[{"b":5},7],"i":6}},"e":{"t":23},"h":{"a":{"s":36}},"i":[{"a":0,"e":{"s":4},"n":34,"r":19,"s":4},24],"o":{"r":{"i":11},"s":{"i":{"t":{"e":6}}},"u":{"s":21},"v":6},"t":{"r":1},"y":24},43],"r":47,"s":[{"h":[{"a":{"c":{"k":251}}},21],"i":19},101],"t":18,"u":[{"l":{"a":{"r":49},"t":[{"i":[{"u":252},54]},32]},"m":27,"n":8,"p":18,"u":1,"d":{"r":{"o":9}}},41],"w":18},"n":{"a":[{"b":[{"u":21},81],"c":{".":18,"a":1,"t":19},"g":{"e":{"r":{".":5}}},"k":0,"l":{"i":[{"a":4},1],"t":18},"m":{"i":{"t":4}},"n":[{"c":{"i":36},"i":{"t":0},"k":17},24],"r":{"c":[{"h":{"s":{".":73}}},11],"e":18,"i":11,"l":0,"m":19},"s":[{"c":0,"t":{"i":5}},21],"t":[{"a":{"l":3},"o":{"m":{"i":{"z":6}}}},24],"u":[{"s":{"e":11},"t":27},24],"v":{"e":0}},41],"b":80,"c":{"a":{"r":6},"e":{"s":{".":21}},"h":{"a":23,"e":{"o":19,"s":{"t":253}},"i":{"l":19,"s":23}},"i":{"n":2,"t":1},"o":{"u":{"r":{"a":7}}},"r":29,"u":29},"d":{"a":{"i":21,"n":19},"e":[{"s":{"t":{".":4}}},29],"i":{"b":0,"f":79,"t":29,"z":23,"e":{"c":{"k":29}}},"u":{"c":19,"r":0},"w":{"e":9},"t":{"h":{"r":3}}},"e":{".":25,"a":{"r":23},"b":[{"u":11,"a":{"c":{"k":3}}},9],"c":[{"k":32},9],"d":25,"g":{"a":{"t":[{"i":{"v":5}},1]},"e":32},"l":{"a":1,"i":{"z":5}},"m":{"i":4,"o":1},"n":[{"e":18},41],"o":27,"p":{"o":1},"q":9,"r":[{"a":{"b":6,"r":21},"e":24,"i":132,"r":0},29],"s":[{".":25,"p":18,"t":25,"w":18,"k":{"i":119}},41],"t":{"i":{"c":27}},"v":[{"e":19},1],"w":1},"f":[{"i":{"n":{"i":{"t":{"e":{"s":226}}}}}},23],"g":{"a":{"b":21},"e":{"l":23,"n":{"e":[{"s":5},133]},"r":{"e":19,"i":23}},"h":{"a":4,"o":2},"i":{"b":23,"n":2,"t":19},"l":{"a":21},"o":{"v":17},"s":{"h":4,"p":{"r":2}},"u":[{"m":21},29],"y":24},"h":[{"a":[{"b":12},0],"e":0},80],"i":{"a":[{"n":[{".":114},3],"p":1},68],"b":{"a":3,"l":1},"d":[{"i":4},1],"e":{"r":1},"f":{"i":[{"c":{"a":{"t":4}}},9]},"g":{"r":19},"k":0,"m":[{"i":{"z":3}},29],"n":[{"e":{".":32},"g":0},29],"o":1,"s":{".":32,"t":{"a":0}},"t":[{"h":21,"i":{"o":27},"o":{"r":23},"r":3},24]},"j":29,"k":[{"e":{"r":{"o":19},"t":23},"i":{"n":3},"l":29,"r":{"u":{"p":3}}},44],"l":[{"e":{"s":{"s":19}}},43],"m":[{"e":[{"t":17},0]},19],"n":[{"e":0,"i":{"a":{"l":11},"v":0}},101],"o":{"b":{"l":[{"e":3},0]},"c":{"l":19,"e":{"r":{"o":{"s":254}}}},"d":66,"e":27,"g":[{"e":17},18],"i":{"s":{"i":6}},"l":{"i":134,"o":{"g":{"i":{"s":32}}}},"m":{"i":{"c":27,"z":108,"s":{"t":82}},"o":1,"y":3,"a":{"l":214},"e":{"n":{"o":194}}},"n":[{"a":{"g":0},"i":[{"z":19,"s":{"o":255}},5],"e":{"q":15}},1],"p":[{"o":{"l":{"i":135,"y":{".":256}}}},18],"r":{"a":{"b":5,"r":{"y":1}}},"s":{"c":18,"e":0,"t":5},"t":{"a":4},"u":[{"n":27},41],"v":{"e":{"l":136,"m":{"b":2}}},"w":{"l":12}},"p":[{"i":0,"r":{"e":{"c":17}}},72],"q":29,"r":[{"u":0},29],"s":[{"a":{"b":4,"t":{"i":36}},"c":[{"e":{"i":{"v":4}}},1],"e":[{"s":83},24],"i":{"d":137,"g":17},"l":24,"m":[{"o":{"o":1}},3],"o":{"c":21},"p":{"e":1,"i":19},"t":{"a":{"b":{"l":6}}}},81],"t":[{"a":{"b":0},"e":{"r":{"s":12}},"i":[{"b":19,"e":{"r":0},"f":8,"n":{"e":23,"g":83},"p":0},9],"r":{"o":{"l":{"l":{"i":7}}},"e":{"p":137}},"s":1,"u":{"m":{"e":11}}},29],"u":{"a":2,"d":1,"e":{"n":4},"f":{"f":{"e":0}},"i":{"n":23,"t":50},"m":[{"e":2,"i":19},21],"n":138,"o":23,"t":{"r":3}},"v":74,"w":72,"y":{"m":0,"p":0},"z":[{"a":23},18]},"o":{"a":[{"d":11,"l":{"e":{"s":108}},"r":{"d":12},"s":{"e":0,"t":{"e":6}},"t":{"i":5}},18],"b":{"a":{"b":35,"r":19},"e":{"l":0},"i":[{"n":[{"g":4},24]},29],"r":23,"u":{"l":3},"l":{"i":{"g":189}}},"c":{"e":29,"h":[{"e":{"t":23},"a":{"s":23}},0],"i":{"f":12,"l":21},"l":{"a":{"m":21}},"o":{"d":21},"r":{"a":{"c":3,"t":{"i":{"z":4}}},"e":12,"i":{"t":32}},"t":{"o":{"r":{"a":7}}},"u":{"l":{"a":3},"r":{"e":19}}},"d":{"d":{"e":{"d":4}},"i":{"c":3,"o":11,"t":{"i":{"c":137}}},"o":[{"r":12},139],"u":{"c":{"t":{".":4,"s":4}}},"e":{"l":{"l":{"i":12}}}},"e":{"l":21,"n":{"g":19},"r":[{"s":{"t":257}},23],"t":{"a":1},"v":23},"f":{"i":[{"t":{"e":4,"t":17}},24]},"g":{"a":{"r":121,"t":{"i":{"v":4},"o":21}},"e":[{"n":{"e":19},"o":19,"r":21},29],"i":{"e":23,"s":140,"t":3},"l":[{"y":79},21],"n":{"i":{"z":27}},"r":{"o":21},"u":{"i":5},"y":[{"n":25},41]},"h":[{"a":{"b":6}},74],"i":[{"c":{"e":{"s":11}},"d":{"e":{"r":3}},"f":{"f":17},"g":0,"l":{"e":{"t":4}},"n":{"g":23,"t":{"e":{"r":6}}},"s":{"m":19,"o":{"n":4},"t":{"e":{"n":6}}},"t":{"e":{"r":3}}},9],"j":19,"k":[{"e":{"n":23,"s":{"t":15}},"i":{"e":4}},25],"l":{"a":[{"n":21,"s":{"s":36}},29],"d":[{"e":15},9],"e":{"r":3,"s":{"c":23,"t":{"e":{"r":88}}},"t":23},"f":{"i":1},"i":[{"a":23,"c":{"e":23},"d":{".":4},"f":73,"l":19,"n":{"g":3},"o":19,"s":{".":19,"h":3},"t":{"e":19,"i":{"o":19}},"v":19,"g":{"o":{"p":{"o":258}}}},9],"l":{"i":{"e":17}},"o":{"g":{"i":{"z":4}},"r":0,"n":{"o":{"m":259}}},"p":{"l":4},"t":9,"u":{"b":3,"m":{"e":3},"n":3,"s":19},"v":9,"y":24},"m":{"a":{"h":4,"l":5,"t":{"i":{"z":4}}},"b":{"e":9,"l":1},"e":[{"n":{"a":3},"r":{"s":{"e":4}},"t":[{"r":{"y":4}},21],"c":{"h":{"a":260}}},24],"i":{"a":23,"c":{".":3,"a":3},"d":19,"n":[{"i":19},2]},"m":{"e":{"n":{"d":32}}},"o":{"g":{"e":0},"n":21},"p":{"i":3,"r":{"o":7}}},"n":[{"a":[{"c":1,"n":23},2],"c":[{"i":{"l":27}},2],"d":[{"o":4},25],"e":{"n":23,"s":{"t":4}},"g":{"u":1},"i":{"c":2,"o":23,"s":2,"u":19},"k":{"e":{"y":3}},"o":{"d":{"i":1},"m":{"y":3,"i":{"c":137}},"r":{"m":{"a":23}},"t":{"o":{"n":261}},"u":23},"s":[{"p":{"i":[{"r":{"a":10}},36]},"u":17},3],"t":{"e":{"n":36},"i":[{"f":7},93]},"u":{"m":4},"v":{"a":6}},24],"o":[{"d":{"e":5,"i":5},"k":1,"p":{"i":11},"r":{"d":23},"s":{"t":6}},9],"p":{"a":24,"e":{"d":5,"r":[{"a":[{"g":18},27]},2]},"h":[{"a":{"n":19},"e":{"r":19}},25],"i":{"n":{"g":3},"t":23,"s":{"m":{".":2}}},"o":{"n":19,"s":{"i":21}},"r":29,"u":2,"y":5},"q":29,"r":{"a":[{".":19,"g":83,"l":{"i":{"z":4}},"n":{"g":{"e":4}}},29],"e":{"a":[{"l":19},5],"i":3,"s":{"h":5,"t":{".":4}},"w":17},"g":{"u":1},"i":{"a":56,"c":{"a":3},"l":19,"n":2,"o":29,"t":{"y":3},"u":23},"m":{"i":9},"n":{"e":8},"o":{"f":19,"u":{"g":3}},"p":{"e":4},"r":{"h":27},"s":{"e":[{"n":5},1],"t":17},"t":{"h":{"i":3,"y":3,"o":{"n":{"i":{"t":262}}},"r":{"i":137}},"y":1,"i":{"v":{"e":{"l":{"y":4}}}}},"u":{"m":19},"y":29},"s":{"a":{"l":3},"c":[{"e":1,"o":{"p":[{"i":18},23]},"r":19},9],"i":{"e":95,"t":{"i":{"v":4},"o":3,"y":3},"u":0},"l":1,"o":24,"p":{"a":1,"o":1,"h":{"e":{"r":83}}},"t":{"a":[{"t":{"i":19}},9],"i":{"l":4,"t":4}}},"t":{"a":{"n":21},"e":{"l":{"e":{"g":36}},"r":{".":3,"s":4},"s":[{"t":{"e":{"r":263},"o":{"r":264}}},21]},"h":[{"e":{"s":{"i":5},"o":{"s":265}},"i":14},18],"i":{"c":{".":3,"a":4,"e":23},"f":23,"s":23},"o":{"s":5}},"u":[{"b":{"l":3,"a":{"d":{"o":116}}},"c":{"h":{"i":6}},"e":{"t":4},"l":1,"n":{"c":{"e":{"r":6}},"d":8},"v":4},9],"v":{"e":{"n":1,"r":{"n":{"e":17},"s":12,"t":1}},"i":{"s":23,"t":{"i":36},"a":{"n":{".":266}}},"o":{"l":60}},"w":{"d":{"e":{"r":3}},"e":{"l":3,"s":{"t":4}},"i":2,"n":{"i":5},"o":21},"y":{"a":2},"x":{"i":{"d":{"i":{"c":267}}}}},"p":{"a":[{"c":{"a":1,"e":1,"t":0},"d":21,"g":{"a":{"n":32,"t":23}},"i":[{"n":17},21],"l":[{"m":{"a":{"t":268}}},21],"n":{"a":0,"e":{"l":11},"t":{"y":0},"y":3},"p":[{"u":1},2],"r":{"a":{"b":{"l":6},"g":{"e":5,"r":{"a":269}},"l":{"e":228},"m":[{"e":12},36]},"d":{"i":5},"e":[{"l":5},27],"i":[{"s":0},28]},"t":{"e":[{"r":4},9],"h":{"i":{"c":32},"y":4},"r":{"i":{"c":1}}},"v":0,"y":27},41],"b":43,"d":1,"e":{".":18,"a":[{"r":{"l":17}},138],"c":9,"d":[{"e":27,"i":[{"a":36,"c":0},27]},37],"e":[{"d":0,"v":208},21],"k":0,"l":{"a":1,"i":{"e":17}},"n":{"a":{"n":1},"c":21,"t":{"h":0}},"o":{"n":4},"r":{"a":{".":21,"b":{"l":6},"g":21},"i":[{"s":{"t":6}},21],"m":{"a":{"l":0},"e":7},"n":21,"o":11,"t":{"i":11},"u":4,"v":15},"t":[{"e":{"n":4},"i":{"z":4}},9]},"f":18,"g":18,"h":{".":18,"a":{"r":{"i":6}},"e":{"n":{"o":11},"r":1,"s":{".":1}},"i":{"c":2,"e":32,"n":{"g":4},"s":{"t":{"i":32}},"z":27,"l":{"a":{"n":{"t":168},"t":{"e":{"l":270}}}}},"l":9,"o":{"b":27,"n":{"e":27,"i":32},"r":0},"s":18,"t":3,"u":32,"y":41},"i":{"a":[{"n":17},3],"c":{"i":{"e":1},"y":1,"a":{"d":271}},"d":[{"a":19,"e":3,"i":32},21],"e":{"c":27,"n":3},"g":{"r":{"a":{"p":1}}},"l":{"o":3},"n":[{".":21,"d":17,"o":21},9],"o":[{"n":17},141],"t":{"h":[{"a":4},23],"u":9}},"k":142,"l":[{"a":{"n":27,"s":{"t":6}},"i":{"a":11,"e":{"r":5},"g":18,"n":[{"a":{"r":5}},0],"c":{"a":{"b":208}}},"o":{"i":17},"u":{"m":[{"b":17},0]}},143],"m":43,"n":48,"o":{"c":1,"d":{".":32},"e":{"m":4,"t":144},"g":145,"i":{"n":[{"t":32,"c":{"a":12}},84]},"l":{"y":{"t":6,"e":137,"p":{"h":{"o":{"n":{"o":272}}}}},"e":{".":41}},"n":{"i":1},"p":1,"r":[{"y":1},124],"s":[{"s":15},41],"t":[{"a":1},21],"u":{"n":32}},"p":[{"a":{"r":{"a":5}},"e":[{"d":21,"l":19,"n":23,"r":23,"t":23},24],"o":{"s":{"i":{"t":{"e":5}}}}},43],"r":[{"a":{"y":{"e":17}},"e":{"c":{"i":32,"o":5},"e":{"m":11},"f":{"a":{"c":6}},"l":{"a":0},"r":11,"s":{"e":23,"s":27,"p":{"l":{"i":84}}},"t":{"e":{"n":5}},"v":11,"m":{"a":{"c":273}},"n":{"e":{"u":15}}},"i":{"e":53,"n":{"t":146},"s":[{"o":12},0]},"o":{"c":{"a":23,"e":{"s":{"s":8}},"i":{"t":{"y":{".":274}}}},"f":{"i":{"t":6}},"l":11,"s":{"e":12},"t":15,"g":{"e":208}}},9],"s":[{"e":[{"u":{"d":[{"o":{"d":276,"f":276}},275]}},24],"h":1,"i":{"b":21}},81],"t":[{"a":{"b":134},"e":24,"h":24,"i":{"m":11},"u":{"r":0},"w":21,"o":{"m":{"a":{"t":277}}},"r":{"o":{"l":278}}},42],"u":{"b":[{"e":{"s":{"c":181}}},11],"e":0,"f":0,"l":{"c":11},"m":1,"n":9,"r":{"r":0},"s":32,"t":[{"e":[{"r":11},32],"r":3,"t":{"e":{"d":0},"i":{"n":0}}},9]},"w":23},"q":{"u":[{"a":{"v":5,"i":{"n":{"t":{"e":279}}},"s":{"i":[{"r":281,"s":281},280]}},"e":{".":25,"r":27,"t":27},"i":{"n":{"t":{"e":{"s":{"s":282}}}},"v":{"a":{"r":14}}}},9]},"r":{"a":{"b":[{"i":3,"o":{"l":{"i":{"c":29},"o":{"i":236}}}},25],"c":{"h":{"e":17,"u":3},"l":19},"f":{"f":{"i":5},"t":0},"i":24,"l":{"o":1},"m":{"e":{"t":[{"r":{"i":{"z":283}}},11],"n":24},"i":24,"o":{"u":3}},"n":{"e":{"o":6},"g":{"e":0},"i":21,"o":4,"h":{"a":{"s":167}}},"p":{"e":{"r":11},"h":{"y":27}},"r":{"c":5,"e":[{"f":5},17],"i":{"l":18}},"s":24,"t":{"i":{"o":{"n":115}}},"u":{"t":0},"v":{"a":{"i":4},"e":{"l":11}},"z":{"i":{"e":4}},"d":{"i":{"g":127,"o":{"g":249}}},"o":{"r":2}},"b":[{"a":{"b":21,"g":21},"i":[{"f":0,"n":[{"e":19,"g":{".":4,"e":284}},24]},8],"o":1},29],"c":[{"e":[{"n":17},24],"h":{"a":23,"e":{"r":0}},"i":{"b":90,"t":1},"u":{"m":12}},29],"d":{"a":{"l":21},"i":[{"a":0,"e":{"r":0},"n":[{"g":3},17]},9]},"e":{".":25,"a":{"l":2,"n":3,"r":{"r":4},"v":32,"w":1},"b":{"r":{"a":{"t":19}}},"c":{"o":{"l":{"l":5},"m":{"p":{"e":5}}},"r":{"e":1},"i":{"p":{"r":285}},"t":{"a":{"n":{"g":286}}}},"d":[{"e":2,"i":{"s":3,"t":5}},37],"f":{"a":{"c":1},"e":[{"r":{".":4}},9],"i":3,"y":1},"g":{"i":{"s":11}},"i":{"t":4},"l":{"i":2,"u":4},"n":{"t":{"a":90,"e":0}},"o":2,"p":{"i":{"n":4},"o":{"s":{"i":1}},"u":2},"r":[{"i":21,"o":17,"u":4},147],"s":{".":21,"p":{"i":1},"s":{"i":{"b":6}},"t":[{"a":{"l":4},"r":3},8]},"t":{"e":{"r":1},"i":{"z":96},"r":{"i":[{"b":{"u":85}},3]}},"u":[{"t":{"i":4}},8],"v":[{"a":{"l":1},"e":{"l":11,"r":{".":30,"s":4,"t":4}},"i":{"l":4},"o":{"l":{"u":5}}},8],"w":{"h":1}},"f":[{"u":0,"y":21},29],"g":[{"e":{"r":3,"t":23},"i":{"c":23,"n":[{"g":3},0],"s":19,"t":19},"l":29,"o":{"n":0},"u":23},9],"h":[{".":18,"a":{"l":18}},1],"i":{"a":[{"b":0,"g":1,"l":{".":23}},3],"b":[{"a":11},21],"c":{"a":{"s":5},"e":21,"i":[{"d":32,"e":1},18],"o":21},"d":{"e":{"r":5}},"e":{"n":{"c":3,"t":3},"r":2,"t":4},"g":{"a":{"n":5},"i":32},"l":{"i":{"z":11}},"m":{"a":{"n":32},"i":5,"o":27,"p":{"e":0}},"n":{"a":[{".":32},24],"d":0,"e":0,"g":0},"o":2,"p":{"h":[{"e":6},32],"l":[{"i":{"c":5}},9]},"q":21,"s":[{".":21,"c":0,"h":23,"p":0},24],"t":{"a":{"b":116},"e":{"d":{".":19},"r":{".":5,"s":5}},"i":{"c":11},"u":[{"r":5},9]},"v":{"e":{"l":5,"t":11},"i":11,"o":{"l":287}}},"j":23,"k":{"e":{"t":23},"l":{"e":1,"i":{"n":1}},".":288,"h":{"o":2},"r":{"a":{"u":29}},"s":{".":288}},"l":[{"e":[{"d":24,"q":{"u":30}},0],"i":{"g":21,"s":[{"h":4},21]},"o":73},29],"m":[{"a":{"c":5},"e":[{"n":23,"r":{"s":4}},24],"i":{"n":{"g":[{".":21},3]},"o":21,"t":23},"y":21},29],"n":{"a":{"r":21},"e":{"l":23,"r":21,"t":19,"y":23},"i":{"c":19,"s":92,"t":23,"v":23},"o":[{"u":21},0],"u":23},"o":{"b":{"l":11,"o":{"t":289}},"c":[{"r":3},24],"e":[{"l":{"a":{"s":167}},"p":{"i":{"d":{"e":290}}}},1],"f":{"e":2,"i":{"l":4}},"k":[{"e":{"r":4}},8],"l":{"e":{".":32}},"m":{"e":{"t":{"e":5},"s":{"h":3}},"i":0,"p":0},"n":{"a":{"l":0},"e":0,"i":{"s":134},"t":{"a":0}},"o":{"m":41,"t":32},"p":{"e":{"l":3},"i":{"c":11}},"r":{"i":11,"o":4},"s":{"p":{"e":{"r":5}},"s":0},"t":{"h":{"e":1},"y":1,"r":{"o":{"n":2}}},"v":{"a":1,"e":{"l":5}},"x":5},"p":[{"e":{"a":21,"n":{"t":19},"r":{".":4},"t":23},"h":95,"i":{"n":{"g":3}},"o":23,"a":{"u":{"l":{"i":291}}}},29],"r":[{"e":{"c":0,"f":0,"o":21,"s":{"t":0}},"i":{"o":0,"v":0},"o":{"n":17,"s":17},"y":{"s":17}},72],"s":[{"a":[{"t":{"i":5}},29],"c":1,"e":[{"c":[{"r":0},23],"r":{".":4,"a":{"d":{"i":238}}},"s":3,"v":148},24],"h":[{"a":19},29],"i":[{"b":90},29],"o":{"n":12},"p":29,"w":19},44],"t":{"a":{"c":{"h":36},"g":21},"e":{"b":23,"n":{"d":17},"o":5},"i":[{"b":4,"d":0,"e":{"r":21},"g":23,"l":{"i":12,"l":17,"y":21},"s":{"t":21},"v":21},29],"r":{"i":23,"o":{"p":{"h":115}},"e":{"u":29}},"s":{"h":1},"h":{"o":{"u":29}}},"u":{"a":3,"e":{"l":93,"n":3},"g":{"l":1},"i":{"n":3},"m":{"p":{"l":11}},"n":[{"k":6,"t":{"y":0}},9],"s":{"c":19},"t":{"i":{"n":6}}},"v":{"e":[{"l":{"i":17},"n":23,"r":{".":4},"s":{"t":19},"y":23,"i":{"l":29}},1],"i":{"c":23,"v":0},"o":23},"w":29,"y":{"c":1,"n":{"g":{"e":32}},"t":3},"z":{"s":{"c":2}}},"s":{"a":[{"b":42,"c":{"k":32,"r":{"i":11},"t":23},"i":32,"l":{"a":{"r":36},"m":0,"o":4,"t":0,"e":{"s":{"c":54,"w":7}}},"n":{"c":27,"d":{"e":0}},"p":[{"a":{"r":{"i":{"l":292}}}},29],"t":{"a":4,"i":{"o":76},"u":11},"u":0,"v":{"o":{"r":4}},"w":32},9],"b":56,"c":{"a":{"n":{"t":149},"p":[{"e":{"r":267}},0],"v":6,"t":{"o":{"l":208}}},"e":{"d":21,"i":18,"s":21},"h":[{"o":21,"i":{"t":{"z":21}},"r":{"o":{"d":{"i":{"n":{"g":293}}}}}},8],"i":{"e":68,"n":{"d":150},"u":{"t":{"t":294}}},"l":{"e":6,"i":21},"o":{"f":17,"p":{"y":18},"u":{"r":{"a":7}}},"u":29,"r":{"a":{"p":{"e":{"r":{".":36}}}}},"y":{"t":{"h":247}}},"d":56,"e":{".":18,"a":[{"s":17,"w":5},1],"c":{"o":151,"t":27},"d":[{"e":95,"l":19},125],"g":[{"r":11},9],"i":32,"l":{"e":2,"f":32,"v":32},"m":{"e":[{"s":{"t":295}},18],"o":{"l":1},"a":{"p":{"h":287}},"i":{"t":{"i":{"c":296}}}},"n":{"a":{"t":5},"c":18,"d":0,"e":{"d":19},"g":5,"i":{"n":19},"t":{"d":18,"l":18}},"p":{"a":152,"t":{"e":{"m":{"b":11}}}},"r":{".":43,"l":21,"o":0,"v":{"o":18}},"s":[{"h":4,"t":5},72],"u":{"m":113},"v":[{"e":{"n":11}},32],"w":{"i":0},"x":32},"f":47,"g":48,"h":[{".":25,"e":{"r":2,"v":32},"i":{"n":2,"o":3,"p":27,"v":6},"o":[{"l":{"d":4},"n":12,"r":[{"t":7},17],"e":{"s":{"t":137}}},0],"w":18},24],"i":{"b":2,"c":{"c":19},"d":{"e":{".":27,"s":[{"t":6,"w":6},32],"d":{".":8}},"i":[{"z":4},32]},"g":{"n":{"a":18}},"l":{"e":0,"y":18},"n":[{"a":24,"e":{".":32},"g":23},42],"o":[{"n":[{"a":6},32]},41],"r":[{"a":5,"e":{"s":{"i":{"d":4}}}},9],"s":41,"t":{"i":{"o":27}},"u":32,"v":41,"z":32},"k":[{"e":[{"t":23},18],"i":{"n":{"e":4,"g":4}},"y":{"s":{"c":15}}},9],"l":[{"a":{"t":23},"e":24,"i":{"t":{"h":7}},"o":{"v":{"a":{"k":{"i":{"a":297}}}}}},74],"m":[{"a":[{"l":{"l":54},"n":12},23],"e":{"l":17,"n":19},"i":{"t":{"h":32}},"o":{"l":{"d":49}}},42],"n":72,"o":[{"c":{"e":1},"f":{"t":12},"l":{"a":{"b":1},"d":153,"i":{"c":3},"v":32,"u":{"t":{"e":9}}},"m":27,"n":{".":68,"a":17,"g":0},"p":[{"h":{"i":{"c":32,"z":19},"y":19}},21],"r":{"c":5,"d":5},"v":[{"i":4},18],"g":{"a":{"m":{"y":298}}}},41],"p":{"a":[{"i":32,"n":0,"c":{"e":299,"i":{"n":69}}},25],"e":{"n":{"d":17},"o":57,"r":25,"c":{"i":{"o":11}}},"h":{"e":[{"r":[{"o":213},27]},24],"o":6},"i":{"l":17,"n":{"g":4},"o":18,"c":{"i":{"l":208}}},"l":{"y":21},"o":{"n":21,"r":[{"t":{"s":{"c":300,"w":300}}},17],"t":18,"k":{"e":{"s":{"w":10}}}}},"q":{"u":{"a":{"l":{"l":36}},"i":{"t":{"o":88}}}},"r":29,"s":[{"a":[{"s":12,"c":{"h":{"u":301}}},29],"c":94,"e":{"l":23,"n":{"g":19},"s":{".":21},"t":19},"i":[{"e":[{"r":0},21],"l":{"y":4},"a":{"n":{".":210}},"g":{"n":{"a":{"b":302}}}},29],"l":[{"i":1},21],"n":21,"p":{"e":{"n":{"d":115}}},"t":9,"u":{"r":{"a":6}},"w":4,"h":{"a":{"t":3}}},25],"t":{".":25,"a":{"g":24,"l":24,"m":{"i":17,"p":69},"n":{"d":32,"t":{"s":{"h":{"i":303}}}},"p":90,"t":{".":32,"i":15},"r":{"t":{"l":{"i":12}}}},"e":{"d":21,"r":{"n":{"i":7},"o":19},"w":[{"a":6},8]},"h":{"e":23},"i":[{".":21,"a":19,"c":[{"k":32},29],"e":21,"f":23,"n":{"g":3},"r":32},9],"l":{"e":29},"o":{"c":{"k":32},"m":{"a":12},"n":{"e":32},"p":21,"r":{"e":27,"a":{"b":304}}},"r":[{"a":{"d":21,"t":{"u":32,"a":{"g":305}},"y":21},"i":{"d":21,"b":{"u":{"t":7}}},"y":18},1],"w":61,"y":[{"l":{"i":{"s":137}}},24],"b":4,"s":{"c":{"r":4}},"u":{"p":{"i":{"d":306}}}},"u":[{"a":{"l":2},"b":111,"g":151,"i":{"s":4,"t":12},"l":21,"m":[{"i":11},9],"n":9,"r":9,"p":{"e":{"r":{"e":307}}}},41],"v":18,"w":[{"o":18,"i":{"m":{"m":177}}},9],"y":[{"c":18,"l":27,"n":{"o":5,"c":41},"r":{"i":{"n":4}},"t":{"h":{"i":308}}},21]},"t":{"a":[{".":27,"b":[{"l":{"e":{"s":4}},"o":{"l":{"i":{"z":32,"s":{"m":309}}}}},25],"c":{"i":18},"d":{"o":4},"f":46,"i":{"l":{"o":5}},"l":[{"a":4,"e":{"n":5},"i":11,"k":[{"a":204},18],"l":{"i":{"s":0}},"o":{"g":4}},9],"m":{"o":4,"i":{"n":82}},"n":{"d":{"e":0},"t":{"a":54}},"p":{"e":{"r":4},"l":4,"a":{"t":{"h":310}}},"r":{"a":0,"c":18,"e":18,"i":{"z":3},"r":{"h":311}},"s":{"e":0,"y":4},"t":{"i":{"c":18},"u":{"r":1}},"u":{"n":17},"v":0,"w":25,"x":{"i":{"s":0}},"g":{"o":{"n":{".":3}}}},41],"b":42,"c":[{"h":[{"e":{"t":5},"c":15,"i":{"e":{"r":237}}},21],"r":29},18],"d":43,"e":{".":18,"a":{"d":{"i":17},"t":18,"c":{"h":{"e":{"r":{".":36}}}}},"c":{"e":17,"t":32},"d":[{"i":4},42],"e":41,"g":[{"e":{"r":4},"i":4},0],"l":{".":27,"i":17,"s":32,"e":{"g":84,"r":{"o":249}}},"m":{"a":[{"t":11},154]},"n":{"a":{"n":27},"c":27,"d":27,"e":{"s":18},"t":[{"a":{"g":0}},41]},"o":41,"p":[{"e":4},1],"r":{"c":11,"d":155,"i":[{"e":{"s":5},"s":11,"z":{"a":6},"c":{".":8}},41],"n":{"i":{"t":32}},"v":5,"g":{"e":{"i":312}}},"s":{".":18,"s":[{".":23,"e":{"s":313}},18]},"t":{"h":{"e":6}},"u":27,"x":27,"y":18},"f":42,"g":43,"h":{".":25,"a":{"n":17,"l":{"a":{"m":228}}},"e":[{"a":[{"s":3,"t":5},18],"i":{"s":11},"t":27},9],"i":{"c":{".":4,"a":4},"l":18,"n":{"k":32}},"l":18,"o":{"d":{"e":4,"i":{"c":32},"o":{"n":11}},"o":18,"r":{"i":{"t":6,"z":5}},"g":{"e":{"n":{"i":314}}},"k":{"e":{"r":175}}},"s":25,"y":{"l":{"a":{"n":228}},"s":{"c":11}}},"i":{"a":[{"b":1,"t":{"o":1},"n":{".":70}},41],"b":156,"c":{"k":18,"o":21,"u":157},"d":{"i":32},"e":{"n":27},"f":[{"y":4},8],"g":[{"u":32},25],"l":{"l":{"i":{"n":6}}},"m":[{"p":18,"u":{"l":5}},41],"n":[{"a":24,"e":{".":27},"i":27,"o":{"m":285}},42],"o":[{"c":4,"n":{"e":{"e":6}}},41],"q":32,"s":{"a":3,"e":27,"m":0,"o":4,"p":0,"t":{"i":{"c":{"a":32}}}},"t":{"l":3},"u":1,"v":[{"a":0},41],"z":[{"a":3,"e":{"n":3}},41]},"l":[{"a":[{"n":17},19],"e":{".":27,"d":27,"s":{".":27},"t":{".":19}},"o":19,"i":{"e":{"r":315}}},25],"m":[{"e":0},43],"n":81,"o":[{"b":3,"c":{"r":{"a":{"t":4}}},"d":{"o":18},"f":25,"g":{"r":9},"i":{"c":4},"m":{"a":9,"b":0,"y":3},"n":{"a":{"l":{"i":0},"t":3},"o":18,"y":18},"r":{"a":9,"i":{"e":3,"z":5}},"s":8,"u":{"r":32,"t":18},"w":{"a":{"r":3}},"l":{"o":{"g":{"y":84}}},"t":{"i":{"c":11}}},41],"p":43,"r":{"a":[{"b":11,"c":{"h":5,"i":[{"t":17},36],"t":{"e":17}},"s":17,"v":{"e":{"n":5,"s":158,"r":{"s":[{"a":{"b":317}},15]}}},"i":{"t":{"o":{"r":316}}}},41],"e":{"f":5,"m":[{"i":6},0],"a":{"c":{"h":{"e":318}}}},"i":{"a":[{"l":{".":1}},32],"c":{"e":{"s":5},"i":{"a":32},"s":18},"m":25,"v":0},"o":{"m":{"i":5},"n":{"i":6,"y":18},"p":{"h":{"e":5},"i":{"s":175},"o":{"l":{"e":{"s":320},"i":{"s":320,"t":321}}}},"s":{"p":11},"v":11,"l":{"e":{"u":{"m":319}}},"f":{"i":{"c":{".":17},"t":11}}},"u":{"i":5,"s":17}},"s":[{"c":[{"h":{"i":{"e":12}}},21],"h":0,"w":21},101],"t":[{"e":{"s":21},"o":19,"u":0,"r":{"i":{"b":{"u":{"t":322}}}}},66],"u":[{"a":[{"r":3},2],"b":{"i":1},"d":8,"e":18,"f":46,"i":76,"m":27,"n":{"i":{"s":1}},"p":{".":48},"r":{"e":27,"i":[{"s":11},32],"o":5,"y":4,"n":{"a":{"r":12}}},"s":27},41],"v":18,"w":[{"a":43,"i":{"s":17},"o":18,"h":29},1],"y":[{"a":18,"l":25,"p":{"e":12,"h":4,"a":{"l":64}}},41],"z":[{"e":1},18]},"u":{"a":{"b":18,"c":0,"n":{"a":4,"i":0},"r":{"a":{"n":{"t":5}},"d":8,"i":11,"t":11},"t":29,"v":0,"d":{"r":{"a":{"t":{"i":3,"u":15}}}}},"b":{"e":[{"l":21,"r":[{"o":21},23]},1],"i":[{"n":{"g":33}},72],"l":{"e":{".":23}}},"c":{"a":23,"i":{"b":0,"t":1},"l":{"e":12},"r":23,"u":23,"y":21},"d":{"d":4,"e":{"r":3,"s":{"t":4},"v":17},"i":{"c":29,"e":{"d":3,"s":3},"s":4,"t":19},"o":{"n":[{"y":232},21]},"s":{"i":1},"u":21},"e":{"n":{"e":21,"s":17,"t":{"e":0}},"r":{"i":{"l":0}},"a":{"m":15}},"f":{"a":27,"l":23},"g":{"h":{"e":{"n":11}},"i":{"n":4}},"i":[{"l":{"i":{"z":5}},"n":[{"g":29},1],"r":{"m":0},"t":{"a":17},"v":[{"e":{"r":{".":0}}},11]},156],"j":19,"k":18,"l":{"a":[{"b":5,"t":{"i":19}},29],"c":{"h":[{"e":32},17]},"d":{"e":{"r":3}},"e":[{"n":29},1],"g":{"i":1},"i":[{"a":19,"n":{"g":3},"s":{"h":4}},9],"l":{"a":{"r":1},"i":{"b":96,"s":1}},"m":61,"o":72,"s":[{"e":{"s":5}},18],"t":{"i":2,"r":{"a":54},"u":18},"u":[{"l":4},23],"v":4},"m":{"a":{"b":4},"b":{"i":1,"l":{"y":1}},"i":[{"n":{"g":83}},29],"o":{"r":{"o":6}},"p":9},"n":{"a":{"t":17},"e":[{"r":1},24],"i":[{"m":1,"n":24,"s":{"h":4},"v":11},29],"s":[{"w":1},93],"t":{"a":{"b":11},"e":{"r":{".":1},"s":1}},"u":0,"y":4,"z":4},"o":{"r":{"s":21},"s":19,"u":29},"p":{"e":[{"r":{"s":6}},29],"i":{"a":19,"n":{"g":3}},"l":23,"p":[{"o":{"r":{"t":10}}},3],"t":{"i":{"b":5},"u":17}},"r":{"a":[{".":18,"g":21,"s":21,"l":{".":216}},29],"b":{"e":1},"c":0,"d":2,"e":{"a":{"t":5}},"f":{"e":{"r":1},"r":1},"i":{"f":[{"i":{"c":0}},23],"n":2,"o":23,"t":29,"z":3,"a":{"l":{".":0}}},"l":[{"i":{"n":{"g":{".":5}}}},9],"n":{"o":1},"o":{"s":17},"p":{"e":1,"i":1},"s":{"e":{"r":5}},"t":{"e":{"s":4},"h":{"e":3},"i":[{"e":1},17]},"u":23},"s":[{"a":{"d":19,"n":19,"p":1},"c":[{"i":3},8],"e":{"a":5,"r":{".":9}},"i":{"a":19,"c":23},"l":{"i":{"n":1}},"p":2,"s":{"l":4},"t":{"e":{"r":{"e":4}},"r":2},"u":[{"r":17},24]},25],"t":{"a":{"b":0,"t":23},"e":{".":18,"l":18,"n":[{"i":17},18]},"i":[{"l":{"i":{"z":5}},"n":{"e":23,"g":3},"o":{"n":{"a":7}},"s":21,"z":31},101],"l":34,"o":{"f":4,"g":5,"m":{"a":{"t":{"i":{"c":5}}}},"n":19,"u":21},"s":0},"u":[{"m":1},23],"v":74,"x":{"u":11},"z":{"e":1}},"v":{"a":[{".":32,"b":159,"c":{"i":{"l":5},"u":11},"g":[{"e":1,"u":{"e":{"r":170}}},0],"l":{"i":{"e":4},"o":5,"u":15},"m":{"o":4},"n":{"i":{"z":4}},"p":{"i":4},"r":{"i":{"e":{"d":5}}},"t":[{"i":{"v":29}},27],"u":{"d":{"e":{"v":54}}}},41],"e":{".":18,"d":18,"g":11,"l":{".":23,"l":{"i":11},"o":1,"y":21},"n":{"o":{"m":11},"u":{"e":19}},"r":{"d":21,"e":{".":32,"l":[{"y":{".":41}},21],"n":[{"c":5},23],"s":21,"i":{"g":324}},"i":{"e":11},"m":{"i":{"n":36}},"s":{"e":27},"t":{"h":11}},"s":[{".":18,"t":{"e":0,"i":{"t":{"e":15}}}},99],"t":{"e":[{"r":11},1],"y":1}},"i":{"a":{"l":{"i":4},"n":32},"d":{"e":{".":32,"d":32,"n":47,"s":32},"i":32},"f":23,"g":{"n":4},"k":0,"l":[{"i":{"t":32,"z":127}},25],"n":[{"a":26,"c":24,"d":5,"g":18},29],"o":{"l":11,"r":73,"u":2},"p":1,"r":{"o":4},"s":{"i":{"t":11},"o":3,"u":3},"t":{"i":18,"r":11,"y":18},"v":[{"i":{"p":{"a":{"r":325}}}},27]},"o":{".":32,"i":[{"r":{"d":{"u":323}},"c":{"e":{"p":213}}},0],"k":27,"l":{"a":1,"e":19,"t":32,"v":27},"m":{"i":5},"r":{"a":{"b":5},"i":17,"y":1},"t":{"a":1,"e":{"e":18}}},"v":26,"y":21},"w":{"a":{"b":{"l":19},"c":25,"g":{"e":{"r":4},"o":5},"i":{"t":6},"l":{".":19},"m":0,"r":{"t":0},"s":{"t":[{"e":{"w":{"a":326}}},0]},"t":{"e":2},"v":{"e":{"r":4,"g":327}}},"b":29,"e":{"a":{"r":{"i":{"e":5}},"t":{"h":54}},"d":{"n":0},"e":{"t":12,"v":5,"k":{"n":137}},"l":{"l":0},"r":29,"s":{"t":12},"v":23},"h":{"i":0},"i":[{"l":[{"l":{"i":{"n":6}}},8],"n":{"d":{"e":0},"g":0},"r":0,"s":{"e":27},"t":{"h":12},"z":5,"d":{"e":{"s":{"p":6}}}},9],"k":21,"l":{"e":{"s":1},"i":{"n":3}},"n":{"o":21},"o":[{"m":15,"v":{"e":{"n":4}},"k":{"e":{"n":85}}},160],"p":19,"r":{"a":[{"p":{"a":{"r":{"o":12}}}},0],"i":[{"t":{"a":36,"e":{"r":{".":183}}}},0]},"s":{"h":23,"l":1,"p":{"e":1},"t":60},"t":18,"y":1,"c":23},"x":{"a":[{"c":{"e":5},"g":{"o":21},"m":11,"p":21,"s":5},29],"c":161,"e":[{"c":{"u":{"t":{"o":1}}},"d":24,"r":{"i":0,"o":4}},29],"h":[{"i":[{"l":6},8],"u":0},29],"i":[{"a":4,"c":4,"d":{"i":4},"m":{"e":21,"i":{"z":4}}},23],"o":[{"b":21},23],"p":[{"a":{"n":{"d":17}},"e":{"c":{"t":{"o":10}},"d":11}},23],"t":[{"i":23},74],"u":[{"a":3},29],"x":1,"q":[{"u":{"i":{"s":54}}},29]},"y":{"a":{"c":19,"r":110,"t":19},"b":29,"c":[{"e":[{"r":4},24],"h":[{"e":[{"d":264},0]},23],"o":{"m":17,"t":17}},29],"d":29,"e":{"e":19,"r":[{"f":21},29],"s":[{"t":{"e":{"r":{"y":328}}}},0],"t":1},"g":{"i":19},"h":47,"i":29,"l":{"a":23,"l":{"a":{"b":{"l":6}}},"o":23,"u":19},"m":{"b":{"o":{"l":7}},"e":[{"t":{"r":{"y":20}}},0],"p":{"a":12}},"n":{"c":{"h":{"r":3}},"d":4,"g":4,"i":{"c":4},"x":32},"o":[{"d":4,"g":33,"m":0,"n":{"e":{"t":4},"s":21},"s":21},72],"p":{"e":{"d":21,"r":6},"i":3,"o":[{"c":21},23],"t":{"a":9},"u":19},"r":{"a":{"m":5},"i":{"a":4},"o":23,"r":1},"s":{"c":1,"e":161,"i":{"c":{"a":3},"o":3,"s":27},"o":21,"s":0,"t":[{"a":3,"r":{"o":29}},2],"u":{"r":17}},"t":{"h":{"i":{"n":23}},"i":{"c":3}},"w":29},"z":{"a":[{"b":79,"r":8},2],"b":18,"e":[{"n":1,"p":1,"r":[{"o":3},29],"t":0},25],"i":[{"l":21,"s":21,"a":{"n":{".":23}}},42],"l":32,"m":18,"o":[{"m":1,"o":{"l":4},"p":{"h":{"r":329}}},41],"t":{"e":0},"z":[{"y":21,"w":231},101]}}',
        [
          "as-so-ciate",
          "as-so-ciates",
          "dec-li-na-tion",
          "oblig-a-tory",
          "phil-an-thropic",
          "present",
          "presents",
          "project",
          "projects",
          "reci-procity",
          "re-cog-ni-zance",
          "ref-or-ma-tion",
          "ret-ri-bu-tion",
          "ta-ble"
        ]
      ];
    });
  }
});

// ../../node_modules/.pnpm/scheduler@0.25.0-rc-603e6108-20241029/node_modules/scheduler/cjs/scheduler.production.js
var require_scheduler_production = __commonJS({
  "../../node_modules/.pnpm/scheduler@0.25.0-rc-603e6108-20241029/node_modules/scheduler/cjs/scheduler.production.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function push(heap, node) {
      var index2 = heap.length;
      heap.push(node);
      a: for (; 0 < index2; ) {
        var parentIndex = index2 - 1 >>> 1, parent = heap[parentIndex];
        if (0 < compare9(parent, node))
          heap[parentIndex] = node, heap[index2] = parent, index2 = parentIndex;
        else break a;
      }
    }
    __name(push, "push");
    function peek(heap) {
      return 0 === heap.length ? null : heap[0];
    }
    __name(peek, "peek");
    function pop(heap) {
      if (0 === heap.length) return null;
      var first = heap[0], last2 = heap.pop();
      if (last2 !== first) {
        heap[0] = last2;
        a: for (var index2 = 0, length2 = heap.length, halfLength = length2 >>> 1; index2 < halfLength; ) {
          var leftIndex = 2 * (index2 + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
          if (0 > compare9(left, last2))
            rightIndex < length2 && 0 > compare9(right, left) ? (heap[index2] = right, heap[rightIndex] = last2, index2 = rightIndex) : (heap[index2] = left, heap[leftIndex] = last2, index2 = leftIndex);
          else if (rightIndex < length2 && 0 > compare9(right, last2))
            heap[index2] = right, heap[rightIndex] = last2, index2 = rightIndex;
          else break a;
        }
      }
      return first;
    }
    __name(pop, "pop");
    function compare9(a4, b3) {
      var diff = a4.sortIndex - b3.sortIndex;
      return 0 !== diff ? diff : a4.id - b3.id;
    }
    __name(compare9, "compare");
    exports.unstable_now = void 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
      localPerformance = performance;
      exports.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      localDate = Date, initialTime = localDate.now();
      exports.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    var localPerformance;
    var localDate;
    var initialTime;
    var taskQueue = [];
    var timerQueue = [];
    var taskIdCounter = 1;
    var currentTask = null;
    var currentPriorityLevel = 3;
    var isPerformingWork = false;
    var isHostCallbackScheduled = false;
    var isHostTimeoutScheduled = false;
    var localSetTimeout = "function" === typeof setTimeout ? setTimeout : null;
    var localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null;
    var localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); null !== timer; ) {
        if (null === timer.callback) pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
        else break;
        timer = peek(timerQueue);
      }
    }
    __name(advanceTimers, "advanceTimers");
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (null !== peek(taskQueue))
          isHostCallbackScheduled = true, requestHostCallback();
        else {
          var firstTimer = peek(timerQueue);
          null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    __name(handleTimeout, "handleTimeout");
    var isMessageLoopRunning = false;
    var taskTimeoutID = -1;
    var frameInterval = 5;
    var startTime3 = -1;
    function shouldYieldToHost() {
      return exports.unstable_now() - startTime3 < frameInterval ? false : true;
    }
    __name(shouldYieldToHost, "shouldYieldToHost");
    function performWorkUntilDeadline() {
      if (isMessageLoopRunning) {
        var currentTime = exports.unstable_now();
        startTime3 = currentTime;
        var hasMoreWork = true;
        try {
          a: {
            isHostCallbackScheduled = false;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                  var callback = currentTask.callback;
                  if ("function" === typeof callback) {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(
                      currentTask.expirationTime <= currentTime
                    );
                    currentTime = exports.unstable_now();
                    if ("function" === typeof continuationCallback) {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = true;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (null !== currentTask) hasMoreWork = true;
                else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer && requestHostTimeout(
                    handleTimeout,
                    firstTimer.startTime - currentTime
                  );
                  hasMoreWork = false;
                }
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
            }
            hasMoreWork = void 0;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
        }
      }
    }
    __name(performWorkUntilDeadline, "performWorkUntilDeadline");
    var schedulePerformWorkUntilDeadline;
    if ("function" === typeof localSetImmediate)
      schedulePerformWorkUntilDeadline = /* @__PURE__ */ __name(function() {
        localSetImmediate(performWorkUntilDeadline);
      }, "schedulePerformWorkUntilDeadline");
    else if ("undefined" !== typeof MessageChannel) {
      channel2 = new MessageChannel(), port = channel2.port2;
      channel2.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = /* @__PURE__ */ __name(function() {
        port.postMessage(null);
      }, "schedulePerformWorkUntilDeadline");
    } else
      schedulePerformWorkUntilDeadline = /* @__PURE__ */ __name(function() {
        localSetTimeout(performWorkUntilDeadline, 0);
      }, "schedulePerformWorkUntilDeadline");
    var channel2;
    var port;
    function requestHostCallback() {
      isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
    }
    __name(requestHostCallback, "requestHostCallback");
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports.unstable_now());
      }, ms);
    }
    __name(requestHostTimeout, "requestHostTimeout");
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports.unstable_continueExecution = function() {
      isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, requestHostCallback());
    };
    exports.unstable_forceFrameRate = function(fps) {
      0 > fps || 125 < fps ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return peek(taskQueue);
    };
    exports.unstable_next = function(eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
      var currentTime = exports.unstable_now();
      "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5e3;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, requestHostCallback()));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
  }
});

// ../../node_modules/.pnpm/scheduler@0.25.0-rc-603e6108-20241029/node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "../../node_modules/.pnpm/scheduler@0.25.0-rc-603e6108-20241029/node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (true) {
      module.exports = require_scheduler_production();
    } else {
      module.exports = null;
    }
  }
});

// ../../node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "../../node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty3 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    __name(toObject, "toObject");
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n5) {
          return test2[n5];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err2) {
        return false;
      }
    }
    __name(shouldUseNative, "shouldUseNative");
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from4;
      var to = toObject(target);
      var symbols;
      for (var s4 = 1; s4 < arguments.length; s4++) {
        from4 = Object(arguments[s4]);
        for (var key in from4) {
          if (hasOwnProperty3.call(from4, key)) {
            to[key] = from4[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from4);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from4, symbols[i2])) {
              to[symbols[i2]] = from4[symbols[i2]];
            }
          }
        }
      }
      return to;
    };
  }
});

// ../../node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react-jsx-runtime.production.js
var require_react_jsx_runtime_production = __commonJS({
  "../../node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react-jsx-runtime.production.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    function jsxProd(type2, config4, maybeKey) {
      var key = null;
      void 0 !== maybeKey && (key = "" + maybeKey);
      void 0 !== config4.key && (key = "" + config4.key);
      if ("key" in config4) {
        maybeKey = {};
        for (var propName in config4)
          "key" !== propName && (maybeKey[propName] = config4[propName]);
      } else maybeKey = config4;
      config4 = maybeKey.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type2,
        key,
        ref: void 0 !== config4 ? config4 : null,
        props: maybeKey
      };
    }
    __name(jsxProd, "jsxProd");
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = jsxProd;
    exports.jsxs = jsxProd;
  }
});

// ../../node_modules/.pnpm/react@19.2.0/node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "../../node_modules/.pnpm/react@19.2.0/node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (true) {
      module.exports = require_react_jsx_runtime_production();
    } else {
      module.exports = null;
    }
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/can-promise.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/utils.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = /* @__PURE__ */ __name(function getSymbolSize(version6) {
      if (!version6) throw new Error('"version" cannot be null or undefined');
      if (version6 < 1 || version6 > 40) throw new Error('"version" should be in range from 1 to 40');
      return version6 * 4 + 17;
    }, "getSymbolSize");
    exports.getSymbolTotalCodewords = /* @__PURE__ */ __name(function getSymbolTotalCodewords(version6) {
      return CODEWORDS_COUNT[version6];
    }, "getSymbolTotalCodewords");
    exports.getBCHDigit = function(data2) {
      let digit = 0;
      while (data2 !== 0) {
        digit++;
        data2 >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = /* @__PURE__ */ __name(function setToSJISFunction(f4) {
      if (typeof f4 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f4;
    }, "setToSJISFunction");
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = /* @__PURE__ */ __name(function toSJIS(kanji) {
      return toSJISFunction(kanji);
    }, "toSJIS");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString4(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    __name(fromString4, "fromString");
    exports.isValid = /* @__PURE__ */ __name(function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    }, "isValid");
    exports.from = /* @__PURE__ */ __name(function from4(value2, defaultValue) {
      if (exports.isValid(value2)) {
        return value2;
      }
      try {
        return fromString4(value2);
      } catch (e4) {
        return defaultValue;
      }
    }, "from");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    __name(BitBuffer, "BitBuffer");
    BitBuffer.prototype = {
      get: /* @__PURE__ */ __name(function(index2) {
        const bufIndex = Math.floor(index2 / 8);
        return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
      }, "get"),
      put: /* @__PURE__ */ __name(function(num, length2) {
        for (let i2 = 0; i2 < length2; i2++) {
          this.putBit((num >>> length2 - i2 - 1 & 1) === 1);
        }
      }, "put"),
      getLengthInBits: /* @__PURE__ */ __name(function() {
        return this.length;
      }, "getLengthInBits"),
      putBit: /* @__PURE__ */ __name(function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }, "putBit")
    };
    module.exports = BitBuffer;
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }
    __name(BitMatrix, "BitMatrix");
    BitMatrix.prototype.set = function(row, col, value2, reserved) {
      const index2 = row * this.size + col;
      this.data[index2] = value2;
      if (reserved) this.reservedBit[index2] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value2) {
      this.data[row * this.size + col] ^= value2;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getSymbolSize = require_utils().getSymbolSize;
    exports.getRowColCoords = /* @__PURE__ */ __name(function getRowColCoords(version6) {
      if (version6 === 1) return [];
      const posCount = Math.floor(version6 / 7) + 2;
      const size = getSymbolSize(version6);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7];
      for (let i2 = 1; i2 < posCount - 1; i2++) {
        positions[i2] = positions[i2 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    }, "getRowColCoords");
    exports.getPositions = /* @__PURE__ */ __name(function getPositions(version6) {
      const coords = [];
      const pos = exports.getRowColCoords(version6);
      const posLength = pos.length;
      for (let i2 = 0; i2 < posLength; i2++) {
        for (let j = 0; j < posLength; j++) {
          if (i2 === 0 && j === 0 || // top-left
          i2 === 0 && j === posLength - 1 || // bottom-left
          i2 === posLength - 1 && j === 0) {
            continue;
          }
          coords.push([pos[i2], pos[j]]);
        }
      }
      return coords;
    }, "getPositions");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getSymbolSize = require_utils().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = /* @__PURE__ */ __name(function getPositions(version6) {
      const size = getSymbolSize(version6);
      return [
        // top-left
        [0, 0],
        // top-right
        [size - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size - FINDER_PATTERN_SIZE]
      ];
    }, "getPositions");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = /* @__PURE__ */ __name(function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    }, "isValid");
    exports.from = /* @__PURE__ */ __name(function from4(value2) {
      return exports.isValid(value2) ? parseInt(value2, 10) : void 0;
    }, "from");
    exports.getPenaltyN1 = /* @__PURE__ */ __name(function getPenaltyN1(data2) {
      const size = data2.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size; col++) {
          let module2 = data2.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data2.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    }, "getPenaltyN1");
    exports.getPenaltyN2 = /* @__PURE__ */ __name(function getPenaltyN2(data2) {
      const size = data2.size;
      let points = 0;
      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last2 = data2.get(row, col) + data2.get(row, col + 1) + data2.get(row + 1, col) + data2.get(row + 1, col + 1);
          if (last2 === 4 || last2 === 0) points++;
        }
      }
      return points * PenaltyScores.N2;
    }, "getPenaltyN2");
    exports.getPenaltyN3 = /* @__PURE__ */ __name(function getPenaltyN3(data2) {
      const size = data2.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data2.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
          bitsRow = bitsRow << 1 & 2047 | data2.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
        }
      }
      return points * PenaltyScores.N3;
    }, "getPenaltyN3");
    exports.getPenaltyN4 = /* @__PURE__ */ __name(function getPenaltyN4(data2) {
      let darkCount = 0;
      const modulesCount = data2.data.length;
      for (let i2 = 0; i2 < modulesCount; i2++) darkCount += data2.data[i2];
      const k3 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k3 * PenaltyScores.N4;
    }, "getPenaltyN4");
    function getMaskAt(maskPattern, i2, j) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i2 + j) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i2 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i2 + j) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i2 / 2) + Math.floor(j / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i2 * j % 2 + i2 * j % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i2 * j % 2 + i2 * j % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i2 * j % 3 + (i2 + j) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    __name(getMaskAt, "getMaskAt");
    exports.applyMask = /* @__PURE__ */ __name(function applyMask(pattern3, data2) {
      const size = data2.size;
      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data2.isReserved(row, col)) continue;
          data2.xor(row, col, getMaskAt(pattern3, row, col));
        }
      }
    }, "applyMask");
    exports.getBestMask = /* @__PURE__ */ __name(function getBestMask(data2, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p3 = 0; p3 < numPatterns; p3++) {
        setupFormatFunc(p3);
        exports.applyMask(p3, data2);
        const penalty = exports.getPenaltyN1(data2) + exports.getPenaltyN2(data2) + exports.getPenaltyN3(data2) + exports.getPenaltyN4(data2);
        exports.applyMask(p3, data2);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p3;
        }
      }
      return bestPattern;
    }, "getBestMask");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = /* @__PURE__ */ __name(function getBlocksCount(version6, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version6 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version6 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version6 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version6 - 1) * 4 + 3];
        default:
          return void 0;
      }
    }, "getBlocksCount");
    exports.getTotalCodewordsCount = /* @__PURE__ */ __name(function getTotalCodewordsCount(version6, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version6 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version6 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version6 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version6 - 1) * 4 + 3];
        default:
          return void 0;
      }
    }, "getTotalCodewordsCount");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/galois-field.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (/* @__PURE__ */ __name(function initTables() {
      let x = 1;
      for (let i2 = 0; i2 < 255; i2++) {
        EXP_TABLE[i2] = x;
        LOG_TABLE[x] = i2;
        x <<= 1;
        if (x & 256) {
          x ^= 285;
        }
      }
      for (let i2 = 255; i2 < 512; i2++) {
        EXP_TABLE[i2] = EXP_TABLE[i2 - 255];
      }
    }, "initTables"))();
    exports.log = /* @__PURE__ */ __name(function log5(n5) {
      if (n5 < 1) throw new Error("log(" + n5 + ")");
      return LOG_TABLE[n5];
    }, "log");
    exports.exp = /* @__PURE__ */ __name(function exp(n5) {
      return EXP_TABLE[n5];
    }, "exp");
    exports.mul = /* @__PURE__ */ __name(function mul(x, y3) {
      if (x === 0 || y3 === 0) return 0;
      return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y3]];
    }, "mul");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/polynomial.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var GF = require_galois_field();
    exports.mul = /* @__PURE__ */ __name(function mul(p1, p22) {
      const coeff = new Uint8Array(p1.length + p22.length - 1);
      for (let i2 = 0; i2 < p1.length; i2++) {
        for (let j = 0; j < p22.length; j++) {
          coeff[i2 + j] ^= GF.mul(p1[i2], p22[j]);
        }
      }
      return coeff;
    }, "mul");
    exports.mod = /* @__PURE__ */ __name(function mod(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i2 = 0; i2 < divisor.length; i2++) {
          result[i2] ^= GF.mul(divisor[i2], coeff);
        }
        let offset2 = 0;
        while (offset2 < result.length && result[offset2] === 0) offset2++;
        result = result.slice(offset2);
      }
      return result;
    }, "mod");
    exports.generateECPolynomial = /* @__PURE__ */ __name(function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i2 = 0; i2 < degree; i2++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i2)]));
      }
      return poly;
    }, "generateECPolynomial");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree) this.initialize(this.degree);
    }
    __name(ReedSolomonEncoder, "ReedSolomonEncoder");
    ReedSolomonEncoder.prototype.initialize = /* @__PURE__ */ __name(function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    }, "initialize");
    ReedSolomonEncoder.prototype.encode = /* @__PURE__ */ __name(function encode(data2) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data2.length + this.degree);
      paddedData.set(data2);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start2 = this.degree - remainder.length;
      if (start2 > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start2);
        return buff;
      }
      return remainder;
    }, "encode");
    module.exports = ReedSolomonEncoder;
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version-check.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports.isValid = /* @__PURE__ */ __name(function isValid(version6) {
      return !isNaN(version6) && version6 >= 1 && version6 <= 40;
    }, "isValid");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/regex.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = /* @__PURE__ */ __name(function testKanji(str) {
      return TEST_KANJI.test(str);
    }, "testKanji");
    exports.testNumeric = /* @__PURE__ */ __name(function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    }, "testNumeric");
    exports.testAlphanumeric = /* @__PURE__ */ __name(function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    }, "testAlphanumeric");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mode.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = /* @__PURE__ */ __name(function getCharCountIndicator(mode, version6) {
      if (!mode.ccBits) throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version6)) {
        throw new Error("Invalid version: " + version6);
      }
      if (version6 >= 1 && version6 < 10) return mode.ccBits[0];
      else if (version6 < 27) return mode.ccBits[1];
      return mode.ccBits[2];
    }, "getCharCountIndicator");
    exports.getBestModeForData = /* @__PURE__ */ __name(function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr)) return exports.KANJI;
      else return exports.BYTE;
    }, "getBestModeForData");
    exports.toString = /* @__PURE__ */ __name(function toString7(mode) {
      if (mode && mode.id) return mode.id;
      throw new Error("Invalid mode");
    }, "toString");
    exports.isValid = /* @__PURE__ */ __name(function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    }, "isValid");
    function fromString4(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    __name(fromString4, "fromString");
    exports.from = /* @__PURE__ */ __name(function from4(value2, defaultValue) {
      if (exports.isValid(value2)) {
        return value2;
      }
      try {
        return fromString4(value2);
      } catch (e4) {
        return defaultValue;
      }
    }, "from");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Utils = require_utils();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length2, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    __name(getBestVersionForDataLength, "getBestVersionForDataLength");
    function getReservedBitsCount(mode, version6) {
      return Mode.getCharCountIndicator(mode, version6) + 4;
    }
    __name(getReservedBitsCount, "getReservedBitsCount");
    function getTotalBitsFromDataArray(segments, version6) {
      let totalBits = 0;
      segments.forEach(function(data2) {
        const reservedBits = getReservedBitsCount(data2.mode, version6);
        totalBits += reservedBits + data2.getBitsLength();
      });
      return totalBits;
    }
    __name(getTotalBitsFromDataArray, "getTotalBitsFromDataArray");
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length2 = getTotalBitsFromDataArray(segments, currentVersion);
        if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    __name(getBestVersionForMixedData, "getBestVersionForMixedData");
    exports.from = /* @__PURE__ */ __name(function from4(value2, defaultValue) {
      if (VersionCheck.isValid(value2)) {
        return parseInt(value2, 10);
      }
      return defaultValue;
    }, "from");
    exports.getCapacity = /* @__PURE__ */ __name(function getCapacity(version6, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version6)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined") mode = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version6);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version6, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED) return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version6);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    }, "getCapacity");
    exports.getBestVersionForData = /* @__PURE__ */ __name(function getBestVersionForData(data2, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data2)) {
        if (data2.length > 1) {
          return getBestVersionForMixedData(data2, ecl);
        }
        if (data2.length === 0) {
          return 1;
        }
        seg = data2[0];
      } else {
        seg = data2;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    }, "getBestVersionForData");
    exports.getEncodedBits = /* @__PURE__ */ __name(function getEncodedBits(version6) {
      if (!VersionCheck.isValid(version6) || version6 < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d3 = version6 << 12;
      while (Utils.getBCHDigit(d3) - G18_BCH >= 0) {
        d3 ^= G18 << Utils.getBCHDigit(d3) - G18_BCH;
      }
      return version6 << 12 | d3;
    }, "getEncodedBits");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/format-info.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Utils = require_utils();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = /* @__PURE__ */ __name(function getEncodedBits(errorCorrectionLevel, mask) {
      const data2 = errorCorrectionLevel.bit << 3 | mask;
      let d3 = data2 << 10;
      while (Utils.getBCHDigit(d3) - G15_BCH >= 0) {
        d3 ^= G15 << Utils.getBCHDigit(d3) - G15_BCH;
      }
      return (data2 << 10 | d3) ^ G15_MASK;
    }, "getEncodedBits");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Mode = require_mode();
    function NumericData(data2) {
      this.mode = Mode.NUMERIC;
      this.data = data2.toString();
    }
    __name(NumericData, "NumericData");
    NumericData.getBitsLength = /* @__PURE__ */ __name(function getBitsLength(length2) {
      return 10 * Math.floor(length2 / 3) + (length2 % 3 ? length2 % 3 * 3 + 1 : 0);
    }, "getBitsLength");
    NumericData.prototype.getLength = /* @__PURE__ */ __name(function getLength() {
      return this.data.length;
    }, "getLength");
    NumericData.prototype.getBitsLength = /* @__PURE__ */ __name(function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    }, "getBitsLength");
    NumericData.prototype.write = /* @__PURE__ */ __name(function write8(bitBuffer) {
      let i2, group3, value2;
      for (i2 = 0; i2 + 3 <= this.data.length; i2 += 3) {
        group3 = this.data.substr(i2, 3);
        value2 = parseInt(group3, 10);
        bitBuffer.put(value2, 10);
      }
      const remainingNum = this.data.length - i2;
      if (remainingNum > 0) {
        group3 = this.data.substr(i2);
        value2 = parseInt(group3, 10);
        bitBuffer.put(value2, remainingNum * 3 + 1);
      }
    }, "write");
    module.exports = NumericData;
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data2) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data2;
    }
    __name(AlphanumericData, "AlphanumericData");
    AlphanumericData.getBitsLength = /* @__PURE__ */ __name(function getBitsLength(length2) {
      return 11 * Math.floor(length2 / 2) + 6 * (length2 % 2);
    }, "getBitsLength");
    AlphanumericData.prototype.getLength = /* @__PURE__ */ __name(function getLength() {
      return this.data.length;
    }, "getLength");
    AlphanumericData.prototype.getBitsLength = /* @__PURE__ */ __name(function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    }, "getBitsLength");
    AlphanumericData.prototype.write = /* @__PURE__ */ __name(function write8(bitBuffer) {
      let i2;
      for (i2 = 0; i2 + 2 <= this.data.length; i2 += 2) {
        let value2 = ALPHA_NUM_CHARS.indexOf(this.data[i2]) * 45;
        value2 += ALPHA_NUM_CHARS.indexOf(this.data[i2 + 1]);
        bitBuffer.put(value2, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i2]), 6);
      }
    }, "write");
    module.exports = AlphanumericData;
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Mode = require_mode();
    function ByteData(data2) {
      this.mode = Mode.BYTE;
      if (typeof data2 === "string") {
        this.data = new TextEncoder().encode(data2);
      } else {
        this.data = new Uint8Array(data2);
      }
    }
    __name(ByteData, "ByteData");
    ByteData.getBitsLength = /* @__PURE__ */ __name(function getBitsLength(length2) {
      return length2 * 8;
    }, "getBitsLength");
    ByteData.prototype.getLength = /* @__PURE__ */ __name(function getLength() {
      return this.data.length;
    }, "getLength");
    ByteData.prototype.getBitsLength = /* @__PURE__ */ __name(function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    }, "getBitsLength");
    ByteData.prototype.write = function(bitBuffer) {
      for (let i2 = 0, l4 = this.data.length; i2 < l4; i2++) {
        bitBuffer.put(this.data[i2], 8);
      }
    };
    module.exports = ByteData;
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Mode = require_mode();
    var Utils = require_utils();
    function KanjiData(data2) {
      this.mode = Mode.KANJI;
      this.data = data2;
    }
    __name(KanjiData, "KanjiData");
    KanjiData.getBitsLength = /* @__PURE__ */ __name(function getBitsLength(length2) {
      return length2 * 13;
    }, "getBitsLength");
    KanjiData.prototype.getLength = /* @__PURE__ */ __name(function getLength() {
      return this.data.length;
    }, "getLength");
    KanjiData.prototype.getBitsLength = /* @__PURE__ */ __name(function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    }, "getBitsLength");
    KanjiData.prototype.write = function(bitBuffer) {
      let i2;
      for (i2 = 0; i2 < this.data.length; i2++) {
        let value2 = Utils.toSJIS(this.data[i2]);
        if (value2 >= 33088 && value2 <= 40956) {
          value2 -= 33088;
        } else if (value2 >= 57408 && value2 <= 60351) {
          value2 -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i2] + "\nMake sure your charset is UTF-8"
          );
        }
        value2 = (value2 >>> 8 & 255) * 192 + (value2 & 255);
        bitBuffer.put(value2, 13);
      }
    };
    module.exports = KanjiData;
  }
});

// ../../node_modules/.pnpm/dijkstrajs@1.0.3/node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "../../node_modules/.pnpm/dijkstrajs@1.0.3/node_modules/dijkstrajs/dijkstra.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var dijkstra = {
      single_source_shortest_paths: /* @__PURE__ */ __name(function(graph, s4, d3) {
        var predecessors = {};
        var costs = {};
        costs[s4] = 0;
        var open3 = dijkstra.PriorityQueue.make();
        open3.push(s4, 0);
        var closest, u4, v3, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open3.empty()) {
          closest = open3.pop();
          u4 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u4] || {};
          for (v3 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v3)) {
              cost_of_e = adjacent_nodes[v3];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v3];
              first_visit = typeof costs[v3] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v3] = cost_of_s_to_u_plus_cost_of_e;
                open3.push(v3, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v3] = u4;
              }
            }
          }
        }
        if (typeof d3 !== "undefined" && typeof costs[d3] === "undefined") {
          var msg2 = ["Could not find a path from ", s4, " to ", d3, "."].join("");
          throw new Error(msg2);
        }
        return predecessors;
      }, "single_source_shortest_paths"),
      extract_shortest_path_from_predecessor_list: /* @__PURE__ */ __name(function(predecessors, d3) {
        var nodes = [];
        var u4 = d3;
        var predecessor;
        while (u4) {
          nodes.push(u4);
          predecessor = predecessors[u4];
          u4 = predecessors[u4];
        }
        nodes.reverse();
        return nodes;
      }, "extract_shortest_path_from_predecessor_list"),
      find_path: /* @__PURE__ */ __name(function(graph, s4, d3) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s4, d3);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d3
        );
      }, "find_path"),
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: /* @__PURE__ */ __name(function(opts2) {
          var T = dijkstra.PriorityQueue, t4 = {}, key;
          opts2 = opts2 || {};
          for (key in T) {
            if (T.hasOwnProperty(key)) {
              t4[key] = T[key];
            }
          }
          t4.queue = [];
          t4.sorter = opts2.sorter || T.default_sorter;
          return t4;
        }, "make"),
        default_sorter: /* @__PURE__ */ __name(function(a4, b3) {
          return a4.cost - b3.cost;
        }, "default_sorter"),
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: /* @__PURE__ */ __name(function(value2, cost) {
          var item = { value: value2, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        }, "push"),
        /**
         * Return the highest priority element in the queue.
         */
        pop: /* @__PURE__ */ __name(function() {
          return this.queue.shift();
        }, "pop"),
        empty: /* @__PURE__ */ __name(function() {
          return this.queue.length === 0;
        }, "empty")
      }
    };
    if (typeof module !== "undefined") {
      module.exports = dijkstra;
    }
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/segments.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    __name(getStringByteLength, "getStringByteLength");
    function getSegments(regex4, mode, str) {
      const segments = [];
      let result;
      while ((result = regex4.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    __name(getSegments, "getSegments");
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s22) {
        return s1.index - s22.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    __name(getSegmentsFromString, "getSegmentsFromString");
    function getSegmentBitsLength(length2, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length2);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length2);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length2);
        case Mode.BYTE:
          return ByteData.getBitsLength(length2);
      }
    }
    __name(getSegmentBitsLength, "getSegmentBitsLength");
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    __name(mergeSegments, "mergeSegments");
    function buildNodes(segs) {
      const nodes = [];
      for (let i2 = 0; i2 < segs.length; i2++) {
        const seg = segs[i2];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    __name(buildNodes, "buildNodes");
    function buildGraph(nodes, version6) {
      const table3 = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const nodeGroup = nodes[i2];
        const currentNodeIds = [];
        for (let j = 0; j < nodeGroup.length; j++) {
          const node = nodeGroup[j];
          const key = "" + i2 + j;
          currentNodeIds.push(key);
          table3[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (let n5 = 0; n5 < prevNodeIds.length; n5++) {
            const prevNodeId = prevNodeIds[n5];
            if (table3[prevNodeId] && table3[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table3[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table3[prevNodeId].lastCount, node.mode);
              table3[prevNodeId].lastCount += node.length;
            } else {
              if (table3[prevNodeId]) table3[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version6);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n5 = 0; n5 < prevNodeIds.length; n5++) {
        graph[prevNodeIds[n5]].end = 0;
      }
      return { map: graph, table: table3 };
    }
    __name(buildGraph, "buildGraph");
    function buildSingleSegment(data2, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data2);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data2 + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data2);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data2);
        case Mode.KANJI:
          return new KanjiData(data2);
        case Mode.BYTE:
          return new ByteData(data2);
      }
    }
    __name(buildSingleSegment, "buildSingleSegment");
    exports.fromArray = /* @__PURE__ */ __name(function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    }, "fromArray");
    exports.fromString = /* @__PURE__ */ __name(function fromString4(data2, version6) {
      const segs = getSegmentsFromString(data2, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version6);
      const path = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i2 = 1; i2 < path.length - 1; i2++) {
        optimizedSegs.push(graph.table[path[i2]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    }, "fromString");
    exports.rawSplit = /* @__PURE__ */ __name(function rawSplit(data2) {
      return exports.fromArray(
        getSegmentsFromString(data2, Utils.isKanjiModeEnabled())
      );
    }, "rawSplit");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/qrcode.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Utils = require_utils();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    function setupFinderPattern(matrix, version6) {
      const size = matrix.size;
      const pos = FinderPattern.getPositions(version6);
      for (let i2 = 0; i2 < pos.length; i2++) {
        const row = pos[i2][0];
        const col = pos[i2][1];
        for (let r5 = -1; r5 <= 7; r5++) {
          if (row + r5 <= -1 || size <= row + r5) continue;
          for (let c2 = -1; c2 <= 7; c2++) {
            if (col + c2 <= -1 || size <= col + c2) continue;
            if (r5 >= 0 && r5 <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r5 === 0 || r5 === 6) || r5 >= 2 && r5 <= 4 && c2 >= 2 && c2 <= 4) {
              matrix.set(row + r5, col + c2, true, true);
            } else {
              matrix.set(row + r5, col + c2, false, true);
            }
          }
        }
      }
    }
    __name(setupFinderPattern, "setupFinderPattern");
    function setupTimingPattern(matrix) {
      const size = matrix.size;
      for (let r5 = 8; r5 < size - 8; r5++) {
        const value2 = r5 % 2 === 0;
        matrix.set(r5, 6, value2, true);
        matrix.set(6, r5, value2, true);
      }
    }
    __name(setupTimingPattern, "setupTimingPattern");
    function setupAlignmentPattern(matrix, version6) {
      const pos = AlignmentPattern.getPositions(version6);
      for (let i2 = 0; i2 < pos.length; i2++) {
        const row = pos[i2][0];
        const col = pos[i2][1];
        for (let r5 = -2; r5 <= 2; r5++) {
          for (let c2 = -2; c2 <= 2; c2++) {
            if (r5 === -2 || r5 === 2 || c2 === -2 || c2 === 2 || r5 === 0 && c2 === 0) {
              matrix.set(row + r5, col + c2, true, true);
            } else {
              matrix.set(row + r5, col + c2, false, true);
            }
          }
        }
      }
    }
    __name(setupAlignmentPattern, "setupAlignmentPattern");
    function setupVersionInfo(matrix, version6) {
      const size = matrix.size;
      const bits = Version.getEncodedBits(version6);
      let row, col, mod;
      for (let i2 = 0; i2 < 18; i2++) {
        row = Math.floor(i2 / 3);
        col = i2 % 3 + size - 8 - 3;
        mod = (bits >> i2 & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    __name(setupVersionInfo, "setupVersionInfo");
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i2, mod;
      for (i2 = 0; i2 < 15; i2++) {
        mod = (bits >> i2 & 1) === 1;
        if (i2 < 6) {
          matrix.set(i2, 8, mod, true);
        } else if (i2 < 8) {
          matrix.set(i2 + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i2, 8, mod, true);
        }
        if (i2 < 8) {
          matrix.set(8, size - i2 - 1, mod, true);
        } else if (i2 < 9) {
          matrix.set(8, 15 - i2 - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i2 - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    __name(setupFormatInfo, "setupFormatInfo");
    function setupData(matrix, data2) {
      const size = matrix.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6) col--;
        while (true) {
          for (let c2 = 0; c2 < 2; c2++) {
            if (!matrix.isReserved(row, col - c2)) {
              let dark = false;
              if (byteIndex < data2.length) {
                dark = (data2[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c2, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    __name(setupData, "setupData");
    function createData(version6, errorCorrectionLevel, segments) {
      const buffer = new BitBuffer();
      segments.forEach(function(data2) {
        buffer.put(data2.mode.bit, 4);
        buffer.put(data2.getLength(), Mode.getCharCountIndicator(data2.mode, version6));
        data2.write(buffer);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version6);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version6, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i2 = 0; i2 < remainingByte; i2++) {
        buffer.put(i2 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version6, errorCorrectionLevel);
    }
    __name(createData, "createData");
    function createCodewords(bitBuffer, version6, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version6);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version6, errorCorrectionLevel);
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(version6, errorCorrectionLevel);
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs = new ReedSolomonEncoder(ecCount);
      let offset2 = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);
      for (let b3 = 0; b3 < ecTotalBlocks; b3++) {
        const dataSize = b3 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b3] = buffer.slice(offset2, offset2 + dataSize);
        ecData[b3] = rs.encode(dcData[b3]);
        offset2 += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data2 = new Uint8Array(totalCodewords);
      let index2 = 0;
      let i2, r5;
      for (i2 = 0; i2 < maxDataSize; i2++) {
        for (r5 = 0; r5 < ecTotalBlocks; r5++) {
          if (i2 < dcData[r5].length) {
            data2[index2++] = dcData[r5][i2];
          }
        }
      }
      for (i2 = 0; i2 < ecCount; i2++) {
        for (r5 = 0; r5 < ecTotalBlocks; r5++) {
          data2[index2++] = ecData[r5][i2];
        }
      }
      return data2;
    }
    __name(createCodewords, "createCodewords");
    function createSymbol(data2, version6, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data2)) {
        segments = Segments.fromArray(data2);
      } else if (typeof data2 === "string") {
        let estimatedVersion = version6;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data2);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data2, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version6) {
        version6 = bestVersion;
      } else if (version6 < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      const dataBits = createData(version6, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version6);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version6);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version6);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version6 >= 7) {
        setupVersionInfo(modules, version6);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version: version6,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    __name(createSymbol, "createSymbol");
    exports.create = /* @__PURE__ */ __name(function create(data2, options) {
      if (typeof data2 === "undefined" || data2 === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version6;
      let mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version6 = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data2, version6, errorCorrectionLevel, mask);
    }, "create");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/utils.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c2) {
          return [c2, c2];
        }));
      }
      if (hexCode.length === 6) hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    __name(hex2rgba, "hex2rgba");
    exports.getOptions = /* @__PURE__ */ __name(function getOptions(options) {
      if (!options) options = {};
      if (!options.color) options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale2 = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale2,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    }, "getOptions");
    exports.getScale = /* @__PURE__ */ __name(function getScale(qrSize, opts2) {
      return opts2.width && opts2.width >= qrSize + opts2.margin * 2 ? opts2.width / (qrSize + opts2.margin * 2) : opts2.scale;
    }, "getScale");
    exports.getImageWidth = /* @__PURE__ */ __name(function getImageWidth(qrSize, opts2) {
      const scale2 = exports.getScale(qrSize, opts2);
      return Math.floor((qrSize + opts2.margin * 2) * scale2);
    }, "getImageWidth");
    exports.qrToImageData = /* @__PURE__ */ __name(function qrToImageData(imgData, qr, opts2) {
      const size = qr.modules.size;
      const data2 = qr.modules.data;
      const scale2 = exports.getScale(size, opts2);
      const symbolSize = Math.floor((size + opts2.margin * 2) * scale2);
      const scaledMargin = opts2.margin * scale2;
      const palette = [opts2.color.light, opts2.color.dark];
      for (let i2 = 0; i2 < symbolSize; i2++) {
        for (let j = 0; j < symbolSize; j++) {
          let posDst = (i2 * symbolSize + j) * 4;
          let pxColor = opts2.color.light;
          if (i2 >= scaledMargin && j >= scaledMargin && i2 < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i2 - scaledMargin) / scale2);
            const jSrc = Math.floor((j - scaledMargin) / scale2);
            pxColor = palette[data2[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    }, "qrToImageData");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Utils = require_utils2();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style) canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    __name(clearCanvas, "clearCanvas");
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e4) {
        throw new Error("You need to specify a canvas element");
      }
    }
    __name(getCanvasElement, "getCanvasElement");
    exports.render = /* @__PURE__ */ __name(function render3(qrData, canvas, options) {
      let opts2 = options;
      let canvasEl = canvas;
      if (typeof opts2 === "undefined" && (!canvas || !canvas.getContext)) {
        opts2 = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts2 = Utils.getOptions(opts2);
      const size = Utils.getImageWidth(qrData.modules.size, opts2);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts2);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    }, "render");
    exports.renderToDataURL = /* @__PURE__ */ __name(function renderToDataURL(qrData, canvas, options) {
      let opts2 = options;
      if (typeof opts2 === "undefined" && (!canvas || !canvas.getContext)) {
        opts2 = canvas;
        canvas = void 0;
      }
      if (!opts2) opts2 = {};
      const canvasEl = exports.render(qrData, canvas, opts2);
      const type2 = opts2.type || "image/png";
      const rendererOpts = opts2.rendererOpts || {};
      return canvasEl.toDataURL(type2, rendererOpts.quality);
    }, "renderToDataURL");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Utils = require_utils2();
    function getColorAttrib(color, attrib) {
      const alpha = color.a / 255;
      const str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    __name(getColorAttrib, "getColorAttrib");
    function svgCmd(cmd, x, y3) {
      let str = cmd + x;
      if (typeof y3 !== "undefined") str += " " + y3;
      return str;
    }
    __name(svgCmd, "svgCmd");
    function qrToPath(data2, size, margin) {
      let path = "";
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;
      for (let i2 = 0; i2 < data2.length; i2++) {
        const col = Math.floor(i2 % size);
        const row = Math.floor(i2 / size);
        if (!col && !newRow) newRow = true;
        if (data2[i2]) {
          lineLength++;
          if (!(i2 > 0 && col > 0 && data2[i2 - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data2[i2 + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    __name(qrToPath, "qrToPath");
    exports.render = /* @__PURE__ */ __name(function render3(qrData, options, cb) {
      const opts2 = Utils.getOptions(options);
      const size = qrData.modules.size;
      const data2 = qrData.modules.data;
      const qrcodesize = size + opts2.margin * 2;
      const bg = !opts2.color.light.a ? "" : "<path " + getColorAttrib(opts2.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      const path = "<path " + getColorAttrib(opts2.color.dark, "stroke") + ' d="' + qrToPath(data2, size, opts2.margin) + '"/>';
      const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      const width = !opts2.width ? "" : 'width="' + opts2.width + '" height="' + opts2.width + '" ';
      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    }, "render");
  }
});

// ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/browser.js
var require_browser = __commonJS({
  "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/browser.js"(exports) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var canPromise = require_can_promise();
    var QRCode2 = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas2(renderFunc, canvas, text, opts2, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts2 = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts2;
            opts2 = void 0;
          } else {
            cb = opts2;
            opts2 = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts2 = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts2 = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve3, reject) {
          try {
            const data2 = QRCode2.create(text, opts2);
            resolve3(renderFunc(data2, canvas, opts2));
          } catch (e4) {
            reject(e4);
          }
        });
      }
      try {
        const data2 = QRCode2.create(text, opts2);
        cb(null, renderFunc(data2, canvas, opts2));
      } catch (e4) {
        cb(e4);
      }
    }
    __name(renderCanvas2, "renderCanvas");
    exports.create = QRCode2.create;
    exports.toCanvas = renderCanvas2.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas2.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas2.bind(null, function(data2, _, opts2) {
      return SvgRenderer.render(data2, opts2);
    });
  }
});

// node-built-in-modules:node:util
import libDefault3 from "node:util";
var require_node_util = __commonJS({
  "node-built-in-modules:node:util"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault3;
  }
});

// node-built-in-modules:node:stream
import libDefault4 from "node:stream";
var require_node_stream = __commonJS({
  "node-built-in-modules:node:stream"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault4;
  }
});

// ../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/is.js
var require_is = __commonJS({
  "../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/is.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var defined = /* @__PURE__ */ __name((val) => typeof val !== "undefined" && val !== null, "defined");
    var object = /* @__PURE__ */ __name((val) => typeof val === "object", "object");
    var plainObject = /* @__PURE__ */ __name((val) => Object.prototype.toString.call(val) === "[object Object]", "plainObject");
    var fn = /* @__PURE__ */ __name((val) => typeof val === "function", "fn");
    var bool = /* @__PURE__ */ __name((val) => typeof val === "boolean", "bool");
    var buffer = /* @__PURE__ */ __name((val) => val instanceof Buffer, "buffer");
    var typedArray = /* @__PURE__ */ __name((val) => {
      if (defined(val)) {
        switch (val.constructor) {
          case Uint8Array:
          case Uint8ClampedArray:
          case Int8Array:
          case Uint16Array:
          case Int16Array:
          case Uint32Array:
          case Int32Array:
          case Float32Array:
          case Float64Array:
            return true;
        }
      }
      return false;
    }, "typedArray");
    var arrayBuffer = /* @__PURE__ */ __name((val) => val instanceof ArrayBuffer, "arrayBuffer");
    var string = /* @__PURE__ */ __name((val) => typeof val === "string" && val.length > 0, "string");
    var number3 = /* @__PURE__ */ __name((val) => typeof val === "number" && !Number.isNaN(val), "number");
    var integer = /* @__PURE__ */ __name((val) => Number.isInteger(val), "integer");
    var inRange = /* @__PURE__ */ __name((val, min2, max2) => val >= min2 && val <= max2, "inRange");
    var inArray = /* @__PURE__ */ __name((val, list) => list.includes(val), "inArray");
    var invalidParameterError = /* @__PURE__ */ __name((name, expected, actual) => new Error(
      `Expected ${expected} for ${name} but received ${actual} of type ${typeof actual}`
    ), "invalidParameterError");
    var nativeError = /* @__PURE__ */ __name((native, context2) => {
      context2.message = native.message;
      return context2;
    }, "nativeError");
    module.exports = {
      defined,
      object,
      plainObject,
      fn,
      bool,
      buffer,
      typedArray,
      arrayBuffer,
      string,
      number: number3,
      integer,
      inRange,
      inArray,
      invalidParameterError,
      nativeError
    };
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/child_process.mjs
var ChildProcess, _forkChild, exec, execFile, execFileSync, execSync, fork, spawn, spawnSync, child_process_default;
var init_child_process = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/child_process.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    ChildProcess = /* @__PURE__ */ notImplementedClass("child_process.ChildProcess");
    _forkChild = /* @__PURE__ */ notImplemented("child_process.ChildProcess");
    exec = /* @__PURE__ */ notImplemented("child_process.exec");
    execFile = /* @__PURE__ */ notImplemented("child_process.execFile");
    execFileSync = /* @__PURE__ */ notImplemented("child_process.execFileSync");
    execSync = /* @__PURE__ */ notImplemented("child_process.execSyn");
    fork = /* @__PURE__ */ notImplemented("child_process.fork");
    spawn = /* @__PURE__ */ notImplemented("child_process.spawn");
    spawnSync = /* @__PURE__ */ notImplemented("child_process.spawnSync");
    child_process_default = {
      ChildProcess,
      _forkChild,
      exec,
      execFile,
      execFileSync,
      execSync,
      fork,
      spawn,
      spawnSync
    };
  }
});

// node-built-in-modules:child_process
var require_child_process = __commonJS({
  "node-built-in-modules:child_process"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_child_process();
    module.exports = child_process_default;
  }
});

// ../../node_modules/.pnpm/detect-libc@2.1.2/node_modules/detect-libc/lib/process.js
var require_process = __commonJS({
  "../../node_modules/.pnpm/detect-libc@2.1.2/node_modules/detect-libc/lib/process.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isLinux = /* @__PURE__ */ __name(() => process.platform === "linux", "isLinux");
    var report2 = null;
    var getReport = /* @__PURE__ */ __name(() => {
      if (!report2) {
        if (isLinux() && process.report) {
          const orig = process.report.excludeNetwork;
          process.report.excludeNetwork = true;
          report2 = process.report.getReport();
          process.report.excludeNetwork = orig;
        } else {
          report2 = {};
        }
      }
      return report2;
    }, "getReport");
    module.exports = { isLinux, getReport };
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/fs/promises.mjs
var access, copyFile, cp, open, opendir, rename, truncate4, rm, rmdir, mkdir, readdir, readlink, symlink, lstat, stat, link, unlink, chmod, lchmod, lchown, chown, utimes, lutimes, realpath, mkdtemp, writeFile, appendFile, readFile, watch, statfs, glob;
var init_promises = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/fs/promises.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    access = /* @__PURE__ */ notImplemented("fs.access");
    copyFile = /* @__PURE__ */ notImplemented("fs.copyFile");
    cp = /* @__PURE__ */ notImplemented("fs.cp");
    open = /* @__PURE__ */ notImplemented("fs.open");
    opendir = /* @__PURE__ */ notImplemented("fs.opendir");
    rename = /* @__PURE__ */ notImplemented("fs.rename");
    truncate4 = /* @__PURE__ */ notImplemented("fs.truncate");
    rm = /* @__PURE__ */ notImplemented("fs.rm");
    rmdir = /* @__PURE__ */ notImplemented("fs.rmdir");
    mkdir = /* @__PURE__ */ notImplemented("fs.mkdir");
    readdir = /* @__PURE__ */ notImplemented("fs.readdir");
    readlink = /* @__PURE__ */ notImplemented("fs.readlink");
    symlink = /* @__PURE__ */ notImplemented("fs.symlink");
    lstat = /* @__PURE__ */ notImplemented("fs.lstat");
    stat = /* @__PURE__ */ notImplemented("fs.stat");
    link = /* @__PURE__ */ notImplemented("fs.link");
    unlink = /* @__PURE__ */ notImplemented("fs.unlink");
    chmod = /* @__PURE__ */ notImplemented("fs.chmod");
    lchmod = /* @__PURE__ */ notImplemented("fs.lchmod");
    lchown = /* @__PURE__ */ notImplemented("fs.lchown");
    chown = /* @__PURE__ */ notImplemented("fs.chown");
    utimes = /* @__PURE__ */ notImplemented("fs.utimes");
    lutimes = /* @__PURE__ */ notImplemented("fs.lutimes");
    realpath = /* @__PURE__ */ notImplemented("fs.realpath");
    mkdtemp = /* @__PURE__ */ notImplemented("fs.mkdtemp");
    writeFile = /* @__PURE__ */ notImplemented("fs.writeFile");
    appendFile = /* @__PURE__ */ notImplemented("fs.appendFile");
    readFile = /* @__PURE__ */ notImplemented("fs.readFile");
    watch = /* @__PURE__ */ notImplemented("fs.watch");
    statfs = /* @__PURE__ */ notImplemented("fs.statfs");
    glob = /* @__PURE__ */ notImplemented("fs.glob");
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/fs/constants.mjs
var constants_exports = {};
__export(constants_exports, {
  COPYFILE_EXCL: () => COPYFILE_EXCL,
  COPYFILE_FICLONE: () => COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE: () => COPYFILE_FICLONE_FORCE,
  EXTENSIONLESS_FORMAT_JAVASCRIPT: () => EXTENSIONLESS_FORMAT_JAVASCRIPT,
  EXTENSIONLESS_FORMAT_WASM: () => EXTENSIONLESS_FORMAT_WASM,
  F_OK: () => F_OK,
  O_APPEND: () => O_APPEND,
  O_CREAT: () => O_CREAT,
  O_DIRECT: () => O_DIRECT,
  O_DIRECTORY: () => O_DIRECTORY,
  O_DSYNC: () => O_DSYNC,
  O_EXCL: () => O_EXCL,
  O_NOATIME: () => O_NOATIME,
  O_NOCTTY: () => O_NOCTTY,
  O_NOFOLLOW: () => O_NOFOLLOW,
  O_NONBLOCK: () => O_NONBLOCK,
  O_RDONLY: () => O_RDONLY,
  O_RDWR: () => O_RDWR,
  O_SYNC: () => O_SYNC,
  O_TRUNC: () => O_TRUNC,
  O_WRONLY: () => O_WRONLY,
  R_OK: () => R_OK,
  S_IFBLK: () => S_IFBLK,
  S_IFCHR: () => S_IFCHR,
  S_IFDIR: () => S_IFDIR,
  S_IFIFO: () => S_IFIFO,
  S_IFLNK: () => S_IFLNK,
  S_IFMT: () => S_IFMT,
  S_IFREG: () => S_IFREG,
  S_IFSOCK: () => S_IFSOCK,
  S_IRGRP: () => S_IRGRP,
  S_IROTH: () => S_IROTH,
  S_IRUSR: () => S_IRUSR,
  S_IRWXG: () => S_IRWXG,
  S_IRWXO: () => S_IRWXO,
  S_IRWXU: () => S_IRWXU,
  S_IWGRP: () => S_IWGRP,
  S_IWOTH: () => S_IWOTH,
  S_IWUSR: () => S_IWUSR,
  S_IXGRP: () => S_IXGRP,
  S_IXOTH: () => S_IXOTH,
  S_IXUSR: () => S_IXUSR,
  UV_DIRENT_BLOCK: () => UV_DIRENT_BLOCK,
  UV_DIRENT_CHAR: () => UV_DIRENT_CHAR,
  UV_DIRENT_DIR: () => UV_DIRENT_DIR,
  UV_DIRENT_FIFO: () => UV_DIRENT_FIFO,
  UV_DIRENT_FILE: () => UV_DIRENT_FILE,
  UV_DIRENT_LINK: () => UV_DIRENT_LINK,
  UV_DIRENT_SOCKET: () => UV_DIRENT_SOCKET,
  UV_DIRENT_UNKNOWN: () => UV_DIRENT_UNKNOWN,
  UV_FS_COPYFILE_EXCL: () => UV_FS_COPYFILE_EXCL,
  UV_FS_COPYFILE_FICLONE: () => UV_FS_COPYFILE_FICLONE,
  UV_FS_COPYFILE_FICLONE_FORCE: () => UV_FS_COPYFILE_FICLONE_FORCE,
  UV_FS_O_FILEMAP: () => UV_FS_O_FILEMAP,
  UV_FS_SYMLINK_DIR: () => UV_FS_SYMLINK_DIR,
  UV_FS_SYMLINK_JUNCTION: () => UV_FS_SYMLINK_JUNCTION,
  W_OK: () => W_OK,
  X_OK: () => X_OK
});
var UV_FS_SYMLINK_DIR, UV_FS_SYMLINK_JUNCTION, O_RDONLY, O_WRONLY, O_RDWR, UV_DIRENT_UNKNOWN, UV_DIRENT_FILE, UV_DIRENT_DIR, UV_DIRENT_LINK, UV_DIRENT_FIFO, UV_DIRENT_SOCKET, UV_DIRENT_CHAR, UV_DIRENT_BLOCK, EXTENSIONLESS_FORMAT_JAVASCRIPT, EXTENSIONLESS_FORMAT_WASM, S_IFMT, S_IFREG, S_IFDIR, S_IFCHR, S_IFBLK, S_IFIFO, S_IFLNK, S_IFSOCK, O_CREAT, O_EXCL, UV_FS_O_FILEMAP, O_NOCTTY, O_TRUNC, O_APPEND, O_DIRECTORY, O_NOATIME, O_NOFOLLOW, O_SYNC, O_DSYNC, O_DIRECT, O_NONBLOCK, S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH, F_OK, R_OK, W_OK, X_OK, UV_FS_COPYFILE_EXCL, COPYFILE_EXCL, UV_FS_COPYFILE_FICLONE, COPYFILE_FICLONE, UV_FS_COPYFILE_FICLONE_FORCE, COPYFILE_FICLONE_FORCE;
var init_constants = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/fs/constants.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    UV_FS_SYMLINK_DIR = 1;
    UV_FS_SYMLINK_JUNCTION = 2;
    O_RDONLY = 0;
    O_WRONLY = 1;
    O_RDWR = 2;
    UV_DIRENT_UNKNOWN = 0;
    UV_DIRENT_FILE = 1;
    UV_DIRENT_DIR = 2;
    UV_DIRENT_LINK = 3;
    UV_DIRENT_FIFO = 4;
    UV_DIRENT_SOCKET = 5;
    UV_DIRENT_CHAR = 6;
    UV_DIRENT_BLOCK = 7;
    EXTENSIONLESS_FORMAT_JAVASCRIPT = 0;
    EXTENSIONLESS_FORMAT_WASM = 1;
    S_IFMT = 61440;
    S_IFREG = 32768;
    S_IFDIR = 16384;
    S_IFCHR = 8192;
    S_IFBLK = 24576;
    S_IFIFO = 4096;
    S_IFLNK = 40960;
    S_IFSOCK = 49152;
    O_CREAT = 64;
    O_EXCL = 128;
    UV_FS_O_FILEMAP = 0;
    O_NOCTTY = 256;
    O_TRUNC = 512;
    O_APPEND = 1024;
    O_DIRECTORY = 65536;
    O_NOATIME = 262144;
    O_NOFOLLOW = 131072;
    O_SYNC = 1052672;
    O_DSYNC = 4096;
    O_DIRECT = 16384;
    O_NONBLOCK = 2048;
    S_IRWXU = 448;
    S_IRUSR = 256;
    S_IWUSR = 128;
    S_IXUSR = 64;
    S_IRWXG = 56;
    S_IRGRP = 32;
    S_IWGRP = 16;
    S_IXGRP = 8;
    S_IRWXO = 7;
    S_IROTH = 4;
    S_IWOTH = 2;
    S_IXOTH = 1;
    F_OK = 0;
    R_OK = 4;
    W_OK = 2;
    X_OK = 1;
    UV_FS_COPYFILE_EXCL = 1;
    COPYFILE_EXCL = 1;
    UV_FS_COPYFILE_FICLONE = 2;
    COPYFILE_FICLONE = 2;
    UV_FS_COPYFILE_FICLONE_FORCE = 4;
    COPYFILE_FICLONE_FORCE = 4;
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/fs/promises.mjs
var promises_default;
var init_promises2 = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/fs/promises.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_promises();
    init_constants();
    init_promises();
    promises_default = {
      constants: constants_exports,
      access,
      appendFile,
      chmod,
      chown,
      copyFile,
      cp,
      glob,
      lchmod,
      lchown,
      link,
      lstat,
      lutimes,
      mkdir,
      mkdtemp,
      open,
      opendir,
      readFile,
      readdir,
      readlink,
      realpath,
      rename,
      rm,
      rmdir,
      stat,
      statfs,
      symlink,
      truncate: truncate4,
      unlink,
      utimes,
      watch,
      writeFile
    };
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/fs/classes.mjs
var Dir, Dirent, Stats, ReadStream2, WriteStream2, FileReadStream, FileWriteStream;
var init_classes = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/fs/classes.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    Dir = /* @__PURE__ */ notImplementedClass("fs.Dir");
    Dirent = /* @__PURE__ */ notImplementedClass("fs.Dirent");
    Stats = /* @__PURE__ */ notImplementedClass("fs.Stats");
    ReadStream2 = /* @__PURE__ */ notImplementedClass("fs.ReadStream");
    WriteStream2 = /* @__PURE__ */ notImplementedClass("fs.WriteStream");
    FileReadStream = ReadStream2;
    FileWriteStream = WriteStream2;
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/fs/fs.mjs
function callbackify3(fn) {
  const fnc = /* @__PURE__ */ __name(function(...args) {
    const cb = args.pop();
    fn().catch((error3) => cb(error3)).then((val) => cb(void 0, val));
  }, "fnc");
  fnc.__promisify__ = fn;
  fnc.native = fnc;
  return fnc;
}
var access2, appendFile2, chown2, chmod2, copyFile2, cp2, lchown2, lchmod2, link2, lstat2, lutimes2, mkdir2, mkdtemp2, realpath2, open2, opendir2, readdir2, readFile2, readlink2, rename2, rm2, rmdir2, stat2, symlink2, truncate5, unlink2, utimes2, writeFile2, statfs2, close, createReadStream, createWriteStream, exists, fchown, fchmod, fdatasync, fstat, fsync, ftruncate, futimes, lstatSync, read4, readv, realpathSync, statSync, unwatchFile, watch2, watchFile, write7, writev, _toUnixTimestamp, openAsBlob, glob2, appendFileSync, accessSync, chownSync, chmodSync, closeSync, copyFileSync, cpSync, existsSync, fchownSync, fchmodSync, fdatasyncSync, fstatSync, fsyncSync, ftruncateSync, futimesSync, lchownSync, lchmodSync, linkSync, lutimesSync, mkdirSync, mkdtempSync, openSync, opendirSync, readdirSync, readSync, readvSync, readFileSync, readlinkSync, renameSync, rmSync, rmdirSync, symlinkSync, truncateSync, unlinkSync, utimesSync, writeFileSync, writeSync, writevSync, statfsSync, globSync;
var init_fs = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/fs/fs.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_promises();
    __name(callbackify3, "callbackify");
    access2 = callbackify3(access);
    appendFile2 = callbackify3(appendFile);
    chown2 = callbackify3(chown);
    chmod2 = callbackify3(chmod);
    copyFile2 = callbackify3(copyFile);
    cp2 = callbackify3(cp);
    lchown2 = callbackify3(lchown);
    lchmod2 = callbackify3(lchmod);
    link2 = callbackify3(link);
    lstat2 = callbackify3(lstat);
    lutimes2 = callbackify3(lutimes);
    mkdir2 = callbackify3(mkdir);
    mkdtemp2 = callbackify3(mkdtemp);
    realpath2 = callbackify3(realpath);
    open2 = callbackify3(open);
    opendir2 = callbackify3(opendir);
    readdir2 = callbackify3(readdir);
    readFile2 = callbackify3(readFile);
    readlink2 = callbackify3(readlink);
    rename2 = callbackify3(rename);
    rm2 = callbackify3(rm);
    rmdir2 = callbackify3(rmdir);
    stat2 = callbackify3(stat);
    symlink2 = callbackify3(symlink);
    truncate5 = callbackify3(truncate4);
    unlink2 = callbackify3(unlink);
    utimes2 = callbackify3(utimes);
    writeFile2 = callbackify3(writeFile);
    statfs2 = callbackify3(statfs);
    close = /* @__PURE__ */ notImplementedAsync("fs.close");
    createReadStream = /* @__PURE__ */ notImplementedAsync("fs.createReadStream");
    createWriteStream = /* @__PURE__ */ notImplementedAsync("fs.createWriteStream");
    exists = /* @__PURE__ */ notImplementedAsync("fs.exists");
    fchown = /* @__PURE__ */ notImplementedAsync("fs.fchown");
    fchmod = /* @__PURE__ */ notImplementedAsync("fs.fchmod");
    fdatasync = /* @__PURE__ */ notImplementedAsync("fs.fdatasync");
    fstat = /* @__PURE__ */ notImplementedAsync("fs.fstat");
    fsync = /* @__PURE__ */ notImplementedAsync("fs.fsync");
    ftruncate = /* @__PURE__ */ notImplementedAsync("fs.ftruncate");
    futimes = /* @__PURE__ */ notImplementedAsync("fs.futimes");
    lstatSync = /* @__PURE__ */ notImplementedAsync("fs.lstatSync");
    read4 = /* @__PURE__ */ notImplementedAsync("fs.read");
    readv = /* @__PURE__ */ notImplementedAsync("fs.readv");
    realpathSync = /* @__PURE__ */ notImplementedAsync("fs.realpathSync");
    statSync = /* @__PURE__ */ notImplementedAsync("fs.statSync");
    unwatchFile = /* @__PURE__ */ notImplementedAsync("fs.unwatchFile");
    watch2 = /* @__PURE__ */ notImplementedAsync("fs.watch");
    watchFile = /* @__PURE__ */ notImplementedAsync("fs.watchFile");
    write7 = /* @__PURE__ */ notImplementedAsync("fs.write");
    writev = /* @__PURE__ */ notImplementedAsync("fs.writev");
    _toUnixTimestamp = /* @__PURE__ */ notImplementedAsync("fs._toUnixTimestamp");
    openAsBlob = /* @__PURE__ */ notImplementedAsync("fs.openAsBlob");
    glob2 = /* @__PURE__ */ notImplementedAsync("fs.glob");
    appendFileSync = /* @__PURE__ */ notImplemented("fs.appendFileSync");
    accessSync = /* @__PURE__ */ notImplemented("fs.accessSync");
    chownSync = /* @__PURE__ */ notImplemented("fs.chownSync");
    chmodSync = /* @__PURE__ */ notImplemented("fs.chmodSync");
    closeSync = /* @__PURE__ */ notImplemented("fs.closeSync");
    copyFileSync = /* @__PURE__ */ notImplemented("fs.copyFileSync");
    cpSync = /* @__PURE__ */ notImplemented("fs.cpSync");
    existsSync = /* @__PURE__ */ __name(() => false, "existsSync");
    fchownSync = /* @__PURE__ */ notImplemented("fs.fchownSync");
    fchmodSync = /* @__PURE__ */ notImplemented("fs.fchmodSync");
    fdatasyncSync = /* @__PURE__ */ notImplemented("fs.fdatasyncSync");
    fstatSync = /* @__PURE__ */ notImplemented("fs.fstatSync");
    fsyncSync = /* @__PURE__ */ notImplemented("fs.fsyncSync");
    ftruncateSync = /* @__PURE__ */ notImplemented("fs.ftruncateSync");
    futimesSync = /* @__PURE__ */ notImplemented("fs.futimesSync");
    lchownSync = /* @__PURE__ */ notImplemented("fs.lchownSync");
    lchmodSync = /* @__PURE__ */ notImplemented("fs.lchmodSync");
    linkSync = /* @__PURE__ */ notImplemented("fs.linkSync");
    lutimesSync = /* @__PURE__ */ notImplemented("fs.lutimesSync");
    mkdirSync = /* @__PURE__ */ notImplemented("fs.mkdirSync");
    mkdtempSync = /* @__PURE__ */ notImplemented("fs.mkdtempSync");
    openSync = /* @__PURE__ */ notImplemented("fs.openSync");
    opendirSync = /* @__PURE__ */ notImplemented("fs.opendirSync");
    readdirSync = /* @__PURE__ */ notImplemented("fs.readdirSync");
    readSync = /* @__PURE__ */ notImplemented("fs.readSync");
    readvSync = /* @__PURE__ */ notImplemented("fs.readvSync");
    readFileSync = /* @__PURE__ */ notImplemented("fs.readFileSync");
    readlinkSync = /* @__PURE__ */ notImplemented("fs.readlinkSync");
    renameSync = /* @__PURE__ */ notImplemented("fs.renameSync");
    rmSync = /* @__PURE__ */ notImplemented("fs.rmSync");
    rmdirSync = /* @__PURE__ */ notImplemented("fs.rmdirSync");
    symlinkSync = /* @__PURE__ */ notImplemented("fs.symlinkSync");
    truncateSync = /* @__PURE__ */ notImplemented("fs.truncateSync");
    unlinkSync = /* @__PURE__ */ notImplemented("fs.unlinkSync");
    utimesSync = /* @__PURE__ */ notImplemented("fs.utimesSync");
    writeFileSync = /* @__PURE__ */ notImplemented("fs.writeFileSync");
    writeSync = /* @__PURE__ */ notImplemented("fs.writeSync");
    writevSync = /* @__PURE__ */ notImplemented("fs.writevSync");
    statfsSync = /* @__PURE__ */ notImplemented("fs.statfsSync");
    globSync = /* @__PURE__ */ notImplemented("fs.globSync");
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/fs.mjs
var fs_default;
var init_fs2 = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/fs.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_promises2();
    init_classes();
    init_fs();
    init_constants();
    init_constants();
    init_fs();
    init_classes();
    fs_default = {
      F_OK,
      R_OK,
      W_OK,
      X_OK,
      constants: constants_exports,
      promises: promises_default,
      Dir,
      Dirent,
      FileReadStream,
      FileWriteStream,
      ReadStream: ReadStream2,
      Stats,
      WriteStream: WriteStream2,
      _toUnixTimestamp,
      access: access2,
      accessSync,
      appendFile: appendFile2,
      appendFileSync,
      chmod: chmod2,
      chmodSync,
      chown: chown2,
      chownSync,
      close,
      closeSync,
      copyFile: copyFile2,
      copyFileSync,
      cp: cp2,
      cpSync,
      createReadStream,
      createWriteStream,
      exists,
      existsSync,
      fchmod,
      fchmodSync,
      fchown,
      fchownSync,
      fdatasync,
      fdatasyncSync,
      fstat,
      fstatSync,
      fsync,
      fsyncSync,
      ftruncate,
      ftruncateSync,
      futimes,
      futimesSync,
      glob: glob2,
      lchmod: lchmod2,
      globSync,
      lchmodSync,
      lchown: lchown2,
      lchownSync,
      link: link2,
      linkSync,
      lstat: lstat2,
      lstatSync,
      lutimes: lutimes2,
      lutimesSync,
      mkdir: mkdir2,
      mkdirSync,
      mkdtemp: mkdtemp2,
      mkdtempSync,
      open: open2,
      openAsBlob,
      openSync,
      opendir: opendir2,
      opendirSync,
      read: read4,
      readFile: readFile2,
      readFileSync,
      readSync,
      readdir: readdir2,
      readdirSync,
      readlink: readlink2,
      readlinkSync,
      readv,
      readvSync,
      realpath: realpath2,
      realpathSync,
      rename: rename2,
      renameSync,
      rm: rm2,
      rmSync,
      rmdir: rmdir2,
      rmdirSync,
      stat: stat2,
      statSync,
      statfs: statfs2,
      statfsSync,
      symlink: symlink2,
      symlinkSync,
      truncate: truncate5,
      truncateSync,
      unlink: unlink2,
      unlinkSync,
      unwatchFile,
      utimes: utimes2,
      utimesSync,
      watch: watch2,
      watchFile,
      write: write7,
      writeFile: writeFile2,
      writeFileSync,
      writeSync,
      writev,
      writevSync
    };
  }
});

// node-built-in-modules:fs
var require_fs = __commonJS({
  "node-built-in-modules:fs"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_fs2();
    module.exports = fs_default;
  }
});

// ../../node_modules/.pnpm/detect-libc@2.1.2/node_modules/detect-libc/lib/filesystem.js
var require_filesystem = __commonJS({
  "../../node_modules/.pnpm/detect-libc@2.1.2/node_modules/detect-libc/lib/filesystem.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var fs2 = require_fs();
    var LDD_PATH = "/usr/bin/ldd";
    var SELF_PATH = "/proc/self/exe";
    var MAX_LENGTH = 2048;
    var readFileSync2 = /* @__PURE__ */ __name((path) => {
      const fd = fs2.openSync(path, "r");
      const buffer = Buffer.alloc(MAX_LENGTH);
      const bytesRead = fs2.readSync(fd, buffer, 0, MAX_LENGTH, 0);
      fs2.close(fd, () => {
      });
      return buffer.subarray(0, bytesRead);
    }, "readFileSync");
    var readFile3 = /* @__PURE__ */ __name((path) => new Promise((resolve3, reject) => {
      fs2.open(path, "r", (err2, fd) => {
        if (err2) {
          reject(err2);
        } else {
          const buffer = Buffer.alloc(MAX_LENGTH);
          fs2.read(fd, buffer, 0, MAX_LENGTH, 0, (_, bytesRead) => {
            resolve3(buffer.subarray(0, bytesRead));
            fs2.close(fd, () => {
            });
          });
        }
      });
    }), "readFile");
    module.exports = {
      LDD_PATH,
      SELF_PATH,
      readFileSync: readFileSync2,
      readFile: readFile3
    };
  }
});

// ../../node_modules/.pnpm/detect-libc@2.1.2/node_modules/detect-libc/lib/elf.js
var require_elf = __commonJS({
  "../../node_modules/.pnpm/detect-libc@2.1.2/node_modules/detect-libc/lib/elf.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var interpreterPath = /* @__PURE__ */ __name((elf) => {
      if (elf.length < 64) {
        return null;
      }
      if (elf.readUInt32BE(0) !== 2135247942) {
        return null;
      }
      if (elf.readUInt8(4) !== 2) {
        return null;
      }
      if (elf.readUInt8(5) !== 1) {
        return null;
      }
      const offset2 = elf.readUInt32LE(32);
      const size = elf.readUInt16LE(54);
      const count3 = elf.readUInt16LE(56);
      for (let i2 = 0; i2 < count3; i2++) {
        const headerOffset = offset2 + i2 * size;
        const type2 = elf.readUInt32LE(headerOffset);
        if (type2 === 3) {
          const fileOffset = elf.readUInt32LE(headerOffset + 8);
          const fileSize = elf.readUInt32LE(headerOffset + 32);
          return elf.subarray(fileOffset, fileOffset + fileSize).toString().replace(/\0.*$/g, "");
        }
      }
      return null;
    }, "interpreterPath");
    module.exports = {
      interpreterPath
    };
  }
});

// ../../node_modules/.pnpm/detect-libc@2.1.2/node_modules/detect-libc/lib/detect-libc.js
var require_detect_libc = __commonJS({
  "../../node_modules/.pnpm/detect-libc@2.1.2/node_modules/detect-libc/lib/detect-libc.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var childProcess = require_child_process();
    var { isLinux, getReport } = require_process();
    var { LDD_PATH, SELF_PATH, readFile: readFile3, readFileSync: readFileSync2 } = require_filesystem();
    var { interpreterPath } = require_elf();
    var cachedFamilyInterpreter;
    var cachedFamilyFilesystem;
    var cachedVersionFilesystem;
    var command = "getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true";
    var commandOut = "";
    var safeCommand = /* @__PURE__ */ __name(() => {
      if (!commandOut) {
        return new Promise((resolve3) => {
          childProcess.exec(command, (err2, out) => {
            commandOut = err2 ? " " : out;
            resolve3(commandOut);
          });
        });
      }
      return commandOut;
    }, "safeCommand");
    var safeCommandSync = /* @__PURE__ */ __name(() => {
      if (!commandOut) {
        try {
          commandOut = childProcess.execSync(command, { encoding: "utf8" });
        } catch (_err) {
          commandOut = " ";
        }
      }
      return commandOut;
    }, "safeCommandSync");
    var GLIBC = "glibc";
    var RE_GLIBC_VERSION = /LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i;
    var MUSL = "musl";
    var isFileMusl = /* @__PURE__ */ __name((f4) => f4.includes("libc.musl-") || f4.includes("ld-musl-"), "isFileMusl");
    var familyFromReport = /* @__PURE__ */ __name(() => {
      const report2 = getReport();
      if (report2.header && report2.header.glibcVersionRuntime) {
        return GLIBC;
      }
      if (Array.isArray(report2.sharedObjects)) {
        if (report2.sharedObjects.some(isFileMusl)) {
          return MUSL;
        }
      }
      return null;
    }, "familyFromReport");
    var familyFromCommand = /* @__PURE__ */ __name((out) => {
      const [getconf, ldd1] = out.split(/[\r\n]+/);
      if (getconf && getconf.includes(GLIBC)) {
        return GLIBC;
      }
      if (ldd1 && ldd1.includes(MUSL)) {
        return MUSL;
      }
      return null;
    }, "familyFromCommand");
    var familyFromInterpreterPath = /* @__PURE__ */ __name((path) => {
      if (path) {
        if (path.includes("/ld-musl-")) {
          return MUSL;
        } else if (path.includes("/ld-linux-")) {
          return GLIBC;
        }
      }
      return null;
    }, "familyFromInterpreterPath");
    var getFamilyFromLddContent = /* @__PURE__ */ __name((content) => {
      content = content.toString();
      if (content.includes("musl")) {
        return MUSL;
      }
      if (content.includes("GNU C Library")) {
        return GLIBC;
      }
      return null;
    }, "getFamilyFromLddContent");
    var familyFromFilesystem = /* @__PURE__ */ __name(async () => {
      if (cachedFamilyFilesystem !== void 0) {
        return cachedFamilyFilesystem;
      }
      cachedFamilyFilesystem = null;
      try {
        const lddContent = await readFile3(LDD_PATH);
        cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
      } catch (e4) {
      }
      return cachedFamilyFilesystem;
    }, "familyFromFilesystem");
    var familyFromFilesystemSync = /* @__PURE__ */ __name(() => {
      if (cachedFamilyFilesystem !== void 0) {
        return cachedFamilyFilesystem;
      }
      cachedFamilyFilesystem = null;
      try {
        const lddContent = readFileSync2(LDD_PATH);
        cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
      } catch (e4) {
      }
      return cachedFamilyFilesystem;
    }, "familyFromFilesystemSync");
    var familyFromInterpreter = /* @__PURE__ */ __name(async () => {
      if (cachedFamilyInterpreter !== void 0) {
        return cachedFamilyInterpreter;
      }
      cachedFamilyInterpreter = null;
      try {
        const selfContent = await readFile3(SELF_PATH);
        const path = interpreterPath(selfContent);
        cachedFamilyInterpreter = familyFromInterpreterPath(path);
      } catch (e4) {
      }
      return cachedFamilyInterpreter;
    }, "familyFromInterpreter");
    var familyFromInterpreterSync = /* @__PURE__ */ __name(() => {
      if (cachedFamilyInterpreter !== void 0) {
        return cachedFamilyInterpreter;
      }
      cachedFamilyInterpreter = null;
      try {
        const selfContent = readFileSync2(SELF_PATH);
        const path = interpreterPath(selfContent);
        cachedFamilyInterpreter = familyFromInterpreterPath(path);
      } catch (e4) {
      }
      return cachedFamilyInterpreter;
    }, "familyFromInterpreterSync");
    var family = /* @__PURE__ */ __name(async () => {
      let family2 = null;
      if (isLinux()) {
        family2 = await familyFromInterpreter();
        if (!family2) {
          family2 = await familyFromFilesystem();
          if (!family2) {
            family2 = familyFromReport();
          }
          if (!family2) {
            const out = await safeCommand();
            family2 = familyFromCommand(out);
          }
        }
      }
      return family2;
    }, "family");
    var familySync = /* @__PURE__ */ __name(() => {
      let family2 = null;
      if (isLinux()) {
        family2 = familyFromInterpreterSync();
        if (!family2) {
          family2 = familyFromFilesystemSync();
          if (!family2) {
            family2 = familyFromReport();
          }
          if (!family2) {
            const out = safeCommandSync();
            family2 = familyFromCommand(out);
          }
        }
      }
      return family2;
    }, "familySync");
    var isNonGlibcLinux = /* @__PURE__ */ __name(async () => isLinux() && await family() !== GLIBC, "isNonGlibcLinux");
    var isNonGlibcLinuxSync = /* @__PURE__ */ __name(() => isLinux() && familySync() !== GLIBC, "isNonGlibcLinuxSync");
    var versionFromFilesystem = /* @__PURE__ */ __name(async () => {
      if (cachedVersionFilesystem !== void 0) {
        return cachedVersionFilesystem;
      }
      cachedVersionFilesystem = null;
      try {
        const lddContent = await readFile3(LDD_PATH);
        const versionMatch = lddContent.match(RE_GLIBC_VERSION);
        if (versionMatch) {
          cachedVersionFilesystem = versionMatch[1];
        }
      } catch (e4) {
      }
      return cachedVersionFilesystem;
    }, "versionFromFilesystem");
    var versionFromFilesystemSync = /* @__PURE__ */ __name(() => {
      if (cachedVersionFilesystem !== void 0) {
        return cachedVersionFilesystem;
      }
      cachedVersionFilesystem = null;
      try {
        const lddContent = readFileSync2(LDD_PATH);
        const versionMatch = lddContent.match(RE_GLIBC_VERSION);
        if (versionMatch) {
          cachedVersionFilesystem = versionMatch[1];
        }
      } catch (e4) {
      }
      return cachedVersionFilesystem;
    }, "versionFromFilesystemSync");
    var versionFromReport = /* @__PURE__ */ __name(() => {
      const report2 = getReport();
      if (report2.header && report2.header.glibcVersionRuntime) {
        return report2.header.glibcVersionRuntime;
      }
      return null;
    }, "versionFromReport");
    var versionSuffix = /* @__PURE__ */ __name((s4) => s4.trim().split(/\s+/)[1], "versionSuffix");
    var versionFromCommand = /* @__PURE__ */ __name((out) => {
      const [getconf, ldd1, ldd2] = out.split(/[\r\n]+/);
      if (getconf && getconf.includes(GLIBC)) {
        return versionSuffix(getconf);
      }
      if (ldd1 && ldd2 && ldd1.includes(MUSL)) {
        return versionSuffix(ldd2);
      }
      return null;
    }, "versionFromCommand");
    var version6 = /* @__PURE__ */ __name(async () => {
      let version7 = null;
      if (isLinux()) {
        version7 = await versionFromFilesystem();
        if (!version7) {
          version7 = versionFromReport();
        }
        if (!version7) {
          const out = await safeCommand();
          version7 = versionFromCommand(out);
        }
      }
      return version7;
    }, "version");
    var versionSync = /* @__PURE__ */ __name(() => {
      let version7 = null;
      if (isLinux()) {
        version7 = versionFromFilesystemSync();
        if (!version7) {
          version7 = versionFromReport();
        }
        if (!version7) {
          const out = safeCommandSync();
          version7 = versionFromCommand(out);
        }
      }
      return version7;
    }, "versionSync");
    module.exports = {
      GLIBC,
      MUSL,
      family,
      familySync,
      isNonGlibcLinux,
      isNonGlibcLinuxSync,
      version: version6,
      versionSync
    };
  }
});

// node-built-in-modules:node:child_process
var require_node_child_process = __commonJS({
  "node-built-in-modules:node:child_process"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_child_process();
    module.exports = child_process_default;
  }
});

// node-built-in-modules:node:crypto
import libDefault5 from "node:crypto";
var require_node_crypto = __commonJS({
  "node-built-in-modules:node:crypto"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault5;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/debug.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var debug5 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug5;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/constants.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/re.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants2();
    var debug5 = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t4 = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = /* @__PURE__ */ __name((value2) => {
      for (const [token, max2] of safeRegexReplacements) {
        value2 = value2.split(`${token}*`).join(`${token}{0,${max2}}`).split(`${token}+`).join(`${token}{1,${max2}}`);
      }
      return value2;
    }, "makeSafeRegex");
    var createToken = /* @__PURE__ */ __name((name, value2, isGlobal) => {
      const safe = makeSafeRegex(value2);
      const index2 = R++;
      debug5(name, index2, value2);
      t4[name] = index2;
      src[index2] = value2;
      safeSrc[index2] = safe;
      re[index2] = new RegExp(value2, isGlobal ? "g" : void 0);
      safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
    }, "createToken");
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t4.NUMERICIDENTIFIER]})\\.(${src[t4.NUMERICIDENTIFIER]})\\.(${src[t4.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t4.NUMERICIDENTIFIERLOOSE]})\\.(${src[t4.NUMERICIDENTIFIERLOOSE]})\\.(${src[t4.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t4.NONNUMERICIDENTIFIER]}|${src[t4.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t4.NONNUMERICIDENTIFIER]}|${src[t4.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t4.PRERELEASEIDENTIFIER]}(?:\\.${src[t4.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t4.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t4.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t4.BUILDIDENTIFIER]}(?:\\.${src[t4.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t4.MAINVERSION]}${src[t4.PRERELEASE]}?${src[t4.BUILD]}?`);
    createToken("FULL", `^${src[t4.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t4.MAINVERSIONLOOSE]}${src[t4.PRERELEASELOOSE]}?${src[t4.BUILD]}?`);
    createToken("LOOSE", `^${src[t4.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t4.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t4.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t4.XRANGEIDENTIFIER]})(?:\\.(${src[t4.XRANGEIDENTIFIER]})(?:\\.(${src[t4.XRANGEIDENTIFIER]})(?:${src[t4.PRERELEASE]})?${src[t4.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t4.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t4.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t4.XRANGEIDENTIFIERLOOSE]})(?:${src[t4.PRERELEASELOOSE]})?${src[t4.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t4.GTLT]}\\s*${src[t4.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t4.GTLT]}\\s*${src[t4.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t4.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t4.COERCEPLAIN] + `(?:${src[t4.PRERELEASE]})?(?:${src[t4.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t4.COERCE], true);
    createToken("COERCERTLFULL", src[t4.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t4.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t4.LONETILDE]}${src[t4.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t4.LONETILDE]}${src[t4.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t4.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t4.LONECARET]}${src[t4.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t4.LONECARET]}${src[t4.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t4.GTLT]}\\s*(${src[t4.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t4.GTLT]}\\s*(${src[t4.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t4.GTLT]}\\s*(${src[t4.LOOSEPLAIN]}|${src[t4.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t4.XRANGEPLAIN]})\\s+-\\s+(${src[t4.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t4.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t4.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/parse-options.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = /* @__PURE__ */ __name((options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    }, "parseOptions");
    module.exports = parseOptions;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/identifiers.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = /* @__PURE__ */ __name((a4, b3) => {
      if (typeof a4 === "number" && typeof b3 === "number") {
        return a4 === b3 ? 0 : a4 < b3 ? -1 : 1;
      }
      const anum = numeric.test(a4);
      const bnum = numeric.test(b3);
      if (anum && bnum) {
        a4 = +a4;
        b3 = +b3;
      }
      return a4 === b3 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a4 < b3 ? -1 : 1;
    }, "compareIdentifiers");
    var rcompareIdentifiers = /* @__PURE__ */ __name((a4, b3) => compareIdentifiers(b3, a4), "rcompareIdentifiers");
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/semver.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var debug5 = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
    var { safeRe: re, t: t4 } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      static {
        __name(this, "SemVer");
      }
      constructor(version6, options) {
        options = parseOptions(options);
        if (version6 instanceof _SemVer) {
          if (version6.loose === !!options.loose && version6.includePrerelease === !!options.includePrerelease) {
            return version6;
          } else {
            version6 = version6.version;
          }
        } else if (typeof version6 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version6}".`);
        }
        if (version6.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug5("SemVer", version6, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m3 = version6.trim().match(options.loose ? re[t4.LOOSE] : re[t4.FULL]);
        if (!m3) {
          throw new TypeError(`Invalid Version: ${version6}`);
        }
        this.raw = version6;
        this.major = +m3[1];
        this.minor = +m3[2];
        this.patch = +m3[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m3[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m3[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m3[5] ? m3[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug5("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.major < other.major) {
          return -1;
        }
        if (this.major > other.major) {
          return 1;
        }
        if (this.minor < other.minor) {
          return -1;
        }
        if (this.minor > other.minor) {
          return 1;
        }
        if (this.patch < other.patch) {
          return -1;
        }
        if (this.patch > other.patch) {
          return 1;
        }
        return 0;
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i2 = 0;
        do {
          const a4 = this.prerelease[i2];
          const b3 = other.prerelease[i2];
          debug5("prerelease compare", i2, a4, b3);
          if (a4 === void 0 && b3 === void 0) {
            return 0;
          } else if (b3 === void 0) {
            return 1;
          } else if (a4 === void 0) {
            return -1;
          } else if (a4 === b3) {
            continue;
          } else {
            return compareIdentifiers(a4, b3);
          }
        } while (++i2);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i2 = 0;
        do {
          const a4 = this.build[i2];
          const b3 = other.build[i2];
          debug5("build compare", i2, a4, b3);
          if (a4 === void 0 && b3 === void 0) {
            return 0;
          } else if (b3 === void 0) {
            return 1;
          } else if (a4 === void 0) {
            return -1;
          } else if (a4 === b3) {
            continue;
          } else {
            return compareIdentifiers(a4, b3);
          }
        } while (++i2);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release5, identifier, identifierBase) {
        if (release5.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match2 = `-${identifier}`.match(this.options.loose ? re[t4.PRERELEASELOOSE] : re[t4.PRERELEASE]);
            if (!match2 || match2[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release5) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i2 = this.prerelease.length;
              while (--i2 >= 0) {
                if (typeof this.prerelease[i2] === "number") {
                  this.prerelease[i2]++;
                  i2 = -2;
                }
              }
              if (i2 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release5}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/parse.js
var require_parse2 = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/parse.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var parse3 = /* @__PURE__ */ __name((version6, options, throwErrors = false) => {
      if (version6 instanceof SemVer) {
        return version6;
      }
      try {
        return new SemVer(version6, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    }, "parse");
    module.exports = parse3;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/coerce.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var parse3 = require_parse2();
    var { safeRe: re, t: t4 } = require_re();
    var coerce = /* @__PURE__ */ __name((version6, options) => {
      if (version6 instanceof SemVer) {
        return version6;
      }
      if (typeof version6 === "number") {
        version6 = String(version6);
      }
      if (typeof version6 !== "string") {
        return null;
      }
      options = options || {};
      let match2 = null;
      if (!options.rtl) {
        match2 = version6.match(options.includePrerelease ? re[t4.COERCEFULL] : re[t4.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t4.COERCERTLFULL] : re[t4.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version6)) && (!match2 || match2.index + match2[0].length !== version6.length)) {
          if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
            match2 = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match2 === null) {
        return null;
      }
      const major2 = match2[2];
      const minor2 = match2[3] || "0";
      const patch = match2[4] || "0";
      const prerelease = options.includePrerelease && match2[5] ? `-${match2[5]}` : "";
      const build = options.includePrerelease && match2[6] ? `+${match2[6]}` : "";
      return parse3(`${major2}.${minor2}.${patch}${prerelease}${build}`, options);
    }, "coerce");
    module.exports = coerce;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var compare9 = /* @__PURE__ */ __name((a4, b3, loose) => new SemVer(a4, loose).compare(new SemVer(b3, loose)), "compare");
    module.exports = compare9;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gte.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare9 = require_compare();
    var gte = /* @__PURE__ */ __name((a4, b3, loose) => compare9(a4, b3, loose) >= 0, "gte");
    module.exports = gte;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/lrucache.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var LRUCache = class {
      static {
        __name(this, "LRUCache");
      }
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value2 = this.map.get(key);
        if (value2 === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value2);
          return value2;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value2) {
        const deleted = this.delete(key);
        if (!deleted && value2 !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value2);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/eq.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare9 = require_compare();
    var eq = /* @__PURE__ */ __name((a4, b3, loose) => compare9(a4, b3, loose) === 0, "eq");
    module.exports = eq;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/neq.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare9 = require_compare();
    var neq = /* @__PURE__ */ __name((a4, b3, loose) => compare9(a4, b3, loose) !== 0, "neq");
    module.exports = neq;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gt.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare9 = require_compare();
    var gt = /* @__PURE__ */ __name((a4, b3, loose) => compare9(a4, b3, loose) > 0, "gt");
    module.exports = gt;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lt.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare9 = require_compare();
    var lt = /* @__PURE__ */ __name((a4, b3, loose) => compare9(a4, b3, loose) < 0, "lt");
    module.exports = lt;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lte.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare9 = require_compare();
    var lte = /* @__PURE__ */ __name((a4, b3, loose) => compare9(a4, b3, loose) <= 0, "lte");
    module.exports = lte;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/cmp.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = /* @__PURE__ */ __name((a4, op, b3, loose) => {
      switch (op) {
        case "===":
          if (typeof a4 === "object") {
            a4 = a4.version;
          }
          if (typeof b3 === "object") {
            b3 = b3.version;
          }
          return a4 === b3;
        case "!==":
          if (typeof a4 === "object") {
            a4 = a4.version;
          }
          if (typeof b3 === "object") {
            b3 = b3.version;
          }
          return a4 !== b3;
        case "":
        case "=":
        case "==":
          return eq(a4, b3, loose);
        case "!=":
          return neq(a4, b3, loose);
        case ">":
          return gt(a4, b3, loose);
        case ">=":
          return gte(a4, b3, loose);
        case "<":
          return lt(a4, b3, loose);
        case "<=":
          return lte(a4, b3, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    }, "cmp");
    module.exports = cmp;
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/comparator.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static {
        __name(this, "Comparator");
      }
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug5("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug5("comp", this);
      }
      parse(comp) {
        const r5 = this.options.loose ? re[t4.COMPARATORLOOSE] : re[t4.COMPARATOR];
        const m3 = comp.match(r5);
        if (!m3) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m3[1] !== void 0 ? m3[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m3[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m3[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version6) {
        debug5("Comparator.test", version6, this.options.loose);
        if (this.semver === ANY || version6 === ANY) {
          return true;
        }
        if (typeof version6 === "string") {
          try {
            version6 = new SemVer(version6, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version6, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t: t4 } = require_re();
    var cmp = require_cmp();
    var debug5 = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/range.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      static {
        __name(this, "Range");
      }
      constructor(range2, options) {
        options = parseOptions(options);
        if (range2 instanceof _Range) {
          if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
            return range2;
          } else {
            return new _Range(range2.raw, options);
          }
        }
        if (range2 instanceof Comparator) {
          this.raw = range2.value;
          this.set = [[range2]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r5) => this.parseRange(r5.trim())).filter((c2) => c2.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c2) => !isNullSet(c2[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c2 of this.set) {
              if (c2.length === 1 && isAny(c2[0])) {
                this.set = [c2];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i2 = 0; i2 < this.set.length; i2++) {
            if (i2 > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i2];
            for (let k3 = 0; k3 < comps.length; k3++) {
              if (k3 > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k3].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range2) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range2;
        const cached = cache2.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t4.HYPHENRANGELOOSE] : re[t4.HYPHENRANGE];
        range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug5("hyphen replace", range2);
        range2 = range2.replace(re[t4.COMPARATORTRIM], comparatorTrimReplace);
        debug5("comparator trim", range2);
        range2 = range2.replace(re[t4.TILDETRIM], tildeTrimReplace);
        debug5("tilde trim", range2);
        range2 = range2.replace(re[t4.CARETTRIM], caretTrimReplace);
        debug5("caret trim", range2);
        let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug5("loose invalid filter", comp, this.options);
            return !!comp.match(re[t4.COMPARATORLOOSE]);
          });
        }
        debug5("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache2.set(memoKey, result);
        return result;
      }
      intersects(range2, options) {
        if (!(range2 instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version6) {
        if (!version6) {
          return false;
        }
        if (typeof version6 === "string") {
          try {
            version6 = new SemVer(version6, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i2 = 0; i2 < this.set.length; i2++) {
          if (testSet(this.set[i2], version6, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache2 = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug5 = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t: t4,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
    var isNullSet = /* @__PURE__ */ __name((c2) => c2.value === "<0.0.0-0", "isNullSet");
    var isAny = /* @__PURE__ */ __name((c2) => c2.value === "", "isAny");
    var isSatisfiable = /* @__PURE__ */ __name((comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }, "isSatisfiable");
    var parseComparator = /* @__PURE__ */ __name((comp, options) => {
      comp = comp.replace(re[t4.BUILD], "");
      debug5("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug5("caret", comp);
      comp = replaceTildes(comp, options);
      debug5("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug5("xrange", comp);
      comp = replaceStars(comp, options);
      debug5("stars", comp);
      return comp;
    }, "parseComparator");
    var isX = /* @__PURE__ */ __name((id) => !id || id.toLowerCase() === "x" || id === "*", "isX");
    var replaceTildes = /* @__PURE__ */ __name((comp, options) => {
      return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options)).join(" ");
    }, "replaceTildes");
    var replaceTilde = /* @__PURE__ */ __name((comp, options) => {
      const r5 = options.loose ? re[t4.TILDELOOSE] : re[t4.TILDE];
      return comp.replace(r5, (_, M, m3, p3, pr) => {
        debug5("tilde", comp, _, M, m3, p3, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m3)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p3)) {
          ret = `>=${M}.${m3}.0 <${M}.${+m3 + 1}.0-0`;
        } else if (pr) {
          debug5("replaceTilde pr", pr);
          ret = `>=${M}.${m3}.${p3}-${pr} <${M}.${+m3 + 1}.0-0`;
        } else {
          ret = `>=${M}.${m3}.${p3} <${M}.${+m3 + 1}.0-0`;
        }
        debug5("tilde return", ret);
        return ret;
      });
    }, "replaceTilde");
    var replaceCarets = /* @__PURE__ */ __name((comp, options) => {
      return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options)).join(" ");
    }, "replaceCarets");
    var replaceCaret = /* @__PURE__ */ __name((comp, options) => {
      debug5("caret", comp, options);
      const r5 = options.loose ? re[t4.CARETLOOSE] : re[t4.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r5, (_, M, m3, p3, pr) => {
        debug5("caret", comp, _, M, m3, p3, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m3)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p3)) {
          if (M === "0") {
            ret = `>=${M}.${m3}.0${z} <${M}.${+m3 + 1}.0-0`;
          } else {
            ret = `>=${M}.${m3}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug5("replaceCaret pr", pr);
          if (M === "0") {
            if (m3 === "0") {
              ret = `>=${M}.${m3}.${p3}-${pr} <${M}.${m3}.${+p3 + 1}-0`;
            } else {
              ret = `>=${M}.${m3}.${p3}-${pr} <${M}.${+m3 + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m3}.${p3}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug5("no pr");
          if (M === "0") {
            if (m3 === "0") {
              ret = `>=${M}.${m3}.${p3}${z} <${M}.${m3}.${+p3 + 1}-0`;
            } else {
              ret = `>=${M}.${m3}.${p3}${z} <${M}.${+m3 + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m3}.${p3} <${+M + 1}.0.0-0`;
          }
        }
        debug5("caret return", ret);
        return ret;
      });
    }, "replaceCaret");
    var replaceXRanges = /* @__PURE__ */ __name((comp, options) => {
      debug5("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c2) => replaceXRange(c2, options)).join(" ");
    }, "replaceXRanges");
    var replaceXRange = /* @__PURE__ */ __name((comp, options) => {
      comp = comp.trim();
      const r5 = options.loose ? re[t4.XRANGELOOSE] : re[t4.XRANGE];
      return comp.replace(r5, (ret, gtlt, M, m3, p3, pr) => {
        debug5("xRange", comp, ret, gtlt, M, m3, p3, pr);
        const xM = isX(M);
        const xm = xM || isX(m3);
        const xp = xm || isX(p3);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m3 = 0;
          }
          p3 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m3 = 0;
              p3 = 0;
            } else {
              m3 = +m3 + 1;
              p3 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m3 = +m3 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m3}.${p3}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m3}.0${pr} <${M}.${+m3 + 1}.0-0`;
        }
        debug5("xRange return", ret);
        return ret;
      });
    }, "replaceXRange");
    var replaceStars = /* @__PURE__ */ __name((comp, options) => {
      debug5("replaceStars", comp, options);
      return comp.trim().replace(re[t4.STAR], "");
    }, "replaceStars");
    var replaceGTE0 = /* @__PURE__ */ __name((comp, options) => {
      debug5("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t4.GTE0PRE : t4.GTE0], "");
    }, "replaceGTE0");
    var hyphenReplace = /* @__PURE__ */ __name((incPr) => ($0, from4, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from4 = "";
      } else if (isX(fm)) {
        from4 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from4 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from4 = `>=${from4}`;
      } else {
        from4 = `>=${from4}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from4} ${to}`.trim();
    }, "hyphenReplace");
    var testSet = /* @__PURE__ */ __name((set5, version6, options) => {
      for (let i2 = 0; i2 < set5.length; i2++) {
        if (!set5[i2].test(version6)) {
          return false;
        }
      }
      if (version6.prerelease.length && !options.includePrerelease) {
        for (let i2 = 0; i2 < set5.length; i2++) {
          debug5(set5[i2].semver);
          if (set5[i2].semver === Comparator.ANY) {
            continue;
          }
          if (set5[i2].semver.prerelease.length > 0) {
            const allowed = set5[i2].semver;
            if (allowed.major === version6.major && allowed.minor === version6.minor && allowed.patch === version6.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }, "testSet");
  }
});

// ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/satisfies.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var satisfies = /* @__PURE__ */ __name((version6, range2, options) => {
      try {
        range2 = new Range(range2, options);
      } catch (er) {
        return false;
      }
      return range2.test(version6);
    }, "satisfies");
    module.exports = satisfies;
  }
});

// ../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/package.json
var require_package = __commonJS({
  "../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/package.json"(exports, module) {
    module.exports = {
      name: "sharp",
      description: "High performance Node.js image processing, the fastest module to resize JPEG, PNG, WebP, GIF, AVIF and TIFF images",
      version: "0.34.5",
      author: "Lovell Fuller <npm@lovell.info>",
      homepage: "https://sharp.pixelplumbing.com",
      contributors: [
        "Pierre Inglebert <pierre.inglebert@gmail.com>",
        "Jonathan Ong <jonathanrichardong@gmail.com>",
        "Chanon Sajjamanochai <chanon.s@gmail.com>",
        "Juliano Julio <julianojulio@gmail.com>",
        "Daniel Gasienica <daniel@gasienica.ch>",
        "Julian Walker <julian@fiftythree.com>",
        "Amit Pitaru <pitaru.amit@gmail.com>",
        "Brandon Aaron <hello.brandon@aaron.sh>",
        "Andreas Lind <andreas@one.com>",
        "Maurus Cuelenaere <mcuelenaere@gmail.com>",
        "Linus Unneb\xE4ck <linus@folkdatorn.se>",
        "Victor Mateevitsi <mvictoras@gmail.com>",
        "Alaric Holloway <alaric.holloway@gmail.com>",
        "Bernhard K. Weisshuhn <bkw@codingforce.com>",
        "Chris Riley <criley@primedia.com>",
        "David Carley <dacarley@gmail.com>",
        "John Tobin <john@limelightmobileinc.com>",
        "Kenton Gray <kentongray@gmail.com>",
        "Felix B\xFCnemann <Felix.Buenemann@gmail.com>",
        "Samy Al Zahrani <samyalzahrany@gmail.com>",
        "Chintan Thakkar <lemnisk8@gmail.com>",
        "F. Orlando Galashan <frulo@gmx.de>",
        "Kleis Auke Wolthuizen <info@kleisauke.nl>",
        "Matt Hirsch <mhirsch@media.mit.edu>",
        "Matthias Thoemmes <thoemmes@gmail.com>",
        "Patrick Paskaris <patrick@paskaris.gr>",
        "J\xE9r\xE9my Lal <kapouer@melix.org>",
        "Rahul Nanwani <r.nanwani@gmail.com>",
        "Alice Monday <alice0meta@gmail.com>",
        "Kristo Jorgenson <kristo.jorgenson@gmail.com>",
        "YvesBos <yves_bos@outlook.com>",
        "Guy Maliar <guy@tailorbrands.com>",
        "Nicolas Coden <nicolas@ncoden.fr>",
        "Matt Parrish <matt.r.parrish@gmail.com>",
        "Marcel Bretschneider <marcel.bretschneider@gmail.com>",
        "Matthew McEachen <matthew+github@mceachen.org>",
        "Jarda Kot\u011B\u0161ovec <jarda.kotesovec@gmail.com>",
        "Kenric D'Souza <kenric.dsouza@gmail.com>",
        "Oleh Aleinyk <oleg.aleynik@gmail.com>",
        "Marcel Bretschneider <marcel.bretschneider@gmail.com>",
        "Andrea Bianco <andrea.bianco@unibas.ch>",
        "Rik Heywood <rik@rik.org>",
        "Thomas Parisot <hi@oncletom.io>",
        "Nathan Graves <nathanrgraves+github@gmail.com>",
        "Tom Lokhorst <tom@lokhorst.eu>",
        "Espen Hovlandsdal <espen@hovlandsdal.com>",
        "Sylvain Dumont <sylvain.dumont35@gmail.com>",
        "Alun Davies <alun.owain.davies@googlemail.com>",
        "Aidan Hoolachan <ajhoolachan21@gmail.com>",
        "Axel Eirola <axel.eirola@iki.fi>",
        "Freezy <freezy@xbmc.org>",
        "Daiz <taneli.vatanen@gmail.com>",
        "Julian Aubourg <j@ubourg.net>",
        "Keith Belovay <keith@picthrive.com>",
        "Michael B. Klein <mbklein@gmail.com>",
        "Jordan Prudhomme <jordan@raboland.fr>",
        "Ilya Ovdin <iovdin@gmail.com>",
        "Andargor <andargor@yahoo.com>",
        "Paul Neave <paul.neave@gmail.com>",
        "Brendan Kennedy <brenwken@gmail.com>",
        "Brychan Bennett-Odlum <git@brychan.io>",
        "Edward Silverton <e.silverton@gmail.com>",
        "Roman Malieiev <aromaleev@gmail.com>",
        "Tomas Szabo <tomas.szabo@deftomat.com>",
        "Robert O'Rourke <robert@o-rourke.org>",
        "Guillermo Alfonso Varela Chouci\xF1o <guillevch@gmail.com>",
        "Christian Flintrup <chr@gigahost.dk>",
        "Manan Jadhav <manan@motionden.com>",
        "Leon Radley <leon@radley.se>",
        "alza54 <alza54@thiocod.in>",
        "Jacob Smith <jacob@frende.me>",
        "Michael Nutt <michael@nutt.im>",
        "Brad Parham <baparham@gmail.com>",
        "Taneli Vatanen <taneli.vatanen@gmail.com>",
        "Joris Dugu\xE9 <zaruike10@gmail.com>",
        "Chris Banks <christopher.bradley.banks@gmail.com>",
        "Ompal Singh <ompal.hitm09@gmail.com>",
        "Brodan <christopher.hranj@gmail.com>",
        "Ankur Parihar <ankur.github@gmail.com>",
        "Brahim Ait elhaj <brahima@gmail.com>",
        "Mart Jansink <m.jansink@gmail.com>",
        "Lachlan Newman <lachnewman007@gmail.com>",
        "Dennis Beatty <dennis@dcbeatty.com>",
        "Ingvar Stepanyan <me@rreverser.com>",
        "Don Denton <don@happycollision.com>"
      ],
      scripts: {
        build: "node install/build.js",
        install: "node install/check.js || npm run build",
        clean: "rm -rf src/build/ .nyc_output/ coverage/ test/fixtures/output.*",
        test: "npm run lint && npm run test-unit",
        lint: "npm run lint-cpp && npm run lint-js && npm run lint-types",
        "lint-cpp": "cpplint --quiet src/*.h src/*.cc",
        "lint-js": "biome lint",
        "lint-types": "tsd --files ./test/types/sharp.test-d.ts",
        "test-leak": "./test/leak/leak.sh",
        "test-unit": "node --experimental-test-coverage test/unit.mjs",
        "package-from-local-build": "node npm/from-local-build.js",
        "package-release-notes": "node npm/release-notes.js",
        "docs-build": "node docs/build.mjs",
        "docs-serve": "cd docs && npm start",
        "docs-publish": "cd docs && npm run build && npx firebase-tools deploy --project pixelplumbing --only hosting:pixelplumbing-sharp"
      },
      type: "commonjs",
      main: "lib/index.js",
      types: "lib/index.d.ts",
      files: [
        "install",
        "lib",
        "src/*.{cc,h,gyp}"
      ],
      repository: {
        type: "git",
        url: "git://github.com/lovell/sharp.git"
      },
      keywords: [
        "jpeg",
        "png",
        "webp",
        "avif",
        "tiff",
        "gif",
        "svg",
        "jp2",
        "dzi",
        "image",
        "resize",
        "thumbnail",
        "crop",
        "embed",
        "libvips",
        "vips"
      ],
      dependencies: {
        "@img/colour": "^1.0.0",
        "detect-libc": "^2.1.2",
        semver: "^7.7.3"
      },
      optionalDependencies: {
        "@img/sharp-darwin-arm64": "0.34.5",
        "@img/sharp-darwin-x64": "0.34.5",
        "@img/sharp-libvips-darwin-arm64": "1.2.4",
        "@img/sharp-libvips-darwin-x64": "1.2.4",
        "@img/sharp-libvips-linux-arm": "1.2.4",
        "@img/sharp-libvips-linux-arm64": "1.2.4",
        "@img/sharp-libvips-linux-ppc64": "1.2.4",
        "@img/sharp-libvips-linux-riscv64": "1.2.4",
        "@img/sharp-libvips-linux-s390x": "1.2.4",
        "@img/sharp-libvips-linux-x64": "1.2.4",
        "@img/sharp-libvips-linuxmusl-arm64": "1.2.4",
        "@img/sharp-libvips-linuxmusl-x64": "1.2.4",
        "@img/sharp-linux-arm": "0.34.5",
        "@img/sharp-linux-arm64": "0.34.5",
        "@img/sharp-linux-ppc64": "0.34.5",
        "@img/sharp-linux-riscv64": "0.34.5",
        "@img/sharp-linux-s390x": "0.34.5",
        "@img/sharp-linux-x64": "0.34.5",
        "@img/sharp-linuxmusl-arm64": "0.34.5",
        "@img/sharp-linuxmusl-x64": "0.34.5",
        "@img/sharp-wasm32": "0.34.5",
        "@img/sharp-win32-arm64": "0.34.5",
        "@img/sharp-win32-ia32": "0.34.5",
        "@img/sharp-win32-x64": "0.34.5"
      },
      devDependencies: {
        "@biomejs/biome": "^2.3.4",
        "@cpplint/cli": "^0.1.0",
        "@emnapi/runtime": "^1.7.0",
        "@img/sharp-libvips-dev": "1.2.4",
        "@img/sharp-libvips-dev-wasm32": "1.2.4",
        "@img/sharp-libvips-win32-arm64": "1.2.4",
        "@img/sharp-libvips-win32-ia32": "1.2.4",
        "@img/sharp-libvips-win32-x64": "1.2.4",
        "@types/node": "*",
        emnapi: "^1.7.0",
        "exif-reader": "^2.0.2",
        "extract-zip": "^2.0.1",
        icc: "^3.0.0",
        "jsdoc-to-markdown": "^9.1.3",
        "node-addon-api": "^8.5.0",
        "node-gyp": "^11.5.0",
        "tar-fs": "^3.1.1",
        tsd: "^0.33.0"
      },
      license: "Apache-2.0",
      engines: {
        node: "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      config: {
        libvips: ">=8.17.3"
      },
      funding: {
        url: "https://opencollective.com/libvips"
      }
    };
  }
});

// ../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/libvips.js
var require_libvips = __commonJS({
  "../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/libvips.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { spawnSync: spawnSync2 } = require_node_child_process();
    var { createHash } = require_node_crypto();
    var semverCoerce = require_coerce();
    var semverGreaterThanOrEqualTo = require_gte();
    var semverSatisfies = require_satisfies();
    var detectLibc = require_detect_libc();
    var { config: config4, engines: engines2, optionalDependencies } = require_package();
    var minimumLibvipsVersionLabelled = process.env.npm_package_config_libvips || config4.libvips;
    var minimumLibvipsVersion = semverCoerce(minimumLibvipsVersionLabelled).version;
    var prebuiltPlatforms = [
      "darwin-arm64",
      "darwin-x64",
      "linux-arm",
      "linux-arm64",
      "linux-ppc64",
      "linux-riscv64",
      "linux-s390x",
      "linux-x64",
      "linuxmusl-arm64",
      "linuxmusl-x64",
      "win32-arm64",
      "win32-ia32",
      "win32-x64"
    ];
    var spawnSyncOptions = {
      encoding: "utf8",
      shell: true
    };
    var log5 = /* @__PURE__ */ __name((item) => {
      if (item instanceof Error) {
        console.error(`sharp: Installation error: ${item.message}`);
      } else {
        console.log(`sharp: ${item}`);
      }
    }, "log");
    var runtimeLibc = /* @__PURE__ */ __name(() => detectLibc.isNonGlibcLinuxSync() ? detectLibc.familySync() : "", "runtimeLibc");
    var runtimePlatformArch = /* @__PURE__ */ __name(() => `${process.platform}${runtimeLibc()}-${process.arch}`, "runtimePlatformArch");
    var buildPlatformArch = /* @__PURE__ */ __name(() => {
      if (isEmscripten()) {
        return "wasm32";
      }
      const { npm_config_arch, npm_config_platform, npm_config_libc } = process.env;
      const libc = typeof npm_config_libc === "string" ? npm_config_libc : runtimeLibc();
      return `${npm_config_platform || process.platform}${libc}-${npm_config_arch || process.arch}`;
    }, "buildPlatformArch");
    var buildSharpLibvipsIncludeDir = /* @__PURE__ */ __name(() => {
      try {
        return __require(`@img/sharp-libvips-dev-${buildPlatformArch()}/include`);
      } catch {
        try {
          return __require("@img/sharp-libvips-dev/include");
        } catch {
        }
      }
      return "";
    }, "buildSharpLibvipsIncludeDir");
    var buildSharpLibvipsCPlusPlusDir = /* @__PURE__ */ __name(() => {
      try {
        return __require("@img/sharp-libvips-dev/cplusplus");
      } catch {
      }
      return "";
    }, "buildSharpLibvipsCPlusPlusDir");
    var buildSharpLibvipsLibDir = /* @__PURE__ */ __name(() => {
      try {
        return __require(`@img/sharp-libvips-dev-${buildPlatformArch()}/lib`);
      } catch {
        try {
          return __require(`@img/sharp-libvips-${buildPlatformArch()}/lib`);
        } catch {
        }
      }
      return "";
    }, "buildSharpLibvipsLibDir");
    var isUnsupportedNodeRuntime = /* @__PURE__ */ __name(() => {
      if (process.release?.name === "node" && process.versions) {
        if (!semverSatisfies(process.versions.node, engines2.node)) {
          return { found: process.versions.node, expected: engines2.node };
        }
      }
    }, "isUnsupportedNodeRuntime");
    var isEmscripten = /* @__PURE__ */ __name(() => {
      const { CC } = process.env;
      return Boolean(CC?.endsWith("/emcc"));
    }, "isEmscripten");
    var isRosetta = /* @__PURE__ */ __name(() => {
      if (process.platform === "darwin" && process.arch === "x64") {
        const translated = spawnSync2("sysctl sysctl.proc_translated", spawnSyncOptions).stdout;
        return (translated || "").trim() === "sysctl.proc_translated: 1";
      }
      return false;
    }, "isRosetta");
    var sha512 = /* @__PURE__ */ __name((s4) => createHash("sha512").update(s4).digest("hex"), "sha512");
    var yarnLocator = /* @__PURE__ */ __name(() => {
      try {
        const identHash = sha512(`imgsharp-libvips-${buildPlatformArch()}`);
        const npmVersion = semverCoerce(optionalDependencies[`@img/sharp-libvips-${buildPlatformArch()}`], {
          includePrerelease: true
        }).version;
        return sha512(`${identHash}npm:${npmVersion}`).slice(0, 10);
      } catch {
      }
      return "";
    }, "yarnLocator");
    var spawnRebuild = /* @__PURE__ */ __name(() => spawnSync2(`node-gyp rebuild --directory=src ${isEmscripten() ? "--nodedir=emscripten" : ""}`, {
      ...spawnSyncOptions,
      stdio: "inherit"
    }).status, "spawnRebuild");
    var globalLibvipsVersion = /* @__PURE__ */ __name(() => {
      if (process.platform !== "win32") {
        const globalLibvipsVersion2 = spawnSync2("pkg-config --modversion vips-cpp", {
          ...spawnSyncOptions,
          env: {
            ...process.env,
            PKG_CONFIG_PATH: pkgConfigPath()
          }
        }).stdout;
        return (globalLibvipsVersion2 || "").trim();
      } else {
        return "";
      }
    }, "globalLibvipsVersion");
    var pkgConfigPath = /* @__PURE__ */ __name(() => {
      if (process.platform !== "win32") {
        const brewPkgConfigPath = spawnSync2(
          'which brew >/dev/null 2>&1 && brew environment --plain | grep PKG_CONFIG_LIBDIR | cut -d" " -f2',
          spawnSyncOptions
        ).stdout || "";
        return [
          brewPkgConfigPath.trim(),
          process.env.PKG_CONFIG_PATH,
          "/usr/local/lib/pkgconfig",
          "/usr/lib/pkgconfig",
          "/usr/local/libdata/pkgconfig",
          "/usr/libdata/pkgconfig"
        ].filter(Boolean).join(":");
      } else {
        return "";
      }
    }, "pkgConfigPath");
    var skipSearch = /* @__PURE__ */ __name((status, reason, logger) => {
      if (logger) {
        logger(`Detected ${reason}, skipping search for globally-installed libvips`);
      }
      return status;
    }, "skipSearch");
    var useGlobalLibvips = /* @__PURE__ */ __name((logger) => {
      if (Boolean(process.env.SHARP_IGNORE_GLOBAL_LIBVIPS) === true) {
        return skipSearch(false, "SHARP_IGNORE_GLOBAL_LIBVIPS", logger);
      }
      if (Boolean(process.env.SHARP_FORCE_GLOBAL_LIBVIPS) === true) {
        return skipSearch(true, "SHARP_FORCE_GLOBAL_LIBVIPS", logger);
      }
      if (isRosetta()) {
        return skipSearch(false, "Rosetta", logger);
      }
      const globalVipsVersion = globalLibvipsVersion();
      return !!globalVipsVersion && semverGreaterThanOrEqualTo(globalVipsVersion, minimumLibvipsVersion);
    }, "useGlobalLibvips");
    module.exports = {
      minimumLibvipsVersion,
      prebuiltPlatforms,
      buildPlatformArch,
      buildSharpLibvipsIncludeDir,
      buildSharpLibvipsCPlusPlusDir,
      buildSharpLibvipsLibDir,
      isUnsupportedNodeRuntime,
      runtimePlatformArch,
      log: log5,
      yarnLocator,
      spawnRebuild,
      globalLibvipsVersion,
      pkgConfigPath,
      useGlobalLibvips
    };
  }
});

// ../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/sharp.js
var require_sharp = __commonJS({
  "../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/sharp.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { familySync, versionSync } = require_detect_libc();
    var { runtimePlatformArch, isUnsupportedNodeRuntime, prebuiltPlatforms, minimumLibvipsVersion } = require_libvips();
    var runtimePlatform = runtimePlatformArch();
    var paths = [
      `../src/build/Release/sharp-${runtimePlatform}.node`,
      "../src/build/Release/sharp-wasm32.node",
      `@img/sharp-${runtimePlatform}/sharp.node`,
      "@img/sharp-wasm32/sharp.node"
    ];
    var path;
    var sharp2;
    var errors = [];
    for (path of paths) {
      try {
        sharp2 = __require(path);
        break;
      } catch (err2) {
        errors.push(err2);
      }
    }
    if (sharp2 && path.startsWith("@img/sharp-linux-x64") && !sharp2._isUsingX64V2()) {
      const err2 = new Error("Prebuilt binaries for linux-x64 require v2 microarchitecture");
      err2.code = "Unsupported CPU";
      errors.push(err2);
      sharp2 = null;
    }
    if (sharp2) {
      module.exports = sharp2;
    } else {
      const [isLinux, isMacOs, isWindows] = ["linux", "darwin", "win32"].map((os) => runtimePlatform.startsWith(os));
      const help = [`Could not load the "sharp" module using the ${runtimePlatform} runtime`];
      errors.forEach((err2) => {
        if (err2.code !== "MODULE_NOT_FOUND") {
          help.push(`${err2.code}: ${err2.message}`);
        }
      });
      const messages2 = errors.map((err2) => err2.message).join(" ");
      help.push("Possible solutions:");
      if (isUnsupportedNodeRuntime()) {
        const { found, expected } = isUnsupportedNodeRuntime();
        help.push(
          "- Please upgrade Node.js:",
          `    Found ${found}`,
          `    Requires ${expected}`
        );
      } else if (prebuiltPlatforms.includes(runtimePlatform)) {
        const [os, cpu] = runtimePlatform.split("-");
        const libc = os.endsWith("musl") ? " --libc=musl" : "";
        help.push(
          "- Ensure optional dependencies can be installed:",
          "    npm install --include=optional sharp",
          "- Ensure your package manager supports multi-platform installation:",
          "    See https://sharp.pixelplumbing.com/install#cross-platform",
          "- Add platform-specific dependencies:",
          `    npm install --os=${os.replace("musl", "")}${libc} --cpu=${cpu} sharp`
        );
      } else {
        help.push(
          `- Manually install libvips >= ${minimumLibvipsVersion}`,
          "- Add experimental WebAssembly-based dependencies:",
          "    npm install --cpu=wasm32 sharp",
          "    npm install @img/sharp-wasm32"
        );
      }
      if (isLinux && /(symbol not found|CXXABI_)/i.test(messages2)) {
        try {
          const { config: config4 } = __require(`@img/sharp-libvips-${runtimePlatform}/package`);
          const libcFound = `${familySync()} ${versionSync()}`;
          const libcRequires = `${config4.musl ? "musl" : "glibc"} ${config4.musl || config4.glibc}`;
          help.push(
            "- Update your OS:",
            `    Found ${libcFound}`,
            `    Requires ${libcRequires}`
          );
        } catch (_errEngines) {
        }
      }
      if (isLinux && /\/snap\/core[0-9]{2}/.test(messages2)) {
        help.push(
          "- Remove the Node.js Snap, which does not support native modules",
          "    snap remove node"
        );
      }
      if (isMacOs && /Incompatible library version/.test(messages2)) {
        help.push(
          "- Update Homebrew:",
          "    brew update && brew upgrade vips"
        );
      }
      if (errors.some((err2) => err2.code === "ERR_DLOPEN_DISABLED")) {
        help.push("- Run Node.js without using the --no-addons flag");
      }
      if (isWindows && /The specified procedure could not be found/.test(messages2)) {
        help.push(
          "- Using the canvas package on Windows?",
          "    See https://sharp.pixelplumbing.com/install#canvas-and-windows",
          "- Check for outdated versions of sharp in the dependency tree:",
          "    npm ls sharp"
        );
      }
      help.push(
        "- Consult the installation documentation:",
        "    See https://sharp.pixelplumbing.com/install"
      );
      throw new Error(help.join("\n"));
    }
  }
});

// ../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/constructor.js
var require_constructor = __commonJS({
  "../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/constructor.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var util = require_node_util();
    var stream2 = require_node_stream();
    var is = require_is();
    require_sharp();
    var debuglog3 = util.debuglog("sharp");
    var queueListener = /* @__PURE__ */ __name((queueLength) => {
      Sharp.queue.emit("change", queueLength);
    }, "queueListener");
    var Sharp = /* @__PURE__ */ __name(function(input, options) {
      if (arguments.length === 1 && !is.defined(input)) {
        throw new Error("Invalid input");
      }
      if (!(this instanceof Sharp)) {
        return new Sharp(input, options);
      }
      stream2.Duplex.call(this);
      this.options = {
        // resize options
        topOffsetPre: -1,
        leftOffsetPre: -1,
        widthPre: -1,
        heightPre: -1,
        topOffsetPost: -1,
        leftOffsetPost: -1,
        widthPost: -1,
        heightPost: -1,
        width: -1,
        height: -1,
        canvas: "crop",
        position: 0,
        resizeBackground: [0, 0, 0, 255],
        angle: 0,
        rotationAngle: 0,
        rotationBackground: [0, 0, 0, 255],
        rotateBefore: false,
        orientBefore: false,
        flip: false,
        flop: false,
        extendTop: 0,
        extendBottom: 0,
        extendLeft: 0,
        extendRight: 0,
        extendBackground: [0, 0, 0, 255],
        extendWith: "background",
        withoutEnlargement: false,
        withoutReduction: false,
        affineMatrix: [],
        affineBackground: [0, 0, 0, 255],
        affineIdx: 0,
        affineIdy: 0,
        affineOdx: 0,
        affineOdy: 0,
        affineInterpolator: this.constructor.interpolators.bilinear,
        kernel: "lanczos3",
        fastShrinkOnLoad: true,
        // operations
        tint: [-1, 0, 0, 0],
        flatten: false,
        flattenBackground: [0, 0, 0],
        unflatten: false,
        negate: false,
        negateAlpha: true,
        medianSize: 0,
        blurSigma: 0,
        precision: "integer",
        minAmpl: 0.2,
        sharpenSigma: 0,
        sharpenM1: 1,
        sharpenM2: 2,
        sharpenX1: 2,
        sharpenY2: 10,
        sharpenY3: 20,
        threshold: 0,
        thresholdGrayscale: true,
        trimBackground: [],
        trimThreshold: -1,
        trimLineArt: false,
        dilateWidth: 0,
        erodeWidth: 0,
        gamma: 0,
        gammaOut: 0,
        greyscale: false,
        normalise: false,
        normaliseLower: 1,
        normaliseUpper: 99,
        claheWidth: 0,
        claheHeight: 0,
        claheMaxSlope: 3,
        brightness: 1,
        saturation: 1,
        hue: 0,
        lightness: 0,
        booleanBufferIn: null,
        booleanFileIn: "",
        joinChannelIn: [],
        extractChannel: -1,
        removeAlpha: false,
        ensureAlpha: -1,
        colourspace: "srgb",
        colourspacePipeline: "last",
        composite: [],
        // output
        fileOut: "",
        formatOut: "input",
        streamOut: false,
        keepMetadata: 0,
        withMetadataOrientation: -1,
        withMetadataDensity: 0,
        withIccProfile: "",
        withExif: {},
        withExifMerge: true,
        withXmp: "",
        resolveWithObject: false,
        loop: -1,
        delay: [],
        // output format
        jpegQuality: 80,
        jpegProgressive: false,
        jpegChromaSubsampling: "4:2:0",
        jpegTrellisQuantisation: false,
        jpegOvershootDeringing: false,
        jpegOptimiseScans: false,
        jpegOptimiseCoding: true,
        jpegQuantisationTable: 0,
        pngProgressive: false,
        pngCompressionLevel: 6,
        pngAdaptiveFiltering: false,
        pngPalette: false,
        pngQuality: 100,
        pngEffort: 7,
        pngBitdepth: 8,
        pngDither: 1,
        jp2Quality: 80,
        jp2TileHeight: 512,
        jp2TileWidth: 512,
        jp2Lossless: false,
        jp2ChromaSubsampling: "4:4:4",
        webpQuality: 80,
        webpAlphaQuality: 100,
        webpLossless: false,
        webpNearLossless: false,
        webpSmartSubsample: false,
        webpSmartDeblock: false,
        webpPreset: "default",
        webpEffort: 4,
        webpMinSize: false,
        webpMixed: false,
        gifBitdepth: 8,
        gifEffort: 7,
        gifDither: 1,
        gifInterFrameMaxError: 0,
        gifInterPaletteMaxError: 3,
        gifKeepDuplicateFrames: false,
        gifReuse: true,
        gifProgressive: false,
        tiffQuality: 80,
        tiffCompression: "jpeg",
        tiffBigtiff: false,
        tiffPredictor: "horizontal",
        tiffPyramid: false,
        tiffMiniswhite: false,
        tiffBitdepth: 8,
        tiffTile: false,
        tiffTileHeight: 256,
        tiffTileWidth: 256,
        tiffXres: 1,
        tiffYres: 1,
        tiffResolutionUnit: "inch",
        heifQuality: 50,
        heifLossless: false,
        heifCompression: "av1",
        heifEffort: 4,
        heifChromaSubsampling: "4:4:4",
        heifBitdepth: 8,
        jxlDistance: 1,
        jxlDecodingTier: 0,
        jxlEffort: 7,
        jxlLossless: false,
        rawDepth: "uchar",
        tileSize: 256,
        tileOverlap: 0,
        tileContainer: "fs",
        tileLayout: "dz",
        tileFormat: "last",
        tileDepth: "last",
        tileAngle: 0,
        tileSkipBlanks: -1,
        tileBackground: [255, 255, 255, 255],
        tileCentre: false,
        tileId: "https://example.com/iiif",
        tileBasename: "",
        timeoutSeconds: 0,
        linearA: [],
        linearB: [],
        pdfBackground: [255, 255, 255, 255],
        // Function to notify of libvips warnings
        debuglog: /* @__PURE__ */ __name((warning) => {
          this.emit("warning", warning);
          debuglog3(warning);
        }, "debuglog"),
        // Function to notify of queue length changes
        queueListener
      };
      this.options.input = this._createInputDescriptor(input, options, { allowStream: true });
      return this;
    }, "Sharp");
    Object.setPrototypeOf(Sharp.prototype, stream2.Duplex.prototype);
    Object.setPrototypeOf(Sharp, stream2.Duplex);
    function clone() {
      const clone2 = this.constructor.call();
      const { debuglog: debuglog4, queueListener: queueListener2, ...options } = this.options;
      clone2.options = structuredClone(options);
      clone2.options.debuglog = debuglog4;
      clone2.options.queueListener = queueListener2;
      if (this._isStreamInput()) {
        this.on("finish", () => {
          this._flattenBufferIn();
          clone2.options.input.buffer = this.options.input.buffer;
          clone2.emit("finish");
        });
      }
      return clone2;
    }
    __name(clone, "clone");
    Object.assign(Sharp.prototype, { clone });
    module.exports = Sharp;
  }
});

// ../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/input.js
var require_input = __commonJS({
  "../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/input.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var is = require_is();
    var sharp2 = require_sharp();
    var align = {
      left: "low",
      top: "low",
      low: "low",
      center: "centre",
      centre: "centre",
      right: "high",
      bottom: "high",
      high: "high"
    };
    var inputStreamParameters = [
      // Limits and error handling
      "failOn",
      "limitInputPixels",
      "unlimited",
      // Format-generic
      "animated",
      "autoOrient",
      "density",
      "ignoreIcc",
      "page",
      "pages",
      "sequentialRead",
      // Format-specific
      "jp2",
      "openSlide",
      "pdf",
      "raw",
      "svg",
      "tiff",
      // Deprecated
      "failOnError",
      "openSlideLevel",
      "pdfBackground",
      "tiffSubifd"
    ];
    function _inputOptionsFromObject(obj) {
      const params = inputStreamParameters.filter((p3) => is.defined(obj[p3])).map((p3) => [p3, obj[p3]]);
      return params.length ? Object.fromEntries(params) : void 0;
    }
    __name(_inputOptionsFromObject, "_inputOptionsFromObject");
    function _createInputDescriptor(input, inputOptions, containerOptions) {
      const inputDescriptor = {
        autoOrient: false,
        failOn: "warning",
        limitInputPixels: 16383 ** 2,
        ignoreIcc: false,
        unlimited: false,
        sequentialRead: true
      };
      if (is.string(input)) {
        inputDescriptor.file = input;
      } else if (is.buffer(input)) {
        if (input.length === 0) {
          throw Error("Input Buffer is empty");
        }
        inputDescriptor.buffer = input;
      } else if (is.arrayBuffer(input)) {
        if (input.byteLength === 0) {
          throw Error("Input bit Array is empty");
        }
        inputDescriptor.buffer = Buffer.from(input, 0, input.byteLength);
      } else if (is.typedArray(input)) {
        if (input.length === 0) {
          throw Error("Input Bit Array is empty");
        }
        inputDescriptor.buffer = Buffer.from(input.buffer, input.byteOffset, input.byteLength);
      } else if (is.plainObject(input) && !is.defined(inputOptions)) {
        inputOptions = input;
        if (_inputOptionsFromObject(inputOptions)) {
          inputDescriptor.buffer = [];
        }
      } else if (!is.defined(input) && !is.defined(inputOptions) && is.object(containerOptions) && containerOptions.allowStream) {
        inputDescriptor.buffer = [];
      } else if (Array.isArray(input)) {
        if (input.length > 1) {
          if (!this.options.joining) {
            this.options.joining = true;
            this.options.join = input.map((i2) => this._createInputDescriptor(i2));
          } else {
            throw new Error("Recursive join is unsupported");
          }
        } else {
          throw new Error("Expected at least two images to join");
        }
      } else {
        throw new Error(`Unsupported input '${input}' of type ${typeof input}${is.defined(inputOptions) ? ` when also providing options of type ${typeof inputOptions}` : ""}`);
      }
      if (is.object(inputOptions)) {
        if (is.defined(inputOptions.failOnError)) {
          if (is.bool(inputOptions.failOnError)) {
            inputDescriptor.failOn = inputOptions.failOnError ? "warning" : "none";
          } else {
            throw is.invalidParameterError("failOnError", "boolean", inputOptions.failOnError);
          }
        }
        if (is.defined(inputOptions.failOn)) {
          if (is.string(inputOptions.failOn) && is.inArray(inputOptions.failOn, ["none", "truncated", "error", "warning"])) {
            inputDescriptor.failOn = inputOptions.failOn;
          } else {
            throw is.invalidParameterError("failOn", "one of: none, truncated, error, warning", inputOptions.failOn);
          }
        }
        if (is.defined(inputOptions.autoOrient)) {
          if (is.bool(inputOptions.autoOrient)) {
            inputDescriptor.autoOrient = inputOptions.autoOrient;
          } else {
            throw is.invalidParameterError("autoOrient", "boolean", inputOptions.autoOrient);
          }
        }
        if (is.defined(inputOptions.density)) {
          if (is.inRange(inputOptions.density, 1, 1e5)) {
            inputDescriptor.density = inputOptions.density;
          } else {
            throw is.invalidParameterError("density", "number between 1 and 100000", inputOptions.density);
          }
        }
        if (is.defined(inputOptions.ignoreIcc)) {
          if (is.bool(inputOptions.ignoreIcc)) {
            inputDescriptor.ignoreIcc = inputOptions.ignoreIcc;
          } else {
            throw is.invalidParameterError("ignoreIcc", "boolean", inputOptions.ignoreIcc);
          }
        }
        if (is.defined(inputOptions.limitInputPixels)) {
          if (is.bool(inputOptions.limitInputPixels)) {
            inputDescriptor.limitInputPixels = inputOptions.limitInputPixels ? 16383 ** 2 : 0;
          } else if (is.integer(inputOptions.limitInputPixels) && is.inRange(inputOptions.limitInputPixels, 0, Number.MAX_SAFE_INTEGER)) {
            inputDescriptor.limitInputPixels = inputOptions.limitInputPixels;
          } else {
            throw is.invalidParameterError("limitInputPixels", "positive integer", inputOptions.limitInputPixels);
          }
        }
        if (is.defined(inputOptions.unlimited)) {
          if (is.bool(inputOptions.unlimited)) {
            inputDescriptor.unlimited = inputOptions.unlimited;
          } else {
            throw is.invalidParameterError("unlimited", "boolean", inputOptions.unlimited);
          }
        }
        if (is.defined(inputOptions.sequentialRead)) {
          if (is.bool(inputOptions.sequentialRead)) {
            inputDescriptor.sequentialRead = inputOptions.sequentialRead;
          } else {
            throw is.invalidParameterError("sequentialRead", "boolean", inputOptions.sequentialRead);
          }
        }
        if (is.defined(inputOptions.raw)) {
          if (is.object(inputOptions.raw) && is.integer(inputOptions.raw.width) && inputOptions.raw.width > 0 && is.integer(inputOptions.raw.height) && inputOptions.raw.height > 0 && is.integer(inputOptions.raw.channels) && is.inRange(inputOptions.raw.channels, 1, 4)) {
            inputDescriptor.rawWidth = inputOptions.raw.width;
            inputDescriptor.rawHeight = inputOptions.raw.height;
            inputDescriptor.rawChannels = inputOptions.raw.channels;
            switch (input.constructor) {
              case Uint8Array:
              case Uint8ClampedArray:
                inputDescriptor.rawDepth = "uchar";
                break;
              case Int8Array:
                inputDescriptor.rawDepth = "char";
                break;
              case Uint16Array:
                inputDescriptor.rawDepth = "ushort";
                break;
              case Int16Array:
                inputDescriptor.rawDepth = "short";
                break;
              case Uint32Array:
                inputDescriptor.rawDepth = "uint";
                break;
              case Int32Array:
                inputDescriptor.rawDepth = "int";
                break;
              case Float32Array:
                inputDescriptor.rawDepth = "float";
                break;
              case Float64Array:
                inputDescriptor.rawDepth = "double";
                break;
              default:
                inputDescriptor.rawDepth = "uchar";
                break;
            }
          } else {
            throw new Error("Expected width, height and channels for raw pixel input");
          }
          inputDescriptor.rawPremultiplied = false;
          if (is.defined(inputOptions.raw.premultiplied)) {
            if (is.bool(inputOptions.raw.premultiplied)) {
              inputDescriptor.rawPremultiplied = inputOptions.raw.premultiplied;
            } else {
              throw is.invalidParameterError("raw.premultiplied", "boolean", inputOptions.raw.premultiplied);
            }
          }
          inputDescriptor.rawPageHeight = 0;
          if (is.defined(inputOptions.raw.pageHeight)) {
            if (is.integer(inputOptions.raw.pageHeight) && inputOptions.raw.pageHeight > 0 && inputOptions.raw.pageHeight <= inputOptions.raw.height) {
              if (inputOptions.raw.height % inputOptions.raw.pageHeight !== 0) {
                throw new Error(`Expected raw.height ${inputOptions.raw.height} to be a multiple of raw.pageHeight ${inputOptions.raw.pageHeight}`);
              }
              inputDescriptor.rawPageHeight = inputOptions.raw.pageHeight;
            } else {
              throw is.invalidParameterError("raw.pageHeight", "positive integer", inputOptions.raw.pageHeight);
            }
          }
        }
        if (is.defined(inputOptions.animated)) {
          if (is.bool(inputOptions.animated)) {
            inputDescriptor.pages = inputOptions.animated ? -1 : 1;
          } else {
            throw is.invalidParameterError("animated", "boolean", inputOptions.animated);
          }
        }
        if (is.defined(inputOptions.pages)) {
          if (is.integer(inputOptions.pages) && is.inRange(inputOptions.pages, -1, 1e5)) {
            inputDescriptor.pages = inputOptions.pages;
          } else {
            throw is.invalidParameterError("pages", "integer between -1 and 100000", inputOptions.pages);
          }
        }
        if (is.defined(inputOptions.page)) {
          if (is.integer(inputOptions.page) && is.inRange(inputOptions.page, 0, 1e5)) {
            inputDescriptor.page = inputOptions.page;
          } else {
            throw is.invalidParameterError("page", "integer between 0 and 100000", inputOptions.page);
          }
        }
        if (is.object(inputOptions.openSlide) && is.defined(inputOptions.openSlide.level)) {
          if (is.integer(inputOptions.openSlide.level) && is.inRange(inputOptions.openSlide.level, 0, 256)) {
            inputDescriptor.openSlideLevel = inputOptions.openSlide.level;
          } else {
            throw is.invalidParameterError("openSlide.level", "integer between 0 and 256", inputOptions.openSlide.level);
          }
        } else if (is.defined(inputOptions.level)) {
          if (is.integer(inputOptions.level) && is.inRange(inputOptions.level, 0, 256)) {
            inputDescriptor.openSlideLevel = inputOptions.level;
          } else {
            throw is.invalidParameterError("level", "integer between 0 and 256", inputOptions.level);
          }
        }
        if (is.object(inputOptions.tiff) && is.defined(inputOptions.tiff.subifd)) {
          if (is.integer(inputOptions.tiff.subifd) && is.inRange(inputOptions.tiff.subifd, -1, 1e5)) {
            inputDescriptor.tiffSubifd = inputOptions.tiff.subifd;
          } else {
            throw is.invalidParameterError("tiff.subifd", "integer between -1 and 100000", inputOptions.tiff.subifd);
          }
        } else if (is.defined(inputOptions.subifd)) {
          if (is.integer(inputOptions.subifd) && is.inRange(inputOptions.subifd, -1, 1e5)) {
            inputDescriptor.tiffSubifd = inputOptions.subifd;
          } else {
            throw is.invalidParameterError("subifd", "integer between -1 and 100000", inputOptions.subifd);
          }
        }
        if (is.object(inputOptions.svg)) {
          if (is.defined(inputOptions.svg.stylesheet)) {
            if (is.string(inputOptions.svg.stylesheet)) {
              inputDescriptor.svgStylesheet = inputOptions.svg.stylesheet;
            } else {
              throw is.invalidParameterError("svg.stylesheet", "string", inputOptions.svg.stylesheet);
            }
          }
          if (is.defined(inputOptions.svg.highBitdepth)) {
            if (is.bool(inputOptions.svg.highBitdepth)) {
              inputDescriptor.svgHighBitdepth = inputOptions.svg.highBitdepth;
            } else {
              throw is.invalidParameterError("svg.highBitdepth", "boolean", inputOptions.svg.highBitdepth);
            }
          }
        }
        if (is.object(inputOptions.pdf) && is.defined(inputOptions.pdf.background)) {
          inputDescriptor.pdfBackground = this._getBackgroundColourOption(inputOptions.pdf.background);
        } else if (is.defined(inputOptions.pdfBackground)) {
          inputDescriptor.pdfBackground = this._getBackgroundColourOption(inputOptions.pdfBackground);
        }
        if (is.object(inputOptions.jp2) && is.defined(inputOptions.jp2.oneshot)) {
          if (is.bool(inputOptions.jp2.oneshot)) {
            inputDescriptor.jp2Oneshot = inputOptions.jp2.oneshot;
          } else {
            throw is.invalidParameterError("jp2.oneshot", "boolean", inputOptions.jp2.oneshot);
          }
        }
        if (is.defined(inputOptions.create)) {
          if (is.object(inputOptions.create) && is.integer(inputOptions.create.width) && inputOptions.create.width > 0 && is.integer(inputOptions.create.height) && inputOptions.create.height > 0 && is.integer(inputOptions.create.channels)) {
            inputDescriptor.createWidth = inputOptions.create.width;
            inputDescriptor.createHeight = inputOptions.create.height;
            inputDescriptor.createChannels = inputOptions.create.channels;
            inputDescriptor.createPageHeight = 0;
            if (is.defined(inputOptions.create.pageHeight)) {
              if (is.integer(inputOptions.create.pageHeight) && inputOptions.create.pageHeight > 0 && inputOptions.create.pageHeight <= inputOptions.create.height) {
                if (inputOptions.create.height % inputOptions.create.pageHeight !== 0) {
                  throw new Error(`Expected create.height ${inputOptions.create.height} to be a multiple of create.pageHeight ${inputOptions.create.pageHeight}`);
                }
                inputDescriptor.createPageHeight = inputOptions.create.pageHeight;
              } else {
                throw is.invalidParameterError("create.pageHeight", "positive integer", inputOptions.create.pageHeight);
              }
            }
            if (is.defined(inputOptions.create.noise)) {
              if (!is.object(inputOptions.create.noise)) {
                throw new Error("Expected noise to be an object");
              }
              if (inputOptions.create.noise.type !== "gaussian") {
                throw new Error("Only gaussian noise is supported at the moment");
              }
              inputDescriptor.createNoiseType = inputOptions.create.noise.type;
              if (!is.inRange(inputOptions.create.channels, 1, 4)) {
                throw is.invalidParameterError("create.channels", "number between 1 and 4", inputOptions.create.channels);
              }
              inputDescriptor.createNoiseMean = 128;
              if (is.defined(inputOptions.create.noise.mean)) {
                if (is.number(inputOptions.create.noise.mean) && is.inRange(inputOptions.create.noise.mean, 0, 1e4)) {
                  inputDescriptor.createNoiseMean = inputOptions.create.noise.mean;
                } else {
                  throw is.invalidParameterError("create.noise.mean", "number between 0 and 10000", inputOptions.create.noise.mean);
                }
              }
              inputDescriptor.createNoiseSigma = 30;
              if (is.defined(inputOptions.create.noise.sigma)) {
                if (is.number(inputOptions.create.noise.sigma) && is.inRange(inputOptions.create.noise.sigma, 0, 1e4)) {
                  inputDescriptor.createNoiseSigma = inputOptions.create.noise.sigma;
                } else {
                  throw is.invalidParameterError("create.noise.sigma", "number between 0 and 10000", inputOptions.create.noise.sigma);
                }
              }
            } else if (is.defined(inputOptions.create.background)) {
              if (!is.inRange(inputOptions.create.channels, 3, 4)) {
                throw is.invalidParameterError("create.channels", "number between 3 and 4", inputOptions.create.channels);
              }
              inputDescriptor.createBackground = this._getBackgroundColourOption(inputOptions.create.background);
            } else {
              throw new Error("Expected valid noise or background to create a new input image");
            }
            delete inputDescriptor.buffer;
          } else {
            throw new Error("Expected valid width, height and channels to create a new input image");
          }
        }
        if (is.defined(inputOptions.text)) {
          if (is.object(inputOptions.text) && is.string(inputOptions.text.text)) {
            inputDescriptor.textValue = inputOptions.text.text;
            if (is.defined(inputOptions.text.height) && is.defined(inputOptions.text.dpi)) {
              throw new Error("Expected only one of dpi or height");
            }
            if (is.defined(inputOptions.text.font)) {
              if (is.string(inputOptions.text.font)) {
                inputDescriptor.textFont = inputOptions.text.font;
              } else {
                throw is.invalidParameterError("text.font", "string", inputOptions.text.font);
              }
            }
            if (is.defined(inputOptions.text.fontfile)) {
              if (is.string(inputOptions.text.fontfile)) {
                inputDescriptor.textFontfile = inputOptions.text.fontfile;
              } else {
                throw is.invalidParameterError("text.fontfile", "string", inputOptions.text.fontfile);
              }
            }
            if (is.defined(inputOptions.text.width)) {
              if (is.integer(inputOptions.text.width) && inputOptions.text.width > 0) {
                inputDescriptor.textWidth = inputOptions.text.width;
              } else {
                throw is.invalidParameterError("text.width", "positive integer", inputOptions.text.width);
              }
            }
            if (is.defined(inputOptions.text.height)) {
              if (is.integer(inputOptions.text.height) && inputOptions.text.height > 0) {
                inputDescriptor.textHeight = inputOptions.text.height;
              } else {
                throw is.invalidParameterError("text.height", "positive integer", inputOptions.text.height);
              }
            }
            if (is.defined(inputOptions.text.align)) {
              if (is.string(inputOptions.text.align) && is.string(this.constructor.align[inputOptions.text.align])) {
                inputDescriptor.textAlign = this.constructor.align[inputOptions.text.align];
              } else {
                throw is.invalidParameterError("text.align", "valid alignment", inputOptions.text.align);
              }
            }
            if (is.defined(inputOptions.text.justify)) {
              if (is.bool(inputOptions.text.justify)) {
                inputDescriptor.textJustify = inputOptions.text.justify;
              } else {
                throw is.invalidParameterError("text.justify", "boolean", inputOptions.text.justify);
              }
            }
            if (is.defined(inputOptions.text.dpi)) {
              if (is.integer(inputOptions.text.dpi) && is.inRange(inputOptions.text.dpi, 1, 1e6)) {
                inputDescriptor.textDpi = inputOptions.text.dpi;
              } else {
                throw is.invalidParameterError("text.dpi", "integer between 1 and 1000000", inputOptions.text.dpi);
              }
            }
            if (is.defined(inputOptions.text.rgba)) {
              if (is.bool(inputOptions.text.rgba)) {
                inputDescriptor.textRgba = inputOptions.text.rgba;
              } else {
                throw is.invalidParameterError("text.rgba", "bool", inputOptions.text.rgba);
              }
            }
            if (is.defined(inputOptions.text.spacing)) {
              if (is.integer(inputOptions.text.spacing) && is.inRange(inputOptions.text.spacing, -1e6, 1e6)) {
                inputDescriptor.textSpacing = inputOptions.text.spacing;
              } else {
                throw is.invalidParameterError("text.spacing", "integer between -1000000 and 1000000", inputOptions.text.spacing);
              }
            }
            if (is.defined(inputOptions.text.wrap)) {
              if (is.string(inputOptions.text.wrap) && is.inArray(inputOptions.text.wrap, ["word", "char", "word-char", "none"])) {
                inputDescriptor.textWrap = inputOptions.text.wrap;
              } else {
                throw is.invalidParameterError("text.wrap", "one of: word, char, word-char, none", inputOptions.text.wrap);
              }
            }
            delete inputDescriptor.buffer;
          } else {
            throw new Error("Expected a valid string to create an image with text.");
          }
        }
        if (is.defined(inputOptions.join)) {
          if (is.defined(this.options.join)) {
            if (is.defined(inputOptions.join.animated)) {
              if (is.bool(inputOptions.join.animated)) {
                inputDescriptor.joinAnimated = inputOptions.join.animated;
              } else {
                throw is.invalidParameterError("join.animated", "boolean", inputOptions.join.animated);
              }
            }
            if (is.defined(inputOptions.join.across)) {
              if (is.integer(inputOptions.join.across) && is.inRange(inputOptions.join.across, 1, 1e6)) {
                inputDescriptor.joinAcross = inputOptions.join.across;
              } else {
                throw is.invalidParameterError("join.across", "integer between 1 and 100000", inputOptions.join.across);
              }
            }
            if (is.defined(inputOptions.join.shim)) {
              if (is.integer(inputOptions.join.shim) && is.inRange(inputOptions.join.shim, 0, 1e6)) {
                inputDescriptor.joinShim = inputOptions.join.shim;
              } else {
                throw is.invalidParameterError("join.shim", "integer between 0 and 100000", inputOptions.join.shim);
              }
            }
            if (is.defined(inputOptions.join.background)) {
              inputDescriptor.joinBackground = this._getBackgroundColourOption(inputOptions.join.background);
            }
            if (is.defined(inputOptions.join.halign)) {
              if (is.string(inputOptions.join.halign) && is.string(this.constructor.align[inputOptions.join.halign])) {
                inputDescriptor.joinHalign = this.constructor.align[inputOptions.join.halign];
              } else {
                throw is.invalidParameterError("join.halign", "valid alignment", inputOptions.join.halign);
              }
            }
            if (is.defined(inputOptions.join.valign)) {
              if (is.string(inputOptions.join.valign) && is.string(this.constructor.align[inputOptions.join.valign])) {
                inputDescriptor.joinValign = this.constructor.align[inputOptions.join.valign];
              } else {
                throw is.invalidParameterError("join.valign", "valid alignment", inputOptions.join.valign);
              }
            }
          } else {
            throw new Error("Expected input to be an array of images to join");
          }
        }
      } else if (is.defined(inputOptions)) {
        throw new Error(`Invalid input options ${inputOptions}`);
      }
      return inputDescriptor;
    }
    __name(_createInputDescriptor, "_createInputDescriptor");
    function _write(chunk, _encoding, callback) {
      if (Array.isArray(this.options.input.buffer)) {
        if (is.buffer(chunk)) {
          if (this.options.input.buffer.length === 0) {
            this.on("finish", () => {
              this.streamInFinished = true;
            });
          }
          this.options.input.buffer.push(chunk);
          callback();
        } else {
          callback(new Error("Non-Buffer data on Writable Stream"));
        }
      } else {
        callback(new Error("Unexpected data on Writable Stream"));
      }
    }
    __name(_write, "_write");
    function _flattenBufferIn() {
      if (this._isStreamInput()) {
        this.options.input.buffer = Buffer.concat(this.options.input.buffer);
      }
    }
    __name(_flattenBufferIn, "_flattenBufferIn");
    function _isStreamInput() {
      return Array.isArray(this.options.input.buffer);
    }
    __name(_isStreamInput, "_isStreamInput");
    function metadata(callback) {
      const stack = Error();
      if (is.fn(callback)) {
        if (this._isStreamInput()) {
          this.on("finish", () => {
            this._flattenBufferIn();
            sharp2.metadata(this.options, (err2, metadata2) => {
              if (err2) {
                callback(is.nativeError(err2, stack));
              } else {
                callback(null, metadata2);
              }
            });
          });
        } else {
          sharp2.metadata(this.options, (err2, metadata2) => {
            if (err2) {
              callback(is.nativeError(err2, stack));
            } else {
              callback(null, metadata2);
            }
          });
        }
        return this;
      } else {
        if (this._isStreamInput()) {
          return new Promise((resolve3, reject) => {
            const finished = /* @__PURE__ */ __name(() => {
              this._flattenBufferIn();
              sharp2.metadata(this.options, (err2, metadata2) => {
                if (err2) {
                  reject(is.nativeError(err2, stack));
                } else {
                  resolve3(metadata2);
                }
              });
            }, "finished");
            if (this.writableFinished) {
              finished();
            } else {
              this.once("finish", finished);
            }
          });
        } else {
          return new Promise((resolve3, reject) => {
            sharp2.metadata(this.options, (err2, metadata2) => {
              if (err2) {
                reject(is.nativeError(err2, stack));
              } else {
                resolve3(metadata2);
              }
            });
          });
        }
      }
    }
    __name(metadata, "metadata");
    function stats(callback) {
      const stack = Error();
      if (is.fn(callback)) {
        if (this._isStreamInput()) {
          this.on("finish", () => {
            this._flattenBufferIn();
            sharp2.stats(this.options, (err2, stats2) => {
              if (err2) {
                callback(is.nativeError(err2, stack));
              } else {
                callback(null, stats2);
              }
            });
          });
        } else {
          sharp2.stats(this.options, (err2, stats2) => {
            if (err2) {
              callback(is.nativeError(err2, stack));
            } else {
              callback(null, stats2);
            }
          });
        }
        return this;
      } else {
        if (this._isStreamInput()) {
          return new Promise((resolve3, reject) => {
            this.on("finish", function() {
              this._flattenBufferIn();
              sharp2.stats(this.options, (err2, stats2) => {
                if (err2) {
                  reject(is.nativeError(err2, stack));
                } else {
                  resolve3(stats2);
                }
              });
            });
          });
        } else {
          return new Promise((resolve3, reject) => {
            sharp2.stats(this.options, (err2, stats2) => {
              if (err2) {
                reject(is.nativeError(err2, stack));
              } else {
                resolve3(stats2);
              }
            });
          });
        }
      }
    }
    __name(stats, "stats");
    module.exports = (Sharp) => {
      Object.assign(Sharp.prototype, {
        // Private
        _inputOptionsFromObject,
        _createInputDescriptor,
        _write,
        _flattenBufferIn,
        _isStreamInput,
        // Public
        metadata,
        stats
      });
      Sharp.align = align;
    };
  }
});

// ../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/resize.js
var require_resize = __commonJS({
  "../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/resize.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var is = require_is();
    var gravity = {
      center: 0,
      centre: 0,
      north: 1,
      east: 2,
      south: 3,
      west: 4,
      northeast: 5,
      southeast: 6,
      southwest: 7,
      northwest: 8
    };
    var position = {
      top: 1,
      right: 2,
      bottom: 3,
      left: 4,
      "right top": 5,
      "right bottom": 6,
      "left bottom": 7,
      "left top": 8
    };
    var extendWith = {
      background: "background",
      copy: "copy",
      repeat: "repeat",
      mirror: "mirror"
    };
    var strategy = {
      entropy: 16,
      attention: 17
    };
    var kernel = {
      nearest: "nearest",
      linear: "linear",
      cubic: "cubic",
      mitchell: "mitchell",
      lanczos2: "lanczos2",
      lanczos3: "lanczos3",
      mks2013: "mks2013",
      mks2021: "mks2021"
    };
    var fit = {
      contain: "contain",
      cover: "cover",
      fill: "fill",
      inside: "inside",
      outside: "outside"
    };
    var mapFitToCanvas = {
      contain: "embed",
      cover: "crop",
      fill: "ignore_aspect",
      inside: "max",
      outside: "min"
    };
    function isRotationExpected(options) {
      return options.angle % 360 !== 0 || options.rotationAngle !== 0;
    }
    __name(isRotationExpected, "isRotationExpected");
    function isResizeExpected(options) {
      return options.width !== -1 || options.height !== -1;
    }
    __name(isResizeExpected, "isResizeExpected");
    function resize(widthOrOptions, height2, options) {
      if (isResizeExpected(this.options)) {
        this.options.debuglog("ignoring previous resize options");
      }
      if (this.options.widthPost !== -1) {
        this.options.debuglog("operation order will be: extract, resize, extract");
      }
      if (is.defined(widthOrOptions)) {
        if (is.object(widthOrOptions) && !is.defined(options)) {
          options = widthOrOptions;
        } else if (is.integer(widthOrOptions) && widthOrOptions > 0) {
          this.options.width = widthOrOptions;
        } else {
          throw is.invalidParameterError("width", "positive integer", widthOrOptions);
        }
      } else {
        this.options.width = -1;
      }
      if (is.defined(height2)) {
        if (is.integer(height2) && height2 > 0) {
          this.options.height = height2;
        } else {
          throw is.invalidParameterError("height", "positive integer", height2);
        }
      } else {
        this.options.height = -1;
      }
      if (is.object(options)) {
        if (is.defined(options.width)) {
          if (is.integer(options.width) && options.width > 0) {
            this.options.width = options.width;
          } else {
            throw is.invalidParameterError("width", "positive integer", options.width);
          }
        }
        if (is.defined(options.height)) {
          if (is.integer(options.height) && options.height > 0) {
            this.options.height = options.height;
          } else {
            throw is.invalidParameterError("height", "positive integer", options.height);
          }
        }
        if (is.defined(options.fit)) {
          const canvas = mapFitToCanvas[options.fit];
          if (is.string(canvas)) {
            this.options.canvas = canvas;
          } else {
            throw is.invalidParameterError("fit", "valid fit", options.fit);
          }
        }
        if (is.defined(options.position)) {
          const pos = is.integer(options.position) ? options.position : strategy[options.position] || position[options.position] || gravity[options.position];
          if (is.integer(pos) && (is.inRange(pos, 0, 8) || is.inRange(pos, 16, 17))) {
            this.options.position = pos;
          } else {
            throw is.invalidParameterError("position", "valid position/gravity/strategy", options.position);
          }
        }
        this._setBackgroundColourOption("resizeBackground", options.background);
        if (is.defined(options.kernel)) {
          if (is.string(kernel[options.kernel])) {
            this.options.kernel = kernel[options.kernel];
          } else {
            throw is.invalidParameterError("kernel", "valid kernel name", options.kernel);
          }
        }
        if (is.defined(options.withoutEnlargement)) {
          this._setBooleanOption("withoutEnlargement", options.withoutEnlargement);
        }
        if (is.defined(options.withoutReduction)) {
          this._setBooleanOption("withoutReduction", options.withoutReduction);
        }
        if (is.defined(options.fastShrinkOnLoad)) {
          this._setBooleanOption("fastShrinkOnLoad", options.fastShrinkOnLoad);
        }
      }
      if (isRotationExpected(this.options) && isResizeExpected(this.options)) {
        this.options.rotateBefore = true;
      }
      return this;
    }
    __name(resize, "resize");
    function extend(extend2) {
      if (is.integer(extend2) && extend2 > 0) {
        this.options.extendTop = extend2;
        this.options.extendBottom = extend2;
        this.options.extendLeft = extend2;
        this.options.extendRight = extend2;
      } else if (is.object(extend2)) {
        if (is.defined(extend2.top)) {
          if (is.integer(extend2.top) && extend2.top >= 0) {
            this.options.extendTop = extend2.top;
          } else {
            throw is.invalidParameterError("top", "positive integer", extend2.top);
          }
        }
        if (is.defined(extend2.bottom)) {
          if (is.integer(extend2.bottom) && extend2.bottom >= 0) {
            this.options.extendBottom = extend2.bottom;
          } else {
            throw is.invalidParameterError("bottom", "positive integer", extend2.bottom);
          }
        }
        if (is.defined(extend2.left)) {
          if (is.integer(extend2.left) && extend2.left >= 0) {
            this.options.extendLeft = extend2.left;
          } else {
            throw is.invalidParameterError("left", "positive integer", extend2.left);
          }
        }
        if (is.defined(extend2.right)) {
          if (is.integer(extend2.right) && extend2.right >= 0) {
            this.options.extendRight = extend2.right;
          } else {
            throw is.invalidParameterError("right", "positive integer", extend2.right);
          }
        }
        this._setBackgroundColourOption("extendBackground", extend2.background);
        if (is.defined(extend2.extendWith)) {
          if (is.string(extendWith[extend2.extendWith])) {
            this.options.extendWith = extendWith[extend2.extendWith];
          } else {
            throw is.invalidParameterError("extendWith", "one of: background, copy, repeat, mirror", extend2.extendWith);
          }
        }
      } else {
        throw is.invalidParameterError("extend", "integer or object", extend2);
      }
      return this;
    }
    __name(extend, "extend");
    function extract(options) {
      const suffix = isResizeExpected(this.options) || this.options.widthPre !== -1 ? "Post" : "Pre";
      if (this.options[`width${suffix}`] !== -1) {
        this.options.debuglog("ignoring previous extract options");
      }
      ["left", "top", "width", "height"].forEach(function(name) {
        const value2 = options[name];
        if (is.integer(value2) && value2 >= 0) {
          this.options[name + (name === "left" || name === "top" ? "Offset" : "") + suffix] = value2;
        } else {
          throw is.invalidParameterError(name, "integer", value2);
        }
      }, this);
      if (isRotationExpected(this.options) && !isResizeExpected(this.options)) {
        if (this.options.widthPre === -1 || this.options.widthPost === -1) {
          this.options.rotateBefore = true;
        }
      }
      if (this.options.input.autoOrient) {
        this.options.orientBefore = true;
      }
      return this;
    }
    __name(extract, "extract");
    function trim2(options) {
      this.options.trimThreshold = 10;
      if (is.defined(options)) {
        if (is.object(options)) {
          if (is.defined(options.background)) {
            this._setBackgroundColourOption("trimBackground", options.background);
          }
          if (is.defined(options.threshold)) {
            if (is.number(options.threshold) && options.threshold >= 0) {
              this.options.trimThreshold = options.threshold;
            } else {
              throw is.invalidParameterError("threshold", "positive number", options.threshold);
            }
          }
          if (is.defined(options.lineArt)) {
            this._setBooleanOption("trimLineArt", options.lineArt);
          }
        } else {
          throw is.invalidParameterError("trim", "object", options);
        }
      }
      if (isRotationExpected(this.options)) {
        this.options.rotateBefore = true;
      }
      return this;
    }
    __name(trim2, "trim");
    module.exports = (Sharp) => {
      Object.assign(Sharp.prototype, {
        resize,
        extend,
        extract,
        trim: trim2
      });
      Sharp.gravity = gravity;
      Sharp.strategy = strategy;
      Sharp.kernel = kernel;
      Sharp.fit = fit;
      Sharp.position = position;
    };
  }
});

// ../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/composite.js
var require_composite = __commonJS({
  "../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/composite.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var is = require_is();
    var blend = {
      clear: "clear",
      source: "source",
      over: "over",
      in: "in",
      out: "out",
      atop: "atop",
      dest: "dest",
      "dest-over": "dest-over",
      "dest-in": "dest-in",
      "dest-out": "dest-out",
      "dest-atop": "dest-atop",
      xor: "xor",
      add: "add",
      saturate: "saturate",
      multiply: "multiply",
      screen: "screen",
      overlay: "overlay",
      darken: "darken",
      lighten: "lighten",
      "colour-dodge": "colour-dodge",
      "color-dodge": "colour-dodge",
      "colour-burn": "colour-burn",
      "color-burn": "colour-burn",
      "hard-light": "hard-light",
      "soft-light": "soft-light",
      difference: "difference",
      exclusion: "exclusion"
    };
    function composite(images) {
      if (!Array.isArray(images)) {
        throw is.invalidParameterError("images to composite", "array", images);
      }
      this.options.composite = images.map((image) => {
        if (!is.object(image)) {
          throw is.invalidParameterError("image to composite", "object", image);
        }
        const inputOptions = this._inputOptionsFromObject(image);
        const composite2 = {
          input: this._createInputDescriptor(image.input, inputOptions, { allowStream: false }),
          blend: "over",
          tile: false,
          left: 0,
          top: 0,
          hasOffset: false,
          gravity: 0,
          premultiplied: false
        };
        if (is.defined(image.blend)) {
          if (is.string(blend[image.blend])) {
            composite2.blend = blend[image.blend];
          } else {
            throw is.invalidParameterError("blend", "valid blend name", image.blend);
          }
        }
        if (is.defined(image.tile)) {
          if (is.bool(image.tile)) {
            composite2.tile = image.tile;
          } else {
            throw is.invalidParameterError("tile", "boolean", image.tile);
          }
        }
        if (is.defined(image.left)) {
          if (is.integer(image.left)) {
            composite2.left = image.left;
          } else {
            throw is.invalidParameterError("left", "integer", image.left);
          }
        }
        if (is.defined(image.top)) {
          if (is.integer(image.top)) {
            composite2.top = image.top;
          } else {
            throw is.invalidParameterError("top", "integer", image.top);
          }
        }
        if (is.defined(image.top) !== is.defined(image.left)) {
          throw new Error("Expected both left and top to be set");
        } else {
          composite2.hasOffset = is.integer(image.top) && is.integer(image.left);
        }
        if (is.defined(image.gravity)) {
          if (is.integer(image.gravity) && is.inRange(image.gravity, 0, 8)) {
            composite2.gravity = image.gravity;
          } else if (is.string(image.gravity) && is.integer(this.constructor.gravity[image.gravity])) {
            composite2.gravity = this.constructor.gravity[image.gravity];
          } else {
            throw is.invalidParameterError("gravity", "valid gravity", image.gravity);
          }
        }
        if (is.defined(image.premultiplied)) {
          if (is.bool(image.premultiplied)) {
            composite2.premultiplied = image.premultiplied;
          } else {
            throw is.invalidParameterError("premultiplied", "boolean", image.premultiplied);
          }
        }
        return composite2;
      });
      return this;
    }
    __name(composite, "composite");
    module.exports = (Sharp) => {
      Sharp.prototype.composite = composite;
      Sharp.blend = blend;
    };
  }
});

// ../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/operation.js
var require_operation = __commonJS({
  "../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/operation.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var is = require_is();
    var vipsPrecision = {
      integer: "integer",
      float: "float",
      approximate: "approximate"
    };
    function rotate(angle, options) {
      if (!is.defined(angle)) {
        return this.autoOrient();
      }
      if (this.options.angle || this.options.rotationAngle) {
        this.options.debuglog("ignoring previous rotate options");
        this.options.angle = 0;
        this.options.rotationAngle = 0;
      }
      if (is.integer(angle) && !(angle % 90)) {
        this.options.angle = angle;
      } else if (is.number(angle)) {
        this.options.rotationAngle = angle;
        if (is.object(options) && options.background) {
          this._setBackgroundColourOption("rotationBackground", options.background);
        }
      } else {
        throw is.invalidParameterError("angle", "numeric", angle);
      }
      return this;
    }
    __name(rotate, "rotate");
    function autoOrient() {
      this.options.input.autoOrient = true;
      return this;
    }
    __name(autoOrient, "autoOrient");
    function flip(flip2) {
      this.options.flip = is.bool(flip2) ? flip2 : true;
      return this;
    }
    __name(flip, "flip");
    function flop(flop2) {
      this.options.flop = is.bool(flop2) ? flop2 : true;
      return this;
    }
    __name(flop, "flop");
    function affine(matrix, options) {
      const flatMatrix = [].concat(...matrix);
      if (flatMatrix.length === 4 && flatMatrix.every(is.number)) {
        this.options.affineMatrix = flatMatrix;
      } else {
        throw is.invalidParameterError("matrix", "1x4 or 2x2 array", matrix);
      }
      if (is.defined(options)) {
        if (is.object(options)) {
          this._setBackgroundColourOption("affineBackground", options.background);
          if (is.defined(options.idx)) {
            if (is.number(options.idx)) {
              this.options.affineIdx = options.idx;
            } else {
              throw is.invalidParameterError("options.idx", "number", options.idx);
            }
          }
          if (is.defined(options.idy)) {
            if (is.number(options.idy)) {
              this.options.affineIdy = options.idy;
            } else {
              throw is.invalidParameterError("options.idy", "number", options.idy);
            }
          }
          if (is.defined(options.odx)) {
            if (is.number(options.odx)) {
              this.options.affineOdx = options.odx;
            } else {
              throw is.invalidParameterError("options.odx", "number", options.odx);
            }
          }
          if (is.defined(options.ody)) {
            if (is.number(options.ody)) {
              this.options.affineOdy = options.ody;
            } else {
              throw is.invalidParameterError("options.ody", "number", options.ody);
            }
          }
          if (is.defined(options.interpolator)) {
            if (is.inArray(options.interpolator, Object.values(this.constructor.interpolators))) {
              this.options.affineInterpolator = options.interpolator;
            } else {
              throw is.invalidParameterError("options.interpolator", "valid interpolator name", options.interpolator);
            }
          }
        } else {
          throw is.invalidParameterError("options", "object", options);
        }
      }
      return this;
    }
    __name(affine, "affine");
    function sharpen(options, flat, jagged) {
      if (!is.defined(options)) {
        this.options.sharpenSigma = -1;
      } else if (is.bool(options)) {
        this.options.sharpenSigma = options ? -1 : 0;
      } else if (is.number(options) && is.inRange(options, 0.01, 1e4)) {
        this.options.sharpenSigma = options;
        if (is.defined(flat)) {
          if (is.number(flat) && is.inRange(flat, 0, 1e4)) {
            this.options.sharpenM1 = flat;
          } else {
            throw is.invalidParameterError("flat", "number between 0 and 10000", flat);
          }
        }
        if (is.defined(jagged)) {
          if (is.number(jagged) && is.inRange(jagged, 0, 1e4)) {
            this.options.sharpenM2 = jagged;
          } else {
            throw is.invalidParameterError("jagged", "number between 0 and 10000", jagged);
          }
        }
      } else if (is.plainObject(options)) {
        if (is.number(options.sigma) && is.inRange(options.sigma, 1e-6, 10)) {
          this.options.sharpenSigma = options.sigma;
        } else {
          throw is.invalidParameterError("options.sigma", "number between 0.000001 and 10", options.sigma);
        }
        if (is.defined(options.m1)) {
          if (is.number(options.m1) && is.inRange(options.m1, 0, 1e6)) {
            this.options.sharpenM1 = options.m1;
          } else {
            throw is.invalidParameterError("options.m1", "number between 0 and 1000000", options.m1);
          }
        }
        if (is.defined(options.m2)) {
          if (is.number(options.m2) && is.inRange(options.m2, 0, 1e6)) {
            this.options.sharpenM2 = options.m2;
          } else {
            throw is.invalidParameterError("options.m2", "number between 0 and 1000000", options.m2);
          }
        }
        if (is.defined(options.x1)) {
          if (is.number(options.x1) && is.inRange(options.x1, 0, 1e6)) {
            this.options.sharpenX1 = options.x1;
          } else {
            throw is.invalidParameterError("options.x1", "number between 0 and 1000000", options.x1);
          }
        }
        if (is.defined(options.y2)) {
          if (is.number(options.y2) && is.inRange(options.y2, 0, 1e6)) {
            this.options.sharpenY2 = options.y2;
          } else {
            throw is.invalidParameterError("options.y2", "number between 0 and 1000000", options.y2);
          }
        }
        if (is.defined(options.y3)) {
          if (is.number(options.y3) && is.inRange(options.y3, 0, 1e6)) {
            this.options.sharpenY3 = options.y3;
          } else {
            throw is.invalidParameterError("options.y3", "number between 0 and 1000000", options.y3);
          }
        }
      } else {
        throw is.invalidParameterError("sigma", "number between 0.01 and 10000", options);
      }
      return this;
    }
    __name(sharpen, "sharpen");
    function median(size) {
      if (!is.defined(size)) {
        this.options.medianSize = 3;
      } else if (is.integer(size) && is.inRange(size, 1, 1e3)) {
        this.options.medianSize = size;
      } else {
        throw is.invalidParameterError("size", "integer between 1 and 1000", size);
      }
      return this;
    }
    __name(median, "median");
    function blur(options) {
      let sigma;
      if (is.number(options)) {
        sigma = options;
      } else if (is.plainObject(options)) {
        if (!is.number(options.sigma)) {
          throw is.invalidParameterError("options.sigma", "number between 0.3 and 1000", sigma);
        }
        sigma = options.sigma;
        if ("precision" in options) {
          if (is.string(vipsPrecision[options.precision])) {
            this.options.precision = vipsPrecision[options.precision];
          } else {
            throw is.invalidParameterError("precision", "one of: integer, float, approximate", options.precision);
          }
        }
        if ("minAmplitude" in options) {
          if (is.number(options.minAmplitude) && is.inRange(options.minAmplitude, 1e-3, 1)) {
            this.options.minAmpl = options.minAmplitude;
          } else {
            throw is.invalidParameterError("minAmplitude", "number between 0.001 and 1", options.minAmplitude);
          }
        }
      }
      if (!is.defined(options)) {
        this.options.blurSigma = -1;
      } else if (is.bool(options)) {
        this.options.blurSigma = options ? -1 : 0;
      } else if (is.number(sigma) && is.inRange(sigma, 0.3, 1e3)) {
        this.options.blurSigma = sigma;
      } else {
        throw is.invalidParameterError("sigma", "number between 0.3 and 1000", sigma);
      }
      return this;
    }
    __name(blur, "blur");
    function dilate(width) {
      if (!is.defined(width)) {
        this.options.dilateWidth = 1;
      } else if (is.integer(width) && width > 0) {
        this.options.dilateWidth = width;
      } else {
        throw is.invalidParameterError("dilate", "positive integer", dilate);
      }
      return this;
    }
    __name(dilate, "dilate");
    function erode(width) {
      if (!is.defined(width)) {
        this.options.erodeWidth = 1;
      } else if (is.integer(width) && width > 0) {
        this.options.erodeWidth = width;
      } else {
        throw is.invalidParameterError("erode", "positive integer", erode);
      }
      return this;
    }
    __name(erode, "erode");
    function flatten3(options) {
      this.options.flatten = is.bool(options) ? options : true;
      if (is.object(options)) {
        this._setBackgroundColourOption("flattenBackground", options.background);
      }
      return this;
    }
    __name(flatten3, "flatten");
    function unflatten() {
      this.options.unflatten = true;
      return this;
    }
    __name(unflatten, "unflatten");
    function gamma(gamma2, gammaOut) {
      if (!is.defined(gamma2)) {
        this.options.gamma = 2.2;
      } else if (is.number(gamma2) && is.inRange(gamma2, 1, 3)) {
        this.options.gamma = gamma2;
      } else {
        throw is.invalidParameterError("gamma", "number between 1.0 and 3.0", gamma2);
      }
      if (!is.defined(gammaOut)) {
        this.options.gammaOut = this.options.gamma;
      } else if (is.number(gammaOut) && is.inRange(gammaOut, 1, 3)) {
        this.options.gammaOut = gammaOut;
      } else {
        throw is.invalidParameterError("gammaOut", "number between 1.0 and 3.0", gammaOut);
      }
      return this;
    }
    __name(gamma, "gamma");
    function negate(options) {
      this.options.negate = is.bool(options) ? options : true;
      if (is.plainObject(options) && "alpha" in options) {
        if (!is.bool(options.alpha)) {
          throw is.invalidParameterError("alpha", "should be boolean value", options.alpha);
        } else {
          this.options.negateAlpha = options.alpha;
        }
      }
      return this;
    }
    __name(negate, "negate");
    function normalise(options) {
      if (is.plainObject(options)) {
        if (is.defined(options.lower)) {
          if (is.number(options.lower) && is.inRange(options.lower, 0, 99)) {
            this.options.normaliseLower = options.lower;
          } else {
            throw is.invalidParameterError("lower", "number between 0 and 99", options.lower);
          }
        }
        if (is.defined(options.upper)) {
          if (is.number(options.upper) && is.inRange(options.upper, 1, 100)) {
            this.options.normaliseUpper = options.upper;
          } else {
            throw is.invalidParameterError("upper", "number between 1 and 100", options.upper);
          }
        }
      }
      if (this.options.normaliseLower >= this.options.normaliseUpper) {
        throw is.invalidParameterError(
          "range",
          "lower to be less than upper",
          `${this.options.normaliseLower} >= ${this.options.normaliseUpper}`
        );
      }
      this.options.normalise = true;
      return this;
    }
    __name(normalise, "normalise");
    function normalize4(options) {
      return this.normalise(options);
    }
    __name(normalize4, "normalize");
    function clahe(options) {
      if (is.plainObject(options)) {
        if (is.integer(options.width) && options.width > 0) {
          this.options.claheWidth = options.width;
        } else {
          throw is.invalidParameterError("width", "integer greater than zero", options.width);
        }
        if (is.integer(options.height) && options.height > 0) {
          this.options.claheHeight = options.height;
        } else {
          throw is.invalidParameterError("height", "integer greater than zero", options.height);
        }
        if (is.defined(options.maxSlope)) {
          if (is.integer(options.maxSlope) && is.inRange(options.maxSlope, 0, 100)) {
            this.options.claheMaxSlope = options.maxSlope;
          } else {
            throw is.invalidParameterError("maxSlope", "integer between 0 and 100", options.maxSlope);
          }
        }
      } else {
        throw is.invalidParameterError("options", "plain object", options);
      }
      return this;
    }
    __name(clahe, "clahe");
    function convolve(kernel) {
      if (!is.object(kernel) || !Array.isArray(kernel.kernel) || !is.integer(kernel.width) || !is.integer(kernel.height) || !is.inRange(kernel.width, 3, 1001) || !is.inRange(kernel.height, 3, 1001) || kernel.height * kernel.width !== kernel.kernel.length) {
        throw new Error("Invalid convolution kernel");
      }
      if (!is.integer(kernel.scale)) {
        kernel.scale = kernel.kernel.reduce((a4, b3) => a4 + b3, 0);
      }
      if (kernel.scale < 1) {
        kernel.scale = 1;
      }
      if (!is.integer(kernel.offset)) {
        kernel.offset = 0;
      }
      this.options.convKernel = kernel;
      return this;
    }
    __name(convolve, "convolve");
    function threshold(threshold2, options) {
      if (!is.defined(threshold2)) {
        this.options.threshold = 128;
      } else if (is.bool(threshold2)) {
        this.options.threshold = threshold2 ? 128 : 0;
      } else if (is.integer(threshold2) && is.inRange(threshold2, 0, 255)) {
        this.options.threshold = threshold2;
      } else {
        throw is.invalidParameterError("threshold", "integer between 0 and 255", threshold2);
      }
      if (!is.object(options) || options.greyscale === true || options.grayscale === true) {
        this.options.thresholdGrayscale = true;
      } else {
        this.options.thresholdGrayscale = false;
      }
      return this;
    }
    __name(threshold, "threshold");
    function boolean(operand, operator, options) {
      this.options.boolean = this._createInputDescriptor(operand, options);
      if (is.string(operator) && is.inArray(operator, ["and", "or", "eor"])) {
        this.options.booleanOp = operator;
      } else {
        throw is.invalidParameterError("operator", "one of: and, or, eor", operator);
      }
      return this;
    }
    __name(boolean, "boolean");
    function linear(a4, b3) {
      if (!is.defined(a4) && is.number(b3)) {
        a4 = 1;
      } else if (is.number(a4) && !is.defined(b3)) {
        b3 = 0;
      }
      if (!is.defined(a4)) {
        this.options.linearA = [];
      } else if (is.number(a4)) {
        this.options.linearA = [a4];
      } else if (Array.isArray(a4) && a4.length && a4.every(is.number)) {
        this.options.linearA = a4;
      } else {
        throw is.invalidParameterError("a", "number or array of numbers", a4);
      }
      if (!is.defined(b3)) {
        this.options.linearB = [];
      } else if (is.number(b3)) {
        this.options.linearB = [b3];
      } else if (Array.isArray(b3) && b3.length && b3.every(is.number)) {
        this.options.linearB = b3;
      } else {
        throw is.invalidParameterError("b", "number or array of numbers", b3);
      }
      if (this.options.linearA.length !== this.options.linearB.length) {
        throw new Error("Expected a and b to be arrays of the same length");
      }
      return this;
    }
    __name(linear, "linear");
    function recomb(inputMatrix) {
      if (!Array.isArray(inputMatrix)) {
        throw is.invalidParameterError("inputMatrix", "array", inputMatrix);
      }
      if (inputMatrix.length !== 3 && inputMatrix.length !== 4) {
        throw is.invalidParameterError("inputMatrix", "3x3 or 4x4 array", inputMatrix.length);
      }
      const recombMatrix = inputMatrix.flat().map(Number);
      if (recombMatrix.length !== 9 && recombMatrix.length !== 16) {
        throw is.invalidParameterError("inputMatrix", "cardinality of 9 or 16", recombMatrix.length);
      }
      this.options.recombMatrix = recombMatrix;
      return this;
    }
    __name(recomb, "recomb");
    function modulate(options) {
      if (!is.plainObject(options)) {
        throw is.invalidParameterError("options", "plain object", options);
      }
      if ("brightness" in options) {
        if (is.number(options.brightness) && options.brightness >= 0) {
          this.options.brightness = options.brightness;
        } else {
          throw is.invalidParameterError("brightness", "number above zero", options.brightness);
        }
      }
      if ("saturation" in options) {
        if (is.number(options.saturation) && options.saturation >= 0) {
          this.options.saturation = options.saturation;
        } else {
          throw is.invalidParameterError("saturation", "number above zero", options.saturation);
        }
      }
      if ("hue" in options) {
        if (is.integer(options.hue)) {
          this.options.hue = options.hue % 360;
        } else {
          throw is.invalidParameterError("hue", "number", options.hue);
        }
      }
      if ("lightness" in options) {
        if (is.number(options.lightness)) {
          this.options.lightness = options.lightness;
        } else {
          throw is.invalidParameterError("lightness", "number", options.lightness);
        }
      }
      return this;
    }
    __name(modulate, "modulate");
    module.exports = (Sharp) => {
      Object.assign(Sharp.prototype, {
        autoOrient,
        rotate,
        flip,
        flop,
        affine,
        sharpen,
        erode,
        dilate,
        median,
        blur,
        flatten: flatten3,
        unflatten,
        gamma,
        negate,
        normalise,
        normalize: normalize4,
        clahe,
        convolve,
        threshold,
        boolean,
        linear,
        recomb,
        modulate
      });
    };
  }
});

// ../../node_modules/.pnpm/@img+colour@1.0.0/node_modules/@img/colour/color.cjs
var require_color = __commonJS({
  "../../node_modules/.pnpm/@img+colour@1.0.0/node_modules/@img/colour/color.cjs"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from4, except, desc) => {
      if (from4 && typeof from4 === "object" || typeof from4 === "function") {
        for (let key of __getOwnPropNames2(from4))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: /* @__PURE__ */ __name(() => from4[key], "get"), enumerable: !(desc = __getOwnPropDesc2(from4, key)) || desc.enumerable });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod), "__toCommonJS");
    var index_exports = {};
    __export2(index_exports, {
      default: /* @__PURE__ */ __name(() => index_default, "default")
    });
    module.exports = __toCommonJS(index_exports);
    var color_name_default = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (const name in color_name_default) {
      if (Object.hasOwn(color_name_default, name)) {
        reverseNames[color_name_default[name]] = name;
      }
    }
    var cs = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      const prefix = string.slice(0, 3).toLowerCase();
      let value2;
      let model;
      switch (prefix) {
        case "hsl": {
          value2 = cs.get.hsl(string);
          model = "hsl";
          break;
        }
        case "hwb": {
          value2 = cs.get.hwb(string);
          model = "hwb";
          break;
        }
        default: {
          value2 = cs.get.rgb(string);
          model = "rgb";
          break;
        }
      }
      if (!value2) {
        return null;
      }
      return { model, value: value2 };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      const abbr = /^#([a-f\d]{3,4})$/i;
      const hex = /^#([a-f\d]{6})([a-f\d]{2})?$/i;
      const rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[\s,|/]\s*([+-]?[\d.]+)(%?)\s*)?\)$/;
      const per = /^rgba?\(\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*(?:[\s,|/]\s*([+-]?[\d.]+)(%?)\s*)?\)$/;
      const keyword = /^(\w+)$/;
      let rgb = [0, 0, 0, 1];
      let match2;
      let i2;
      let hexAlpha;
      if (match2 = string.match(hex)) {
        hexAlpha = match2[2];
        match2 = match2[1];
        for (i2 = 0; i2 < 3; i2++) {
          const i22 = i2 * 2;
          rgb[i2] = Number.parseInt(match2.slice(i22, i22 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = Number.parseInt(hexAlpha, 16) / 255;
        }
      } else if (match2 = string.match(abbr)) {
        match2 = match2[1];
        hexAlpha = match2[3];
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = Number.parseInt(match2[i2] + match2[i2], 16);
        }
        if (hexAlpha) {
          rgb[3] = Number.parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match2 = string.match(rgba)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = Number.parseInt(match2[i2 + 1], 10);
        }
        if (match2[4]) {
          rgb[3] = match2[5] ? Number.parseFloat(match2[4]) * 0.01 : Number.parseFloat(match2[4]);
        }
      } else if (match2 = string.match(per)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = Math.round(Number.parseFloat(match2[i2 + 1]) * 2.55);
        }
        if (match2[4]) {
          rgb[3] = match2[5] ? Number.parseFloat(match2[4]) * 0.01 : Number.parseFloat(match2[4]);
        }
      } else if (match2 = string.match(keyword)) {
        if (match2[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!Object.hasOwn(color_name_default, match2[1])) {
          return null;
        }
        rgb = color_name_default[match2[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i2 = 0; i2 < 3; i2++) {
        rgb[i2] = clamp(rgb[i2], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      const hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*(?:[,|/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      const match2 = string.match(hsl);
      if (match2) {
        const alpha = Number.parseFloat(match2[4]);
        const h = (Number.parseFloat(match2[1]) % 360 + 360) % 360;
        const s4 = clamp(Number.parseFloat(match2[2]), 0, 100);
        const l4 = clamp(Number.parseFloat(match2[3]), 0, 100);
        const a4 = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s4, l4, a4];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      const hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*[\s,]\s*([+-]?[\d.]+)%\s*[\s,]\s*([+-]?[\d.]+)%\s*(?:[\s,]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      const match2 = string.match(hwb);
      if (match2) {
        const alpha = Number.parseFloat(match2[4]);
        const h = (Number.parseFloat(match2[1]) % 360 + 360) % 360;
        const w = clamp(Number.parseFloat(match2[2]), 0, 100);
        const b3 = clamp(Number.parseFloat(match2[3]), 0, 100);
        const a4 = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b3, a4];
      }
      return null;
    };
    cs.to.hex = function(...rgba) {
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function(...rgba) {
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function(...rgba) {
      const r5 = Math.round(rgba[0] / 255 * 100);
      const g = Math.round(rgba[1] / 255 * 100);
      const b3 = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r5 + "%, " + g + "%, " + b3 + "%)" : "rgba(" + r5 + "%, " + g + "%, " + b3 + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function(...hsla) {
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function(...hwba) {
      let a4 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a4 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a4 + ")";
    };
    cs.to.keyword = function(...rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(number_, min2, max2) {
      return Math.min(Math.max(min2, number_), max2);
    }
    __name(clamp, "clamp");
    function hexDouble(number_) {
      const string_ = Math.round(number_).toString(16).toUpperCase();
      return string_.length < 2 ? "0" + string_ : string_;
    }
    __name(hexDouble, "hexDouble");
    var color_string_default = cs;
    var reverseKeywords = {};
    for (const key of Object.keys(color_name_default)) {
      reverseKeywords[color_name_default[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      oklab: { channels: 3, labels: ["okl", "oka", "okb"] },
      lch: { channels: 3, labels: "lch" },
      oklch: { channels: 3, labels: ["okl", "okc", "okh"] },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    var conversions_default = convert;
    var LAB_FT = (6 / 29) ** 3;
    function srgbNonlinearTransform(c2) {
      const cc = c2 > 31308e-7 ? 1.055 * c2 ** (1 / 2.4) - 0.055 : c2 * 12.92;
      return Math.min(Math.max(0, cc), 1);
    }
    __name(srgbNonlinearTransform, "srgbNonlinearTransform");
    function srgbNonlinearTransformInv(c2) {
      return c2 > 0.04045 ? ((c2 + 0.055) / 1.055) ** 2.4 : c2 / 12.92;
    }
    __name(srgbNonlinearTransformInv, "srgbNonlinearTransformInv");
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r5 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b3 = rgb[2] / 255;
      const min2 = Math.min(r5, g, b3);
      const max2 = Math.max(r5, g, b3);
      const delta = max2 - min2;
      let h;
      let s4;
      switch (max2) {
        case min2: {
          h = 0;
          break;
        }
        case r5: {
          h = (g - b3) / delta;
          break;
        }
        case g: {
          h = 2 + (b3 - r5) / delta;
          break;
        }
        case b3: {
          h = 4 + (r5 - g) / delta;
          break;
        }
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l4 = (min2 + max2) / 2;
      if (max2 === min2) {
        s4 = 0;
      } else if (l4 <= 0.5) {
        s4 = delta / (max2 + min2);
      } else {
        s4 = delta / (2 - max2 - min2);
      }
      return [h, s4 * 100, l4 * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s4;
      const r5 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b3 = rgb[2] / 255;
      const v3 = Math.max(r5, g, b3);
      const diff = v3 - Math.min(r5, g, b3);
      const diffc = /* @__PURE__ */ __name(function(c2) {
        return (v3 - c2) / 6 / diff + 1 / 2;
      }, "diffc");
      if (diff === 0) {
        h = 0;
        s4 = 0;
      } else {
        s4 = diff / v3;
        rdif = diffc(r5);
        gdif = diffc(g);
        bdif = diffc(b3);
        switch (v3) {
          case r5: {
            h = bdif - gdif;
            break;
          }
          case g: {
            h = 1 / 3 + rdif - bdif;
            break;
          }
          case b3: {
            h = 2 / 3 + gdif - rdif;
            break;
          }
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s4 * 100,
        v3 * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r5 = rgb[0];
      const g = rgb[1];
      let b3 = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r5, Math.min(g, b3));
      b3 = 1 - 1 / 255 * Math.max(r5, Math.max(g, b3));
      return [h, w * 100, b3 * 100];
    };
    convert.rgb.oklab = function(rgb) {
      const r5 = srgbNonlinearTransformInv(rgb[0] / 255);
      const g = srgbNonlinearTransformInv(rgb[1] / 255);
      const b3 = srgbNonlinearTransformInv(rgb[2] / 255);
      const lp = Math.cbrt(0.4122214708 * r5 + 0.5363325363 * g + 0.0514459929 * b3);
      const mp = Math.cbrt(0.2119034982 * r5 + 0.6806995451 * g + 0.1073969566 * b3);
      const sp = Math.cbrt(0.0883024619 * r5 + 0.2817188376 * g + 0.6299787005 * b3);
      const l4 = 0.2104542553 * lp + 0.793617785 * mp - 0.0040720468 * sp;
      const aa = 1.9779984951 * lp - 2.428592205 * mp + 0.4505937099 * sp;
      const bb = 0.0259040371 * lp + 0.7827717662 * mp - 0.808675766 * sp;
      return [l4 * 100, aa * 100, bb * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r5 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b3 = rgb[2] / 255;
      const k3 = Math.min(1 - r5, 1 - g, 1 - b3);
      const c2 = (1 - r5 - k3) / (1 - k3) || 0;
      const m3 = (1 - g - k3) / (1 - k3) || 0;
      const y3 = (1 - b3 - k3) / (1 - k3) || 0;
      return [c2 * 100, m3 * 100, y3 * 100, k3 * 100];
    };
    function comparativeDistance(x, y3) {
      return (x[0] - y3[0]) ** 2 + (x[1] - y3[1]) ** 2 + (x[2] - y3[2]) ** 2;
    }
    __name(comparativeDistance, "comparativeDistance");
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Number.POSITIVE_INFINITY;
      let currentClosestKeyword;
      for (const keyword of Object.keys(color_name_default)) {
        const value2 = color_name_default[keyword];
        const distance = comparativeDistance(rgb, value2);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return color_name_default[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      const r5 = srgbNonlinearTransformInv(rgb[0] / 255);
      const g = srgbNonlinearTransformInv(rgb[1] / 255);
      const b3 = srgbNonlinearTransformInv(rgb[2] / 255);
      const x = r5 * 0.4124564 + g * 0.3575761 + b3 * 0.1804375;
      const y3 = r5 * 0.2126729 + g * 0.7151522 + b3 * 0.072175;
      const z = r5 * 0.0193339 + g * 0.119192 + b3 * 0.9503041;
      return [x * 100, y3 * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y3 = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y3 /= 100;
      z /= 108.883;
      x = x > LAB_FT ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y3 = y3 > LAB_FT ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116;
      z = z > LAB_FT ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l4 = 116 * y3 - 16;
      const a4 = 500 * (x - y3);
      const b3 = 200 * (y3 - z);
      return [l4, a4, b3];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s4 = hsl[1] / 100;
      const l4 = hsl[2] / 100;
      let t32;
      let value2;
      if (s4 === 0) {
        value2 = l4 * 255;
        return [value2, value2, value2];
      }
      const t22 = l4 < 0.5 ? l4 * (1 + s4) : l4 + s4 - l4 * s4;
      const t1 = 2 * l4 - t22;
      const rgb = [0, 0, 0];
      for (let i2 = 0; i2 < 3; i2++) {
        t32 = h + 1 / 3 * -(i2 - 1);
        if (t32 < 0) {
          t32++;
        }
        if (t32 > 1) {
          t32--;
        }
        if (6 * t32 < 1) {
          value2 = t1 + (t22 - t1) * 6 * t32;
        } else if (2 * t32 < 1) {
          value2 = t22;
        } else if (3 * t32 < 2) {
          value2 = t1 + (t22 - t1) * (2 / 3 - t32) * 6;
        } else {
          value2 = t1;
        }
        rgb[i2] = value2 * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s4 = hsl[1] / 100;
      let l4 = hsl[2] / 100;
      let smin = s4;
      const lmin = Math.max(l4, 0.01);
      l4 *= 2;
      s4 *= l4 <= 1 ? l4 : 2 - l4;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v3 = (l4 + s4) / 2;
      const sv = l4 === 0 ? 2 * smin / (lmin + smin) : 2 * s4 / (l4 + s4);
      return [h, sv * 100, v3 * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s4 = hsv[1] / 100;
      let v3 = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f4 = h - Math.floor(h);
      const p3 = 255 * v3 * (1 - s4);
      const q = 255 * v3 * (1 - s4 * f4);
      const t4 = 255 * v3 * (1 - s4 * (1 - f4));
      v3 *= 255;
      switch (hi) {
        case 0: {
          return [v3, t4, p3];
        }
        case 1: {
          return [q, v3, p3];
        }
        case 2: {
          return [p3, v3, t4];
        }
        case 3: {
          return [p3, q, v3];
        }
        case 4: {
          return [t4, p3, v3];
        }
        case 5: {
          return [v3, p3, q];
        }
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s4 = hsv[1] / 100;
      const v3 = hsv[2] / 100;
      const vmin = Math.max(v3, 0.01);
      let sl;
      let l4;
      l4 = (2 - s4) * v3;
      const lmin = (2 - s4) * vmin;
      sl = s4 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l4 /= 2;
      return [h, sl * 100, l4 * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f4;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i2 = Math.floor(6 * h);
      const v3 = 1 - bl;
      f4 = 6 * h - i2;
      if ((i2 & 1) !== 0) {
        f4 = 1 - f4;
      }
      const n5 = wh + f4 * (v3 - wh);
      let r5;
      let g;
      let b3;
      switch (i2) {
        default:
        case 6:
        case 0: {
          r5 = v3;
          g = n5;
          b3 = wh;
          break;
        }
        case 1: {
          r5 = n5;
          g = v3;
          b3 = wh;
          break;
        }
        case 2: {
          r5 = wh;
          g = v3;
          b3 = n5;
          break;
        }
        case 3: {
          r5 = wh;
          g = n5;
          b3 = v3;
          break;
        }
        case 4: {
          r5 = n5;
          g = wh;
          b3 = v3;
          break;
        }
        case 5: {
          r5 = v3;
          g = wh;
          b3 = n5;
          break;
        }
      }
      return [r5 * 255, g * 255, b3 * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c2 = cmyk[0] / 100;
      const m3 = cmyk[1] / 100;
      const y3 = cmyk[2] / 100;
      const k3 = cmyk[3] / 100;
      const r5 = 1 - Math.min(1, c2 * (1 - k3) + k3);
      const g = 1 - Math.min(1, m3 * (1 - k3) + k3);
      const b3 = 1 - Math.min(1, y3 * (1 - k3) + k3);
      return [r5 * 255, g * 255, b3 * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y3 = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r5;
      let g;
      let b3;
      r5 = x * 3.2404542 + y3 * -1.5371385 + z * -0.4985314;
      g = x * -0.969266 + y3 * 1.8760108 + z * 0.041556;
      b3 = x * 0.0556434 + y3 * -0.2040259 + z * 1.0572252;
      r5 = srgbNonlinearTransform(r5);
      g = srgbNonlinearTransform(g);
      b3 = srgbNonlinearTransform(b3);
      return [r5 * 255, g * 255, b3 * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y3 = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y3 /= 100;
      z /= 108.883;
      x = x > LAB_FT ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y3 = y3 > LAB_FT ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116;
      z = z > LAB_FT ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l4 = 116 * y3 - 16;
      const a4 = 500 * (x - y3);
      const b3 = 200 * (y3 - z);
      return [l4, a4, b3];
    };
    convert.xyz.oklab = function(xyz) {
      const x = xyz[0] / 100;
      const y3 = xyz[1] / 100;
      const z = xyz[2] / 100;
      const lp = Math.cbrt(0.8189330101 * x + 0.3618667424 * y3 - 0.1288597137 * z);
      const mp = Math.cbrt(0.0329845436 * x + 0.9293118715 * y3 + 0.0361456387 * z);
      const sp = Math.cbrt(0.0482003018 * x + 0.2643662691 * y3 + 0.633851707 * z);
      const l4 = 0.2104542553 * lp + 0.793617785 * mp - 0.0040720468 * sp;
      const a4 = 1.9779984951 * lp - 2.428592205 * mp + 0.4505937099 * sp;
      const b3 = 0.0259040371 * lp + 0.7827717662 * mp - 0.808675766 * sp;
      return [l4 * 100, a4 * 100, b3 * 100];
    };
    convert.oklab.oklch = function(oklab) {
      return convert.lab.lch(oklab);
    };
    convert.oklab.xyz = function(oklab) {
      const ll = oklab[0] / 100;
      const a4 = oklab[1] / 100;
      const b3 = oklab[2] / 100;
      const l4 = (0.999999998 * ll + 0.396337792 * a4 + 0.215803758 * b3) ** 3;
      const m3 = (1.000000008 * ll - 0.105561342 * a4 - 0.063854175 * b3) ** 3;
      const s4 = (1.000000055 * ll - 0.089484182 * a4 - 1.291485538 * b3) ** 3;
      const x = 1.227013851 * l4 - 0.55779998 * m3 + 0.281256149 * s4;
      const y3 = -0.040580178 * l4 + 1.11225687 * m3 - 0.071676679 * s4;
      const z = -0.076381285 * l4 - 0.421481978 * m3 + 1.58616322 * s4;
      return [x * 100, y3 * 100, z * 100];
    };
    convert.oklab.rgb = function(oklab) {
      const ll = oklab[0] / 100;
      const aa = oklab[1] / 100;
      const bb = oklab[2] / 100;
      const l4 = (ll + 0.3963377774 * aa + 0.2158037573 * bb) ** 3;
      const m3 = (ll - 0.1055613458 * aa - 0.0638541728 * bb) ** 3;
      const s4 = (ll - 0.0894841775 * aa - 1.291485548 * bb) ** 3;
      const r5 = srgbNonlinearTransform(4.0767416621 * l4 - 3.3077115913 * m3 + 0.2309699292 * s4);
      const g = srgbNonlinearTransform(-1.2684380046 * l4 + 2.6097574011 * m3 - 0.3413193965 * s4);
      const b3 = srgbNonlinearTransform(-0.0041960863 * l4 - 0.7034186147 * m3 + 1.707614701 * s4);
      return [r5 * 255, g * 255, b3 * 255];
    };
    convert.oklch.oklab = function(oklch) {
      return convert.lch.lab(oklch);
    };
    convert.lab.xyz = function(lab) {
      const l4 = lab[0];
      const a4 = lab[1];
      const b3 = lab[2];
      let x;
      let y3;
      let z;
      y3 = (l4 + 16) / 116;
      x = a4 / 500 + y3;
      z = y3 - b3 / 200;
      const y22 = y3 ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y3 = y22 > LAB_FT ? y22 : (y3 - 16 / 116) / 7.787;
      x = x2 > LAB_FT ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > LAB_FT ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y3 *= 100;
      z *= 108.883;
      return [x, y3, z];
    };
    convert.lab.lch = function(lab) {
      const l4 = lab[0];
      const a4 = lab[1];
      const b3 = lab[2];
      let h;
      const hr = Math.atan2(b3, a4);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c2 = Math.sqrt(a4 * a4 + b3 * b3);
      return [l4, c2, h];
    };
    convert.lch.lab = function(lch) {
      const l4 = lch[0];
      const c2 = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a4 = c2 * Math.cos(hr);
      const b3 = c2 * Math.sin(hr);
      return [l4, a4, b3];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r5, g, b3] = args;
      let value2 = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value2 = Math.round(value2 / 50);
      if (value2 === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b3 / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r5 / 255));
      if (value2 === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r5 = args[0];
      const g = args[1];
      const b3 = args[2];
      if (r5 >> 4 === g >> 4 && g >> 4 === b3 >> 4) {
        if (r5 < 8) {
          return 16;
        }
        if (r5 > 248) {
          return 231;
        }
        return Math.round((r5 - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r5 / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b3 / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      args = args[0];
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (Math.trunc(args > 50) + 1) * 0.5;
      const r5 = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b3 = (color >> 2 & 1) * mult * 255;
      return [r5, g, b3];
    };
    convert.ansi256.rgb = function(args) {
      args = args[0];
      if (args >= 232) {
        const c2 = (args - 232) * 10 + 8;
        return [c2, c2, c2];
      }
      args -= 16;
      let rem;
      const r5 = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b3 = rem % 6 / 5 * 255;
      return [r5, g, b3];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".slice(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match2 = args.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
      if (!match2) {
        return [0, 0, 0];
      }
      let colorString3 = match2[0];
      if (match2[0].length === 3) {
        colorString3 = [...colorString3].map((char) => char + char).join("");
      }
      const integer = Number.parseInt(colorString3, 16);
      const r5 = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b3 = integer & 255;
      return [r5, g, b3];
    };
    convert.rgb.hcg = function(rgb) {
      const r5 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b3 = rgb[2] / 255;
      const max2 = Math.max(Math.max(r5, g), b3);
      const min2 = Math.min(Math.min(r5, g), b3);
      const chroma = max2 - min2;
      let hue;
      const grayscale = chroma < 1 ? min2 / (1 - chroma) : 0;
      if (chroma <= 0) {
        hue = 0;
      } else if (max2 === r5) {
        hue = (g - b3) / chroma % 6;
      } else if (max2 === g) {
        hue = 2 + (b3 - r5) / chroma;
      } else {
        hue = 4 + (r5 - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s4 = hsl[1] / 100;
      const l4 = hsl[2] / 100;
      const c2 = l4 < 0.5 ? 2 * s4 * l4 : 2 * s4 * (1 - l4);
      let f4 = 0;
      if (c2 < 1) {
        f4 = (l4 - 0.5 * c2) / (1 - c2);
      }
      return [hsl[0], c2 * 100, f4 * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s4 = hsv[1] / 100;
      const v3 = hsv[2] / 100;
      const c2 = s4 * v3;
      let f4 = 0;
      if (c2 < 1) {
        f4 = (v3 - c2) / (1 - c2);
      }
      return [hsv[0], c2 * 100, f4 * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c2 === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v3 = hi % 1;
      const w = 1 - v3;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0: {
          pure[0] = 1;
          pure[1] = v3;
          pure[2] = 0;
          break;
        }
        case 1: {
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        }
        case 2: {
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v3;
          break;
        }
        case 3: {
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        }
        case 4: {
          pure[0] = v3;
          pure[1] = 0;
          pure[2] = 1;
          break;
        }
        default: {
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
        }
      }
      mg = (1 - c2) * g;
      return [
        (c2 * pure[0] + mg) * 255,
        (c2 * pure[1] + mg) * 255,
        (c2 * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v3 = c2 + g * (1 - c2);
      let f4 = 0;
      if (v3 > 0) {
        f4 = c2 / v3;
      }
      return [hcg[0], f4 * 100, v3 * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l4 = g * (1 - c2) + 0.5 * c2;
      let s4 = 0;
      if (l4 > 0 && l4 < 0.5) {
        s4 = c2 / (2 * l4);
      } else if (l4 >= 0.5 && l4 < 1) {
        s4 = c2 / (2 * (1 - l4));
      }
      return [hcg[0], s4 * 100, l4 * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v3 = c2 + g * (1 - c2);
      return [hcg[0], (v3 - c2) * 100, (1 - v3) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b3 = hwb[2] / 100;
      const v3 = 1 - b3;
      const c2 = v3 - w;
      let g = 0;
      if (c2 < 1) {
        g = (v3 - c2) / (1 - c2);
      }
      return [hwb[0], c2 * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const value2 = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (value2 << 16) + (value2 << 8) + value2;
      const string = integer.toString(16).toUpperCase();
      return "000000".slice(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const value2 = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [value2 / 255 * 100];
    };
    function buildGraph() {
      const graph = {};
      const models2 = Object.keys(conversions_default);
      for (let { length: length2 } = models2, i2 = 0; i2 < length2; i2++) {
        graph[models2[i2]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    __name(buildGraph, "buildGraph");
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue4 = [fromModel];
      graph[fromModel].distance = 0;
      while (queue4.length > 0) {
        const current = queue4.pop();
        const adjacents = Object.keys(conversions_default[current]);
        for (let { length: length2 } = adjacents, i2 = 0; i2 < length2; i2++) {
          const adjacent = adjacents[i2];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue4.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    __name(deriveBFS, "deriveBFS");
    function link3(from4, to) {
      return function(args) {
        return to(from4(args));
      };
    }
    __name(link3, "link");
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions_default[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link3(conversions_default[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    __name(wrapConversion, "wrapConversion");
    function route(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models2 = Object.keys(graph);
      for (let { length: length2 } = models2, i2 = 0; i2 < length2; i2++) {
        const toModel = models2[i2];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    }
    __name(route, "route");
    var route_default = route;
    var convert2 = {};
    var models = Object.keys(conversions_default);
    function wrapRaw(fn) {
      const wrappedFn = /* @__PURE__ */ __name(function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      }, "wrappedFn");
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    __name(wrapRaw, "wrapRaw");
    function wrapRounded(fn) {
      const wrappedFn = /* @__PURE__ */ __name(function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let { length: length2 } = result, i2 = 0; i2 < length2; i2++) {
            result[i2] = Math.round(result[i2]);
          }
        }
        return result;
      }, "wrappedFn");
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    __name(wrapRounded, "wrapRounded");
    for (const fromModel of models) {
      convert2[fromModel] = {};
      Object.defineProperty(convert2[fromModel], "channels", { value: conversions_default[fromModel].channels });
      Object.defineProperty(convert2[fromModel], "labels", { value: conversions_default[fromModel].labels });
      const routes = route_default(fromModel);
      const routeModels = Object.keys(routes);
      for (const toModel of routeModels) {
        const fn = routes[toModel];
        convert2[fromModel][toModel] = wrapRounded(fn);
        convert2[fromModel][toModel].raw = wrapRaw(fn);
      }
    }
    var color_convert_default = convert2;
    var skippedModels = [
      // To be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // Gray conflicts with some method names, and has its own method defined.
      "gray",
      // Shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    for (const model of Object.keys(color_convert_default)) {
      hashedModelKeys[[...color_convert_default[model].labels].sort().join("")] = model;
    }
    var limiters = {};
    function Color(object, model) {
      if (!(this instanceof Color)) {
        return new Color(object, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in color_convert_default)) {
        throw new Error("Unknown model: " + model);
      }
      let i2;
      let channels;
      if (object == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (object instanceof Color) {
        this.model = object.model;
        this.color = [...object.color];
        this.valpha = object.valpha;
      } else if (typeof object === "string") {
        const result = color_string_default.get(object);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + object);
        }
        this.model = result.model;
        channels = color_convert_default[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (object.length > 0) {
        this.model = model || "rgb";
        channels = color_convert_default[this.model].channels;
        const newArray = Array.prototype.slice.call(object, 0, channels);
        this.color = zeroArray(newArray, channels);
        this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
      } else if (typeof object === "number") {
        this.model = "rgb";
        this.color = [
          object >> 16 & 255,
          object >> 8 & 255,
          object & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        const keys2 = Object.keys(object);
        if ("alpha" in object) {
          keys2.splice(keys2.indexOf("alpha"), 1);
          this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
        }
        const hashedKeys = keys2.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(object));
        }
        this.model = hashedModelKeys[hashedKeys];
        const { labels } = color_convert_default[this.model];
        const color = [];
        for (i2 = 0; i2 < labels.length; i2++) {
          color.push(object[labels[i2]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = color_convert_default[this.model].channels;
        for (i2 = 0; i2 < channels; i2++) {
          const limit = limiters[this.model][i2];
          if (limit) {
            this.color[i2] = limit(this.color[i2]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    __name(Color, "Color");
    Color.prototype = {
      toString() {
        return this.string();
      },
      toJSON() {
        return this[this.model]();
      },
      string(places) {
        let self2 = this.model in color_string_default.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        const arguments_ = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
        return color_string_default.to[self2.model](...arguments_);
      },
      percentString(places) {
        const self2 = this.rgb().round(typeof places === "number" ? places : 1);
        const arguments_ = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
        return color_string_default.to.rgb.percent(...arguments_);
      },
      array() {
        return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
      },
      object() {
        const result = {};
        const { channels } = color_convert_default[this.model];
        const { labels } = color_convert_default[this.model];
        for (let i2 = 0; i2 < channels; i2++) {
          result[labels[i2]] = this.color[i2];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray() {
        const rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject() {
        const rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round(places) {
        places = Math.max(places || 0, 0);
        return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
      },
      alpha(value2) {
        if (value2 !== void 0) {
          return new Color([...this.color, Math.max(0, Math.min(1, value2))], this.model);
        }
        return this.valpha;
      },
      // Rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value2) => (value2 % 360 + 360) % 360),
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(95.047)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(108.833)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword(value2) {
        if (value2 !== void 0) {
          return new Color(value2);
        }
        return color_convert_default[this.model].keyword(this.color);
      },
      hex(value2) {
        if (value2 !== void 0) {
          return new Color(value2);
        }
        return color_string_default.to.hex(...this.rgb().round().color);
      },
      hexa(value2) {
        if (value2 !== void 0) {
          return new Color(value2);
        }
        const rgbArray = this.rgb().round().color;
        let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
        if (alphaHex.length === 1) {
          alphaHex = "0" + alphaHex;
        }
        return color_string_default.to.hex(...rgbArray) + alphaHex;
      },
      rgbNumber() {
        const rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity() {
        const rgb = this.rgb().color;
        const lum = [];
        for (const [i2, element] of rgb.entries()) {
          const chan = element / 255;
          lum[i2] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast(color2) {
        const lum1 = this.luminosity();
        const lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level(color2) {
        const contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark() {
        const rgb = this.rgb().color;
        const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
        return yiq < 128;
      },
      isLight() {
        return !this.isDark();
      },
      negate() {
        const rgb = this.rgb();
        for (let i2 = 0; i2 < 3; i2++) {
          rgb.color[i2] = 255 - rgb.color[i2];
        }
        return rgb;
      },
      lighten(ratio) {
        const hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken(ratio) {
        const hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten(ratio) {
        const hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken(ratio) {
        const hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale() {
        const rgb = this.rgb().color;
        const value2 = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(value2, value2, value2);
      },
      fade(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate(degrees) {
        const hsl = this.hsl();
        let hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        const color1 = mixinColor.rgb();
        const color2 = this.rgb();
        const p3 = weight === void 0 ? 0.5 : weight;
        const w = 2 * p3 - 1;
        const a4 = color1.alpha() - color2.alpha();
        const w1 = ((w * a4 === -1 ? w : (w + a4) / (1 + w * a4)) + 1) / 2;
        const w2 = 1 - w1;
        return Color.rgb(
          w1 * color1.red() + w2 * color2.red(),
          w1 * color1.green() + w2 * color2.green(),
          w1 * color1.blue() + w2 * color2.blue(),
          color1.alpha() * p3 + color2.alpha() * (1 - p3)
        );
      }
    };
    for (const model of Object.keys(color_convert_default)) {
      if (skippedModels.includes(model)) {
        continue;
      }
      const { channels } = color_convert_default[model];
      Color.prototype[model] = function(...arguments_) {
        if (this.model === model) {
          return new Color(this);
        }
        if (arguments_.length > 0) {
          return new Color(arguments_, model);
        }
        return new Color([...assertArray(color_convert_default[this.model][model].raw(this.color)), this.valpha], model);
      };
      Color[model] = function(...arguments_) {
        let color = arguments_[0];
        if (typeof color === "number") {
          color = zeroArray(arguments_, channels);
        }
        return new Color(color, model);
      };
    }
    function roundTo(number3, places) {
      return Number(number3.toFixed(places));
    }
    __name(roundTo, "roundTo");
    function roundToPlace(places) {
      return function(number3) {
        return roundTo(number3, places);
      };
    }
    __name(roundToPlace, "roundToPlace");
    function getset(model, channel2, modifier) {
      model = Array.isArray(model) ? model : [model];
      for (const m3 of model) {
        (limiters[m3] ||= [])[channel2] = modifier;
      }
      model = model[0];
      return function(value2) {
        let result;
        if (value2 !== void 0) {
          if (modifier) {
            value2 = modifier(value2);
          }
          result = this[model]();
          result.color[channel2] = value2;
          return result;
        }
        result = this[model]().color[channel2];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    __name(getset, "getset");
    function maxfn(max2) {
      return function(v3) {
        return Math.max(0, Math.min(max2, v3));
      };
    }
    __name(maxfn, "maxfn");
    function assertArray(value2) {
      return Array.isArray(value2) ? value2 : [value2];
    }
    __name(assertArray, "assertArray");
    function zeroArray(array, length2) {
      for (let i2 = 0; i2 < length2; i2++) {
        if (typeof array[i2] !== "number") {
          array[i2] = 0;
        }
      }
      return array;
    }
    __name(zeroArray, "zeroArray");
    var index_default = Color;
  }
});

// ../../node_modules/.pnpm/@img+colour@1.0.0/node_modules/@img/colour/index.cjs
var require_colour = __commonJS({
  "../../node_modules/.pnpm/@img+colour@1.0.0/node_modules/@img/colour/index.cjs"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = require_color().default;
  }
});

// ../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/colour.js
var require_colour2 = __commonJS({
  "../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/colour.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var color = require_colour();
    var is = require_is();
    var colourspace = {
      multiband: "multiband",
      "b-w": "b-w",
      bw: "b-w",
      cmyk: "cmyk",
      srgb: "srgb"
    };
    function tint(tint2) {
      this._setBackgroundColourOption("tint", tint2);
      return this;
    }
    __name(tint, "tint");
    function greyscale(greyscale2) {
      this.options.greyscale = is.bool(greyscale2) ? greyscale2 : true;
      return this;
    }
    __name(greyscale, "greyscale");
    function grayscale(grayscale2) {
      return this.greyscale(grayscale2);
    }
    __name(grayscale, "grayscale");
    function pipelineColourspace(colourspace2) {
      if (!is.string(colourspace2)) {
        throw is.invalidParameterError("colourspace", "string", colourspace2);
      }
      this.options.colourspacePipeline = colourspace2;
      return this;
    }
    __name(pipelineColourspace, "pipelineColourspace");
    function pipelineColorspace(colorspace) {
      return this.pipelineColourspace(colorspace);
    }
    __name(pipelineColorspace, "pipelineColorspace");
    function toColourspace(colourspace2) {
      if (!is.string(colourspace2)) {
        throw is.invalidParameterError("colourspace", "string", colourspace2);
      }
      this.options.colourspace = colourspace2;
      return this;
    }
    __name(toColourspace, "toColourspace");
    function toColorspace(colorspace) {
      return this.toColourspace(colorspace);
    }
    __name(toColorspace, "toColorspace");
    function _getBackgroundColourOption(value2) {
      if (is.object(value2) || is.string(value2) && value2.length >= 3 && value2.length <= 200) {
        const colour = color(value2);
        return [
          colour.red(),
          colour.green(),
          colour.blue(),
          Math.round(colour.alpha() * 255)
        ];
      } else {
        throw is.invalidParameterError("background", "object or string", value2);
      }
    }
    __name(_getBackgroundColourOption, "_getBackgroundColourOption");
    function _setBackgroundColourOption(key, value2) {
      if (is.defined(value2)) {
        this.options[key] = _getBackgroundColourOption(value2);
      }
    }
    __name(_setBackgroundColourOption, "_setBackgroundColourOption");
    module.exports = (Sharp) => {
      Object.assign(Sharp.prototype, {
        // Public
        tint,
        greyscale,
        grayscale,
        pipelineColourspace,
        pipelineColorspace,
        toColourspace,
        toColorspace,
        // Private
        _getBackgroundColourOption,
        _setBackgroundColourOption
      });
      Sharp.colourspace = colourspace;
      Sharp.colorspace = colourspace;
    };
  }
});

// ../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/channel.js
var require_channel = __commonJS({
  "../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/channel.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var is = require_is();
    var bool = {
      and: "and",
      or: "or",
      eor: "eor"
    };
    function removeAlpha() {
      this.options.removeAlpha = true;
      return this;
    }
    __name(removeAlpha, "removeAlpha");
    function ensureAlpha(alpha) {
      if (is.defined(alpha)) {
        if (is.number(alpha) && is.inRange(alpha, 0, 1)) {
          this.options.ensureAlpha = alpha;
        } else {
          throw is.invalidParameterError("alpha", "number between 0 and 1", alpha);
        }
      } else {
        this.options.ensureAlpha = 1;
      }
      return this;
    }
    __name(ensureAlpha, "ensureAlpha");
    function extractChannel(channel2) {
      const channelMap = { red: 0, green: 1, blue: 2, alpha: 3 };
      if (Object.keys(channelMap).includes(channel2)) {
        channel2 = channelMap[channel2];
      }
      if (is.integer(channel2) && is.inRange(channel2, 0, 4)) {
        this.options.extractChannel = channel2;
      } else {
        throw is.invalidParameterError("channel", "integer or one of: red, green, blue, alpha", channel2);
      }
      return this;
    }
    __name(extractChannel, "extractChannel");
    function joinChannel(images, options) {
      if (Array.isArray(images)) {
        images.forEach(function(image) {
          this.options.joinChannelIn.push(this._createInputDescriptor(image, options));
        }, this);
      } else {
        this.options.joinChannelIn.push(this._createInputDescriptor(images, options));
      }
      return this;
    }
    __name(joinChannel, "joinChannel");
    function bandbool(boolOp) {
      if (is.string(boolOp) && is.inArray(boolOp, ["and", "or", "eor"])) {
        this.options.bandBoolOp = boolOp;
      } else {
        throw is.invalidParameterError("boolOp", "one of: and, or, eor", boolOp);
      }
      return this;
    }
    __name(bandbool, "bandbool");
    module.exports = (Sharp) => {
      Object.assign(Sharp.prototype, {
        // Public instance functions
        removeAlpha,
        ensureAlpha,
        extractChannel,
        joinChannel,
        bandbool
      });
      Sharp.bool = bool;
    };
  }
});

// node-built-in-modules:node:path
import libDefault6 from "node:path";
var require_node_path = __commonJS({
  "node-built-in-modules:node:path"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault6;
  }
});

// ../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/output.js
var require_output = __commonJS({
  "../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/output.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var path = require_node_path();
    var is = require_is();
    var sharp2 = require_sharp();
    var formats = /* @__PURE__ */ new Map([
      ["heic", "heif"],
      ["heif", "heif"],
      ["avif", "avif"],
      ["jpeg", "jpeg"],
      ["jpg", "jpeg"],
      ["jpe", "jpeg"],
      ["tile", "tile"],
      ["dz", "tile"],
      ["png", "png"],
      ["raw", "raw"],
      ["tiff", "tiff"],
      ["tif", "tiff"],
      ["webp", "webp"],
      ["gif", "gif"],
      ["jp2", "jp2"],
      ["jpx", "jp2"],
      ["j2k", "jp2"],
      ["j2c", "jp2"],
      ["jxl", "jxl"]
    ]);
    var jp2Regex = /\.(jp[2x]|j2[kc])$/i;
    var errJp2Save = /* @__PURE__ */ __name(() => new Error("JP2 output requires libvips with support for OpenJPEG"), "errJp2Save");
    var bitdepthFromColourCount = /* @__PURE__ */ __name((colours) => 1 << 31 - Math.clz32(Math.ceil(Math.log2(colours))), "bitdepthFromColourCount");
    function toFile(fileOut, callback) {
      let err2;
      if (!is.string(fileOut)) {
        err2 = new Error("Missing output file path");
      } else if (is.string(this.options.input.file) && path.resolve(this.options.input.file) === path.resolve(fileOut)) {
        err2 = new Error("Cannot use same file for input and output");
      } else if (jp2Regex.test(path.extname(fileOut)) && !this.constructor.format.jp2k.output.file) {
        err2 = errJp2Save();
      }
      if (err2) {
        if (is.fn(callback)) {
          callback(err2);
        } else {
          return Promise.reject(err2);
        }
      } else {
        this.options.fileOut = fileOut;
        const stack = Error();
        return this._pipeline(callback, stack);
      }
      return this;
    }
    __name(toFile, "toFile");
    function toBuffer(options, callback) {
      if (is.object(options)) {
        this._setBooleanOption("resolveWithObject", options.resolveWithObject);
      } else if (this.options.resolveWithObject) {
        this.options.resolveWithObject = false;
      }
      this.options.fileOut = "";
      const stack = Error();
      return this._pipeline(is.fn(options) ? options : callback, stack);
    }
    __name(toBuffer, "toBuffer");
    function keepExif() {
      this.options.keepMetadata |= 1;
      return this;
    }
    __name(keepExif, "keepExif");
    function withExif(exif) {
      if (is.object(exif)) {
        for (const [ifd, entries] of Object.entries(exif)) {
          if (is.object(entries)) {
            for (const [k3, v3] of Object.entries(entries)) {
              if (is.string(v3)) {
                this.options.withExif[`exif-${ifd.toLowerCase()}-${k3}`] = v3;
              } else {
                throw is.invalidParameterError(`${ifd}.${k3}`, "string", v3);
              }
            }
          } else {
            throw is.invalidParameterError(ifd, "object", entries);
          }
        }
      } else {
        throw is.invalidParameterError("exif", "object", exif);
      }
      this.options.withExifMerge = false;
      return this.keepExif();
    }
    __name(withExif, "withExif");
    function withExifMerge(exif) {
      this.withExif(exif);
      this.options.withExifMerge = true;
      return this;
    }
    __name(withExifMerge, "withExifMerge");
    function keepIccProfile() {
      this.options.keepMetadata |= 8;
      return this;
    }
    __name(keepIccProfile, "keepIccProfile");
    function withIccProfile(icc, options) {
      if (is.string(icc)) {
        this.options.withIccProfile = icc;
      } else {
        throw is.invalidParameterError("icc", "string", icc);
      }
      this.keepIccProfile();
      if (is.object(options)) {
        if (is.defined(options.attach)) {
          if (is.bool(options.attach)) {
            if (!options.attach) {
              this.options.keepMetadata &= ~8;
            }
          } else {
            throw is.invalidParameterError("attach", "boolean", options.attach);
          }
        }
      }
      return this;
    }
    __name(withIccProfile, "withIccProfile");
    function keepXmp() {
      this.options.keepMetadata |= 2;
      return this;
    }
    __name(keepXmp, "keepXmp");
    function withXmp(xmp) {
      if (is.string(xmp) && xmp.length > 0) {
        this.options.withXmp = xmp;
        this.options.keepMetadata |= 2;
      } else {
        throw is.invalidParameterError("xmp", "non-empty string", xmp);
      }
      return this;
    }
    __name(withXmp, "withXmp");
    function keepMetadata() {
      this.options.keepMetadata = 31;
      return this;
    }
    __name(keepMetadata, "keepMetadata");
    function withMetadata(options) {
      this.keepMetadata();
      this.withIccProfile("srgb");
      if (is.object(options)) {
        if (is.defined(options.orientation)) {
          if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {
            this.options.withMetadataOrientation = options.orientation;
          } else {
            throw is.invalidParameterError("orientation", "integer between 1 and 8", options.orientation);
          }
        }
        if (is.defined(options.density)) {
          if (is.number(options.density) && options.density > 0) {
            this.options.withMetadataDensity = options.density;
          } else {
            throw is.invalidParameterError("density", "positive number", options.density);
          }
        }
        if (is.defined(options.icc)) {
          this.withIccProfile(options.icc);
        }
        if (is.defined(options.exif)) {
          this.withExifMerge(options.exif);
        }
      }
      return this;
    }
    __name(withMetadata, "withMetadata");
    function toFormat(format3, options) {
      const actualFormat = formats.get((is.object(format3) && is.string(format3.id) ? format3.id : format3).toLowerCase());
      if (!actualFormat) {
        throw is.invalidParameterError("format", `one of: ${[...formats.keys()].join(", ")}`, format3);
      }
      return this[actualFormat](options);
    }
    __name(toFormat, "toFormat");
    function jpeg(options) {
      if (is.object(options)) {
        if (is.defined(options.quality)) {
          if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
            this.options.jpegQuality = options.quality;
          } else {
            throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
          }
        }
        if (is.defined(options.progressive)) {
          this._setBooleanOption("jpegProgressive", options.progressive);
        }
        if (is.defined(options.chromaSubsampling)) {
          if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ["4:2:0", "4:4:4"])) {
            this.options.jpegChromaSubsampling = options.chromaSubsampling;
          } else {
            throw is.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", options.chromaSubsampling);
          }
        }
        const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;
        if (is.defined(optimiseCoding)) {
          this._setBooleanOption("jpegOptimiseCoding", optimiseCoding);
        }
        if (is.defined(options.mozjpeg)) {
          if (is.bool(options.mozjpeg)) {
            if (options.mozjpeg) {
              this.options.jpegTrellisQuantisation = true;
              this.options.jpegOvershootDeringing = true;
              this.options.jpegOptimiseScans = true;
              this.options.jpegProgressive = true;
              this.options.jpegQuantisationTable = 3;
            }
          } else {
            throw is.invalidParameterError("mozjpeg", "boolean", options.mozjpeg);
          }
        }
        const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;
        if (is.defined(trellisQuantisation)) {
          this._setBooleanOption("jpegTrellisQuantisation", trellisQuantisation);
        }
        if (is.defined(options.overshootDeringing)) {
          this._setBooleanOption("jpegOvershootDeringing", options.overshootDeringing);
        }
        const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;
        if (is.defined(optimiseScans)) {
          this._setBooleanOption("jpegOptimiseScans", optimiseScans);
          if (optimiseScans) {
            this.options.jpegProgressive = true;
          }
        }
        const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;
        if (is.defined(quantisationTable)) {
          if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {
            this.options.jpegQuantisationTable = quantisationTable;
          } else {
            throw is.invalidParameterError("quantisationTable", "integer between 0 and 8", quantisationTable);
          }
        }
      }
      return this._updateFormatOut("jpeg", options);
    }
    __name(jpeg, "jpeg");
    function png(options) {
      if (is.object(options)) {
        if (is.defined(options.progressive)) {
          this._setBooleanOption("pngProgressive", options.progressive);
        }
        if (is.defined(options.compressionLevel)) {
          if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {
            this.options.pngCompressionLevel = options.compressionLevel;
          } else {
            throw is.invalidParameterError("compressionLevel", "integer between 0 and 9", options.compressionLevel);
          }
        }
        if (is.defined(options.adaptiveFiltering)) {
          this._setBooleanOption("pngAdaptiveFiltering", options.adaptiveFiltering);
        }
        const colours = options.colours || options.colors;
        if (is.defined(colours)) {
          if (is.integer(colours) && is.inRange(colours, 2, 256)) {
            this.options.pngBitdepth = bitdepthFromColourCount(colours);
          } else {
            throw is.invalidParameterError("colours", "integer between 2 and 256", colours);
          }
        }
        if (is.defined(options.palette)) {
          this._setBooleanOption("pngPalette", options.palette);
        } else if ([options.quality, options.effort, options.colours, options.colors, options.dither].some(is.defined)) {
          this._setBooleanOption("pngPalette", true);
        }
        if (this.options.pngPalette) {
          if (is.defined(options.quality)) {
            if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {
              this.options.pngQuality = options.quality;
            } else {
              throw is.invalidParameterError("quality", "integer between 0 and 100", options.quality);
            }
          }
          if (is.defined(options.effort)) {
            if (is.integer(options.effort) && is.inRange(options.effort, 1, 10)) {
              this.options.pngEffort = options.effort;
            } else {
              throw is.invalidParameterError("effort", "integer between 1 and 10", options.effort);
            }
          }
          if (is.defined(options.dither)) {
            if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {
              this.options.pngDither = options.dither;
            } else {
              throw is.invalidParameterError("dither", "number between 0.0 and 1.0", options.dither);
            }
          }
        }
      }
      return this._updateFormatOut("png", options);
    }
    __name(png, "png");
    function webp(options) {
      if (is.object(options)) {
        if (is.defined(options.quality)) {
          if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
            this.options.webpQuality = options.quality;
          } else {
            throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
          }
        }
        if (is.defined(options.alphaQuality)) {
          if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {
            this.options.webpAlphaQuality = options.alphaQuality;
          } else {
            throw is.invalidParameterError("alphaQuality", "integer between 0 and 100", options.alphaQuality);
          }
        }
        if (is.defined(options.lossless)) {
          this._setBooleanOption("webpLossless", options.lossless);
        }
        if (is.defined(options.nearLossless)) {
          this._setBooleanOption("webpNearLossless", options.nearLossless);
        }
        if (is.defined(options.smartSubsample)) {
          this._setBooleanOption("webpSmartSubsample", options.smartSubsample);
        }
        if (is.defined(options.smartDeblock)) {
          this._setBooleanOption("webpSmartDeblock", options.smartDeblock);
        }
        if (is.defined(options.preset)) {
          if (is.string(options.preset) && is.inArray(options.preset, ["default", "photo", "picture", "drawing", "icon", "text"])) {
            this.options.webpPreset = options.preset;
          } else {
            throw is.invalidParameterError("preset", "one of: default, photo, picture, drawing, icon, text", options.preset);
          }
        }
        if (is.defined(options.effort)) {
          if (is.integer(options.effort) && is.inRange(options.effort, 0, 6)) {
            this.options.webpEffort = options.effort;
          } else {
            throw is.invalidParameterError("effort", "integer between 0 and 6", options.effort);
          }
        }
        if (is.defined(options.minSize)) {
          this._setBooleanOption("webpMinSize", options.minSize);
        }
        if (is.defined(options.mixed)) {
          this._setBooleanOption("webpMixed", options.mixed);
        }
      }
      trySetAnimationOptions(options, this.options);
      return this._updateFormatOut("webp", options);
    }
    __name(webp, "webp");
    function gif(options) {
      if (is.object(options)) {
        if (is.defined(options.reuse)) {
          this._setBooleanOption("gifReuse", options.reuse);
        }
        if (is.defined(options.progressive)) {
          this._setBooleanOption("gifProgressive", options.progressive);
        }
        const colours = options.colours || options.colors;
        if (is.defined(colours)) {
          if (is.integer(colours) && is.inRange(colours, 2, 256)) {
            this.options.gifBitdepth = bitdepthFromColourCount(colours);
          } else {
            throw is.invalidParameterError("colours", "integer between 2 and 256", colours);
          }
        }
        if (is.defined(options.effort)) {
          if (is.number(options.effort) && is.inRange(options.effort, 1, 10)) {
            this.options.gifEffort = options.effort;
          } else {
            throw is.invalidParameterError("effort", "integer between 1 and 10", options.effort);
          }
        }
        if (is.defined(options.dither)) {
          if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {
            this.options.gifDither = options.dither;
          } else {
            throw is.invalidParameterError("dither", "number between 0.0 and 1.0", options.dither);
          }
        }
        if (is.defined(options.interFrameMaxError)) {
          if (is.number(options.interFrameMaxError) && is.inRange(options.interFrameMaxError, 0, 32)) {
            this.options.gifInterFrameMaxError = options.interFrameMaxError;
          } else {
            throw is.invalidParameterError("interFrameMaxError", "number between 0.0 and 32.0", options.interFrameMaxError);
          }
        }
        if (is.defined(options.interPaletteMaxError)) {
          if (is.number(options.interPaletteMaxError) && is.inRange(options.interPaletteMaxError, 0, 256)) {
            this.options.gifInterPaletteMaxError = options.interPaletteMaxError;
          } else {
            throw is.invalidParameterError("interPaletteMaxError", "number between 0.0 and 256.0", options.interPaletteMaxError);
          }
        }
        if (is.defined(options.keepDuplicateFrames)) {
          if (is.bool(options.keepDuplicateFrames)) {
            this._setBooleanOption("gifKeepDuplicateFrames", options.keepDuplicateFrames);
          } else {
            throw is.invalidParameterError("keepDuplicateFrames", "boolean", options.keepDuplicateFrames);
          }
        }
      }
      trySetAnimationOptions(options, this.options);
      return this._updateFormatOut("gif", options);
    }
    __name(gif, "gif");
    function jp2(options) {
      if (!this.constructor.format.jp2k.output.buffer) {
        throw errJp2Save();
      }
      if (is.object(options)) {
        if (is.defined(options.quality)) {
          if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
            this.options.jp2Quality = options.quality;
          } else {
            throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
          }
        }
        if (is.defined(options.lossless)) {
          if (is.bool(options.lossless)) {
            this.options.jp2Lossless = options.lossless;
          } else {
            throw is.invalidParameterError("lossless", "boolean", options.lossless);
          }
        }
        if (is.defined(options.tileWidth)) {
          if (is.integer(options.tileWidth) && is.inRange(options.tileWidth, 1, 32768)) {
            this.options.jp2TileWidth = options.tileWidth;
          } else {
            throw is.invalidParameterError("tileWidth", "integer between 1 and 32768", options.tileWidth);
          }
        }
        if (is.defined(options.tileHeight)) {
          if (is.integer(options.tileHeight) && is.inRange(options.tileHeight, 1, 32768)) {
            this.options.jp2TileHeight = options.tileHeight;
          } else {
            throw is.invalidParameterError("tileHeight", "integer between 1 and 32768", options.tileHeight);
          }
        }
        if (is.defined(options.chromaSubsampling)) {
          if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ["4:2:0", "4:4:4"])) {
            this.options.jp2ChromaSubsampling = options.chromaSubsampling;
          } else {
            throw is.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", options.chromaSubsampling);
          }
        }
      }
      return this._updateFormatOut("jp2", options);
    }
    __name(jp2, "jp2");
    function trySetAnimationOptions(source, target) {
      if (is.object(source) && is.defined(source.loop)) {
        if (is.integer(source.loop) && is.inRange(source.loop, 0, 65535)) {
          target.loop = source.loop;
        } else {
          throw is.invalidParameterError("loop", "integer between 0 and 65535", source.loop);
        }
      }
      if (is.object(source) && is.defined(source.delay)) {
        if (is.integer(source.delay) && is.inRange(source.delay, 0, 65535)) {
          target.delay = [source.delay];
        } else if (Array.isArray(source.delay) && source.delay.every(is.integer) && source.delay.every((v3) => is.inRange(v3, 0, 65535))) {
          target.delay = source.delay;
        } else {
          throw is.invalidParameterError("delay", "integer or an array of integers between 0 and 65535", source.delay);
        }
      }
    }
    __name(trySetAnimationOptions, "trySetAnimationOptions");
    function tiff(options) {
      if (is.object(options)) {
        if (is.defined(options.quality)) {
          if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
            this.options.tiffQuality = options.quality;
          } else {
            throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
          }
        }
        if (is.defined(options.bitdepth)) {
          if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [1, 2, 4, 8])) {
            this.options.tiffBitdepth = options.bitdepth;
          } else {
            throw is.invalidParameterError("bitdepth", "1, 2, 4 or 8", options.bitdepth);
          }
        }
        if (is.defined(options.tile)) {
          this._setBooleanOption("tiffTile", options.tile);
        }
        if (is.defined(options.tileWidth)) {
          if (is.integer(options.tileWidth) && options.tileWidth > 0) {
            this.options.tiffTileWidth = options.tileWidth;
          } else {
            throw is.invalidParameterError("tileWidth", "integer greater than zero", options.tileWidth);
          }
        }
        if (is.defined(options.tileHeight)) {
          if (is.integer(options.tileHeight) && options.tileHeight > 0) {
            this.options.tiffTileHeight = options.tileHeight;
          } else {
            throw is.invalidParameterError("tileHeight", "integer greater than zero", options.tileHeight);
          }
        }
        if (is.defined(options.miniswhite)) {
          this._setBooleanOption("tiffMiniswhite", options.miniswhite);
        }
        if (is.defined(options.pyramid)) {
          this._setBooleanOption("tiffPyramid", options.pyramid);
        }
        if (is.defined(options.xres)) {
          if (is.number(options.xres) && options.xres > 0) {
            this.options.tiffXres = options.xres;
          } else {
            throw is.invalidParameterError("xres", "number greater than zero", options.xres);
          }
        }
        if (is.defined(options.yres)) {
          if (is.number(options.yres) && options.yres > 0) {
            this.options.tiffYres = options.yres;
          } else {
            throw is.invalidParameterError("yres", "number greater than zero", options.yres);
          }
        }
        if (is.defined(options.compression)) {
          if (is.string(options.compression) && is.inArray(options.compression, ["none", "jpeg", "deflate", "packbits", "ccittfax4", "lzw", "webp", "zstd", "jp2k"])) {
            this.options.tiffCompression = options.compression;
          } else {
            throw is.invalidParameterError("compression", "one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k", options.compression);
          }
        }
        if (is.defined(options.bigtiff)) {
          this._setBooleanOption("tiffBigtiff", options.bigtiff);
        }
        if (is.defined(options.predictor)) {
          if (is.string(options.predictor) && is.inArray(options.predictor, ["none", "horizontal", "float"])) {
            this.options.tiffPredictor = options.predictor;
          } else {
            throw is.invalidParameterError("predictor", "one of: none, horizontal, float", options.predictor);
          }
        }
        if (is.defined(options.resolutionUnit)) {
          if (is.string(options.resolutionUnit) && is.inArray(options.resolutionUnit, ["inch", "cm"])) {
            this.options.tiffResolutionUnit = options.resolutionUnit;
          } else {
            throw is.invalidParameterError("resolutionUnit", "one of: inch, cm", options.resolutionUnit);
          }
        }
      }
      return this._updateFormatOut("tiff", options);
    }
    __name(tiff, "tiff");
    function avif(options) {
      return this.heif({ ...options, compression: "av1" });
    }
    __name(avif, "avif");
    function heif(options) {
      if (is.object(options)) {
        if (is.string(options.compression) && is.inArray(options.compression, ["av1", "hevc"])) {
          this.options.heifCompression = options.compression;
        } else {
          throw is.invalidParameterError("compression", "one of: av1, hevc", options.compression);
        }
        if (is.defined(options.quality)) {
          if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
            this.options.heifQuality = options.quality;
          } else {
            throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
          }
        }
        if (is.defined(options.lossless)) {
          if (is.bool(options.lossless)) {
            this.options.heifLossless = options.lossless;
          } else {
            throw is.invalidParameterError("lossless", "boolean", options.lossless);
          }
        }
        if (is.defined(options.effort)) {
          if (is.integer(options.effort) && is.inRange(options.effort, 0, 9)) {
            this.options.heifEffort = options.effort;
          } else {
            throw is.invalidParameterError("effort", "integer between 0 and 9", options.effort);
          }
        }
        if (is.defined(options.chromaSubsampling)) {
          if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ["4:2:0", "4:4:4"])) {
            this.options.heifChromaSubsampling = options.chromaSubsampling;
          } else {
            throw is.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", options.chromaSubsampling);
          }
        }
        if (is.defined(options.bitdepth)) {
          if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [8, 10, 12])) {
            if (options.bitdepth !== 8 && this.constructor.versions.heif) {
              throw is.invalidParameterError("bitdepth when using prebuilt binaries", 8, options.bitdepth);
            }
            this.options.heifBitdepth = options.bitdepth;
          } else {
            throw is.invalidParameterError("bitdepth", "8, 10 or 12", options.bitdepth);
          }
        }
      } else {
        throw is.invalidParameterError("options", "Object", options);
      }
      return this._updateFormatOut("heif", options);
    }
    __name(heif, "heif");
    function jxl(options) {
      if (is.object(options)) {
        if (is.defined(options.quality)) {
          if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
            this.options.jxlDistance = options.quality >= 30 ? 0.1 + (100 - options.quality) * 0.09 : 53 / 3e3 * options.quality * options.quality - 23 / 20 * options.quality + 25;
          } else {
            throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
          }
        } else if (is.defined(options.distance)) {
          if (is.number(options.distance) && is.inRange(options.distance, 0, 15)) {
            this.options.jxlDistance = options.distance;
          } else {
            throw is.invalidParameterError("distance", "number between 0.0 and 15.0", options.distance);
          }
        }
        if (is.defined(options.decodingTier)) {
          if (is.integer(options.decodingTier) && is.inRange(options.decodingTier, 0, 4)) {
            this.options.jxlDecodingTier = options.decodingTier;
          } else {
            throw is.invalidParameterError("decodingTier", "integer between 0 and 4", options.decodingTier);
          }
        }
        if (is.defined(options.lossless)) {
          if (is.bool(options.lossless)) {
            this.options.jxlLossless = options.lossless;
          } else {
            throw is.invalidParameterError("lossless", "boolean", options.lossless);
          }
        }
        if (is.defined(options.effort)) {
          if (is.integer(options.effort) && is.inRange(options.effort, 1, 9)) {
            this.options.jxlEffort = options.effort;
          } else {
            throw is.invalidParameterError("effort", "integer between 1 and 9", options.effort);
          }
        }
      }
      trySetAnimationOptions(options, this.options);
      return this._updateFormatOut("jxl", options);
    }
    __name(jxl, "jxl");
    function raw2(options) {
      if (is.object(options)) {
        if (is.defined(options.depth)) {
          if (is.string(options.depth) && is.inArray(
            options.depth,
            ["char", "uchar", "short", "ushort", "int", "uint", "float", "complex", "double", "dpcomplex"]
          )) {
            this.options.rawDepth = options.depth;
          } else {
            throw is.invalidParameterError("depth", "one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex", options.depth);
          }
        }
      }
      return this._updateFormatOut("raw");
    }
    __name(raw2, "raw");
    function tile(options) {
      if (is.object(options)) {
        if (is.defined(options.size)) {
          if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {
            this.options.tileSize = options.size;
          } else {
            throw is.invalidParameterError("size", "integer between 1 and 8192", options.size);
          }
        }
        if (is.defined(options.overlap)) {
          if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {
            if (options.overlap > this.options.tileSize) {
              throw is.invalidParameterError("overlap", `<= size (${this.options.tileSize})`, options.overlap);
            }
            this.options.tileOverlap = options.overlap;
          } else {
            throw is.invalidParameterError("overlap", "integer between 0 and 8192", options.overlap);
          }
        }
        if (is.defined(options.container)) {
          if (is.string(options.container) && is.inArray(options.container, ["fs", "zip"])) {
            this.options.tileContainer = options.container;
          } else {
            throw is.invalidParameterError("container", "one of: fs, zip", options.container);
          }
        }
        if (is.defined(options.layout)) {
          if (is.string(options.layout) && is.inArray(options.layout, ["dz", "google", "iiif", "iiif3", "zoomify"])) {
            this.options.tileLayout = options.layout;
          } else {
            throw is.invalidParameterError("layout", "one of: dz, google, iiif, iiif3, zoomify", options.layout);
          }
        }
        if (is.defined(options.angle)) {
          if (is.integer(options.angle) && !(options.angle % 90)) {
            this.options.tileAngle = options.angle;
          } else {
            throw is.invalidParameterError("angle", "positive/negative multiple of 90", options.angle);
          }
        }
        this._setBackgroundColourOption("tileBackground", options.background);
        if (is.defined(options.depth)) {
          if (is.string(options.depth) && is.inArray(options.depth, ["onepixel", "onetile", "one"])) {
            this.options.tileDepth = options.depth;
          } else {
            throw is.invalidParameterError("depth", "one of: onepixel, onetile, one", options.depth);
          }
        }
        if (is.defined(options.skipBlanks)) {
          if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {
            this.options.tileSkipBlanks = options.skipBlanks;
          } else {
            throw is.invalidParameterError("skipBlanks", "integer between -1 and 255/65535", options.skipBlanks);
          }
        } else if (is.defined(options.layout) && options.layout === "google") {
          this.options.tileSkipBlanks = 5;
        }
        const centre = is.bool(options.center) ? options.center : options.centre;
        if (is.defined(centre)) {
          this._setBooleanOption("tileCentre", centre);
        }
        if (is.defined(options.id)) {
          if (is.string(options.id)) {
            this.options.tileId = options.id;
          } else {
            throw is.invalidParameterError("id", "string", options.id);
          }
        }
        if (is.defined(options.basename)) {
          if (is.string(options.basename)) {
            this.options.tileBasename = options.basename;
          } else {
            throw is.invalidParameterError("basename", "string", options.basename);
          }
        }
      }
      if (is.inArray(this.options.formatOut, ["jpeg", "png", "webp"])) {
        this.options.tileFormat = this.options.formatOut;
      } else if (this.options.formatOut !== "input") {
        throw is.invalidParameterError("format", "one of: jpeg, png, webp", this.options.formatOut);
      }
      return this._updateFormatOut("dz");
    }
    __name(tile, "tile");
    function timeout(options) {
      if (!is.plainObject(options)) {
        throw is.invalidParameterError("options", "object", options);
      }
      if (is.integer(options.seconds) && is.inRange(options.seconds, 0, 3600)) {
        this.options.timeoutSeconds = options.seconds;
      } else {
        throw is.invalidParameterError("seconds", "integer between 0 and 3600", options.seconds);
      }
      return this;
    }
    __name(timeout, "timeout");
    function _updateFormatOut(formatOut, options) {
      if (!(is.object(options) && options.force === false)) {
        this.options.formatOut = formatOut;
      }
      return this;
    }
    __name(_updateFormatOut, "_updateFormatOut");
    function _setBooleanOption(key, val) {
      if (is.bool(val)) {
        this.options[key] = val;
      } else {
        throw is.invalidParameterError(key, "boolean", val);
      }
    }
    __name(_setBooleanOption, "_setBooleanOption");
    function _read() {
      if (!this.options.streamOut) {
        this.options.streamOut = true;
        const stack = Error();
        this._pipeline(void 0, stack);
      }
    }
    __name(_read, "_read");
    function _pipeline(callback, stack) {
      if (typeof callback === "function") {
        if (this._isStreamInput()) {
          this.on("finish", () => {
            this._flattenBufferIn();
            sharp2.pipeline(this.options, (err2, data2, info3) => {
              if (err2) {
                callback(is.nativeError(err2, stack));
              } else {
                callback(null, data2, info3);
              }
            });
          });
        } else {
          sharp2.pipeline(this.options, (err2, data2, info3) => {
            if (err2) {
              callback(is.nativeError(err2, stack));
            } else {
              callback(null, data2, info3);
            }
          });
        }
        return this;
      } else if (this.options.streamOut) {
        if (this._isStreamInput()) {
          this.once("finish", () => {
            this._flattenBufferIn();
            sharp2.pipeline(this.options, (err2, data2, info3) => {
              if (err2) {
                this.emit("error", is.nativeError(err2, stack));
              } else {
                this.emit("info", info3);
                this.push(data2);
              }
              this.push(null);
              this.on("end", () => this.emit("close"));
            });
          });
          if (this.streamInFinished) {
            this.emit("finish");
          }
        } else {
          sharp2.pipeline(this.options, (err2, data2, info3) => {
            if (err2) {
              this.emit("error", is.nativeError(err2, stack));
            } else {
              this.emit("info", info3);
              this.push(data2);
            }
            this.push(null);
            this.on("end", () => this.emit("close"));
          });
        }
        return this;
      } else {
        if (this._isStreamInput()) {
          return new Promise((resolve3, reject) => {
            this.once("finish", () => {
              this._flattenBufferIn();
              sharp2.pipeline(this.options, (err2, data2, info3) => {
                if (err2) {
                  reject(is.nativeError(err2, stack));
                } else {
                  if (this.options.resolveWithObject) {
                    resolve3({ data: data2, info: info3 });
                  } else {
                    resolve3(data2);
                  }
                }
              });
            });
          });
        } else {
          return new Promise((resolve3, reject) => {
            sharp2.pipeline(this.options, (err2, data2, info3) => {
              if (err2) {
                reject(is.nativeError(err2, stack));
              } else {
                if (this.options.resolveWithObject) {
                  resolve3({ data: data2, info: info3 });
                } else {
                  resolve3(data2);
                }
              }
            });
          });
        }
      }
    }
    __name(_pipeline, "_pipeline");
    module.exports = (Sharp) => {
      Object.assign(Sharp.prototype, {
        // Public
        toFile,
        toBuffer,
        keepExif,
        withExif,
        withExifMerge,
        keepIccProfile,
        withIccProfile,
        keepXmp,
        withXmp,
        keepMetadata,
        withMetadata,
        toFormat,
        jpeg,
        jp2,
        png,
        webp,
        tiff,
        avif,
        heif,
        jxl,
        gif,
        raw: raw2,
        tile,
        timeout,
        // Private
        _updateFormatOut,
        _setBooleanOption,
        _read,
        _pipeline
      });
    };
  }
});

// node-built-in-modules:node:events
import libDefault7 from "node:events";
var require_node_events = __commonJS({
  "node-built-in-modules:node:events"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault7;
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/os/constants.mjs
var UV_UDP_REUSEADDR, dlopen2, errno, signals, priority;
var init_constants2 = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/os/constants.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    UV_UDP_REUSEADDR = 4;
    dlopen2 = {
      RTLD_LAZY: 1,
      RTLD_NOW: 2,
      RTLD_GLOBAL: 256,
      RTLD_LOCAL: 0,
      RTLD_DEEPBIND: 8
    };
    errno = {
      E2BIG: 7,
      EACCES: 13,
      EADDRINUSE: 98,
      EADDRNOTAVAIL: 99,
      EAFNOSUPPORT: 97,
      EAGAIN: 11,
      EALREADY: 114,
      EBADF: 9,
      EBADMSG: 74,
      EBUSY: 16,
      ECANCELED: 125,
      ECHILD: 10,
      ECONNABORTED: 103,
      ECONNREFUSED: 111,
      ECONNRESET: 104,
      EDEADLK: 35,
      EDESTADDRREQ: 89,
      EDOM: 33,
      EDQUOT: 122,
      EEXIST: 17,
      EFAULT: 14,
      EFBIG: 27,
      EHOSTUNREACH: 113,
      EIDRM: 43,
      EILSEQ: 84,
      EINPROGRESS: 115,
      EINTR: 4,
      EINVAL: 22,
      EIO: 5,
      EISCONN: 106,
      EISDIR: 21,
      ELOOP: 40,
      EMFILE: 24,
      EMLINK: 31,
      EMSGSIZE: 90,
      EMULTIHOP: 72,
      ENAMETOOLONG: 36,
      ENETDOWN: 100,
      ENETRESET: 102,
      ENETUNREACH: 101,
      ENFILE: 23,
      ENOBUFS: 105,
      ENODATA: 61,
      ENODEV: 19,
      ENOENT: 2,
      ENOEXEC: 8,
      ENOLCK: 37,
      ENOLINK: 67,
      ENOMEM: 12,
      ENOMSG: 42,
      ENOPROTOOPT: 92,
      ENOSPC: 28,
      ENOSR: 63,
      ENOSTR: 60,
      ENOSYS: 38,
      ENOTCONN: 107,
      ENOTDIR: 20,
      ENOTEMPTY: 39,
      ENOTSOCK: 88,
      ENOTSUP: 95,
      ENOTTY: 25,
      ENXIO: 6,
      EOPNOTSUPP: 95,
      EOVERFLOW: 75,
      EPERM: 1,
      EPIPE: 32,
      EPROTO: 71,
      EPROTONOSUPPORT: 93,
      EPROTOTYPE: 91,
      ERANGE: 34,
      EROFS: 30,
      ESPIPE: 29,
      ESRCH: 3,
      ESTALE: 116,
      ETIME: 62,
      ETIMEDOUT: 110,
      ETXTBSY: 26,
      EWOULDBLOCK: 11,
      EXDEV: 18
    };
    signals = {
      SIGHUP: 1,
      SIGINT: 2,
      SIGQUIT: 3,
      SIGILL: 4,
      SIGTRAP: 5,
      SIGABRT: 6,
      SIGIOT: 6,
      SIGBUS: 7,
      SIGFPE: 8,
      SIGKILL: 9,
      SIGUSR1: 10,
      SIGSEGV: 11,
      SIGUSR2: 12,
      SIGPIPE: 13,
      SIGALRM: 14,
      SIGTERM: 15,
      SIGCHLD: 17,
      SIGSTKFLT: 16,
      SIGCONT: 18,
      SIGSTOP: 19,
      SIGTSTP: 20,
      SIGTTIN: 21,
      SIGTTOU: 22,
      SIGURG: 23,
      SIGXCPU: 24,
      SIGXFSZ: 25,
      SIGVTALRM: 26,
      SIGPROF: 27,
      SIGWINCH: 28,
      SIGIO: 29,
      SIGPOLL: 29,
      SIGPWR: 30,
      SIGSYS: 31
    };
    priority = {
      PRIORITY_LOW: 19,
      PRIORITY_BELOW_NORMAL: 10,
      PRIORITY_NORMAL: 0,
      PRIORITY_ABOVE_NORMAL: -7,
      PRIORITY_HIGH: -14,
      PRIORITY_HIGHEST: -20
    };
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/os.mjs
var constants3, NUM_CPUS, availableParallelism, arch2, machine, endianness, cpus, getPriority, setPriority, homedir, tmpdir, devNull, freemem, totalmem, loadavg, uptime4, hostname, networkInterfaces, platform4, type, release4, version5, userInfo, EOL, os_default;
var init_os = __esm({
  "../../node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/os.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_constants2();
    constants3 = {
      UV_UDP_REUSEADDR,
      dlopen: dlopen2,
      errno,
      signals,
      priority
    };
    NUM_CPUS = 8;
    availableParallelism = /* @__PURE__ */ __name(() => NUM_CPUS, "availableParallelism");
    arch2 = /* @__PURE__ */ __name(() => "", "arch");
    machine = /* @__PURE__ */ __name(() => "", "machine");
    endianness = /* @__PURE__ */ __name(() => "LE", "endianness");
    cpus = /* @__PURE__ */ __name(() => {
      const info3 = {
        model: "",
        speed: 0,
        times: {
          user: 0,
          nice: 0,
          sys: 0,
          idle: 0,
          irq: 0
        }
      };
      return Array.from({ length: NUM_CPUS }, () => info3);
    }, "cpus");
    getPriority = /* @__PURE__ */ __name(() => 0, "getPriority");
    setPriority = /* @__PURE__ */ notImplemented("os.setPriority");
    homedir = /* @__PURE__ */ __name(() => "/", "homedir");
    tmpdir = /* @__PURE__ */ __name(() => "/tmp", "tmpdir");
    devNull = "/dev/null";
    freemem = /* @__PURE__ */ __name(() => 0, "freemem");
    totalmem = /* @__PURE__ */ __name(() => 0, "totalmem");
    loadavg = /* @__PURE__ */ __name(() => [
      0,
      0,
      0
    ], "loadavg");
    uptime4 = /* @__PURE__ */ __name(() => 0, "uptime");
    hostname = /* @__PURE__ */ __name(() => "", "hostname");
    networkInterfaces = /* @__PURE__ */ __name(() => {
      return { lo0: [
        {
          address: "127.0.0.1",
          netmask: "255.0.0.0",
          family: "IPv4",
          mac: "00:00:00:00:00:00",
          internal: true,
          cidr: "127.0.0.1/8"
        },
        {
          address: "::1",
          netmask: "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",
          family: "IPv6",
          mac: "00:00:00:00:00:00",
          internal: true,
          cidr: "::1/128",
          scopeid: 0
        },
        {
          address: "fe80::1",
          netmask: "ffff:ffff:ffff:ffff::",
          family: "IPv6",
          mac: "00:00:00:00:00:00",
          internal: true,
          cidr: "fe80::1/64",
          scopeid: 1
        }
      ] };
    }, "networkInterfaces");
    platform4 = /* @__PURE__ */ __name(() => "linux", "platform");
    type = /* @__PURE__ */ __name(() => "Linux", "type");
    release4 = /* @__PURE__ */ __name(() => "", "release");
    version5 = /* @__PURE__ */ __name(() => "", "version");
    userInfo = /* @__PURE__ */ __name((opts2) => {
      const encode = /* @__PURE__ */ __name((str) => {
        if (opts2?.encoding) {
          const buff = Buffer.from(str);
          return opts2.encoding === "buffer" ? buff : buff.toString(opts2.encoding);
        }
        return str;
      }, "encode");
      return {
        gid: 1e3,
        uid: 1e3,
        homedir: encode("/"),
        shell: encode("/bin/sh"),
        username: encode("root")
      };
    }, "userInfo");
    EOL = "\n";
    os_default = {
      arch: arch2,
      availableParallelism,
      constants: constants3,
      cpus,
      EOL,
      endianness,
      devNull,
      freemem,
      getPriority,
      homedir,
      hostname,
      loadavg,
      machine,
      networkInterfaces,
      platform: platform4,
      release: release4,
      setPriority,
      tmpdir,
      totalmem,
      type,
      uptime: uptime4,
      userInfo,
      version: version5
    };
  }
});

// node-built-in-modules:node:os
var require_node_os = __commonJS({
  "node-built-in-modules:node:os"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_os();
    module.exports = os_default;
  }
});

// ../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/utility.js
var require_utility = __commonJS({
  "../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/utility.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var events2 = require_node_events();
    var detectLibc = require_detect_libc();
    var is = require_is();
    var { runtimePlatformArch } = require_libvips();
    var sharp2 = require_sharp();
    var runtimePlatform = runtimePlatformArch();
    var libvipsVersion = sharp2.libvipsVersion();
    var format3 = sharp2.format();
    format3.heif.output.alias = ["avif", "heic"];
    format3.jpeg.output.alias = ["jpe", "jpg"];
    format3.tiff.output.alias = ["tif"];
    format3.jp2k.output.alias = ["j2c", "j2k", "jp2", "jpx"];
    var interpolators = {
      /** [Nearest neighbour interpolation](http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation). Suitable for image enlargement only. */
      nearest: "nearest",
      /** [Bilinear interpolation](http://en.wikipedia.org/wiki/Bilinear_interpolation). Faster than bicubic but with less smooth results. */
      bilinear: "bilinear",
      /** [Bicubic interpolation](http://en.wikipedia.org/wiki/Bicubic_interpolation) (the default). */
      bicubic: "bicubic",
      /** [LBB interpolation](https://github.com/libvips/libvips/blob/master/libvips/resample/lbb.cpp#L100). Prevents some "[acutance](http://en.wikipedia.org/wiki/Acutance)" but typically reduces performance by a factor of 2. */
      locallyBoundedBicubic: "lbb",
      /** [Nohalo interpolation](http://eprints.soton.ac.uk/268086/). Prevents acutance but typically reduces performance by a factor of 3. */
      nohalo: "nohalo",
      /** [VSQBS interpolation](https://github.com/libvips/libvips/blob/master/libvips/resample/vsqbs.cpp#L48). Prevents "staircasing" when enlarging. */
      vertexSplitQuadraticBasisSpline: "vsqbs"
    };
    var versions4 = {
      vips: libvipsVersion.semver
    };
    if (!libvipsVersion.isGlobal) {
      if (!libvipsVersion.isWasm) {
        try {
          versions4 = __require(`@img/sharp-${runtimePlatform}/versions`);
        } catch (_) {
          try {
            versions4 = __require(`@img/sharp-libvips-${runtimePlatform}/versions`);
          } catch (_2) {
          }
        }
      } else {
        try {
          versions4 = __require("@img/sharp-wasm32/versions");
        } catch (_) {
        }
      }
    }
    versions4.sharp = require_package().version;
    if (versions4.heif && format3.heif) {
      format3.heif.input.fileSuffix = [".avif"];
      format3.heif.output.alias = ["avif"];
    }
    function cache2(options) {
      if (is.bool(options)) {
        if (options) {
          return sharp2.cache(50, 20, 100);
        } else {
          return sharp2.cache(0, 0, 0);
        }
      } else if (is.object(options)) {
        return sharp2.cache(options.memory, options.files, options.items);
      } else {
        return sharp2.cache();
      }
    }
    __name(cache2, "cache");
    cache2(true);
    function concurrency(concurrency2) {
      return sharp2.concurrency(is.integer(concurrency2) ? concurrency2 : null);
    }
    __name(concurrency, "concurrency");
    if (detectLibc.familySync() === detectLibc.GLIBC && !sharp2._isUsingJemalloc()) {
      sharp2.concurrency(1);
    } else if (detectLibc.familySync() === detectLibc.MUSL && sharp2.concurrency() === 1024) {
      sharp2.concurrency(require_node_os().availableParallelism());
    }
    var queue4 = new events2.EventEmitter();
    function counters() {
      return sharp2.counters();
    }
    __name(counters, "counters");
    function simd(simd2) {
      return sharp2.simd(is.bool(simd2) ? simd2 : null);
    }
    __name(simd, "simd");
    function block(options) {
      if (is.object(options)) {
        if (Array.isArray(options.operation) && options.operation.every(is.string)) {
          sharp2.block(options.operation, true);
        } else {
          throw is.invalidParameterError("operation", "Array<string>", options.operation);
        }
      } else {
        throw is.invalidParameterError("options", "object", options);
      }
    }
    __name(block, "block");
    function unblock(options) {
      if (is.object(options)) {
        if (Array.isArray(options.operation) && options.operation.every(is.string)) {
          sharp2.block(options.operation, false);
        } else {
          throw is.invalidParameterError("operation", "Array<string>", options.operation);
        }
      } else {
        throw is.invalidParameterError("options", "object", options);
      }
    }
    __name(unblock, "unblock");
    module.exports = (Sharp) => {
      Sharp.cache = cache2;
      Sharp.concurrency = concurrency;
      Sharp.counters = counters;
      Sharp.simd = simd;
      Sharp.format = format3;
      Sharp.interpolators = interpolators;
      Sharp.versions = versions4;
      Sharp.queue = queue4;
      Sharp.block = block;
      Sharp.unblock = unblock;
    };
  }
});

// ../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/sharp@0.34.5/node_modules/sharp/lib/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Sharp = require_constructor();
    require_input()(Sharp);
    require_resize()(Sharp);
    require_composite()(Sharp);
    require_operation()(Sharp);
    require_colour2()(Sharp);
    require_channel()(Sharp);
    require_output()(Sharp);
    require_utility()(Sharp);
    module.exports = Sharp;
  }
});

// .wrangler/tmp/bundle-ub9Yx7/middleware-loader.entry.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .wrangler/tmp/bundle-ub9Yx7/middleware-insertion-facade.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/index.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/app.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/hono.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/hono-base.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/compose.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var compose = /* @__PURE__ */ __name((middleware, onError, onNotFound) => {
  return (context2, next) => {
    let index2 = -1;
    return dispatch(0);
    async function dispatch(i2) {
      if (i2 <= index2) {
        throw new Error("next() called multiple times");
      }
      index2 = i2;
      let res;
      let isError3 = false;
      let handler;
      if (middleware[i2]) {
        handler = middleware[i2][0][0];
        context2.req.routeIndex = i2;
      } else {
        handler = i2 === middleware.length && next || void 0;
      }
      if (handler) {
        try {
          res = await handler(context2, () => dispatch(i2 + 1));
        } catch (err2) {
          if (err2 instanceof Error && onError) {
            context2.error = err2;
            res = await onError(err2, context2);
            isError3 = true;
          } else {
            throw err2;
          }
        }
      } else {
        if (context2.finalized === false && onNotFound) {
          res = await onNotFound(context2);
        }
      }
      if (res && (context2.finalized === false || isError3)) {
        context2.res = res;
      }
      return context2;
    }
    __name(dispatch, "dispatch");
  };
}, "compose");

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/context.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/request.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/http-exception.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/request/constants.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var GET_MATCH_RESULT = Symbol();

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/utils/body.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parseBody = /* @__PURE__ */ __name(async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
}, "parseBody");
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
__name(parseFormData, "parseFormData");
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value2, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value2;
    } else {
      handleParsingAllValues(form, key, value2);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value2]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value2);
        delete form[key];
      }
    });
  }
  return form;
}
__name(convertFormDataToBodyData, "convertFormDataToBodyData");
var handleParsingAllValues = /* @__PURE__ */ __name((form, key, value2) => {
  if (form[key] !== void 0) {
    if (Array.isArray(form[key])) {
      ;
      form[key].push(value2);
    } else {
      form[key] = [form[key], value2];
    }
  } else {
    if (!key.endsWith("[]")) {
      form[key] = value2;
    } else {
      form[key] = [value2];
    }
  }
}, "handleParsingAllValues");
var handleParsingNestedValues = /* @__PURE__ */ __name((form, key, value2) => {
  let nestedForm = form;
  const keys2 = key.split(".");
  keys2.forEach((key2, index2) => {
    if (index2 === keys2.length - 1) {
      nestedForm[key2] = value2;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
}, "handleParsingNestedValues");

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/utils/url.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var splitPath = /* @__PURE__ */ __name((path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
}, "splitPath");
var splitRoutingPath = /* @__PURE__ */ __name((routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
}, "splitRoutingPath");
var extractGroupsFromPath = /* @__PURE__ */ __name((path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match2, index2) => {
    const mark = `@${index2}`;
    groups.push([mark, match2]);
    return mark;
  });
  return { groups, path };
}, "extractGroupsFromPath");
var replaceGroupMarks = /* @__PURE__ */ __name((paths, groups) => {
  for (let i2 = groups.length - 1; i2 >= 0; i2--) {
    const [mark] = groups[i2];
    for (let j = paths.length - 1; j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i2][1]);
        break;
      }
    }
  }
  return paths;
}, "replaceGroupMarks");
var patternCache = {};
var getPattern = /* @__PURE__ */ __name((label, next) => {
  if (label === "*") {
    return "*";
  }
  const match2 = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match2) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match2[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match2[1], new RegExp(`^${match2[2]}(?=/${next})`)] : [label, match2[1], new RegExp(`^${match2[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match2[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
}, "getPattern");
var tryDecode = /* @__PURE__ */ __name((str, decoder2) => {
  try {
    return decoder2(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match2) => {
      try {
        return decoder2(match2);
      } catch {
        return match2;
      }
    });
  }
}, "tryDecode");
var tryDecodeURI = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURI), "tryDecodeURI");
var getPath = /* @__PURE__ */ __name((request) => {
  const url = request.url;
  const start2 = url.indexOf("/", url.indexOf(":") + 4);
  let i2 = start2;
  for (; i2 < url.length; i2++) {
    const charCode = url.charCodeAt(i2);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i2);
      const path = url.slice(start2, queryIndex === -1 ? void 0 : queryIndex);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start2, i2);
}, "getPath");
var getPathNoStrict = /* @__PURE__ */ __name((request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
}, "getPathNoStrict");
var mergePath = /* @__PURE__ */ __name((base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
}, "mergePath");
var checkOptionalParameter = /* @__PURE__ */ __name((path) => {
  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v3, i2, a4) => a4.indexOf(v3) === i2);
}, "checkOptionalParameter");
var _decodeURI = /* @__PURE__ */ __name((value2) => {
  if (!/[%+]/.test(value2)) {
    return value2;
  }
  if (value2.indexOf("+") !== -1) {
    value2 = value2.replace(/\+/g, " ");
  }
  return value2.indexOf("%") !== -1 ? tryDecode(value2, decodeURIComponent_) : value2;
}, "_decodeURI");
var _getQueryParam = /* @__PURE__ */ __name((url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf("?", 8);
    if (keyIndex2 === -1) {
      return void 0;
    }
    if (!url.startsWith(key, keyIndex2 + 1)) {
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return void 0;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(
      keyIndex + 1,
      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
    );
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value2;
    if (valueIndex === -1) {
      value2 = "";
    } else {
      value2 = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
      if (encoded) {
        value2 = _decodeURI(value2);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      ;
      results[name].push(value2);
    } else {
      results[name] ??= value2;
    }
  }
  return key ? results[key] : results;
}, "_getQueryParam");
var getQueryParam = _getQueryParam;
var getQueryParams = /* @__PURE__ */ __name((url, key) => {
  return _getQueryParam(url, key, true);
}, "getQueryParams");
var decodeURIComponent_ = decodeURIComponent;

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/request.js
var tryDecodeURIComponent = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURIComponent_), "tryDecodeURIComponent");
var HonoRequest = class {
  static {
    __name(this, "HonoRequest");
  }
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param && /\%/.test(param) ? tryDecodeURIComponent(param) : param;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys2 = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys2) {
      const value2 = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value2 !== void 0) {
        decoded[key] = /\%/.test(value2) ? tryDecodeURIComponent(value2) : value2;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? void 0;
    }
    const headerData = {};
    this.raw.headers.forEach((value2, key) => {
      headerData[key] = value2;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = /* @__PURE__ */ __name((key) => {
    const { bodyCache, raw: raw2 } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw2[key]();
  }, "#cachedBody");
  json() {
    return this.#cachedBody("text").then((text) => JSON.parse(text));
  }
  text() {
    return this.#cachedBody("text");
  }
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  blob() {
    return this.#cachedBody("blob");
  }
  formData() {
    return this.#cachedBody("formData");
  }
  addValidatedData(target, data2) {
    this.#validatedData[target] = data2;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/utils/html.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = /* @__PURE__ */ __name((value2, callbacks) => {
  const escapedString = new String(value2);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
}, "raw");
var resolveCallback = /* @__PURE__ */ __name(async (str, phase, preserveCallbacks, context2, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c2) => c2({ phase, buffer, context: context2 }))).then(
    (res) => Promise.all(
      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context2, buffer))
    ).then(() => buffer[0])
  );
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
}, "resolveCallback");

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = /* @__PURE__ */ __name((contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
}, "setDefaultContentType");
var Context = class {
  static {
    __name(this, "Context");
  }
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers()
    });
  }
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k3, v3] of this.#res.headers.entries()) {
        if (k3 === "content-type") {
          continue;
        }
        if (k3 === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k3, v3);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = /* @__PURE__ */ __name((...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  }, "render");
  setLayout = /* @__PURE__ */ __name((layout2) => this.#layout = layout2, "setLayout");
  getLayout = /* @__PURE__ */ __name(() => this.#layout, "getLayout");
  setRenderer = /* @__PURE__ */ __name((renderer3) => {
    this.#renderer = renderer3;
  }, "setRenderer");
  header = /* @__PURE__ */ __name((name, value2, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers();
    if (value2 === void 0) {
      headers.delete(name);
    } else if (options?.append) {
      headers.append(name, value2);
    } else {
      headers.set(name, value2);
    }
  }, "header");
  status = /* @__PURE__ */ __name((status) => {
    this.#status = status;
  }, "status");
  set = /* @__PURE__ */ __name((key, value2) => {
    this.#var ??= /* @__PURE__ */ new Map();
    this.#var.set(key, value2);
  }, "set");
  get = /* @__PURE__ */ __name((key) => {
    return this.#var ? this.#var.get(key) : void 0;
  }, "get");
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data2, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers();
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key, value2] of argHeaders) {
        if (key.toLowerCase() === "set-cookie") {
          responseHeaders.append(key, value2);
        } else {
          responseHeaders.set(key, value2);
        }
      }
    }
    if (headers) {
      for (const [k3, v3] of Object.entries(headers)) {
        if (typeof v3 === "string") {
          responseHeaders.set(k3, v3);
        } else {
          responseHeaders.delete(k3);
          for (const v22 of v3) {
            responseHeaders.append(k3, v22);
          }
        }
      }
    }
    const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data2, { status, headers: responseHeaders });
  }
  newResponse = /* @__PURE__ */ __name((...args) => this.#newResponse(...args), "newResponse");
  body = /* @__PURE__ */ __name((data2, arg, headers) => this.#newResponse(data2, arg, headers), "body");
  text = /* @__PURE__ */ __name((text, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(
      text,
      arg,
      setDefaultContentType(TEXT_PLAIN, headers)
    );
  }, "text");
  json = /* @__PURE__ */ __name((object, arg, headers) => {
    return this.#newResponse(
      JSON.stringify(object),
      arg,
      setDefaultContentType("application/json", headers)
    );
  }, "json");
  html = /* @__PURE__ */ __name((html, arg, headers) => {
    const res = /* @__PURE__ */ __name((html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers)), "res");
    return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
  }, "html");
  redirect = /* @__PURE__ */ __name((location, status) => {
    const locationString = String(location);
    this.header(
      "Location",
      !/[^\x00-\xFF]/.test(locationString) ? locationString : encodeURI(locationString)
    );
    return this.newResponse(null, status ?? 302);
  }, "redirect");
  notFound = /* @__PURE__ */ __name(() => {
    this.#notFoundHandler ??= () => new Response();
    return this.#notFoundHandler(this);
  }, "notFound");
};

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/router.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
  static {
    __name(this, "UnsupportedPathError");
  }
};

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/utils/constants.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/hono-base.js
var notFoundHandler = /* @__PURE__ */ __name((c2) => {
  return c2.text("404 Not Found", 404);
}, "notFoundHandler");
var errorHandler = /* @__PURE__ */ __name((err2, c2) => {
  if ("getResponse" in err2) {
    const res = err2.getResponse();
    return c2.newResponse(res.body, res);
  }
  console.error(err2);
  return c2.text("Internal Server Error", 500);
}, "errorHandler");
var Hono = class {
  static {
    __name(this, "Hono");
  }
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers2) => {
      for (const p3 of [path].flat()) {
        this.#path = p3;
        for (const m3 of [method].flat()) {
          handlers2.map((handler) => {
            this.#addRoute(m3.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers2) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers2.unshift(arg1);
      }
      handlers2.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.errorHandler = this.errorHandler;
    clone.#notFoundHandler = this.#notFoundHandler;
    clone.routes = this.routes;
    return clone;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app2) {
    const subApp = this.basePath(path);
    app2.routes.map((r5) => {
      let handler;
      if (app2.errorHandler === errorHandler) {
        handler = r5.handler;
      } else {
        handler = /* @__PURE__ */ __name(async (c2, next) => (await compose([], app2.errorHandler)(c2, () => r5.handler(c2, next))).res, "handler");
        handler[COMPOSED_HANDLER] = r5.handler;
      }
      subApp.#addRoute(r5.method, r5.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = /* @__PURE__ */ __name((handler) => {
    this.errorHandler = handler;
    return this;
  }, "onError");
  notFound = /* @__PURE__ */ __name((handler) => {
    this.#notFoundHandler = handler;
    return this;
  }, "notFound");
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = /* @__PURE__ */ __name((request) => request, "replaceRequest");
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c2) => {
      const options2 = optionHandler(c2);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c2) => {
      let executionContext = void 0;
      try {
        executionContext = c2.executionCtx;
      } catch {
      }
      return [c2.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url = new URL(request.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request);
      };
    })();
    const handler = /* @__PURE__ */ __name(async (c2, next) => {
      const res = await applicationHandler(replaceRequest(c2.req.raw), ...getOptions(c2));
      if (res) {
        return res;
      }
      await next();
    }, "handler");
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r5 = { basePath: this._basePath, path, method, handler };
    this.router.add(method, path, [handler, r5]);
    this.routes.push(r5);
  }
  #handleError(err2, c2) {
    if (err2 instanceof Error) {
      return this.errorHandler(err2, c2);
    }
    throw err2;
  }
  #dispatch(request, executionCtx, env4, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env4, "GET")))();
    }
    const path = this.getPath(request, { env: env4 });
    const matchResult = this.router.match(method, path);
    const c2 = new Context(request, {
      path,
      matchResult,
      env: env4,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c2, async () => {
          c2.res = await this.#notFoundHandler(c2);
        });
      } catch (err2) {
        return this.#handleError(err2, c2);
      }
      return res instanceof Promise ? res.then(
        (resolved) => resolved || (c2.finalized ? c2.res : this.#notFoundHandler(c2))
      ).catch((err2) => this.#handleError(err2, c2)) : res ?? this.#notFoundHandler(c2);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context2 = await composed(c2);
        if (!context2.finalized) {
          throw new Error(
            "Context is not finalized. Did you forget to return a Response object or `await next()`?"
          );
        }
        return context2.res;
      } catch (err2) {
        return this.#handleError(err2, c2);
      }
    })();
  }
  fetch = /* @__PURE__ */ __name((request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  }, "fetch");
  request = /* @__PURE__ */ __name((input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(
      new Request(
        /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`,
        requestInit
      ),
      Env,
      executionCtx
    );
  }, "request");
  fire = /* @__PURE__ */ __name(() => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));
    });
  }, "fire");
};

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/router/reg-exp-router/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/router/reg-exp-router/router.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/router/reg-exp-router/matcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var emptyParam = [];
function match(method, path) {
  const matchers = this.buildAllMatchers();
  const match2 = /* @__PURE__ */ __name((method2, path2) => {
    const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
    const staticMatch = matcher[2][path2];
    if (staticMatch) {
      return staticMatch;
    }
    const match3 = path2.match(matcher[0]);
    if (!match3) {
      return [[], emptyParam];
    }
    const index2 = match3.indexOf("", 1);
    return [matcher[1][index2], match3];
  }, "match2");
  this.match = match2;
  return match2(method, path);
}
__name(match, "match");

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/router/reg-exp-router/node.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a4, b3) {
  if (a4.length === 1) {
    return b3.length === 1 ? a4 < b3 ? -1 : 1 : -1;
  }
  if (b3.length === 1) {
    return 1;
  }
  if (a4 === ONLY_WILDCARD_REG_EXP_STR || a4 === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b3 === ONLY_WILDCARD_REG_EXP_STR || b3 === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a4 === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b3 === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a4.length === b3.length ? a4 < b3 ? -1 : 1 : b3.length - a4.length;
}
__name(compareKey, "compareKey");
var Node = class {
  static {
    __name(this, "Node");
  }
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index2, paramMap, context2, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== void 0) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index2;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern3 = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern3) {
      const name = pattern3[1];
      let regexpStr = pattern3[2] || LABEL_REG_EXP_STR;
      if (name && pattern3[2]) {
        if (regexpStr === ".*") {
          throw PATH_ERROR;
        }
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k3) => k3 !== ONLY_WILDCARD_REG_EXP_STR && k3 !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node();
        if (name !== "") {
          node.#varIndex = context2.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k3) => k3.length > 1 && k3 !== ONLY_WILDCARD_REG_EXP_STR && k3 !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node();
      }
    }
    node.insert(restTokens, index2, paramMap, context2, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k3) => {
      const c2 = this.#children[k3];
      return (typeof c2.#varIndex === "number" ? `(${k3})@${c2.#varIndex}` : regExpMetaChars.has(k3) ? `\\${k3}` : k3) + c2.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/router/reg-exp-router/trie.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Trie = class {
  static {
    __name(this, "Trie");
  }
  #context = { varIndex: 0 };
  #root = new Node();
  insert(path, index2, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i2 = 0; ; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m3) => {
        const mark = `@\\${i2}`;
        groups[i2] = [mark, m3];
        i2++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i2 = groups.length - 1; i2 >= 0; i2--) {
      const [mark] = groups[i2];
      for (let j = tokens.length - 1; j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i2][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index2, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== void 0) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== void 0) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/router/reg-exp-router/router.js
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(
    path === "*" ? "" : `^${path.replace(
      /\/\*$|([.\\+*[^\]$()])/g,
      (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)"
    )}$`
  );
}
__name(buildWildcardRegExp, "buildWildcardRegExp");
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
__name(clearWildcardRegExpCache, "clearWildcardRegExpCache");
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie();
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map(
    (route) => [!/\*|\/:/.test(route[0]), ...route]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i2 = 0, j = -1, len = routesWithStaticPathFlag.length; i2 < len; i2++) {
    const [pathErrorCheckOnly, path, handlers2] = routesWithStaticPathFlag[i2];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers2.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e4) {
      throw e4 === PATH_ERROR ? new UnsupportedPathError(path) : e4;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers2.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key, value2] = paramAssoc[paramCount];
        paramIndexMap[key] = value2;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i2 = 0, len = handlerData.length; i2 < len; i2++) {
    for (let j = 0, len2 = handlerData[i2].length; j < len2; j++) {
      const map = handlerData[i2][j]?.[1];
      if (!map) {
        continue;
      }
      const keys2 = Object.keys(map);
      for (let k3 = 0, len3 = keys2.length; k3 < len3; k3++) {
        map[keys2[k3]] = paramReplacementMap[map[keys2[k3]]];
      }
    }
  }
  const handlerMap = [];
  for (const i2 in indexReplacementMap) {
    handlerMap[i2] = handlerData[indexReplacementMap[i2]];
  }
  return [regexp, handlerMap, staticMap];
}
__name(buildMatcherFromPreprocessedRoutes, "buildMatcherFromPreprocessedRoutes");
function findMiddleware(middleware, path) {
  if (!middleware) {
    return void 0;
  }
  for (const k3 of Object.keys(middleware).sort((a4, b3) => b3.length - a4.length)) {
    if (buildWildcardRegExp(k3).test(path)) {
      return [...middleware[k3]];
    }
  }
  return void 0;
}
__name(findMiddleware, "findMiddleware");
var RegExpRouter = class {
  static {
    __name(this, "RegExpRouter");
  }
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      ;
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p3) => {
          handlerMap[method][p3] = [...handlerMap[METHOD_NAME_ALL][p3]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m3) => {
          middleware[m3][path] ||= findMiddleware(middleware[m3], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m3) => {
        if (method === METHOD_NAME_ALL || method === m3) {
          Object.keys(middleware[m3]).forEach((p3) => {
            re.test(p3) && middleware[m3][p3].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m3) => {
        if (method === METHOD_NAME_ALL || method === m3) {
          Object.keys(routes[m3]).forEach(
            (p3) => re.test(p3) && routes[m3][p3].push([handler, paramCount])
          );
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i2 = 0, len = paths.length; i2 < len; i2++) {
      const path2 = paths[i2];
      Object.keys(routes).forEach((m3) => {
        if (method === METHOD_NAME_ALL || method === m3) {
          routes[m3][path2] ||= [
            ...findMiddleware(middleware[m3], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes[m3][path2].push([handler, paramCount - len + i2 + 1]);
        }
      });
    }
  }
  match = match;
  buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = void 0;
    clearWildcardRegExpCache();
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r5) => {
      const ownRoute = r5[method] ? Object.keys(r5[method]).map((path) => [path, r5[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(
          ...Object.keys(r5[METHOD_NAME_ALL]).map((path) => [path, r5[METHOD_NAME_ALL][path]])
        );
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/router/reg-exp-router/prepared-router.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/router/smart-router/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/router/smart-router/router.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SmartRouter = class {
  static {
    __name(this, "SmartRouter");
  }
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init4) {
    this.#routers = init4.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i2 = 0;
    let res;
    for (; i2 < len; i2++) {
      const router = routers[i2];
      try {
        for (let i22 = 0, len2 = routes.length; i22 < len2; i22++) {
          router.add(...routes[i22]);
        }
        res = router.match(method, path);
      } catch (e4) {
        if (e4 instanceof UnsupportedPathError) {
          continue;
        }
        throw e4;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = void 0;
      break;
    }
    if (i2 === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/router/trie-router/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/router/trie-router/router.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/router/trie-router/node.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  static {
    __name(this, "Node");
  }
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m3 = /* @__PURE__ */ Object.create(null);
      m3[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m3];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i2 = 0, len = parts.length; i2 < len; i2++) {
      const p3 = parts[i2];
      const nextP = parts[i2 + 1];
      const pattern3 = getPattern(p3, nextP);
      const key = Array.isArray(pattern3) ? pattern3[0] : p3;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern3) {
          possibleKeys.push(pattern3[1]);
        }
        continue;
      }
      curNode.#children[key] = new Node2();
      if (pattern3) {
        curNode.#patterns.push(pattern3);
        possibleKeys.push(pattern3[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v3, i2, a4) => a4.indexOf(v3) === i2),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i2 = 0, len = node.#methods.length; i2 < len; i2++) {
      const m3 = node.#methods[i2];
      const handlerSet = m3[method] || m3[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== void 0) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i22 = 0, len2 = handlerSet.possibleKeys.length; i22 < len2; i22++) {
            const key = handlerSet.possibleKeys[i22];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    const curNodesQueue = [];
    for (let i2 = 0, len = parts.length; i2 < len; i2++) {
      const part = parts[i2];
      const isLast = i2 === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length; j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(
                ...this.#getHandlerSets(nextNode.#children["*"], method, node.#params)
              );
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k3 = 0, len3 = node.#patterns.length; k3 < len3; k3++) {
          const pattern3 = node.#patterns[k3];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern3 === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          const [key, name, matcher] = pattern3;
          if (!part && !(matcher instanceof RegExp)) {
            continue;
          }
          const child = node.#children[key];
          const restPathString = parts.slice(i2).join("/");
          if (matcher instanceof RegExp) {
            const m3 = matcher.exec(restPathString);
            if (m3) {
              params[name] = m3[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m3[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(
                  ...this.#getHandlerSets(child.#children["*"], method, params, node.#params)
                );
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a4, b3) => {
        return a4.score - b3.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  static {
    __name(this, "TrieRouter");
  }
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2();
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i2 = 0, len = results.length; i2 < len; i2++) {
        this.#node.insert(method, results[i2], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  static {
    __name(this, "Hono");
  }
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter(), new TrieRouter()]
    });
  }
};

// ../../node_modules/.pnpm/hono@4.10.6/node_modules/hono/dist/middleware/cors/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var cors = /* @__PURE__ */ __name((options) => {
  const defaults = {
    origin: "*",
    allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
    allowHeaders: [],
    exposeHeaders: []
  };
  const opts2 = {
    ...defaults,
    ...options
  };
  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === "string") {
      if (optsOrigin === "*") {
        return () => optsOrigin;
      } else {
        return (origin) => optsOrigin === origin ? origin : null;
      }
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin) ? origin : null;
    }
  })(opts2.origin);
  const findAllowMethods = ((optsAllowMethods) => {
    if (typeof optsAllowMethods === "function") {
      return optsAllowMethods;
    } else if (Array.isArray(optsAllowMethods)) {
      return () => optsAllowMethods;
    } else {
      return () => [];
    }
  })(opts2.allowMethods);
  return /* @__PURE__ */ __name(async function cors2(c2, next) {
    function set5(key, value2) {
      c2.res.headers.set(key, value2);
    }
    __name(set5, "set");
    const allowOrigin = await findAllowOrigin(c2.req.header("origin") || "", c2);
    if (allowOrigin) {
      set5("Access-Control-Allow-Origin", allowOrigin);
    }
    if (opts2.credentials) {
      set5("Access-Control-Allow-Credentials", "true");
    }
    if (opts2.exposeHeaders?.length) {
      set5("Access-Control-Expose-Headers", opts2.exposeHeaders.join(","));
    }
    if (c2.req.method === "OPTIONS") {
      if (opts2.origin !== "*") {
        set5("Vary", "Origin");
      }
      if (opts2.maxAge != null) {
        set5("Access-Control-Max-Age", opts2.maxAge.toString());
      }
      const allowMethods = await findAllowMethods(c2.req.header("origin") || "", c2);
      if (allowMethods.length) {
        set5("Access-Control-Allow-Methods", allowMethods.join(","));
      }
      let headers = opts2.allowHeaders;
      if (!headers?.length) {
        const requestHeaders = c2.req.header("Access-Control-Request-Headers");
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/);
        }
      }
      if (headers?.length) {
        set5("Access-Control-Allow-Headers", headers.join(","));
        c2.res.headers.append("Vary", "Access-Control-Request-Headers");
      }
      c2.res.headers.delete("Content-Length");
      c2.res.headers.delete("Content-Type");
      return new Response(null, {
        headers: c2.res.headers,
        status: 204,
        statusText: "No Content"
      });
    }
    await next();
    if (opts2.origin !== "*") {
      c2.header("Vary", "Origin", { append: true });
    }
  }, "cors2");
}, "cors");

// src/routes/print.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_react12 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@react-pdf+renderer@4.3.2_react@19.2.0/node_modules/@react-pdf/renderer/lib/react-pdf.browser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/@react-pdf+primitives@4.1.1/node_modules/@react-pdf/primitives/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  Canvas: () => Canvas,
  Checkbox: () => Checkbox,
  Circle: () => Circle,
  ClipPath: () => ClipPath,
  Defs: () => Defs,
  Document: () => Document,
  Ellipse: () => Ellipse,
  FieldSet: () => FieldSet,
  G: () => G,
  Image: () => Image,
  Line: () => Line,
  LinearGradient: () => LinearGradient,
  Link: () => Link,
  List: () => List,
  Note: () => Note,
  Page: () => Page,
  Path: () => Path,
  Polygon: () => Polygon,
  Polyline: () => Polyline,
  RadialGradient: () => RadialGradient,
  Rect: () => Rect,
  Select: () => Select,
  Stop: () => Stop,
  Svg: () => Svg,
  Text: () => Text,
  TextInput: () => TextInput,
  TextInstance: () => TextInstance,
  Tspan: () => Tspan,
  View: () => View
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var G = "G";
var Svg = "SVG";
var View = "VIEW";
var Text = "TEXT";
var Link = "LINK";
var Page = "PAGE";
var Note = "NOTE";
var Path = "PATH";
var Rect = "RECT";
var Line = "LINE";
var FieldSet = "FIELD_SET";
var TextInput = "TEXT_INPUT";
var Select = "SELECT";
var Checkbox = "CHECKBOX";
var List = "LIST";
var Stop = "STOP";
var Defs = "DEFS";
var Image = "IMAGE";
var Tspan = "TSPAN";
var Canvas = "CANVAS";
var Circle = "CIRCLE";
var Ellipse = "ELLIPSE";
var Polygon = "POLYGON";
var Document = "DOCUMENT";
var Polyline = "POLYLINE";
var ClipPath = "CLIP_PATH";
var TextInstance = "TEXT_INSTANCE";
var LinearGradient = "LINEAR_GRADIENT";
var RadialGradient = "RADIAL_GRADIENT";

// ../../node_modules/.pnpm/@react-pdf+renderer@4.3.2_react@19.2.0/node_modules/@react-pdf/renderer/lib/react-pdf.browser.js
var import_queue = __toESM(require_queue(), 1);
var import_react5 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@react-pdf+font@4.0.4/node_modules/@react-pdf/font/lib/index.browser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_is_url = __toESM(require_is_url(), 1);

// ../../node_modules/.pnpm/fontkit@2.0.4/node_modules/fontkit/dist/browser-module.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/EncodeStream.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/DecodeStream.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ENCODING_MAPPING = {
  utf16le: "utf-16le",
  ucs2: "utf-16le",
  utf16be: "utf-16be"
};
var DecodeStream = class {
  static {
    __name(this, "DecodeStream");
  }
  constructor(buffer) {
    this.buffer = buffer;
    this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    this.pos = 0;
    this.length = this.buffer.length;
  }
  readString(length2, encoding = "ascii") {
    encoding = ENCODING_MAPPING[encoding] || encoding;
    let buf = this.readBuffer(length2);
    try {
      let decoder2 = new TextDecoder(encoding);
      return decoder2.decode(buf);
    } catch (err2) {
      return buf;
    }
  }
  readBuffer(length2) {
    return this.buffer.slice(this.pos, this.pos += length2);
  }
  readUInt24BE() {
    return (this.readUInt16BE() << 8) + this.readUInt8();
  }
  readUInt24LE() {
    return this.readUInt16LE() + (this.readUInt8() << 16);
  }
  readInt24BE() {
    return (this.readInt16BE() << 8) + this.readUInt8();
  }
  readInt24LE() {
    return this.readUInt16LE() + (this.readInt8() << 16);
  }
};
DecodeStream.TYPES = {
  UInt8: 1,
  UInt16: 2,
  UInt24: 3,
  UInt32: 4,
  Int8: 1,
  Int16: 2,
  Int24: 3,
  Int32: 4,
  Float: 4,
  Double: 8
};
for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (key.slice(0, 3) === "get") {
    let type2 = key.slice(3).replace("Ui", "UI");
    if (type2 === "Float32") {
      type2 = "Float";
    } else if (type2 === "Float64") {
      type2 = "Double";
    }
    let bytes = DecodeStream.TYPES[type2];
    DecodeStream.prototype["read" + type2 + (bytes === 1 ? "" : "BE")] = function() {
      const ret = this.view[key](this.pos, false);
      this.pos += bytes;
      return ret;
    };
    if (bytes !== 1) {
      DecodeStream.prototype["read" + type2 + "LE"] = function() {
        const ret = this.view[key](this.pos, true);
        this.pos += bytes;
        return ret;
      };
    }
  }
}

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/EncodeStream.js
var textEncoder = new TextEncoder();
var isBigEndian = new Uint8Array(new Uint16Array([4660]).buffer)[0] == 18;
var EncodeStream = class {
  static {
    __name(this, "EncodeStream");
  }
  constructor(buffer) {
    this.buffer = buffer;
    this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
    this.pos = 0;
  }
  writeBuffer(buffer) {
    this.buffer.set(buffer, this.pos);
    this.pos += buffer.length;
  }
  writeString(string, encoding = "ascii") {
    let buf;
    switch (encoding) {
      case "utf16le":
      case "utf16-le":
      case "ucs2":
        buf = stringToUtf16(string, isBigEndian);
        break;
      case "utf16be":
      case "utf16-be":
        buf = stringToUtf16(string, !isBigEndian);
        break;
      case "utf8":
        buf = textEncoder.encode(string);
        break;
      case "ascii":
        buf = stringToAscii(string);
        break;
      default:
        throw new Error(`Unsupported encoding: ${encoding}`);
    }
    this.writeBuffer(buf);
  }
  writeUInt24BE(val) {
    this.buffer[this.pos++] = val >>> 16 & 255;
    this.buffer[this.pos++] = val >>> 8 & 255;
    this.buffer[this.pos++] = val & 255;
  }
  writeUInt24LE(val) {
    this.buffer[this.pos++] = val & 255;
    this.buffer[this.pos++] = val >>> 8 & 255;
    this.buffer[this.pos++] = val >>> 16 & 255;
  }
  writeInt24BE(val) {
    if (val >= 0) {
      this.writeUInt24BE(val);
    } else {
      this.writeUInt24BE(val + 16777215 + 1);
    }
  }
  writeInt24LE(val) {
    if (val >= 0) {
      this.writeUInt24LE(val);
    } else {
      this.writeUInt24LE(val + 16777215 + 1);
    }
  }
  fill(val, length2) {
    if (length2 < this.buffer.length) {
      this.buffer.fill(val, this.pos, this.pos + length2);
      this.pos += length2;
    } else {
      const buf = new Uint8Array(length2);
      buf.fill(val);
      this.writeBuffer(buf);
    }
  }
};
function stringToUtf16(string, swap4) {
  let buf = new Uint16Array(string.length);
  for (let i2 = 0; i2 < string.length; i2++) {
    let code = string.charCodeAt(i2);
    if (swap4) {
      code = code >> 8 | (code & 255) << 8;
    }
    buf[i2] = code;
  }
  return new Uint8Array(buf.buffer);
}
__name(stringToUtf16, "stringToUtf16");
function stringToAscii(string) {
  let buf = new Uint8Array(string.length);
  for (let i2 = 0; i2 < string.length; i2++) {
    buf[i2] = string.charCodeAt(i2);
  }
  return buf;
}
__name(stringToAscii, "stringToAscii");
for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (key.slice(0, 3) === "set") {
    let type2 = key.slice(3).replace("Ui", "UI");
    if (type2 === "Float32") {
      type2 = "Float";
    } else if (type2 === "Float64") {
      type2 = "Double";
    }
    let bytes = DecodeStream.TYPES[type2];
    EncodeStream.prototype["write" + type2 + (bytes === 1 ? "" : "BE")] = function(value2) {
      this.view[key](this.pos, value2, false);
      this.pos += bytes;
    };
    if (bytes !== 1) {
      EncodeStream.prototype["write" + type2 + "LE"] = function(value2) {
        this.view[key](this.pos, value2, true);
        this.pos += bytes;
      };
    }
  }
}

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/Array.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/Base.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Base = class {
  static {
    __name(this, "Base");
  }
  fromBuffer(buffer) {
    let stream2 = new DecodeStream(buffer);
    return this.decode(stream2);
  }
  toBuffer(value2) {
    let size = this.size(value2);
    let buffer = new Uint8Array(size);
    let stream2 = new EncodeStream(buffer);
    this.encode(stream2, value2);
    return buffer;
  }
};

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/Number.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var NumberT = class extends Base {
  static {
    __name(this, "NumberT");
  }
  constructor(type2, endian = "BE") {
    super();
    this.type = type2;
    this.endian = endian;
    this.fn = this.type;
    if (this.type[this.type.length - 1] !== "8") {
      this.fn += this.endian;
    }
  }
  size() {
    return DecodeStream.TYPES[this.type];
  }
  decode(stream2) {
    return stream2[`read${this.fn}`]();
  }
  encode(stream2, val) {
    return stream2[`write${this.fn}`](val);
  }
};
var uint8 = new NumberT("UInt8");
var uint16be = new NumberT("UInt16", "BE");
var uint16 = uint16be;
var uint16le = new NumberT("UInt16", "LE");
var uint24be = new NumberT("UInt24", "BE");
var uint24 = uint24be;
var uint24le = new NumberT("UInt24", "LE");
var uint32be = new NumberT("UInt32", "BE");
var uint32 = uint32be;
var uint32le = new NumberT("UInt32", "LE");
var int8 = new NumberT("Int8");
var int16be = new NumberT("Int16", "BE");
var int16 = int16be;
var int16le = new NumberT("Int16", "LE");
var int24be = new NumberT("Int24", "BE");
var int24le = new NumberT("Int24", "LE");
var int32be = new NumberT("Int32", "BE");
var int32 = int32be;
var int32le = new NumberT("Int32", "LE");
var floatbe = new NumberT("Float", "BE");
var floatle = new NumberT("Float", "LE");
var doublebe = new NumberT("Double", "BE");
var doublele = new NumberT("Double", "LE");
var Fixed = class extends NumberT {
  static {
    __name(this, "Fixed");
  }
  constructor(size, endian, fracBits = size >> 1) {
    super(`Int${size}`, endian);
    this._point = 1 << fracBits;
  }
  decode(stream2) {
    return super.decode(stream2) / this._point;
  }
  encode(stream2, val) {
    return super.encode(stream2, val * this._point | 0);
  }
};
var fixed16be = new Fixed(16, "BE");
var fixed16 = fixed16be;
var fixed16le = new Fixed(16, "LE");
var fixed32be = new Fixed(32, "BE");
var fixed32 = fixed32be;
var fixed32le = new Fixed(32, "LE");

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/utils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function resolveLength(length2, stream2, parent) {
  let res;
  if (typeof length2 === "number") {
    res = length2;
  } else if (typeof length2 === "function") {
    res = length2.call(parent, parent);
  } else if (parent && typeof length2 === "string") {
    res = parent[length2];
  } else if (stream2 && length2 instanceof NumberT) {
    res = length2.decode(stream2);
  }
  if (isNaN(res)) {
    throw new Error("Not a fixed size");
  }
  return res;
}
__name(resolveLength, "resolveLength");
var PropertyDescriptor = class {
  static {
    __name(this, "PropertyDescriptor");
  }
  constructor(opts2 = {}) {
    this.enumerable = true;
    this.configurable = true;
    for (let key in opts2) {
      const val = opts2[key];
      this[key] = val;
    }
  }
};

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/Array.js
var ArrayT = class extends Base {
  static {
    __name(this, "ArrayT");
  }
  constructor(type2, length2, lengthType = "count") {
    super();
    this.type = type2;
    this.length = length2;
    this.lengthType = lengthType;
  }
  decode(stream2, parent) {
    let length2;
    const { pos } = stream2;
    const res = [];
    let ctx = parent;
    if (this.length != null) {
      length2 = resolveLength(this.length, stream2, parent);
    }
    if (this.length instanceof NumberT) {
      Object.defineProperties(res, {
        parent: { value: parent },
        _startOffset: { value: pos },
        _currentOffset: { value: 0, writable: true },
        _length: { value: length2 }
      });
      ctx = res;
    }
    if (length2 == null || this.lengthType === "bytes") {
      const target = length2 != null ? stream2.pos + length2 : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream2.length;
      while (stream2.pos < target) {
        res.push(this.type.decode(stream2, ctx));
      }
    } else {
      for (let i2 = 0, end2 = length2; i2 < end2; i2++) {
        res.push(this.type.decode(stream2, ctx));
      }
    }
    return res;
  }
  size(array, ctx, includePointers = true) {
    if (!array) {
      return this.type.size(null, ctx) * resolveLength(this.length, null, ctx);
    }
    let size = 0;
    if (this.length instanceof NumberT) {
      size += this.length.size();
      ctx = { parent: ctx, pointerSize: 0 };
    }
    for (let item of array) {
      size += this.type.size(item, ctx);
    }
    if (ctx && includePointers && this.length instanceof NumberT) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, array, parent) {
    let ctx = parent;
    if (this.length instanceof NumberT) {
      ctx = {
        pointers: [],
        startOffset: stream2.pos,
        parent
      };
      ctx.pointerOffset = stream2.pos + this.size(array, ctx, false);
      this.length.encode(stream2, array.length);
    }
    for (let item of array) {
      this.type.encode(stream2, item, ctx);
    }
    if (this.length instanceof NumberT) {
      let i2 = 0;
      while (i2 < ctx.pointers.length) {
        const ptr = ctx.pointers[i2++];
        ptr.type.encode(stream2, ptr.val, ptr.parent);
      }
    }
  }
};

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/LazyArray.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var LazyArray = class extends ArrayT {
  static {
    __name(this, "LazyArray");
  }
  decode(stream2, parent) {
    const { pos } = stream2;
    const length2 = resolveLength(this.length, stream2, parent);
    if (this.length instanceof NumberT) {
      parent = {
        parent,
        _startOffset: pos,
        _currentOffset: 0,
        _length: length2
      };
    }
    const res = new LazyArrayValue(this.type, length2, stream2, parent);
    stream2.pos += length2 * this.type.size(null, parent);
    return res;
  }
  size(val, ctx) {
    if (val instanceof LazyArrayValue) {
      val = val.toArray();
    }
    return super.size(val, ctx);
  }
  encode(stream2, val, ctx) {
    if (val instanceof LazyArrayValue) {
      val = val.toArray();
    }
    return super.encode(stream2, val, ctx);
  }
};
var LazyArrayValue = class {
  static {
    __name(this, "LazyArrayValue");
  }
  constructor(type2, length2, stream2, ctx) {
    this.type = type2;
    this.length = length2;
    this.stream = stream2;
    this.ctx = ctx;
    this.base = this.stream.pos;
    this.items = [];
  }
  get(index2) {
    if (index2 < 0 || index2 >= this.length) {
      return void 0;
    }
    if (this.items[index2] == null) {
      const { pos } = this.stream;
      this.stream.pos = this.base + this.type.size(null, this.ctx) * index2;
      this.items[index2] = this.type.decode(this.stream, this.ctx);
      this.stream.pos = pos;
    }
    return this.items[index2];
  }
  toArray() {
    const result = [];
    for (let i2 = 0, end2 = this.length; i2 < end2; i2++) {
      result.push(this.get(i2));
    }
    return result;
  }
};

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/Bitfield.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Bitfield = class extends Base {
  static {
    __name(this, "Bitfield");
  }
  constructor(type2, flags = []) {
    super();
    this.type = type2;
    this.flags = flags;
  }
  decode(stream2) {
    const val = this.type.decode(stream2);
    const res = {};
    for (let i2 = 0; i2 < this.flags.length; i2++) {
      const flag = this.flags[i2];
      if (flag != null) {
        res[flag] = !!(val & 1 << i2);
      }
    }
    return res;
  }
  size() {
    return this.type.size();
  }
  encode(stream2, keys2) {
    let val = 0;
    for (let i2 = 0; i2 < this.flags.length; i2++) {
      const flag = this.flags[i2];
      if (flag != null) {
        if (keys2[flag]) {
          val |= 1 << i2;
        }
      }
    }
    return this.type.encode(stream2, val);
  }
};

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/Boolean.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/Buffer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BufferT = class extends Base {
  static {
    __name(this, "BufferT");
  }
  constructor(length2) {
    super();
    this.length = length2;
  }
  decode(stream2, parent) {
    const length2 = resolveLength(this.length, stream2, parent);
    return stream2.readBuffer(length2);
  }
  size(val, parent) {
    if (!val) {
      return resolveLength(this.length, null, parent);
    }
    let len = val.length;
    if (this.length instanceof NumberT) {
      len += this.length.size();
    }
    return len;
  }
  encode(stream2, buf, parent) {
    if (this.length instanceof NumberT) {
      this.length.encode(stream2, buf.length);
    }
    return stream2.writeBuffer(buf);
  }
};

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/Enum.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/Optional.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Optional = class extends Base {
  static {
    __name(this, "Optional");
  }
  constructor(type2, condition = true) {
    super();
    this.type = type2;
    this.condition = condition;
  }
  decode(stream2, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.decode(stream2, parent);
    }
  }
  size(val, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.size(val, parent);
    } else {
      return 0;
    }
  }
  encode(stream2, val, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.encode(stream2, val, parent);
    }
  }
};

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/Reserved.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Reserved = class extends Base {
  static {
    __name(this, "Reserved");
  }
  constructor(type2, count3 = 1) {
    super();
    this.type = type2;
    this.count = count3;
  }
  decode(stream2, parent) {
    stream2.pos += this.size(null, parent);
    return void 0;
  }
  size(data2, parent) {
    const count3 = resolveLength(this.count, null, parent);
    return this.type.size() * count3;
  }
  encode(stream2, val, parent) {
    return stream2.fill(0, this.size(val, parent));
  }
};

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/String.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var StringT = class extends Base {
  static {
    __name(this, "StringT");
  }
  constructor(length2, encoding = "ascii") {
    super();
    this.length = length2;
    this.encoding = encoding;
  }
  decode(stream2, parent) {
    let length2, pos;
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent, parent) || "ascii";
    }
    let width = encodingWidth(encoding);
    if (this.length != null) {
      length2 = resolveLength(this.length, stream2, parent);
    } else {
      let buffer;
      ({ buffer, length: length2, pos } = stream2);
      while (pos < length2 - width + 1 && (buffer[pos] !== 0 || width === 2 && buffer[pos + 1] !== 0)) {
        pos += width;
      }
      length2 = pos - stream2.pos;
    }
    const string = stream2.readString(length2, encoding);
    if (this.length == null && stream2.pos < stream2.length) {
      stream2.pos += width;
    }
    return string;
  }
  size(val, parent) {
    if (val === void 0 || val === null) {
      return resolveLength(this.length, null, parent);
    }
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
    }
    if (encoding === "utf16be") {
      encoding = "utf16le";
    }
    let size = byteLength(val, encoding);
    if (this.length instanceof NumberT) {
      size += this.length.size();
    }
    if (this.length == null) {
      size += encodingWidth(encoding);
    }
    return size;
  }
  encode(stream2, val, parent) {
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
    }
    if (this.length instanceof NumberT) {
      this.length.encode(stream2, byteLength(val, encoding));
    }
    stream2.writeString(val, encoding);
    if (this.length == null) {
      return encodingWidth(encoding) == 2 ? stream2.writeUInt16LE(0) : stream2.writeUInt8(0);
    }
  }
};
function encodingWidth(encoding) {
  switch (encoding) {
    case "ascii":
    case "utf8":
      return 1;
    case "utf16le":
    case "utf16-le":
    case "utf-16be":
    case "utf-16le":
    case "utf16be":
    case "utf16-be":
    case "ucs2":
      return 2;
    default:
      return 1;
  }
}
__name(encodingWidth, "encodingWidth");
function byteLength(string, encoding) {
  switch (encoding) {
    case "ascii":
      return string.length;
    case "utf8":
      let len = 0;
      for (let i2 = 0; i2 < string.length; i2++) {
        let c2 = string.charCodeAt(i2);
        if (c2 >= 55296 && c2 <= 56319 && i2 < string.length - 1) {
          let c22 = string.charCodeAt(++i2);
          if ((c22 & 64512) === 56320) {
            c2 = ((c2 & 1023) << 10) + (c22 & 1023) + 65536;
          } else {
            i2--;
          }
        }
        if ((c2 & 4294967168) === 0) {
          len++;
        } else if ((c2 & 4294965248) === 0) {
          len += 2;
        } else if ((c2 & 4294901760) === 0) {
          len += 3;
        } else if ((c2 & 4292870144) === 0) {
          len += 4;
        }
      }
      return len;
    case "utf16le":
    case "utf16-le":
    case "utf16be":
    case "utf16-be":
    case "ucs2":
      return string.length * 2;
    default:
      throw new Error("Unknown encoding " + encoding);
  }
}
__name(byteLength, "byteLength");

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/Struct.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Struct = class extends Base {
  static {
    __name(this, "Struct");
  }
  constructor(fields = {}) {
    super();
    this.fields = fields;
  }
  decode(stream2, parent, length2 = 0) {
    const res = this._setup(stream2, parent, length2);
    this._parseFields(stream2, res, this.fields);
    if (this.process != null) {
      this.process.call(res, stream2);
    }
    return res;
  }
  _setup(stream2, parent, length2) {
    const res = {};
    Object.defineProperties(res, {
      parent: { value: parent },
      _startOffset: { value: stream2.pos },
      _currentOffset: { value: 0, writable: true },
      _length: { value: length2 }
    });
    return res;
  }
  _parseFields(stream2, res, fields) {
    for (let key in fields) {
      var val;
      const type2 = fields[key];
      if (typeof type2 === "function") {
        val = type2.call(res, res);
      } else {
        val = type2.decode(stream2, res);
      }
      if (val !== void 0) {
        if (val instanceof PropertyDescriptor) {
          Object.defineProperty(res, key, val);
        } else {
          res[key] = val;
        }
      }
      res._currentOffset = stream2.pos - res._startOffset;
    }
  }
  size(val, parent, includePointers = true) {
    if (val == null) {
      val = {};
    }
    const ctx = {
      parent,
      val,
      pointerSize: 0
    };
    if (this.preEncode != null) {
      this.preEncode.call(val);
    }
    let size = 0;
    for (let key in this.fields) {
      const type2 = this.fields[key];
      if (type2.size != null) {
        size += type2.size(val[key], ctx);
      }
    }
    if (includePointers) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, val, parent) {
    let type2;
    if (this.preEncode != null) {
      this.preEncode.call(val, stream2);
    }
    const ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
    for (let key in this.fields) {
      type2 = this.fields[key];
      if (type2.encode != null) {
        type2.encode(stream2, val[key], ctx);
      }
    }
    let i2 = 0;
    while (i2 < ctx.pointers.length) {
      const ptr = ctx.pointers[i2++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
  }
};

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/VersionedStruct.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var getPath2 = /* @__PURE__ */ __name((object, pathArray) => {
  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);
}, "getPath");
var VersionedStruct = class _VersionedStruct extends Struct {
  static {
    __name(this, "VersionedStruct");
  }
  constructor(type2, versions4 = {}) {
    super();
    this.type = type2;
    this.versions = versions4;
    if (typeof type2 === "string") {
      this.versionPath = type2.split(".");
    }
  }
  decode(stream2, parent, length2 = 0) {
    const res = this._setup(stream2, parent, length2);
    if (typeof this.type === "string") {
      res.version = getPath2(parent, this.versionPath);
    } else {
      res.version = this.type.decode(stream2);
    }
    if (this.versions.header) {
      this._parseFields(stream2, res, this.versions.header);
    }
    const fields = this.versions[res.version];
    if (fields == null) {
      throw new Error(`Unknown version ${res.version}`);
    }
    if (fields instanceof _VersionedStruct) {
      return fields.decode(stream2, parent);
    }
    this._parseFields(stream2, res, fields);
    if (this.process != null) {
      this.process.call(res, stream2);
    }
    return res;
  }
  size(val, parent, includePointers = true) {
    let key, type2;
    if (!val) {
      throw new Error("Not a fixed size");
    }
    if (this.preEncode != null) {
      this.preEncode.call(val);
    }
    const ctx = {
      parent,
      val,
      pointerSize: 0
    };
    let size = 0;
    if (typeof this.type !== "string") {
      size += this.type.size(val.version, ctx);
    }
    if (this.versions.header) {
      for (key in this.versions.header) {
        type2 = this.versions.header[key];
        if (type2.size != null) {
          size += type2.size(val[key], ctx);
        }
      }
    }
    const fields = this.versions[val.version];
    if (fields == null) {
      throw new Error(`Unknown version ${val.version}`);
    }
    for (key in fields) {
      type2 = fields[key];
      if (type2.size != null) {
        size += type2.size(val[key], ctx);
      }
    }
    if (includePointers) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, val, parent) {
    let key, type2;
    if (this.preEncode != null) {
      this.preEncode.call(val, stream2);
    }
    const ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
    if (typeof this.type !== "string") {
      this.type.encode(stream2, val.version);
    }
    if (this.versions.header) {
      for (key in this.versions.header) {
        type2 = this.versions.header[key];
        if (type2.encode != null) {
          type2.encode(stream2, val[key], ctx);
        }
      }
    }
    const fields = this.versions[val.version];
    for (key in fields) {
      type2 = fields[key];
      if (type2.encode != null) {
        type2.encode(stream2, val[key], ctx);
      }
    }
    let i2 = 0;
    while (i2 < ctx.pointers.length) {
      const ptr = ctx.pointers[i2++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
  }
};

// ../../node_modules/.pnpm/restructure@3.0.2/node_modules/restructure/src/Pointer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Pointer = class extends Base {
  static {
    __name(this, "Pointer");
  }
  constructor(offsetType, type2, options = {}) {
    super();
    this.offsetType = offsetType;
    this.type = type2;
    this.options = options;
    if (this.type === "void") {
      this.type = null;
    }
    if (this.options.type == null) {
      this.options.type = "local";
    }
    if (this.options.allowNull == null) {
      this.options.allowNull = true;
    }
    if (this.options.nullValue == null) {
      this.options.nullValue = 0;
    }
    if (this.options.lazy == null) {
      this.options.lazy = false;
    }
    if (this.options.relativeTo) {
      if (typeof this.options.relativeTo !== "function") {
        throw new Error("relativeTo option must be a function");
      }
      this.relativeToGetter = options.relativeTo;
    }
  }
  decode(stream2, ctx) {
    const offset2 = this.offsetType.decode(stream2, ctx);
    if (offset2 === this.options.nullValue && this.options.allowNull) {
      return null;
    }
    let relative;
    switch (this.options.type) {
      case "local":
        relative = ctx._startOffset;
        break;
      case "immediate":
        relative = stream2.pos - this.offsetType.size();
        break;
      case "parent":
        relative = ctx.parent._startOffset;
        break;
      default:
        var c2 = ctx;
        while (c2.parent) {
          c2 = c2.parent;
        }
        relative = c2._startOffset || 0;
    }
    if (this.options.relativeTo) {
      relative += this.relativeToGetter(ctx);
    }
    const ptr = offset2 + relative;
    if (this.type != null) {
      let val = null;
      const decodeValue = /* @__PURE__ */ __name(() => {
        if (val != null) {
          return val;
        }
        const { pos } = stream2;
        stream2.pos = ptr;
        val = this.type.decode(stream2, ctx);
        stream2.pos = pos;
        return val;
      }, "decodeValue");
      if (this.options.lazy) {
        return new PropertyDescriptor({
          get: decodeValue
        });
      }
      return decodeValue();
    } else {
      return ptr;
    }
  }
  size(val, ctx) {
    const parent = ctx;
    switch (this.options.type) {
      case "local":
      case "immediate":
        break;
      case "parent":
        ctx = ctx.parent;
        break;
      default:
        while (ctx.parent) {
          ctx = ctx.parent;
        }
    }
    let { type: type2 } = this;
    if (type2 == null) {
      if (!(val instanceof VoidPointer)) {
        throw new Error("Must be a VoidPointer");
      }
      ({ type: type2 } = val);
      val = val.value;
    }
    if (val && ctx) {
      let size = type2.size(val, parent);
      ctx.pointerSize += size;
    }
    return this.offsetType.size();
  }
  encode(stream2, val, ctx) {
    let relative;
    const parent = ctx;
    if (val == null) {
      this.offsetType.encode(stream2, this.options.nullValue);
      return;
    }
    switch (this.options.type) {
      case "local":
        relative = ctx.startOffset;
        break;
      case "immediate":
        relative = stream2.pos + this.offsetType.size(val, parent);
        break;
      case "parent":
        ctx = ctx.parent;
        relative = ctx.startOffset;
        break;
      default:
        relative = 0;
        while (ctx.parent) {
          ctx = ctx.parent;
        }
    }
    if (this.options.relativeTo) {
      relative += this.relativeToGetter(parent.val);
    }
    this.offsetType.encode(stream2, ctx.pointerOffset - relative);
    let { type: type2 } = this;
    if (type2 == null) {
      if (!(val instanceof VoidPointer)) {
        throw new Error("Must be a VoidPointer");
      }
      ({ type: type2 } = val);
      val = val.value;
    }
    ctx.pointers.push({
      type: type2,
      val,
      parent
    });
    return ctx.pointerOffset += type2.size(val, parent);
  }
};
var VoidPointer = class {
  static {
    __name(this, "VoidPointer");
  }
  constructor(type2, value2) {
    this.type = type2;
    this.value = value2;
  }
};

// ../../node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_define_property.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function _define_property(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else obj[key] = value2;
  return obj;
}
__name(_define_property, "_define_property");

// ../../node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_ts_decorate.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r5 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r5 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r5 = (c2 < 3 ? d3(r5) : c2 > 3 ? d3(target, key, r5) : d3(target, key)) || r5;
  return c2 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
}
__name(__decorate, "__decorate");

// ../../node_modules/.pnpm/fontkit@2.0.4/node_modules/fontkit/dist/browser-module.mjs
var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);

// ../../node_modules/.pnpm/unicode-properties@1.4.1/node_modules/unicode-properties/dist/module.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_base64_js = __toESM(require_base64_js(), 1);
var import_unicode_trie = __toESM(require_unicode_trie(), 1);
function $parcel$interopDefault(a4) {
  return a4 && a4.__esModule ? a4.default : a4;
}
__name($parcel$interopDefault, "$parcel$interopDefault");
var $f4087201da764553$exports = {};
$f4087201da764553$exports = JSON.parse('{"categories":["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"],"combiningClasses":["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"],"scripts":["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Osage","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Hanifi_Rohingya","Old_Sogdian","Sogdian","Elymaic","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Newa","Tirhuta","Siddham","Modi","Takri","Ahom","Dogra","Warang_Citi","Nandinagari","Zanabazar_Square","Soyombo","Pau_Cin_Hau","Bhaiksuki","Marchen","Masaram_Gondi","Gunjala_Gondi","Makasar","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Medefaidrin","Miao","Tangut","Nushu","Duployan","SignWriting","Nyiakeng_Puachue_Hmong","Wancho","Mende_Kikakui","Adlam"],"eaw":["N","Na","A","W","H","F"]}');
var $747425b437e121da$var$trie = new (0, import_unicode_trie.default)((0, import_base64_js.default).toByteArray("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"));
var $747425b437e121da$var$log2 = Math.log2 || ((n5) => Math.log(n5) / Math.LN2);
var $747425b437e121da$var$bits = /* @__PURE__ */ __name((n5) => $747425b437e121da$var$log2(n5) + 1 | 0, "$747425b437e121da$var$bits");
var $747425b437e121da$var$CATEGORY_BITS = $747425b437e121da$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).categories.length - 1);
var $747425b437e121da$var$COMBINING_BITS = $747425b437e121da$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).combiningClasses.length - 1);
var $747425b437e121da$var$SCRIPT_BITS = $747425b437e121da$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).scripts.length - 1);
var $747425b437e121da$var$EAW_BITS = $747425b437e121da$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).eaw.length - 1);
var $747425b437e121da$var$NUMBER_BITS = 10;
var $747425b437e121da$var$CATEGORY_SHIFT = $747425b437e121da$var$COMBINING_BITS + $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$COMBINING_SHIFT = $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$SCRIPT_SHIFT = $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$EAW_SHIFT = $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$CATEGORY_MASK = (1 << $747425b437e121da$var$CATEGORY_BITS) - 1;
var $747425b437e121da$var$COMBINING_MASK = (1 << $747425b437e121da$var$COMBINING_BITS) - 1;
var $747425b437e121da$var$SCRIPT_MASK = (1 << $747425b437e121da$var$SCRIPT_BITS) - 1;
var $747425b437e121da$var$EAW_MASK = (1 << $747425b437e121da$var$EAW_BITS) - 1;
var $747425b437e121da$var$NUMBER_MASK = (1 << $747425b437e121da$var$NUMBER_BITS) - 1;
function $747425b437e121da$export$410364bbb673ddbc(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).categories[val >> $747425b437e121da$var$CATEGORY_SHIFT & $747425b437e121da$var$CATEGORY_MASK];
}
__name($747425b437e121da$export$410364bbb673ddbc, "$747425b437e121da$export$410364bbb673ddbc");
function $747425b437e121da$export$c03b919c6651ed55(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).combiningClasses[val >> $747425b437e121da$var$COMBINING_SHIFT & $747425b437e121da$var$COMBINING_MASK];
}
__name($747425b437e121da$export$c03b919c6651ed55, "$747425b437e121da$export$c03b919c6651ed55");
function $747425b437e121da$export$941569448d136665(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).scripts[val >> $747425b437e121da$var$SCRIPT_SHIFT & $747425b437e121da$var$SCRIPT_MASK];
}
__name($747425b437e121da$export$941569448d136665, "$747425b437e121da$export$941569448d136665");
function $747425b437e121da$export$92f6187db8ca6d26(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).eaw[val >> $747425b437e121da$var$EAW_SHIFT & $747425b437e121da$var$EAW_MASK];
}
__name($747425b437e121da$export$92f6187db8ca6d26, "$747425b437e121da$export$92f6187db8ca6d26");
function $747425b437e121da$export$7d1258ebb7625a0d(codePoint) {
  let val = $747425b437e121da$var$trie.get(codePoint);
  let num = val & $747425b437e121da$var$NUMBER_MASK;
  if (num === 0) return null;
  else if (num <= 50) return num - 1;
  else if (num < 480) {
    const numerator = (num >> 4) - 12;
    const denominator = (num & 15) + 1;
    return numerator / denominator;
  } else if (num < 768) {
    val = (num >> 5) - 14;
    let exp = (num & 31) + 2;
    while (exp > 0) {
      val *= 10;
      exp--;
    }
    return val;
  } else {
    val = (num >> 2) - 191;
    let exp = (num & 3) + 1;
    while (exp > 0) {
      val *= 60;
      exp--;
    }
    return val;
  }
}
__name($747425b437e121da$export$7d1258ebb7625a0d, "$747425b437e121da$export$7d1258ebb7625a0d");
function $747425b437e121da$export$52c8ea63abd07594(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Nl";
}
__name($747425b437e121da$export$52c8ea63abd07594, "$747425b437e121da$export$52c8ea63abd07594");
function $747425b437e121da$export$727d9dbc4fbb948f(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Nd";
}
__name($747425b437e121da$export$727d9dbc4fbb948f, "$747425b437e121da$export$727d9dbc4fbb948f");
function $747425b437e121da$export$a5b49f4dc6a07d2c(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Pc" || category === "Pd" || category === "Pe" || category === "Pf" || category === "Pi" || category === "Po" || category === "Ps";
}
__name($747425b437e121da$export$a5b49f4dc6a07d2c, "$747425b437e121da$export$a5b49f4dc6a07d2c");
function $747425b437e121da$export$7b6804e8df61fcf5(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Ll";
}
__name($747425b437e121da$export$7b6804e8df61fcf5, "$747425b437e121da$export$7b6804e8df61fcf5");
function $747425b437e121da$export$aebd617640818cda(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lu";
}
__name($747425b437e121da$export$aebd617640818cda, "$747425b437e121da$export$aebd617640818cda");
function $747425b437e121da$export$de8b4ee23b2cf823(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lt";
}
__name($747425b437e121da$export$de8b4ee23b2cf823, "$747425b437e121da$export$de8b4ee23b2cf823");
function $747425b437e121da$export$3c52dd84024ae72c(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Zs" || category === "Zl" || category === "Zp";
}
__name($747425b437e121da$export$3c52dd84024ae72c, "$747425b437e121da$export$3c52dd84024ae72c");
function $747425b437e121da$export$a11bdcffe109e74b(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Nd" || category === "No" || category === "Nl" || category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Me" || category === "Mc";
}
__name($747425b437e121da$export$a11bdcffe109e74b, "$747425b437e121da$export$a11bdcffe109e74b");
function $747425b437e121da$export$e33ad6871e762338(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Mn" || category === "Me" || category === "Mc";
}
__name($747425b437e121da$export$e33ad6871e762338, "$747425b437e121da$export$e33ad6871e762338");
var $747425b437e121da$export$2e2bcd8739ae039 = {
  getCategory: $747425b437e121da$export$410364bbb673ddbc,
  getCombiningClass: $747425b437e121da$export$c03b919c6651ed55,
  getScript: $747425b437e121da$export$941569448d136665,
  getEastAsianWidth: $747425b437e121da$export$92f6187db8ca6d26,
  getNumericValue: $747425b437e121da$export$7d1258ebb7625a0d,
  isAlphabetic: $747425b437e121da$export$52c8ea63abd07594,
  isDigit: $747425b437e121da$export$727d9dbc4fbb948f,
  isPunctuation: $747425b437e121da$export$a5b49f4dc6a07d2c,
  isLowerCase: $747425b437e121da$export$7b6804e8df61fcf5,
  isUpperCase: $747425b437e121da$export$aebd617640818cda,
  isTitleCase: $747425b437e121da$export$de8b4ee23b2cf823,
  isWhiteSpace: $747425b437e121da$export$3c52dd84024ae72c,
  isBaseForm: $747425b437e121da$export$a11bdcffe109e74b,
  isMark: $747425b437e121da$export$e33ad6871e762338
};

// ../../node_modules/.pnpm/fontkit@2.0.4/node_modules/fontkit/dist/browser-module.mjs
var import_unicode_trie2 = __toESM(require_unicode_trie(), 1);
var import_dfa = __toESM(require_dfa(), 1);
var import_clone = __toESM(require_clone(), 1);
var import_tiny_inflate = __toESM(require_tiny_inflate(), 1);
var import_decompress = __toESM(require_decompress(), 1);
function $parcel$export(e4, n5, v3, s4) {
  Object.defineProperty(e4, n5, { get: v3, set: s4, enumerable: true, configurable: true });
}
__name($parcel$export, "$parcel$export");
function $parcel$interopDefault2(a4) {
  return a4 && a4.__esModule ? a4.default : a4;
}
__name($parcel$interopDefault2, "$parcel$interopDefault");
var $d636bc798e7178db$exports = {};
$parcel$export($d636bc798e7178db$exports, "logErrors", () => $d636bc798e7178db$export$bd5c5d8b8dcafd78);
$parcel$export($d636bc798e7178db$exports, "registerFormat", () => $d636bc798e7178db$export$36b2f24e97d43be);
$parcel$export($d636bc798e7178db$exports, "create", () => $d636bc798e7178db$export$185802fd694ee1f5);
$parcel$export($d636bc798e7178db$exports, "defaultLanguage", () => $d636bc798e7178db$export$42940898df819940);
$parcel$export($d636bc798e7178db$exports, "setDefaultLanguage", () => $d636bc798e7178db$export$5157e7780d44cc36);
var $d636bc798e7178db$export$bd5c5d8b8dcafd78 = false;
var $d636bc798e7178db$var$formats = [];
function $d636bc798e7178db$export$36b2f24e97d43be(format3) {
  $d636bc798e7178db$var$formats.push(format3);
}
__name($d636bc798e7178db$export$36b2f24e97d43be, "$d636bc798e7178db$export$36b2f24e97d43be");
function $d636bc798e7178db$export$185802fd694ee1f5(buffer, postscriptName) {
  for (let i2 = 0; i2 < $d636bc798e7178db$var$formats.length; i2++) {
    let format3 = $d636bc798e7178db$var$formats[i2];
    if (format3.probe(buffer)) {
      let font = new format3(new (0, DecodeStream)(buffer));
      if (postscriptName) return font.getFont(postscriptName);
      return font;
    }
  }
  throw new Error("Unknown font format");
}
__name($d636bc798e7178db$export$185802fd694ee1f5, "$d636bc798e7178db$export$185802fd694ee1f5");
var $d636bc798e7178db$export$42940898df819940 = "en";
function $d636bc798e7178db$export$5157e7780d44cc36(lang = "en") {
  $d636bc798e7178db$export$42940898df819940 = lang;
}
__name($d636bc798e7178db$export$5157e7780d44cc36, "$d636bc798e7178db$export$5157e7780d44cc36");
function $e71565f2ce09cb6b$export$69a3209f1a06c04d(target, key, descriptor) {
  if (descriptor.get) {
    let get14 = descriptor.get;
    descriptor.get = function() {
      let value2 = get14.call(this);
      Object.defineProperty(this, key, {
        value: value2
      });
      return value2;
    };
  } else if (typeof descriptor.value === "function") {
    let fn = descriptor.value;
    return {
      get() {
        let cache2 = /* @__PURE__ */ new Map();
        function memoized(...args) {
          let key2 = args.length > 0 ? args[0] : "value";
          if (cache2.has(key2)) return cache2.get(key2);
          let result = fn.apply(this, args);
          cache2.set(key2, result);
          return result;
        }
        __name(memoized, "memoized");
        Object.defineProperty(this, key, {
          value: memoized
        });
        return memoized;
      }
    };
  }
}
__name($e71565f2ce09cb6b$export$69a3209f1a06c04d, "$e71565f2ce09cb6b$export$69a3209f1a06c04d");
var $26a62205ad06574e$var$SubHeader = new Struct({
  firstCode: uint16,
  entryCount: uint16,
  idDelta: int16,
  idRangeOffset: uint16
});
var $26a62205ad06574e$var$CmapGroup = new Struct({
  startCharCode: uint32,
  endCharCode: uint32,
  glyphID: uint32
});
var $26a62205ad06574e$var$UnicodeValueRange = new Struct({
  startUnicodeValue: uint24,
  additionalCount: uint8
});
var $26a62205ad06574e$var$UVSMapping = new Struct({
  unicodeValue: uint24,
  glyphID: uint16
});
var $26a62205ad06574e$var$DefaultUVS = new ArrayT($26a62205ad06574e$var$UnicodeValueRange, uint32);
var $26a62205ad06574e$var$NonDefaultUVS = new ArrayT($26a62205ad06574e$var$UVSMapping, uint32);
var $26a62205ad06574e$var$VarSelectorRecord = new Struct({
  varSelector: uint24,
  defaultUVS: new Pointer(uint32, $26a62205ad06574e$var$DefaultUVS, {
    type: "parent"
  }),
  nonDefaultUVS: new Pointer(uint32, $26a62205ad06574e$var$NonDefaultUVS, {
    type: "parent"
  })
});
var $26a62205ad06574e$var$CmapSubtable = new VersionedStruct(uint16, {
  0: {
    length: uint16,
    language: uint16,
    codeMap: new LazyArray(uint8, 256)
  },
  2: {
    length: uint16,
    language: uint16,
    subHeaderKeys: new ArrayT(uint16, 256),
    subHeaderCount: /* @__PURE__ */ __name((t4) => Math.max.apply(Math, t4.subHeaderKeys), "subHeaderCount"),
    subHeaders: new LazyArray($26a62205ad06574e$var$SubHeader, "subHeaderCount"),
    glyphIndexArray: new LazyArray(uint16, "subHeaderCount")
  },
  4: {
    length: uint16,
    language: uint16,
    segCountX2: uint16,
    segCount: /* @__PURE__ */ __name((t4) => t4.segCountX2 >> 1, "segCount"),
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    endCode: new LazyArray(uint16, "segCount"),
    reservedPad: new Reserved(uint16),
    startCode: new LazyArray(uint16, "segCount"),
    idDelta: new LazyArray(int16, "segCount"),
    idRangeOffset: new LazyArray(uint16, "segCount"),
    glyphIndexArray: new LazyArray(uint16, (t4) => (t4.length - t4._currentOffset) / 2)
  },
  6: {
    length: uint16,
    language: uint16,
    firstCode: uint16,
    entryCount: uint16,
    glyphIndices: new LazyArray(uint16, "entryCount")
  },
  8: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint16,
    is32: new LazyArray(uint8, 8192),
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  10: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    firstCode: uint32,
    entryCount: uint32,
    glyphIndices: new LazyArray(uint16, "numChars")
  },
  12: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  13: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  14: {
    length: uint32,
    numRecords: uint32,
    varSelectors: new LazyArray($26a62205ad06574e$var$VarSelectorRecord, "numRecords")
  }
});
var $26a62205ad06574e$var$CmapEntry = new Struct({
  platformID: uint16,
  encodingID: uint16,
  table: new Pointer(uint32, $26a62205ad06574e$var$CmapSubtable, {
    type: "parent",
    lazy: true
  })
});
var $26a62205ad06574e$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numSubtables: uint16,
  tables: new ArrayT($26a62205ad06574e$var$CmapEntry, "numSubtables")
});
var $f2612a29f92ac062$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  revision: int32,
  checkSumAdjustment: uint32,
  magicNumber: uint32,
  flags: uint16,
  unitsPerEm: uint16,
  created: new ArrayT(int32, 2),
  modified: new ArrayT(int32, 2),
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16,
  macStyle: new Bitfield(uint16, [
    "bold",
    "italic",
    "underline",
    "outline",
    "shadow",
    "condensed",
    "extended"
  ]),
  lowestRecPPEM: uint16,
  fontDirectionHint: int16,
  indexToLocFormat: int16,
  glyphDataFormat: int16
  // 0 for current format
});
var $2c179dd593583073$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  ascent: int16,
  descent: int16,
  lineGap: int16,
  advanceWidthMax: uint16,
  minLeftSideBearing: int16,
  minRightSideBearing: int16,
  xMaxExtent: int16,
  caretSlopeRise: int16,
  caretSlopeRun: int16,
  caretOffset: int16,
  reserved: new Reserved(int16, 4),
  metricDataFormat: int16,
  numberOfMetrics: uint16
  // Number of advance widths in 'hmtx' table
});
var $bdc9060542264b85$var$HmtxEntry = new Struct({
  advance: uint16,
  bearing: int16
});
var $bdc9060542264b85$export$2e2bcd8739ae039 = new Struct({
  metrics: new LazyArray($bdc9060542264b85$var$HmtxEntry, (t4) => t4.parent.hhea.numberOfMetrics),
  bearings: new LazyArray(int16, (t4) => t4.parent.maxp.numGlyphs - t4.parent.hhea.numberOfMetrics)
});
var $dbf51cb3d3fe409d$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  numGlyphs: uint16,
  maxPoints: uint16,
  maxContours: uint16,
  maxComponentPoints: uint16,
  maxComponentContours: uint16,
  maxZones: uint16,
  maxTwilightPoints: uint16,
  maxStorage: uint16,
  maxFunctionDefs: uint16,
  maxInstructionDefs: uint16,
  maxStackElements: uint16,
  maxSizeOfInstructions: uint16,
  maxComponentElements: uint16,
  maxComponentDepth: uint16
  // Maximum levels of recursion; 1 for simple components
});
function $e449ad78d50845fe$export$badc544e0651b6b1(platformID, encodingID, languageID = 0) {
  if (platformID === 1 && $e449ad78d50845fe$export$479e671907f486d1[languageID]) return $e449ad78d50845fe$export$479e671907f486d1[languageID];
  return $e449ad78d50845fe$export$6fef87b7618bdf0b[platformID][encodingID];
}
__name($e449ad78d50845fe$export$badc544e0651b6b1, "$e449ad78d50845fe$export$badc544e0651b6b1");
var $e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS = /* @__PURE__ */ new Set([
  "x-mac-roman",
  "x-mac-cyrillic",
  "iso-8859-6",
  "iso-8859-8"
]);
var $e449ad78d50845fe$var$MAC_ENCODINGS = {
  "x-mac-croatian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u03A9\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026 \xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uF8FF\xA9\u2044\u20AC\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7",
  "x-mac-gaelic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u1E02\xB1\u2264\u2265\u1E03\u010A\u010B\u1E0A\u1E0B\u1E1E\u1E1F\u0120\u0121\u1E40\xE6\xF8\u1E41\u1E56\u1E57\u027C\u0192\u017F\u1E60\xAB\xBB\u2026 \xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\u1E61\u1E9B\xFF\u0178\u1E6A\u20AC\u2039\u203A\u0176\u0177\u1E6B\xB7\u1EF2\u1EF3\u204A\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u2663\xD2\xDA\xDB\xD9\u0131\xDD\xFD\u0174\u0175\u1E84\u1E85\u1E80\u1E81\u1E82\u1E83",
  "x-mac-greek": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\u20AC\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\xB7\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026 \u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xAD",
  "x-mac-icelandic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026 \xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
  "x-mac-inuit": "\u1403\u1404\u1405\u1406\u140A\u140B\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144E\u144F\u1450\u1451\u1455\u1456\u1466\u146D\u146E\u146F\u1470\u1472\u1473\u1483\u148B\u148C\u148D\u148E\u1490\u1491\xB0\u14A1\u14A5\u14A6\u2022\xB6\u14A7\xAE\xA9\u2122\u14A8\u14AA\u14AB\u14BB\u14C2\u14C3\u14C4\u14C5\u14C7\u14C8\u14D0\u14EF\u14F0\u14F1\u14F2\u14F4\u14F5\u1505\u14D5\u14D6\u14D7\u14D8\u14DA\u14DB\u14EA\u1528\u1529\u152A\u152B\u152D\u2026 \u152E\u153E\u1555\u1556\u1557\u2013\u2014\u201C\u201D\u2018\u2019\u1558\u1559\u155A\u155D\u1546\u1547\u1548\u1549\u154B\u154C\u1550\u157F\u1580\u1581\u1582\u1583\u1584\u1585\u158F\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15A0\u15A1\u15A2\u15A3\u15A4\u15A5\u15A6\u157C\u0141\u0142",
  "x-mac-ce": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026 \u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7",
  "x-mac-romanian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u0218\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\u0103\u0219\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026 \xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\u021A\u021B\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
  "x-mac-turkish": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026 \xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\uF8A0\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
};
var $e449ad78d50845fe$var$encodingCache = /* @__PURE__ */ new Map();
function $e449ad78d50845fe$export$1dceb3c14ed68bee(encoding) {
  let cached = $e449ad78d50845fe$var$encodingCache.get(encoding);
  if (cached) return cached;
  let mapping = $e449ad78d50845fe$var$MAC_ENCODINGS[encoding];
  if (mapping) {
    let res = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < mapping.length; i2++) res.set(mapping.charCodeAt(i2), 128 + i2);
    $e449ad78d50845fe$var$encodingCache.set(encoding, res);
    return res;
  }
  if ($e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS.has(encoding)) {
    let decoder2 = new TextDecoder(encoding);
    let mapping2 = new Uint8Array(128);
    for (let i2 = 0; i2 < 128; i2++) mapping2[i2] = 128 + i2;
    let res = /* @__PURE__ */ new Map();
    let s4 = decoder2.decode(mapping2);
    for (let i2 = 0; i2 < 128; i2++) res.set(s4.charCodeAt(i2), 128 + i2);
    $e449ad78d50845fe$var$encodingCache.set(encoding, res);
    return res;
  }
}
__name($e449ad78d50845fe$export$1dceb3c14ed68bee, "$e449ad78d50845fe$export$1dceb3c14ed68bee");
var $e449ad78d50845fe$export$6fef87b7618bdf0b = [
  // unicode
  [
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be"
  ],
  // macintosh
  // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/
  // 0	Roman                 17	Malayalam
  // 1	Japanese	            18	Sinhalese
  // 2	Traditional Chinese	  19	Burmese
  // 3	Korean	              20	Khmer
  // 4	Arabic	              21	Thai
  // 5	Hebrew	              22	Laotian
  // 6	Greek	                23	Georgian
  // 7	Russian	              24	Armenian
  // 8	RSymbol	              25	Simplified Chinese
  // 9	Devanagari	          26	Tibetan
  // 10	Gurmukhi	            27	Mongolian
  // 11	Gujarati	            28	Geez
  // 12	Oriya	                29	Slavic
  // 13	Bengali	              30	Vietnamese
  // 14	Tamil	                31	Sindhi
  // 15	Telugu	              32	(Uninterpreted)
  // 16	Kannada
  [
    "x-mac-roman",
    "shift-jis",
    "big5",
    "euc-kr",
    "iso-8859-6",
    "iso-8859-8",
    "x-mac-greek",
    "x-mac-cyrillic",
    "x-mac-symbol",
    "x-mac-devanagari",
    "x-mac-gurmukhi",
    "x-mac-gujarati",
    "Oriya",
    "Bengali",
    "Tamil",
    "Telugu",
    "Kannada",
    "Malayalam",
    "Sinhalese",
    "Burmese",
    "Khmer",
    "iso-8859-11",
    "Laotian",
    "Georgian",
    "Armenian",
    "gbk",
    "Tibetan",
    "Mongolian",
    "Geez",
    "x-mac-ce",
    "Vietnamese",
    "Sindhi"
  ],
  // ISO (deprecated)
  [
    "ascii",
    null,
    "iso-8859-1"
  ],
  // windows
  // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx
  [
    "symbol",
    "utf-16be",
    "shift-jis",
    "gb18030",
    "big5",
    "euc-kr",
    "johab",
    null,
    null,
    null,
    "utf-16be"
  ]
];
var $e449ad78d50845fe$export$479e671907f486d1 = {
  15: "x-mac-icelandic",
  17: "x-mac-turkish",
  18: "x-mac-croatian",
  24: "x-mac-ce",
  25: "x-mac-ce",
  26: "x-mac-ce",
  27: "x-mac-ce",
  28: "x-mac-ce",
  30: "x-mac-icelandic",
  37: "x-mac-romanian",
  38: "x-mac-ce",
  39: "x-mac-ce",
  40: "x-mac-ce",
  143: "x-mac-inuit",
  146: "x-mac-gaelic"
};
var $e449ad78d50845fe$export$2092376fd002e13 = [
  // unicode
  [],
  {
    0: "en",
    30: "fo",
    60: "ks",
    90: "rw",
    1: "fr",
    31: "fa",
    61: "ku",
    91: "rn",
    2: "de",
    32: "ru",
    62: "sd",
    92: "ny",
    3: "it",
    33: "zh",
    63: "bo",
    93: "mg",
    4: "nl",
    34: "nl-BE",
    64: "ne",
    94: "eo",
    5: "sv",
    35: "ga",
    65: "sa",
    128: "cy",
    6: "es",
    36: "sq",
    66: "mr",
    129: "eu",
    7: "da",
    37: "ro",
    67: "bn",
    130: "ca",
    8: "pt",
    38: "cz",
    68: "as",
    131: "la",
    9: "no",
    39: "sk",
    69: "gu",
    132: "qu",
    10: "he",
    40: "si",
    70: "pa",
    133: "gn",
    11: "ja",
    41: "yi",
    71: "or",
    134: "ay",
    12: "ar",
    42: "sr",
    72: "ml",
    135: "tt",
    13: "fi",
    43: "mk",
    73: "kn",
    136: "ug",
    14: "el",
    44: "bg",
    74: "ta",
    137: "dz",
    15: "is",
    45: "uk",
    75: "te",
    138: "jv",
    16: "mt",
    46: "be",
    76: "si",
    139: "su",
    17: "tr",
    47: "uz",
    77: "my",
    140: "gl",
    18: "hr",
    48: "kk",
    78: "km",
    141: "af",
    19: "zh-Hant",
    49: "az-Cyrl",
    79: "lo",
    142: "br",
    20: "ur",
    50: "az-Arab",
    80: "vi",
    143: "iu",
    21: "hi",
    51: "hy",
    81: "id",
    144: "gd",
    22: "th",
    52: "ka",
    82: "tl",
    145: "gv",
    23: "ko",
    53: "mo",
    83: "ms",
    146: "ga",
    24: "lt",
    54: "ky",
    84: "ms-Arab",
    147: "to",
    25: "pl",
    55: "tg",
    85: "am",
    148: "el-polyton",
    26: "hu",
    56: "tk",
    86: "ti",
    149: "kl",
    27: "es",
    57: "mn-CN",
    87: "om",
    150: "az",
    28: "lv",
    58: "mn",
    88: "so",
    151: "nn",
    29: "se",
    59: "ps",
    89: "sw"
  },
  // ISO (deprecated)
  [],
  {
    1078: "af",
    16393: "en-IN",
    1159: "rw",
    1074: "tn",
    1052: "sq",
    6153: "en-IE",
    1089: "sw",
    1115: "si",
    1156: "gsw",
    8201: "en-JM",
    1111: "kok",
    1051: "sk",
    1118: "am",
    17417: "en-MY",
    1042: "ko",
    1060: "sl",
    5121: "ar-DZ",
    5129: "en-NZ",
    1088: "ky",
    11274: "es-AR",
    15361: "ar-BH",
    13321: "en-PH",
    1108: "lo",
    16394: "es-BO",
    3073: "ar",
    18441: "en-SG",
    1062: "lv",
    13322: "es-CL",
    2049: "ar-IQ",
    7177: "en-ZA",
    1063: "lt",
    9226: "es-CO",
    11265: "ar-JO",
    11273: "en-TT",
    2094: "dsb",
    5130: "es-CR",
    13313: "ar-KW",
    2057: "en-GB",
    1134: "lb",
    7178: "es-DO",
    12289: "ar-LB",
    1033: "en",
    1071: "mk",
    12298: "es-EC",
    4097: "ar-LY",
    12297: "en-ZW",
    2110: "ms-BN",
    17418: "es-SV",
    6145: "ary",
    1061: "et",
    1086: "ms",
    4106: "es-GT",
    8193: "ar-OM",
    1080: "fo",
    1100: "ml",
    18442: "es-HN",
    16385: "ar-QA",
    1124: "fil",
    1082: "mt",
    2058: "es-MX",
    1025: "ar-SA",
    1035: "fi",
    1153: "mi",
    19466: "es-NI",
    10241: "ar-SY",
    2060: "fr-BE",
    1146: "arn",
    6154: "es-PA",
    7169: "aeb",
    3084: "fr-CA",
    1102: "mr",
    15370: "es-PY",
    14337: "ar-AE",
    1036: "fr",
    1148: "moh",
    10250: "es-PE",
    9217: "ar-YE",
    5132: "fr-LU",
    1104: "mn",
    20490: "es-PR",
    1067: "hy",
    6156: "fr-MC",
    2128: "mn-CN",
    3082: "es",
    1101: "as",
    4108: "fr-CH",
    1121: "ne",
    1034: "es",
    2092: "az-Cyrl",
    1122: "fy",
    1044: "nb",
    21514: "es-US",
    1068: "az",
    1110: "gl",
    2068: "nn",
    14346: "es-UY",
    1133: "ba",
    1079: "ka",
    1154: "oc",
    8202: "es-VE",
    1069: "eu",
    3079: "de-AT",
    1096: "or",
    2077: "sv-FI",
    1059: "be",
    1031: "de",
    1123: "ps",
    1053: "sv",
    2117: "bn",
    5127: "de-LI",
    1045: "pl",
    1114: "syr",
    1093: "bn-IN",
    4103: "de-LU",
    1046: "pt",
    1064: "tg",
    8218: "bs-Cyrl",
    2055: "de-CH",
    2070: "pt-PT",
    2143: "tzm",
    5146: "bs",
    1032: "el",
    1094: "pa",
    1097: "ta",
    1150: "br",
    1135: "kl",
    1131: "qu-BO",
    1092: "tt",
    1026: "bg",
    1095: "gu",
    2155: "qu-EC",
    1098: "te",
    1027: "ca",
    1128: "ha",
    3179: "qu",
    1054: "th",
    3076: "zh-HK",
    1037: "he",
    1048: "ro",
    1105: "bo",
    5124: "zh-MO",
    1081: "hi",
    1047: "rm",
    1055: "tr",
    2052: "zh",
    1038: "hu",
    1049: "ru",
    1090: "tk",
    4100: "zh-SG",
    1039: "is",
    9275: "smn",
    1152: "ug",
    1028: "zh-TW",
    1136: "ig",
    4155: "smj-NO",
    1058: "uk",
    1155: "co",
    1057: "id",
    5179: "smj",
    1070: "hsb",
    1050: "hr",
    1117: "iu",
    3131: "se-FI",
    1056: "ur",
    4122: "hr-BA",
    2141: "iu-Latn",
    1083: "se",
    2115: "uz-Cyrl",
    1029: "cs",
    2108: "ga",
    2107: "se-SE",
    1091: "uz",
    1030: "da",
    1076: "xh",
    8251: "sms",
    1066: "vi",
    1164: "prs",
    1077: "zu",
    6203: "sma-NO",
    1106: "cy",
    1125: "dv",
    1040: "it",
    7227: "sms",
    1160: "wo",
    2067: "nl-BE",
    2064: "it-CH",
    1103: "sa",
    1157: "sah",
    1043: "nl",
    1041: "ja",
    7194: "sr-Cyrl-BA",
    1144: "ii",
    3081: "en-AU",
    1099: "kn",
    3098: "sr",
    1130: "yo",
    10249: "en-BZ",
    1087: "kk",
    6170: "sr-Latn-BA",
    4105: "en-CA",
    1107: "km",
    2074: "sr-Latn",
    9225: "en-029",
    1158: "quc",
    1132: "nso"
  }
];
var $2bcf221753ec8e32$var$NameRecord = new Struct({
  platformID: uint16,
  encodingID: uint16,
  languageID: uint16,
  nameID: uint16,
  length: uint16,
  string: new Pointer(uint16, new StringT("length", (t4) => (0, $e449ad78d50845fe$export$badc544e0651b6b1)(t4.platformID, t4.encodingID, t4.languageID)), {
    type: "parent",
    relativeTo: /* @__PURE__ */ __name((ctx) => ctx.parent.stringOffset, "relativeTo"),
    allowNull: false
  })
});
var $2bcf221753ec8e32$var$LangTagRecord = new Struct({
  length: uint16,
  tag: new Pointer(uint16, new StringT("length", "utf16be"), {
    type: "parent",
    relativeTo: /* @__PURE__ */ __name((ctx) => ctx.stringOffset, "relativeTo")
  })
});
var $2bcf221753ec8e32$var$NameTable = new VersionedStruct(uint16, {
  0: {
    count: uint16,
    stringOffset: uint16,
    records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count")
  },
  1: {
    count: uint16,
    stringOffset: uint16,
    records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count"),
    langTagCount: uint16,
    langTags: new ArrayT($2bcf221753ec8e32$var$LangTagRecord, "langTagCount")
  }
});
var $2bcf221753ec8e32$export$2e2bcd8739ae039 = $2bcf221753ec8e32$var$NameTable;
var $2bcf221753ec8e32$var$NAMES = [
  "copyright",
  "fontFamily",
  "fontSubfamily",
  "uniqueSubfamily",
  "fullName",
  "version",
  "postscriptName",
  "trademark",
  "manufacturer",
  "designer",
  "description",
  "vendorURL",
  "designerURL",
  "license",
  "licenseURL",
  null,
  "preferredFamily",
  "preferredSubfamily",
  "compatibleFull",
  "sampleText",
  "postscriptCIDFontName",
  "wwsFamilyName",
  "wwsSubfamilyName"
];
$2bcf221753ec8e32$var$NameTable.process = function(stream2) {
  var records = {};
  for (let record of this.records) {
    let language = (0, $e449ad78d50845fe$export$2092376fd002e13)[record.platformID][record.languageID];
    if (language == null && this.langTags != null && record.languageID >= 32768) language = this.langTags[record.languageID - 32768].tag;
    if (language == null) language = record.platformID + "-" + record.languageID;
    let key = record.nameID >= 256 ? "fontFeatures" : $2bcf221753ec8e32$var$NAMES[record.nameID] || record.nameID;
    if (records[key] == null) records[key] = {};
    let obj = records[key];
    if (record.nameID >= 256) obj = obj[record.nameID] || (obj[record.nameID] = {});
    if (typeof record.string === "string" || typeof obj[language] !== "string") obj[language] = record.string;
  }
  this.records = records;
};
$2bcf221753ec8e32$var$NameTable.preEncode = function() {
  if (Array.isArray(this.records)) return;
  this.version = 0;
  let records = [];
  for (let key in this.records) {
    let val = this.records[key];
    if (key === "fontFeatures") continue;
    records.push({
      platformID: 3,
      encodingID: 1,
      languageID: 1033,
      nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
      length: val.en.length * 2,
      string: val.en
    });
    if (key === "postscriptName") records.push({
      platformID: 1,
      encodingID: 0,
      languageID: 0,
      nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
      length: val.en.length,
      string: val.en
    });
  }
  this.records = records;
  this.count = records.length;
  this.stringOffset = $2bcf221753ec8e32$var$NameTable.size(this, null, false);
};
var $84b272aa31b70606$var$OS2 = new VersionedStruct(uint16, {
  header: {
    xAvgCharWidth: int16,
    usWeightClass: uint16,
    usWidthClass: uint16,
    fsType: new Bitfield(uint16, [
      null,
      "noEmbedding",
      "viewOnly",
      "editable",
      null,
      null,
      null,
      null,
      "noSubsetting",
      "bitmapOnly"
    ]),
    ySubscriptXSize: int16,
    ySubscriptYSize: int16,
    ySubscriptXOffset: int16,
    ySubscriptYOffset: int16,
    ySuperscriptXSize: int16,
    ySuperscriptYSize: int16,
    ySuperscriptXOffset: int16,
    ySuperscriptYOffset: int16,
    yStrikeoutSize: int16,
    yStrikeoutPosition: int16,
    sFamilyClass: int16,
    panose: new ArrayT(uint8, 10),
    ulCharRange: new ArrayT(uint32, 4),
    vendorID: new StringT(4),
    fsSelection: new Bitfield(uint16, [
      "italic",
      "underscore",
      "negative",
      "outlined",
      "strikeout",
      "bold",
      "regular",
      "useTypoMetrics",
      "wws",
      "oblique"
    ]),
    usFirstCharIndex: uint16,
    usLastCharIndex: uint16
    // The maximum Unicode index in this font
  },
  // The Apple version of this table ends here, but the Microsoft one continues on...
  0: {},
  1: {
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2)
  },
  2: {
    // these should be common with version 1 somehow
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2),
    xHeight: int16,
    capHeight: int16,
    defaultChar: uint16,
    breakChar: uint16,
    maxContent: uint16
  },
  5: {
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2),
    xHeight: int16,
    capHeight: int16,
    defaultChar: uint16,
    breakChar: uint16,
    maxContent: uint16,
    usLowerOpticalPointSize: uint16,
    usUpperOpticalPointSize: uint16
  }
});
var $84b272aa31b70606$var$versions = $84b272aa31b70606$var$OS2.versions;
$84b272aa31b70606$var$versions[3] = $84b272aa31b70606$var$versions[4] = $84b272aa31b70606$var$versions[2];
var $84b272aa31b70606$export$2e2bcd8739ae039 = $84b272aa31b70606$var$OS2;
var $32d9e2eb9565d93c$export$2e2bcd8739ae039 = new VersionedStruct(fixed32, {
  header: {
    italicAngle: fixed32,
    underlinePosition: int16,
    underlineThickness: int16,
    isFixedPitch: uint32,
    minMemType42: uint32,
    maxMemType42: uint32,
    minMemType1: uint32,
    maxMemType1: uint32
    // Maximum memory usage when a TrueType font is downloaded as a Type 1 font
  },
  1: {},
  2: {
    numberOfGlyphs: uint16,
    glyphNameIndex: new ArrayT(uint16, "numberOfGlyphs"),
    names: new ArrayT(new StringT(uint8))
  },
  2.5: {
    numberOfGlyphs: uint16,
    offsets: new ArrayT(uint8, "numberOfGlyphs")
  },
  3: {},
  4: {
    map: new ArrayT(uint32, (t4) => t4.parent.maxp.numGlyphs)
  }
});
var $5202bd9d9ad8eaac$export$2e2bcd8739ae039 = new Struct({
  controlValues: new ArrayT(int16)
});
var $5c0f37ca5ffb1850$export$2e2bcd8739ae039 = new Struct({
  instructions: new ArrayT(uint8)
});
var $2b2b260902b1c57e$var$loca = new VersionedStruct("head.indexToLocFormat", {
  0: {
    offsets: new ArrayT(uint16)
  },
  1: {
    offsets: new ArrayT(uint32)
  }
});
$2b2b260902b1c57e$var$loca.process = function() {
  if (this.version === 0 && !this._processed) {
    for (let i2 = 0; i2 < this.offsets.length; i2++) this.offsets[i2] <<= 1;
    this._processed = true;
  }
};
$2b2b260902b1c57e$var$loca.preEncode = function() {
  if (this.version === 0 && this._processed !== false) {
    for (let i2 = 0; i2 < this.offsets.length; i2++) this.offsets[i2] >>>= 1;
    this._processed = false;
  }
};
var $2b2b260902b1c57e$export$2e2bcd8739ae039 = $2b2b260902b1c57e$var$loca;
var $7afb878c7bea4f66$export$2e2bcd8739ae039 = new Struct({
  controlValueProgram: new ArrayT(uint8)
});
var $6c92b6371bce8bd9$export$2e2bcd8739ae039 = new ArrayT(new BufferT());
var $43e9821ef3717eec$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$43e9821ef3717eec$export$2e2bcd8739ae039");
  }
  getCFFVersion(ctx) {
    while (ctx && !ctx.hdrSize) ctx = ctx.parent;
    return ctx ? ctx.version : -1;
  }
  decode(stream2, parent) {
    let version6 = this.getCFFVersion(parent);
    let count3 = version6 >= 2 ? stream2.readUInt32BE() : stream2.readUInt16BE();
    if (count3 === 0) return [];
    let offSize = stream2.readUInt8();
    let offsetType;
    if (offSize === 1) offsetType = uint8;
    else if (offSize === 2) offsetType = uint16;
    else if (offSize === 3) offsetType = uint24;
    else if (offSize === 4) offsetType = uint32;
    else throw new Error(`Bad offset size in CFFIndex: ${offSize} ${stream2.pos}`);
    let ret = [];
    let startPos = stream2.pos + (count3 + 1) * offSize - 1;
    let start2 = offsetType.decode(stream2);
    for (let i2 = 0; i2 < count3; i2++) {
      let end2 = offsetType.decode(stream2);
      if (this.type != null) {
        let pos = stream2.pos;
        stream2.pos = startPos + start2;
        parent.length = end2 - start2;
        ret.push(this.type.decode(stream2, parent));
        stream2.pos = pos;
      } else ret.push({
        offset: startPos + start2,
        length: end2 - start2
      });
      start2 = end2;
    }
    stream2.pos = startPos + start2;
    return ret;
  }
  size(arr, parent) {
    let size = 2;
    if (arr.length === 0) return size;
    let type2 = this.type || new BufferT();
    let offset2 = 1;
    for (let i2 = 0; i2 < arr.length; i2++) {
      let item = arr[i2];
      offset2 += type2.size(item, parent);
    }
    let offsetType;
    if (offset2 <= 255) offsetType = uint8;
    else if (offset2 <= 65535) offsetType = uint16;
    else if (offset2 <= 16777215) offsetType = uint24;
    else if (offset2 <= 4294967295) offsetType = uint32;
    else throw new Error("Bad offset in CFFIndex");
    size += 1 + offsetType.size() * (arr.length + 1);
    size += offset2 - 1;
    return size;
  }
  encode(stream2, arr, parent) {
    stream2.writeUInt16BE(arr.length);
    if (arr.length === 0) return;
    let type2 = this.type || new BufferT();
    let sizes = [];
    let offset2 = 1;
    for (let item of arr) {
      let s4 = type2.size(item, parent);
      sizes.push(s4);
      offset2 += s4;
    }
    let offsetType;
    if (offset2 <= 255) offsetType = uint8;
    else if (offset2 <= 65535) offsetType = uint16;
    else if (offset2 <= 16777215) offsetType = uint24;
    else if (offset2 <= 4294967295) offsetType = uint32;
    else throw new Error("Bad offset in CFFIndex");
    stream2.writeUInt8(offsetType.size());
    offset2 = 1;
    offsetType.encode(stream2, offset2);
    for (let size of sizes) {
      offset2 += size;
      offsetType.encode(stream2, offset2);
    }
    for (let item of arr) type2.encode(stream2, item, parent);
    return;
  }
  constructor(type2) {
    this.type = type2;
  }
};
var $c2d28e92708f99da$var$FLOAT_EOF = 15;
var $c2d28e92708f99da$var$FLOAT_LOOKUP = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  ".",
  "E",
  "E-",
  null,
  "-"
];
var $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP = {
  ".": 10,
  "E": 11,
  "E-": 12,
  "-": 14
};
var $c2d28e92708f99da$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$c2d28e92708f99da$export$2e2bcd8739ae039");
  }
  static decode(stream2, value2) {
    if (32 <= value2 && value2 <= 246) return value2 - 139;
    if (247 <= value2 && value2 <= 250) return (value2 - 247) * 256 + stream2.readUInt8() + 108;
    if (251 <= value2 && value2 <= 254) return -(value2 - 251) * 256 - stream2.readUInt8() - 108;
    if (value2 === 28) return stream2.readInt16BE();
    if (value2 === 29) return stream2.readInt32BE();
    if (value2 === 30) {
      let str = "";
      while (true) {
        let b3 = stream2.readUInt8();
        let n1 = b3 >> 4;
        if (n1 === $c2d28e92708f99da$var$FLOAT_EOF) break;
        str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n1];
        let n22 = b3 & 15;
        if (n22 === $c2d28e92708f99da$var$FLOAT_EOF) break;
        str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n22];
      }
      return parseFloat(str);
    }
    return null;
  }
  static size(value2) {
    if (value2.forceLarge) value2 = 32768;
    if ((value2 | 0) !== value2) {
      let str = "" + value2;
      return 1 + Math.ceil((str.length + 1) / 2);
    } else if (-107 <= value2 && value2 <= 107) return 1;
    else if (108 <= value2 && value2 <= 1131 || -1131 <= value2 && value2 <= -108) return 2;
    else if (-32768 <= value2 && value2 <= 32767) return 3;
    else return 5;
  }
  static encode(stream2, value2) {
    let val = Number(value2);
    if (value2.forceLarge) {
      stream2.writeUInt8(29);
      return stream2.writeInt32BE(val);
    } else if ((val | 0) !== val) {
      stream2.writeUInt8(30);
      let str = "" + val;
      for (let i2 = 0; i2 < str.length; i2 += 2) {
        let c1 = str[i2];
        let n1 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c1] || +c1;
        if (i2 === str.length - 1) var n22 = $c2d28e92708f99da$var$FLOAT_EOF;
        else {
          let c2 = str[i2 + 1];
          var n22 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c2] || +c2;
        }
        stream2.writeUInt8(n1 << 4 | n22 & 15);
      }
      if (n22 !== $c2d28e92708f99da$var$FLOAT_EOF) return stream2.writeUInt8($c2d28e92708f99da$var$FLOAT_EOF << 4);
    } else if (-107 <= val && val <= 107) return stream2.writeUInt8(val + 139);
    else if (108 <= val && val <= 1131) {
      val -= 108;
      stream2.writeUInt8((val >> 8) + 247);
      return stream2.writeUInt8(val & 255);
    } else if (-1131 <= val && val <= -108) {
      val = -val - 108;
      stream2.writeUInt8((val >> 8) + 251);
      return stream2.writeUInt8(val & 255);
    } else if (-32768 <= val && val <= 32767) {
      stream2.writeUInt8(28);
      return stream2.writeInt16BE(val);
    } else {
      stream2.writeUInt8(29);
      return stream2.writeInt32BE(val);
    }
  }
};
var $61aa549f16d58b9b$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$61aa549f16d58b9b$export$2e2bcd8739ae039");
  }
  decodeOperands(type2, stream2, ret, operands) {
    if (Array.isArray(type2)) return operands.map((op, i2) => this.decodeOperands(type2[i2], stream2, ret, [
      op
    ]));
    else if (type2.decode != null) return type2.decode(stream2, ret, operands);
    else switch (type2) {
      case "number":
      case "offset":
      case "sid":
        return operands[0];
      case "boolean":
        return !!operands[0];
      default:
        return operands;
    }
  }
  encodeOperands(type2, stream2, ctx, operands) {
    if (Array.isArray(type2)) return operands.map((op, i2) => this.encodeOperands(type2[i2], stream2, ctx, op)[0]);
    else if (type2.encode != null) return type2.encode(stream2, operands, ctx);
    else if (typeof operands === "number") return [
      operands
    ];
    else if (typeof operands === "boolean") return [
      +operands
    ];
    else if (Array.isArray(operands)) return operands;
    else return [
      operands
    ];
  }
  decode(stream2, parent) {
    let end2 = stream2.pos + parent.length;
    let ret = {};
    let operands = [];
    Object.defineProperties(ret, {
      parent: {
        value: parent
      },
      _startOffset: {
        value: stream2.pos
      }
    });
    for (let key in this.fields) {
      let field = this.fields[key];
      ret[field[1]] = field[3];
    }
    while (stream2.pos < end2) {
      let b3 = stream2.readUInt8();
      if (b3 < 28) {
        if (b3 === 12) b3 = b3 << 8 | stream2.readUInt8();
        let field = this.fields[b3];
        if (!field) throw new Error(`Unknown operator ${b3}`);
        let val = this.decodeOperands(field[2], stream2, ret, operands);
        if (val != null) {
          if (val instanceof (0, PropertyDescriptor)) Object.defineProperty(ret, field[1], val);
          else ret[field[1]] = val;
        }
        operands = [];
      } else operands.push((0, $c2d28e92708f99da$export$2e2bcd8739ae039).decode(stream2, b3));
    }
    return ret;
  }
  size(dict, parent, includePointers = true) {
    let ctx = {
      parent,
      val: dict,
      pointerSize: 0,
      startOffset: parent.startOffset || 0
    };
    let len = 0;
    for (let k3 in this.fields) {
      let field = this.fields[k3];
      let val = dict[field[1]];
      if (val == null || (0, import_fast_deep_equal.default)(val, field[3])) continue;
      let operands = this.encodeOperands(field[2], null, ctx, val);
      for (let op of operands) len += (0, $c2d28e92708f99da$export$2e2bcd8739ae039).size(op);
      let key = Array.isArray(field[0]) ? field[0] : [
        field[0]
      ];
      len += key.length;
    }
    if (includePointers) len += ctx.pointerSize;
    return len;
  }
  encode(stream2, dict, parent) {
    let ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val: dict,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(dict, ctx, false);
    for (let field of this.ops) {
      let val = dict[field[1]];
      if (val == null || (0, import_fast_deep_equal.default)(val, field[3])) continue;
      let operands = this.encodeOperands(field[2], stream2, ctx, val);
      for (let op of operands) (0, $c2d28e92708f99da$export$2e2bcd8739ae039).encode(stream2, op);
      let key = Array.isArray(field[0]) ? field[0] : [
        field[0]
      ];
      for (let op of key) stream2.writeUInt8(op);
    }
    let i2 = 0;
    while (i2 < ctx.pointers.length) {
      let ptr = ctx.pointers[i2++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
    return;
  }
  constructor(ops = []) {
    this.ops = ops;
    this.fields = {};
    for (let field of ops) {
      let key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
      this.fields[key] = field;
    }
  }
};
var $0e34a43d05bde82c$export$2e2bcd8739ae039 = class extends Pointer {
  static {
    __name(this, "$0e34a43d05bde82c$export$2e2bcd8739ae039");
  }
  decode(stream2, parent, operands) {
    this.offsetType = {
      decode: /* @__PURE__ */ __name(() => operands[0], "decode")
    };
    return super.decode(stream2, parent, operands);
  }
  encode(stream2, value2, ctx) {
    if (!stream2) {
      this.offsetType = {
        size: /* @__PURE__ */ __name(() => 0, "size")
      };
      this.size(value2, ctx);
      return [
        new $0e34a43d05bde82c$var$Ptr(0)
      ];
    }
    let ptr = null;
    this.offsetType = {
      encode: /* @__PURE__ */ __name((stream3, val) => ptr = val, "encode")
    };
    super.encode(stream2, value2, ctx);
    return [
      new $0e34a43d05bde82c$var$Ptr(ptr)
    ];
  }
  constructor(type2, options = {}) {
    if (options.type == null) options.type = "global";
    super(null, type2, options);
  }
};
var $0e34a43d05bde82c$var$Ptr = class {
  static {
    __name(this, "$0e34a43d05bde82c$var$Ptr");
  }
  valueOf() {
    return this.val;
  }
  constructor(val) {
    this.val = val;
    this.forceLarge = true;
  }
};
var $6d59db2e29cc77b3$var$CFFBlendOp = class {
  static {
    __name(this, "$6d59db2e29cc77b3$var$CFFBlendOp");
  }
  static decode(stream2, parent, operands) {
    let numBlends = operands.pop();
    while (operands.length > numBlends) operands.pop();
  }
};
var $6d59db2e29cc77b3$export$2e2bcd8739ae039 = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                    type                                          default
  [
    6,
    "BlueValues",
    "delta",
    null
  ],
  [
    7,
    "OtherBlues",
    "delta",
    null
  ],
  [
    8,
    "FamilyBlues",
    "delta",
    null
  ],
  [
    9,
    "FamilyOtherBlues",
    "delta",
    null
  ],
  [
    [
      12,
      9
    ],
    "BlueScale",
    "number",
    0.039625
  ],
  [
    [
      12,
      10
    ],
    "BlueShift",
    "number",
    7
  ],
  [
    [
      12,
      11
    ],
    "BlueFuzz",
    "number",
    1
  ],
  [
    10,
    "StdHW",
    "number",
    null
  ],
  [
    11,
    "StdVW",
    "number",
    null
  ],
  [
    [
      12,
      12
    ],
    "StemSnapH",
    "delta",
    null
  ],
  [
    [
      12,
      13
    ],
    "StemSnapV",
    "delta",
    null
  ],
  [
    [
      12,
      14
    ],
    "ForceBold",
    "boolean",
    false
  ],
  [
    [
      12,
      17
    ],
    "LanguageGroup",
    "number",
    0
  ],
  [
    [
      12,
      18
    ],
    "ExpansionFactor",
    "number",
    0.06
  ],
  [
    [
      12,
      19
    ],
    "initialRandomSeed",
    "number",
    0
  ],
  [
    20,
    "defaultWidthX",
    "number",
    0
  ],
  [
    21,
    "nominalWidthX",
    "number",
    0
  ],
  [
    22,
    "vsindex",
    "number",
    0
  ],
  [
    23,
    "blend",
    $6d59db2e29cc77b3$var$CFFBlendOp,
    null
  ],
  [
    19,
    "Subrs",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(), {
      type: "local"
    }),
    null
  ]
]);
var $229224aec43783c5$export$2e2bcd8739ae039 = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall",
  "001.000",
  "001.001",
  "001.002",
  "001.003",
  "Black",
  "Bold",
  "Book",
  "Light",
  "Medium",
  "Regular",
  "Roman",
  "Semibold"
];
var $bc0433d9b7e41f5f$export$dee0027060fa13bd = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "",
  "questiondown",
  "",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "",
  "ring",
  "cedilla",
  "",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "AE",
  "",
  "ordfeminine",
  "",
  "",
  "",
  "",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "",
  "",
  "",
  "",
  "",
  "ae",
  "",
  "",
  "",
  "dotlessi",
  "",
  "",
  "lslash",
  "oslash",
  "oe",
  "germandbls"
];
var $bc0433d9b7e41f5f$export$4f58f497e14a53c3 = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "",
  "",
  "isuperior",
  "",
  "",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "",
  "",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "",
  "",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "",
  "Dotaccentsmall",
  "",
  "",
  "Macronsmall",
  "",
  "",
  "figuredash",
  "hypheninferior",
  "",
  "",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "",
  "",
  "",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "",
  "",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var $ef658f5c9a1488b2$export$c33b50336c234f16 = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron"
];
var $ef658f5c9a1488b2$export$3ed0f9e1fee8d489 = [
  ".notdef",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var $ef658f5c9a1488b2$export$dc28be11139d4120 = [
  ".notdef",
  "space",
  "dollaroldstyle",
  "dollarsuperior",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "hyphensuperior",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "centoldstyle",
  "figuredash",
  "hypheninferior",
  "onequarter",
  "onehalf",
  "threequarters",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior"
];
var $7cbbe4e24ef3cb75$var$LangSysTable = new Struct({
  reserved: new Reserved(uint16),
  reqFeatureIndex: uint16,
  featureCount: uint16,
  featureIndexes: new ArrayT(uint16, "featureCount")
});
var $7cbbe4e24ef3cb75$var$LangSysRecord = new Struct({
  tag: new StringT(4),
  langSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$var$Script = new Struct({
  defaultLangSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable),
  count: uint16,
  langSysRecords: new ArrayT($7cbbe4e24ef3cb75$var$LangSysRecord, "count")
});
var $7cbbe4e24ef3cb75$var$ScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $7cbbe4e24ef3cb75$var$Script, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$export$3e15fc05ce864229 = new ArrayT($7cbbe4e24ef3cb75$var$ScriptRecord, uint16);
var $7cbbe4e24ef3cb75$var$FeatureParams = new Struct({
  version: uint16,
  nameID: uint16
});
var $7cbbe4e24ef3cb75$export$6e91cf7616333d5 = new Struct({
  featureParams: new Pointer(uint16, $7cbbe4e24ef3cb75$var$FeatureParams),
  lookupCount: uint16,
  lookupListIndexes: new ArrayT(uint16, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$FeatureRecord = new Struct({
  tag: new StringT(4),
  feature: new Pointer(uint16, $7cbbe4e24ef3cb75$export$6e91cf7616333d5, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$export$aa18130def4b6cb4 = new ArrayT($7cbbe4e24ef3cb75$var$FeatureRecord, uint16);
var $7cbbe4e24ef3cb75$var$LookupFlags = new Struct({
  markAttachmentType: uint8,
  flags: new Bitfield(uint8, [
    "rightToLeft",
    "ignoreBaseGlyphs",
    "ignoreLigatures",
    "ignoreMarks",
    "useMarkFilteringSet"
  ])
});
function $7cbbe4e24ef3cb75$export$df0008c6ff2da22a(SubTable) {
  let Lookup = new Struct({
    lookupType: uint16,
    flags: $7cbbe4e24ef3cb75$var$LookupFlags,
    subTableCount: uint16,
    subTables: new ArrayT(new Pointer(uint16, SubTable), "subTableCount"),
    markFilteringSet: new Optional(uint16, (t4) => t4.flags.flags.useMarkFilteringSet)
  });
  return new LazyArray(new Pointer(uint16, Lookup), uint16);
}
__name($7cbbe4e24ef3cb75$export$df0008c6ff2da22a, "$7cbbe4e24ef3cb75$export$df0008c6ff2da22a");
var $7cbbe4e24ef3cb75$var$RangeRecord = new Struct({
  start: uint16,
  end: uint16,
  startCoverageIndex: uint16
});
var $7cbbe4e24ef3cb75$export$17608c3f81a6111 = new VersionedStruct(uint16, {
  1: {
    glyphCount: uint16,
    glyphs: new ArrayT(uint16, "glyphCount")
  },
  2: {
    rangeCount: uint16,
    rangeRecords: new ArrayT($7cbbe4e24ef3cb75$var$RangeRecord, "rangeCount")
  }
});
var $7cbbe4e24ef3cb75$var$ClassRangeRecord = new Struct({
  start: uint16,
  end: uint16,
  class: uint16
});
var $7cbbe4e24ef3cb75$export$843d551fbbafef71 = new VersionedStruct(uint16, {
  1: {
    startGlyph: uint16,
    glyphCount: uint16,
    classValueArray: new ArrayT(uint16, "glyphCount")
  },
  2: {
    classRangeCount: uint16,
    classRangeRecord: new ArrayT($7cbbe4e24ef3cb75$var$ClassRangeRecord, "classRangeCount")
  }
});
var $7cbbe4e24ef3cb75$export$8215d14a63d9fb10 = new Struct({
  a: uint16,
  b: uint16,
  deltaFormat: uint16
});
var $7cbbe4e24ef3cb75$var$LookupRecord = new Struct({
  sequenceIndex: uint16,
  lookupListIndex: uint16
});
var $7cbbe4e24ef3cb75$var$Rule = new Struct({
  glyphCount: uint16,
  lookupCount: uint16,
  input: new ArrayT(uint16, (t4) => t4.glyphCount - 1),
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$RuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$Rule), uint16);
var $7cbbe4e24ef3cb75$var$ClassRule = new Struct({
  glyphCount: uint16,
  lookupCount: uint16,
  classes: new ArrayT(uint16, (t4) => t4.glyphCount - 1),
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$ClassSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassRule), uint16);
var $7cbbe4e24ef3cb75$export$841858b892ce1f4c = new VersionedStruct(uint16, {
  1: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    ruleSetCount: uint16,
    ruleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$RuleSet), "ruleSetCount")
  },
  2: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    classDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    classSetCnt: uint16,
    classSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassSet), "classSetCnt")
  },
  3: {
    glyphCount: uint16,
    lookupCount: uint16,
    coverages: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "glyphCount"),
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  }
});
var $7cbbe4e24ef3cb75$var$ChainRule = new Struct({
  backtrackGlyphCount: uint16,
  backtrack: new ArrayT(uint16, "backtrackGlyphCount"),
  inputGlyphCount: uint16,
  input: new ArrayT(uint16, (t4) => t4.inputGlyphCount - 1),
  lookaheadGlyphCount: uint16,
  lookahead: new ArrayT(uint16, "lookaheadGlyphCount"),
  lookupCount: uint16,
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$ChainRuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRule), uint16);
var $7cbbe4e24ef3cb75$export$5e6d09e6861162f6 = new VersionedStruct(uint16, {
  1: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    chainCount: uint16,
    chainRuleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
  },
  2: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    backtrackClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    inputClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    lookaheadClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    chainCount: uint16,
    chainClassSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
  },
  3: {
    backtrackGlyphCount: uint16,
    backtrackCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "backtrackGlyphCount"),
    inputGlyphCount: uint16,
    inputCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "inputGlyphCount"),
    lookaheadGlyphCount: uint16,
    lookaheadCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "lookaheadGlyphCount"),
    lookupCount: uint16,
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  }
});
var $1a47b0c45c1c22fe$var$F2DOT14 = new Fixed(16, "BE", 14);
var $1a47b0c45c1c22fe$var$RegionAxisCoordinates = new Struct({
  startCoord: $1a47b0c45c1c22fe$var$F2DOT14,
  peakCoord: $1a47b0c45c1c22fe$var$F2DOT14,
  endCoord: $1a47b0c45c1c22fe$var$F2DOT14
});
var $1a47b0c45c1c22fe$var$VariationRegionList = new Struct({
  axisCount: uint16,
  regionCount: uint16,
  variationRegions: new ArrayT(new ArrayT($1a47b0c45c1c22fe$var$RegionAxisCoordinates, "axisCount"), "regionCount")
});
var $1a47b0c45c1c22fe$var$DeltaSet = new Struct({
  shortDeltas: new ArrayT(int16, (t4) => t4.parent.shortDeltaCount),
  regionDeltas: new ArrayT(int8, (t4) => t4.parent.regionIndexCount - t4.parent.shortDeltaCount),
  deltas: /* @__PURE__ */ __name((t4) => t4.shortDeltas.concat(t4.regionDeltas), "deltas")
});
var $1a47b0c45c1c22fe$var$ItemVariationData = new Struct({
  itemCount: uint16,
  shortDeltaCount: uint16,
  regionIndexCount: uint16,
  regionIndexes: new ArrayT(uint16, "regionIndexCount"),
  deltaSets: new ArrayT($1a47b0c45c1c22fe$var$DeltaSet, "itemCount")
});
var $1a47b0c45c1c22fe$export$fe1b122a2710f241 = new Struct({
  format: uint16,
  variationRegionList: new Pointer(uint32, $1a47b0c45c1c22fe$var$VariationRegionList),
  variationDataCount: uint16,
  itemVariationData: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ItemVariationData), "variationDataCount")
});
var $1a47b0c45c1c22fe$var$ConditionTable = new VersionedStruct(uint16, {
  1: {
    axisIndex: uint16,
    axisIndex: uint16,
    filterRangeMinValue: $1a47b0c45c1c22fe$var$F2DOT14,
    filterRangeMaxValue: $1a47b0c45c1c22fe$var$F2DOT14
  }
});
var $1a47b0c45c1c22fe$var$ConditionSet = new Struct({
  conditionCount: uint16,
  conditionTable: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionTable), "conditionCount")
});
var $1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord = new Struct({
  featureIndex: uint16,
  alternateFeatureTable: new Pointer(uint32, (0, $7cbbe4e24ef3cb75$export$6e91cf7616333d5), {
    type: "parent"
  })
});
var $1a47b0c45c1c22fe$var$FeatureTableSubstitution = new Struct({
  version: fixed32,
  substitutionCount: uint16,
  substitutions: new ArrayT($1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord, "substitutionCount")
});
var $1a47b0c45c1c22fe$var$FeatureVariationRecord = new Struct({
  conditionSet: new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionSet, {
    type: "parent"
  }),
  featureTableSubstitution: new Pointer(uint32, $1a47b0c45c1c22fe$var$FeatureTableSubstitution, {
    type: "parent"
  })
});
var $1a47b0c45c1c22fe$export$441b70b7971dd419 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  featureVariationRecordCount: uint32,
  featureVariationRecords: new ArrayT($1a47b0c45c1c22fe$var$FeatureVariationRecord, "featureVariationRecordCount")
});
var $b84fd3dd9d8eddb2$var$PredefinedOp = class {
  static {
    __name(this, "$b84fd3dd9d8eddb2$var$PredefinedOp");
  }
  decode(stream2, parent, operands) {
    if (this.predefinedOps[operands[0]]) return this.predefinedOps[operands[0]];
    return this.type.decode(stream2, parent, operands);
  }
  size(value2, ctx) {
    return this.type.size(value2, ctx);
  }
  encode(stream2, value2, ctx) {
    let index2 = this.predefinedOps.indexOf(value2);
    if (index2 !== -1) return index2;
    return this.type.encode(stream2, value2, ctx);
  }
  constructor(predefinedOps, type2) {
    this.predefinedOps = predefinedOps;
    this.type = type2;
  }
};
var $b84fd3dd9d8eddb2$var$CFFEncodingVersion = class extends NumberT {
  static {
    __name(this, "$b84fd3dd9d8eddb2$var$CFFEncodingVersion");
  }
  decode(stream2) {
    return uint8.decode(stream2) & 127;
  }
  constructor() {
    super("UInt8");
  }
};
var $b84fd3dd9d8eddb2$var$Range1 = new Struct({
  first: uint16,
  nLeft: uint8
});
var $b84fd3dd9d8eddb2$var$Range2 = new Struct({
  first: uint16,
  nLeft: uint16
});
var $b84fd3dd9d8eddb2$var$CFFCustomEncoding = new VersionedStruct(new $b84fd3dd9d8eddb2$var$CFFEncodingVersion(), {
  0: {
    nCodes: uint8,
    codes: new ArrayT(uint8, "nCodes")
  },
  1: {
    nRanges: uint8,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$Range1, "nRanges")
  }
});
var $b84fd3dd9d8eddb2$var$CFFEncoding = new $b84fd3dd9d8eddb2$var$PredefinedOp([
  (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd),
  (0, $bc0433d9b7e41f5f$export$4f58f497e14a53c3)
], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomEncoding, {
  lazy: true
}));
var $b84fd3dd9d8eddb2$var$RangeArray = class extends ArrayT {
  static {
    __name(this, "$b84fd3dd9d8eddb2$var$RangeArray");
  }
  decode(stream2, parent) {
    let length2 = (0, resolveLength)(this.length, stream2, parent);
    let count3 = 0;
    let res = [];
    while (count3 < length2) {
      let range2 = this.type.decode(stream2, parent);
      range2.offset = count3;
      count3 += range2.nLeft + 1;
      res.push(range2);
    }
    return res;
  }
};
var $b84fd3dd9d8eddb2$var$CFFCustomCharset = new VersionedStruct(uint8, {
  0: {
    glyphs: new ArrayT(uint16, (t4) => t4.parent.CharStrings.length - 1)
  },
  1: {
    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range1, (t4) => t4.parent.CharStrings.length - 1)
  },
  2: {
    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range2, (t4) => t4.parent.CharStrings.length - 1)
  }
});
var $b84fd3dd9d8eddb2$var$CFFCharset = new $b84fd3dd9d8eddb2$var$PredefinedOp([
  (0, $ef658f5c9a1488b2$export$c33b50336c234f16),
  (0, $ef658f5c9a1488b2$export$3ed0f9e1fee8d489),
  (0, $ef658f5c9a1488b2$export$dc28be11139d4120)
], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomCharset, {
  lazy: true
}));
var $b84fd3dd9d8eddb2$var$FDRange3 = new Struct({
  first: uint16,
  fd: uint8
});
var $b84fd3dd9d8eddb2$var$FDRange4 = new Struct({
  first: uint32,
  fd: uint16
});
var $b84fd3dd9d8eddb2$var$FDSelect = new VersionedStruct(uint8, {
  0: {
    fds: new ArrayT(uint8, (t4) => t4.parent.CharStrings.length)
  },
  3: {
    nRanges: uint16,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange3, "nRanges"),
    sentinel: uint16
  },
  4: {
    nRanges: uint32,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange4, "nRanges"),
    sentinel: uint32
  }
});
var $b84fd3dd9d8eddb2$var$ptr = new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)((0, $6d59db2e29cc77b3$export$2e2bcd8739ae039));
var $b84fd3dd9d8eddb2$var$CFFPrivateOp = class {
  static {
    __name(this, "$b84fd3dd9d8eddb2$var$CFFPrivateOp");
  }
  decode(stream2, parent, operands) {
    parent.length = operands[0];
    return $b84fd3dd9d8eddb2$var$ptr.decode(stream2, parent, [
      operands[1]
    ]);
  }
  size(dict, ctx) {
    return [
      (0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx, false),
      $b84fd3dd9d8eddb2$var$ptr.size(dict, ctx)[0]
    ];
  }
  encode(stream2, dict, ctx) {
    return [
      (0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx, false),
      $b84fd3dd9d8eddb2$var$ptr.encode(stream2, dict, ctx)[0]
    ];
  }
};
var $b84fd3dd9d8eddb2$var$FontDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                   type(s)                                 default
  [
    18,
    "Private",
    new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
    null
  ],
  [
    [
      12,
      38
    ],
    "FontName",
    "sid",
    null
  ],
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    [
      12,
      5
    ],
    "PaintType",
    "number",
    0
  ]
]);
var $b84fd3dd9d8eddb2$var$CFFTopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                   type(s)                                 default
  [
    [
      12,
      30
    ],
    "ROS",
    [
      "sid",
      "sid",
      "number"
    ],
    null
  ],
  [
    0,
    "version",
    "sid",
    null
  ],
  [
    1,
    "Notice",
    "sid",
    null
  ],
  [
    [
      12,
      0
    ],
    "Copyright",
    "sid",
    null
  ],
  [
    2,
    "FullName",
    "sid",
    null
  ],
  [
    3,
    "FamilyName",
    "sid",
    null
  ],
  [
    4,
    "Weight",
    "sid",
    null
  ],
  [
    [
      12,
      1
    ],
    "isFixedPitch",
    "boolean",
    false
  ],
  [
    [
      12,
      2
    ],
    "ItalicAngle",
    "number",
    0
  ],
  [
    [
      12,
      3
    ],
    "UnderlinePosition",
    "number",
    -100
  ],
  [
    [
      12,
      4
    ],
    "UnderlineThickness",
    "number",
    50
  ],
  [
    [
      12,
      5
    ],
    "PaintType",
    "number",
    0
  ],
  [
    [
      12,
      6
    ],
    "CharstringType",
    "number",
    2
  ],
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    13,
    "UniqueID",
    "number",
    null
  ],
  [
    5,
    "FontBBox",
    "array",
    [
      0,
      0,
      0,
      0
    ]
  ],
  [
    [
      12,
      8
    ],
    "StrokeWidth",
    "number",
    0
  ],
  [
    14,
    "XUID",
    "array",
    null
  ],
  [
    15,
    "charset",
    $b84fd3dd9d8eddb2$var$CFFCharset,
    (0, $ef658f5c9a1488b2$export$c33b50336c234f16)
  ],
  [
    16,
    "Encoding",
    $b84fd3dd9d8eddb2$var$CFFEncoding,
    (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd)
  ],
  [
    17,
    "CharStrings",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()),
    null
  ],
  [
    18,
    "Private",
    new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
    null
  ],
  [
    [
      12,
      20
    ],
    "SyntheticBase",
    "number",
    null
  ],
  [
    [
      12,
      21
    ],
    "PostScript",
    "sid",
    null
  ],
  [
    [
      12,
      22
    ],
    "BaseFontName",
    "sid",
    null
  ],
  [
    [
      12,
      23
    ],
    "BaseFontBlend",
    "delta",
    null
  ],
  // CID font specific
  [
    [
      12,
      31
    ],
    "CIDFontVersion",
    "number",
    0
  ],
  [
    [
      12,
      32
    ],
    "CIDFontRevision",
    "number",
    0
  ],
  [
    [
      12,
      33
    ],
    "CIDFontType",
    "number",
    0
  ],
  [
    [
      12,
      34
    ],
    "CIDCount",
    "number",
    8720
  ],
  [
    [
      12,
      35
    ],
    "UIDBase",
    "number",
    null
  ],
  [
    [
      12,
      37
    ],
    "FDSelect",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect),
    null
  ],
  [
    [
      12,
      36
    ],
    "FDArray",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)),
    null
  ],
  [
    [
      12,
      38
    ],
    "FontName",
    "sid",
    null
  ]
]);
var $b84fd3dd9d8eddb2$var$VariationStore = new Struct({
  length: uint16,
  itemVariationStore: (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)
});
var $b84fd3dd9d8eddb2$var$CFF2TopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    17,
    "CharStrings",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()),
    null
  ],
  [
    [
      12,
      37
    ],
    "FDSelect",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect),
    null
  ],
  [
    [
      12,
      36
    ],
    "FDArray",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)),
    null
  ],
  [
    24,
    "vstore",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$VariationStore),
    null
  ],
  [
    25,
    "maxstack",
    "number",
    193
  ]
]);
var $b84fd3dd9d8eddb2$var$CFFTop = new VersionedStruct(fixed16, {
  1: {
    hdrSize: uint8,
    offSize: uint8,
    nameIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new StringT("length")),
    topDictIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFTopDict),
    stringIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new StringT("length")),
    globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()
  },
  2: {
    hdrSize: uint8,
    length: uint16,
    topDict: $b84fd3dd9d8eddb2$var$CFF2TopDict,
    globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()
  }
});
var $b84fd3dd9d8eddb2$export$2e2bcd8739ae039 = $b84fd3dd9d8eddb2$var$CFFTop;
var $822ac0d589e4e237$var$CFFFont = class _$822ac0d589e4e237$var$CFFFont {
  static {
    __name(this, "$822ac0d589e4e237$var$CFFFont");
  }
  static decode(stream2) {
    return new _$822ac0d589e4e237$var$CFFFont(stream2);
  }
  decode() {
    let start2 = this.stream.pos;
    let top = (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).decode(this.stream);
    for (let key in top) {
      let val = top[key];
      this[key] = val;
    }
    if (this.version < 2) {
      if (this.topDictIndex.length !== 1) throw new Error("Only a single font is allowed in CFF");
      this.topDict = this.topDictIndex[0];
    }
    this.isCIDFont = this.topDict.ROS != null;
    return this;
  }
  string(sid) {
    if (this.version >= 2) return null;
    if (sid < (0, $229224aec43783c5$export$2e2bcd8739ae039).length) return (0, $229224aec43783c5$export$2e2bcd8739ae039)[sid];
    return this.stringIndex[sid - (0, $229224aec43783c5$export$2e2bcd8739ae039).length];
  }
  get postscriptName() {
    if (this.version < 2) return this.nameIndex[0];
    return null;
  }
  get fullName() {
    return this.string(this.topDict.FullName);
  }
  get familyName() {
    return this.string(this.topDict.FamilyName);
  }
  getCharString(glyph) {
    this.stream.pos = this.topDict.CharStrings[glyph].offset;
    return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);
  }
  getGlyphName(gid) {
    if (this.version >= 2) return null;
    if (this.isCIDFont) return null;
    let { charset } = this.topDict;
    if (Array.isArray(charset)) return charset[gid];
    if (gid === 0) return ".notdef";
    gid -= 1;
    switch (charset.version) {
      case 0:
        return this.string(charset.glyphs[gid]);
      case 1:
      case 2:
        for (let i2 = 0; i2 < charset.ranges.length; i2++) {
          let range2 = charset.ranges[i2];
          if (range2.offset <= gid && gid <= range2.offset + range2.nLeft) return this.string(range2.first + (gid - range2.offset));
        }
        break;
    }
    return null;
  }
  fdForGlyph(gid) {
    if (!this.topDict.FDSelect) return null;
    switch (this.topDict.FDSelect.version) {
      case 0:
        return this.topDict.FDSelect.fds[gid];
      case 3:
      case 4:
        let { ranges } = this.topDict.FDSelect;
        let low = 0;
        let high = ranges.length - 1;
        while (low <= high) {
          let mid = low + high >> 1;
          if (gid < ranges[mid].first) high = mid - 1;
          else if (mid < high && gid >= ranges[mid + 1].first) low = mid + 1;
          else return ranges[mid].fd;
        }
      default:
        throw new Error(`Unknown FDSelect version: ${this.topDict.FDSelect.version}`);
    }
  }
  privateDictForGlyph(gid) {
    if (this.topDict.FDSelect) {
      let fd = this.fdForGlyph(gid);
      if (this.topDict.FDArray[fd]) return this.topDict.FDArray[fd].Private;
      return null;
    }
    if (this.version < 2) return this.topDict.Private;
    return this.topDict.FDArray[0].Private;
  }
  constructor(stream2) {
    this.stream = stream2;
    this.decode();
  }
};
var $822ac0d589e4e237$export$2e2bcd8739ae039 = $822ac0d589e4e237$var$CFFFont;
var $2bbf2bc1ce37cd8f$var$VerticalOrigin = new Struct({
  glyphIndex: uint16,
  vertOriginY: int16
});
var $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  defaultVertOriginY: int16,
  numVertOriginYMetrics: uint16,
  metrics: new ArrayT($2bbf2bc1ce37cd8f$var$VerticalOrigin, "numVertOriginYMetrics")
});
var $0941618dc22a946d$export$16b227cb15d716a0 = new Struct({
  height: uint8,
  width: uint8,
  horiBearingX: int8,
  horiBearingY: int8,
  horiAdvance: uint8,
  vertBearingX: int8,
  vertBearingY: int8,
  vertAdvance: uint8
});
var $0941618dc22a946d$export$62c53e75f69bfe12 = new Struct({
  height: uint8,
  width: uint8,
  bearingX: int8,
  bearingY: int8,
  advance: uint8
});
var $0941618dc22a946d$var$EBDTComponent = new Struct({
  glyph: uint16,
  xOffset: int8,
  yOffset: int8
});
var $0941618dc22a946d$var$ByteAligned = class {
  static {
    __name(this, "$0941618dc22a946d$var$ByteAligned");
  }
};
var $0941618dc22a946d$var$BitAligned = class {
  static {
    __name(this, "$0941618dc22a946d$var$BitAligned");
  }
};
var $0941618dc22a946d$export$f1f5ddeb20d14f = new VersionedStruct("version", {
  1: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    data: $0941618dc22a946d$var$ByteAligned
  },
  2: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    data: $0941618dc22a946d$var$BitAligned
  },
  // format 3 is deprecated
  // format 4 is not supported by Microsoft
  5: {
    data: $0941618dc22a946d$var$BitAligned
  },
  6: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    data: $0941618dc22a946d$var$ByteAligned
  },
  7: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    data: $0941618dc22a946d$var$BitAligned
  },
  8: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    pad: new Reserved(uint8),
    numComponents: uint16,
    components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
  },
  9: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    pad: new Reserved(uint8),
    numComponents: uint16,
    components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
  },
  17: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    dataLen: uint32,
    data: new BufferT("dataLen")
  },
  18: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    dataLen: uint32,
    data: new BufferT("dataLen")
  },
  19: {
    dataLen: uint32,
    data: new BufferT("dataLen")
  }
});
var $9911c4c7201c13de$var$SBitLineMetrics = new Struct({
  ascender: int8,
  descender: int8,
  widthMax: uint8,
  caretSlopeNumerator: int8,
  caretSlopeDenominator: int8,
  caretOffset: int8,
  minOriginSB: int8,
  minAdvanceSB: int8,
  maxBeforeBL: int8,
  minAfterBL: int8,
  pad: new Reserved(int8, 2)
});
var $9911c4c7201c13de$var$CodeOffsetPair = new Struct({
  glyphCode: uint16,
  offset: uint16
});
var $9911c4c7201c13de$var$IndexSubtable = new VersionedStruct(uint16, {
  header: {
    imageFormat: uint16,
    imageDataOffset: uint32
  },
  1: {
    offsetArray: new ArrayT(uint32, (t4) => t4.parent.lastGlyphIndex - t4.parent.firstGlyphIndex + 1)
  },
  2: {
    imageSize: uint32,
    bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0)
  },
  3: {
    offsetArray: new ArrayT(uint16, (t4) => t4.parent.lastGlyphIndex - t4.parent.firstGlyphIndex + 1)
  },
  4: {
    numGlyphs: uint32,
    glyphArray: new ArrayT($9911c4c7201c13de$var$CodeOffsetPair, (t4) => t4.numGlyphs + 1)
  },
  5: {
    imageSize: uint32,
    bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0),
    numGlyphs: uint32,
    glyphCodeArray: new ArrayT(uint16, "numGlyphs")
  }
});
var $9911c4c7201c13de$var$IndexSubtableArray = new Struct({
  firstGlyphIndex: uint16,
  lastGlyphIndex: uint16,
  subtable: new Pointer(uint32, $9911c4c7201c13de$var$IndexSubtable)
});
var $9911c4c7201c13de$var$BitmapSizeTable = new Struct({
  indexSubTableArray: new Pointer(uint32, new ArrayT($9911c4c7201c13de$var$IndexSubtableArray, 1), {
    type: "parent"
  }),
  indexTablesSize: uint32,
  numberOfIndexSubTables: uint32,
  colorRef: uint32,
  hori: $9911c4c7201c13de$var$SBitLineMetrics,
  vert: $9911c4c7201c13de$var$SBitLineMetrics,
  startGlyphIndex: uint16,
  endGlyphIndex: uint16,
  ppemX: uint8,
  ppemY: uint8,
  bitDepth: uint8,
  flags: new Bitfield(uint8, [
    "horizontal",
    "vertical"
  ])
});
var $9911c4c7201c13de$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  numSizes: uint32,
  sizes: new ArrayT($9911c4c7201c13de$var$BitmapSizeTable, "numSizes")
});
var $abb847051efd51b1$var$ImageTable = new Struct({
  ppem: uint16,
  resolution: uint16,
  imageOffsets: new ArrayT(new Pointer(uint32, "void"), (t4) => t4.parent.parent.maxp.numGlyphs + 1)
});
var $abb847051efd51b1$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  flags: new Bitfield(uint16, [
    "renderOutlines"
  ]),
  numImgTables: uint32,
  imageTables: new ArrayT(new Pointer(uint32, $abb847051efd51b1$var$ImageTable), "numImgTables")
});
var $eb629188f3dfefdd$var$LayerRecord = new Struct({
  gid: uint16,
  paletteIndex: uint16
  // Index value to use in the appropriate palette. This value must
});
var $eb629188f3dfefdd$var$BaseGlyphRecord = new Struct({
  gid: uint16,
  // and is not rendered for color.
  firstLayerIndex: uint16,
  // There will be numLayers consecutive entries for this base glyph.
  numLayers: uint16
});
var $eb629188f3dfefdd$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numBaseGlyphRecords: uint16,
  baseGlyphRecord: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$BaseGlyphRecord, "numBaseGlyphRecords")),
  layerRecords: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$LayerRecord, "numLayerRecords"), {
    lazy: true
  }),
  numLayerRecords: uint16
});
var $08734b8e7dc64587$var$ColorRecord = new Struct({
  blue: uint8,
  green: uint8,
  red: uint8,
  alpha: uint8
});
var $08734b8e7dc64587$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
  header: {
    numPaletteEntries: uint16,
    numPalettes: uint16,
    numColorRecords: uint16,
    colorRecords: new Pointer(uint32, new ArrayT($08734b8e7dc64587$var$ColorRecord, "numColorRecords")),
    colorRecordIndices: new ArrayT(uint16, "numPalettes")
  },
  0: {},
  1: {
    offsetPaletteTypeArray: new Pointer(uint32, new ArrayT(uint32, "numPalettes")),
    offsetPaletteLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPalettes")),
    offsetPaletteEntryLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPaletteEntries"))
  }
});
var $497cef411d884e34$var$BaseCoord = new VersionedStruct(uint16, {
  1: {
    coordinate: int16
    // X or Y value, in design units
  },
  2: {
    coordinate: int16,
    referenceGlyph: uint16,
    baseCoordPoint: uint16
    // Index of contour point on the referenceGlyph
  },
  3: {
    coordinate: int16,
    deviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
    // Device table for X or Y value
  }
});
var $497cef411d884e34$var$BaseValues = new Struct({
  defaultIndex: uint16,
  baseCoordCount: uint16,
  baseCoords: new ArrayT(new Pointer(uint16, $497cef411d884e34$var$BaseCoord), "baseCoordCount")
});
var $497cef411d884e34$var$FeatMinMaxRecord = new Struct({
  tag: new StringT(4),
  minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
    type: "parent"
  }),
  maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
    type: "parent"
  })
  // May be NULL
});
var $497cef411d884e34$var$MinMax = new Struct({
  minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
  maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
  featMinMaxCount: uint16,
  featMinMaxRecords: new ArrayT($497cef411d884e34$var$FeatMinMaxRecord, "featMinMaxCount")
  // In alphabetical order
});
var $497cef411d884e34$var$BaseLangSysRecord = new Struct({
  tag: new StringT(4),
  minMax: new Pointer(uint16, $497cef411d884e34$var$MinMax, {
    type: "parent"
  })
});
var $497cef411d884e34$var$BaseScript = new Struct({
  baseValues: new Pointer(uint16, $497cef411d884e34$var$BaseValues),
  defaultMinMax: new Pointer(uint16, $497cef411d884e34$var$MinMax),
  baseLangSysCount: uint16,
  baseLangSysRecords: new ArrayT($497cef411d884e34$var$BaseLangSysRecord, "baseLangSysCount")
  // in alphabetical order by BaseLangSysTag
});
var $497cef411d884e34$var$BaseScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $497cef411d884e34$var$BaseScript, {
    type: "parent"
  })
});
var $497cef411d884e34$var$BaseScriptList = new ArrayT($497cef411d884e34$var$BaseScriptRecord, uint16);
var $497cef411d884e34$var$BaseTagList = new ArrayT(new StringT(4), uint16);
var $497cef411d884e34$var$Axis = new Struct({
  baseTagList: new Pointer(uint16, $497cef411d884e34$var$BaseTagList),
  baseScriptList: new Pointer(uint16, $497cef411d884e34$var$BaseScriptList)
});
var $497cef411d884e34$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    horizAxis: new Pointer(uint16, $497cef411d884e34$var$Axis),
    vertAxis: new Pointer(uint16, $497cef411d884e34$var$Axis)
    // May be NULL
  },
  65536: {},
  65537: {
    itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))
  }
});
var $cf5f33c63ef209e6$var$AttachPoint = new ArrayT(uint16, uint16);
var $cf5f33c63ef209e6$var$AttachList = new Struct({
  coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
  glyphCount: uint16,
  attachPoints: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$AttachPoint), "glyphCount")
});
var $cf5f33c63ef209e6$var$CaretValue = new VersionedStruct(uint16, {
  1: {
    coordinate: int16
  },
  2: {
    caretValuePoint: uint16
  },
  3: {
    coordinate: int16,
    deviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
  }
});
var $cf5f33c63ef209e6$var$LigGlyph = new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$CaretValue), uint16);
var $cf5f33c63ef209e6$var$LigCaretList = new Struct({
  coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
  ligGlyphCount: uint16,
  ligGlyphs: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$LigGlyph), "ligGlyphCount")
});
var $cf5f33c63ef209e6$var$MarkGlyphSetsDef = new Struct({
  markSetTableFormat: uint16,
  markSetCount: uint16,
  coverage: new ArrayT(new Pointer(uint32, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "markSetCount")
});
var $cf5f33c63ef209e6$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    glyphClassDef: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
    attachList: new Pointer(uint16, $cf5f33c63ef209e6$var$AttachList),
    ligCaretList: new Pointer(uint16, $cf5f33c63ef209e6$var$LigCaretList),
    markAttachClassDef: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71))
  },
  65536: {},
  65538: {
    markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef)
  },
  65539: {
    markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef),
    itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))
  }
});
var $47e0e8ef515d9903$var$ValueFormat = new Bitfield(uint16, [
  "xPlacement",
  "yPlacement",
  "xAdvance",
  "yAdvance",
  "xPlaDevice",
  "yPlaDevice",
  "xAdvDevice",
  "yAdvDevice"
]);
var $47e0e8ef515d9903$var$types = {
  xPlacement: int16,
  yPlacement: int16,
  xAdvance: int16,
  yAdvance: int16,
  xPlaDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: /* @__PURE__ */ __name((ctx) => ctx.rel, "relativeTo")
  }),
  yPlaDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: /* @__PURE__ */ __name((ctx) => ctx.rel, "relativeTo")
  }),
  xAdvDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: /* @__PURE__ */ __name((ctx) => ctx.rel, "relativeTo")
  }),
  yAdvDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: /* @__PURE__ */ __name((ctx) => ctx.rel, "relativeTo")
  })
};
var $47e0e8ef515d9903$var$ValueRecord = class {
  static {
    __name(this, "$47e0e8ef515d9903$var$ValueRecord");
  }
  buildStruct(parent) {
    let struct = parent;
    while (!struct[this.key] && struct.parent) struct = struct.parent;
    if (!struct[this.key]) return;
    let fields = {};
    fields.rel = () => struct._startOffset;
    let format3 = struct[this.key];
    for (let key in format3) if (format3[key]) fields[key] = $47e0e8ef515d9903$var$types[key];
    return new Struct(fields);
  }
  size(val, ctx) {
    return this.buildStruct(ctx).size(val, ctx);
  }
  decode(stream2, parent) {
    let res = this.buildStruct(parent).decode(stream2, parent);
    delete res.rel;
    return res;
  }
  constructor(key = "valueFormat") {
    this.key = key;
  }
};
var $47e0e8ef515d9903$var$PairValueRecord = new Struct({
  secondGlyph: uint16,
  value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
  value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
});
var $47e0e8ef515d9903$var$PairSet = new ArrayT($47e0e8ef515d9903$var$PairValueRecord, uint16);
var $47e0e8ef515d9903$var$Class2Record = new Struct({
  value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
  value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
});
var $47e0e8ef515d9903$var$Anchor = new VersionedStruct(uint16, {
  1: {
    xCoordinate: int16,
    yCoordinate: int16
  },
  2: {
    xCoordinate: int16,
    yCoordinate: int16,
    anchorPoint: uint16
  },
  3: {
    xCoordinate: int16,
    yCoordinate: int16,
    xDeviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10)),
    yDeviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
  }
});
var $47e0e8ef515d9903$var$EntryExitRecord = new Struct({
  entryAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  }),
  exitAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  })
});
var $47e0e8ef515d9903$var$MarkRecord = new Struct({
  class: uint16,
  markAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  })
});
var $47e0e8ef515d9903$var$MarkArray = new ArrayT($47e0e8ef515d9903$var$MarkRecord, uint16);
var $47e0e8ef515d9903$var$BaseRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t4) => t4.parent.classCount);
var $47e0e8ef515d9903$var$BaseArray = new ArrayT($47e0e8ef515d9903$var$BaseRecord, uint16);
var $47e0e8ef515d9903$var$ComponentRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t4) => t4.parent.parent.classCount);
var $47e0e8ef515d9903$var$LigatureAttach = new ArrayT($47e0e8ef515d9903$var$ComponentRecord, uint16);
var $47e0e8ef515d9903$var$LigatureArray = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$LigatureAttach), uint16);
var $47e0e8ef515d9903$export$73a8cfb19cd43a0f = new VersionedStruct("lookupType", {
  1: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat: $47e0e8ef515d9903$var$ValueFormat,
      value: new $47e0e8ef515d9903$var$ValueRecord()
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat: $47e0e8ef515d9903$var$ValueFormat,
      valueCount: uint16,
      values: new LazyArray(new $47e0e8ef515d9903$var$ValueRecord(), "valueCount")
    }
  }),
  2: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
      pairSetCount: uint16,
      pairSets: new LazyArray(new Pointer(uint16, $47e0e8ef515d9903$var$PairSet), "pairSetCount")
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
      classDef1: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
      classDef2: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
      class1Count: uint16,
      class2Count: uint16,
      classRecords: new LazyArray(new LazyArray($47e0e8ef515d9903$var$Class2Record, "class2Count"), "class1Count")
    }
  }),
  3: {
    format: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    entryExitCount: uint16,
    entryExitRecords: new ArrayT($47e0e8ef515d9903$var$EntryExitRecord, "entryExitCount")
  },
  4: {
    format: uint16,
    markCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    baseCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    baseArray: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
  },
  5: {
    format: uint16,
    markCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    ligatureCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    ligatureArray: new Pointer(uint16, $47e0e8ef515d9903$var$LigatureArray)
  },
  6: {
    format: uint16,
    mark1Coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    mark2Coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    mark1Array: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    mark2Array: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
  },
  7: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),
  8: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),
  9: {
    posFormat: uint16,
    lookupType: uint16,
    extension: new Pointer(uint32, null)
  }
});
$47e0e8ef515d9903$export$73a8cfb19cd43a0f.versions[9].extension.type = $47e0e8ef515d9903$export$73a8cfb19cd43a0f;
var $47e0e8ef515d9903$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    scriptList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),
    featureList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),
    lookupList: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($47e0e8ef515d9903$export$73a8cfb19cd43a0f))
  },
  65536: {},
  65537: {
    featureVariations: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))
  }
});
var $d3f442064af66e06$var$Sequence = new ArrayT(uint16, uint16);
var $d3f442064af66e06$var$AlternateSet = $d3f442064af66e06$var$Sequence;
var $d3f442064af66e06$var$Ligature = new Struct({
  glyph: uint16,
  compCount: uint16,
  components: new ArrayT(uint16, (t4) => t4.compCount - 1)
});
var $d3f442064af66e06$var$LigatureSet = new ArrayT(new Pointer(uint16, $d3f442064af66e06$var$Ligature), uint16);
var $d3f442064af66e06$var$GSUBLookup = new VersionedStruct("lookupType", {
  1: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      deltaGlyphID: int16
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      glyphCount: uint16,
      substitute: new LazyArray(uint16, "glyphCount")
    }
  }),
  2: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    sequences: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$Sequence), "count")
  },
  3: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    alternateSet: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$AlternateSet), "count")
  },
  4: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    ligatureSets: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$LigatureSet), "count")
  },
  5: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),
  6: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),
  7: {
    substFormat: uint16,
    lookupType: uint16,
    extension: new Pointer(uint32, null)
  },
  8: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    backtrackCoverage: new ArrayT(new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "backtrackGlyphCount"),
    lookaheadGlyphCount: uint16,
    lookaheadCoverage: new ArrayT(new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "lookaheadGlyphCount"),
    glyphCount: uint16,
    substitutes: new ArrayT(uint16, "glyphCount")
  }
});
$d3f442064af66e06$var$GSUBLookup.versions[7].extension.type = $d3f442064af66e06$var$GSUBLookup;
var $d3f442064af66e06$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    scriptList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),
    featureList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),
    lookupList: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($d3f442064af66e06$var$GSUBLookup))
  },
  65536: {},
  65537: {
    featureVariations: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))
  }
});
var $71cfb3c4767fbd0c$var$JstfGSUBModList = new ArrayT(uint16, uint16);
var $71cfb3c4767fbd0c$var$JstfPriority = new Struct({
  shrinkageEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageJstfMax: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f))),
  extensionEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionJstfMax: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f)))
});
var $71cfb3c4767fbd0c$var$JstfLangSys = new ArrayT(new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfPriority), uint16);
var $71cfb3c4767fbd0c$var$JstfLangSysRecord = new Struct({
  tag: new StringT(4),
  jstfLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys)
});
var $71cfb3c4767fbd0c$var$JstfScript = new Struct({
  extenderGlyphs: new Pointer(uint16, new ArrayT(uint16, uint16)),
  defaultLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys),
  langSysCount: uint16,
  langSysRecords: new ArrayT($71cfb3c4767fbd0c$var$JstfLangSysRecord, "langSysCount")
});
var $71cfb3c4767fbd0c$var$JstfScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfScript, {
    type: "parent"
  })
});
var $71cfb3c4767fbd0c$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  scriptCount: uint16,
  scriptList: new ArrayT($71cfb3c4767fbd0c$var$JstfScriptRecord, "scriptCount")
});
var $d059a6bd2d3b5b63$var$VariableSizeNumber = class {
  static {
    __name(this, "$d059a6bd2d3b5b63$var$VariableSizeNumber");
  }
  decode(stream2, parent) {
    switch (this.size(0, parent)) {
      case 1:
        return stream2.readUInt8();
      case 2:
        return stream2.readUInt16BE();
      case 3:
        return stream2.readUInt24BE();
      case 4:
        return stream2.readUInt32BE();
    }
  }
  size(val, parent) {
    return (0, resolveLength)(this._size, null, parent);
  }
  constructor(size) {
    this._size = size;
  }
};
var $d059a6bd2d3b5b63$var$MapDataEntry = new Struct({
  entry: new $d059a6bd2d3b5b63$var$VariableSizeNumber((t4) => ((t4.parent.entryFormat & 48) >> 4) + 1),
  outerIndex: /* @__PURE__ */ __name((t4) => t4.entry >> (t4.parent.entryFormat & 15) + 1, "outerIndex"),
  innerIndex: /* @__PURE__ */ __name((t4) => t4.entry & (1 << (t4.parent.entryFormat & 15) + 1) - 1, "innerIndex")
});
var $d059a6bd2d3b5b63$var$DeltaSetIndexMap = new Struct({
  entryFormat: uint16,
  mapCount: uint16,
  mapData: new ArrayT($d059a6bd2d3b5b63$var$MapDataEntry, "mapCount")
});
var $d059a6bd2d3b5b63$export$2e2bcd8739ae039 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)),
  advanceWidthMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
  LSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
  RSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap)
});
var $dceeca3e1977ce30$var$Signature = new Struct({
  format: uint32,
  length: uint32,
  offset: uint32
});
var $dceeca3e1977ce30$var$SignatureBlock = new Struct({
  reserved: new Reserved(uint16, 2),
  cbSignature: uint32,
  signature: new BufferT("cbSignature")
});
var $dceeca3e1977ce30$export$2e2bcd8739ae039 = new Struct({
  ulVersion: uint32,
  usNumSigs: uint16,
  usFlag: uint16,
  signatures: new ArrayT($dceeca3e1977ce30$var$Signature, "usNumSigs"),
  signatureBlocks: new ArrayT($dceeca3e1977ce30$var$SignatureBlock, "usNumSigs")
});
var $8acd740a9435aad0$var$GaspRange = new Struct({
  rangeMaxPPEM: uint16,
  rangeGaspBehavior: new Bitfield(uint16, [
    "grayscale",
    "gridfit",
    "symmetricSmoothing",
    "symmetricGridfit"
    // only in version 1, for ClearType
  ])
});
var $8acd740a9435aad0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRanges: uint16,
  gaspRanges: new ArrayT($8acd740a9435aad0$var$GaspRange, "numRanges")
  // Sorted by ppem
});
var $b5f380243c34d6a0$var$DeviceRecord = new Struct({
  pixelSize: uint8,
  maximumWidth: uint8,
  widths: new ArrayT(uint8, (t4) => t4.parent.parent.maxp.numGlyphs)
});
var $b5f380243c34d6a0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRecords: int16,
  sizeDeviceRecord: int32,
  records: new ArrayT($b5f380243c34d6a0$var$DeviceRecord, "numRecords")
});
var $ca2df1256966e313$var$KernPair = new Struct({
  left: uint16,
  right: uint16,
  value: int16
});
var $ca2df1256966e313$var$ClassTable = new Struct({
  firstGlyph: uint16,
  nGlyphs: uint16,
  offsets: new ArrayT(uint16, "nGlyphs"),
  max: /* @__PURE__ */ __name((t4) => t4.offsets.length && Math.max.apply(Math, t4.offsets), "max")
});
var $ca2df1256966e313$var$Kern2Array = new Struct({
  off: /* @__PURE__ */ __name((t4) => t4._startOffset - t4.parent.parent._startOffset, "off"),
  len: /* @__PURE__ */ __name((t4) => ((t4.parent.leftTable.max - t4.off) / t4.parent.rowWidth + 1) * (t4.parent.rowWidth / 2), "len"),
  values: new LazyArray(int16, "len")
});
var $ca2df1256966e313$var$KernSubtable = new VersionedStruct("format", {
  0: {
    nPairs: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    pairs: new ArrayT($ca2df1256966e313$var$KernPair, "nPairs")
  },
  2: {
    rowWidth: uint16,
    leftTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
      type: "parent"
    }),
    rightTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
      type: "parent"
    }),
    array: new Pointer(uint16, $ca2df1256966e313$var$Kern2Array, {
      type: "parent"
    })
  },
  3: {
    glyphCount: uint16,
    kernValueCount: uint8,
    leftClassCount: uint8,
    rightClassCount: uint8,
    flags: uint8,
    kernValue: new ArrayT(int16, "kernValueCount"),
    leftClass: new ArrayT(uint8, "glyphCount"),
    rightClass: new ArrayT(uint8, "glyphCount"),
    kernIndex: new ArrayT(uint8, (t4) => t4.leftClassCount * t4.rightClassCount)
  }
});
var $ca2df1256966e313$var$KernTable = new VersionedStruct("version", {
  0: {
    subVersion: uint16,
    length: uint16,
    format: uint8,
    coverage: new Bitfield(uint8, [
      "horizontal",
      "minimum",
      "crossStream",
      "override"
      // If set to 1 the value in this table replaces the accumulated value
    ]),
    subtable: $ca2df1256966e313$var$KernSubtable,
    padding: new Reserved(uint8, (t4) => t4.length - t4._currentOffset)
  },
  1: {
    length: uint32,
    coverage: new Bitfield(uint8, [
      null,
      null,
      null,
      null,
      null,
      "variation",
      "crossStream",
      "vertical"
      // Set if table has vertical kerning values
    ]),
    format: uint8,
    tupleIndex: uint16,
    subtable: $ca2df1256966e313$var$KernSubtable,
    padding: new Reserved(uint8, (t4) => t4.length - t4._currentOffset)
  }
});
var $ca2df1256966e313$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
  0: {
    nTables: uint16,
    tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
  },
  1: {
    reserved: new Reserved(uint16),
    nTables: uint32,
    tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
  }
});
var $7a9f92b0c46ebe33$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numGlyphs: uint16,
  yPels: new ArrayT(uint8, "numGlyphs")
});
var $2b2ccc419d152631$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  fontNumber: uint32,
  pitch: uint16,
  xHeight: uint16,
  style: uint16,
  typeFamily: uint16,
  capHeight: uint16,
  symbolSet: uint16,
  typeface: new StringT(16),
  characterComplement: new StringT(8),
  fileName: new StringT(6),
  strokeWeight: new StringT(1),
  widthType: new StringT(1),
  serifStyle: uint8,
  reserved: new Reserved(uint8)
});
var $ca5b40b9bcda9c9b$var$Ratio = new Struct({
  bCharSet: uint8,
  xRatio: uint8,
  yStartRatio: uint8,
  yEndRatio: uint8
  // Ending y-Ratio value
});
var $ca5b40b9bcda9c9b$var$vTable = new Struct({
  yPelHeight: uint16,
  yMax: int16,
  yMin: int16
  // Minimum value (in pels) for this yPelHeight
});
var $ca5b40b9bcda9c9b$var$VdmxGroup = new Struct({
  recs: uint16,
  startsz: uint8,
  endsz: uint8,
  entries: new ArrayT($ca5b40b9bcda9c9b$var$vTable, "recs")
  // The VDMX records
});
var $ca5b40b9bcda9c9b$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRecs: uint16,
  numRatios: uint16,
  ratioRanges: new ArrayT($ca5b40b9bcda9c9b$var$Ratio, "numRatios"),
  offsets: new ArrayT(uint16, "numRatios"),
  groups: new ArrayT($ca5b40b9bcda9c9b$var$VdmxGroup, "numRecs")
  // The actual VDMX groupings
});
var $69530a3c40755af0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  ascent: int16,
  descent: int16,
  lineGap: int16,
  advanceHeightMax: int16,
  minTopSideBearing: int16,
  minBottomSideBearing: int16,
  yMaxExtent: int16,
  caretSlopeRise: int16,
  caretSlopeRun: int16,
  caretOffset: int16,
  reserved: new Reserved(int16, 4),
  metricDataFormat: int16,
  numberOfMetrics: uint16
  // Number of advance heights in the Vertical Metrics table
});
var $344073dd270f0e62$var$VmtxEntry = new Struct({
  advance: uint16,
  bearing: int16
  // The top sidebearing of the glyph
});
var $344073dd270f0e62$export$2e2bcd8739ae039 = new Struct({
  metrics: new LazyArray($344073dd270f0e62$var$VmtxEntry, (t4) => t4.parent.vhea.numberOfMetrics),
  bearings: new LazyArray(int16, (t4) => t4.parent.maxp.numGlyphs - t4.parent.vhea.numberOfMetrics)
});
var $3793b781918cfced$var$shortFrac = new Fixed(16, "BE", 14);
var $3793b781918cfced$var$Correspondence = new Struct({
  fromCoord: $3793b781918cfced$var$shortFrac,
  toCoord: $3793b781918cfced$var$shortFrac
});
var $3793b781918cfced$var$Segment = new Struct({
  pairCount: uint16,
  correspondence: new ArrayT($3793b781918cfced$var$Correspondence, "pairCount")
});
var $3793b781918cfced$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  axisCount: uint32,
  segment: new ArrayT($3793b781918cfced$var$Segment, "axisCount")
});
var $6cb7dd5f47d82580$var$UnboundedArrayAccessor = class {
  static {
    __name(this, "$6cb7dd5f47d82580$var$UnboundedArrayAccessor");
  }
  getItem(index2) {
    if (this._items[index2] == null) {
      let pos = this.stream.pos;
      this.stream.pos = this.base + this.type.size(null, this.parent) * index2;
      this._items[index2] = this.type.decode(this.stream, this.parent);
      this.stream.pos = pos;
    }
    return this._items[index2];
  }
  inspect() {
    return `[UnboundedArray ${this.type.constructor.name}]`;
  }
  constructor(type2, stream2, parent) {
    this.type = type2;
    this.stream = stream2;
    this.parent = parent;
    this.base = this.stream.pos;
    this._items = [];
  }
};
var $6cb7dd5f47d82580$export$c5af1eebc882e39a = class extends ArrayT {
  static {
    __name(this, "$6cb7dd5f47d82580$export$c5af1eebc882e39a");
  }
  decode(stream2, parent) {
    return new $6cb7dd5f47d82580$var$UnboundedArrayAccessor(this.type, stream2, parent);
  }
  constructor(type2) {
    super(type2, 0);
  }
};
var $6cb7dd5f47d82580$export$8351f8c2ae2f103c = /* @__PURE__ */ __name(function(ValueType = uint16) {
  class Shadow {
    static {
      __name(this, "Shadow");
    }
    decode(stream2, ctx) {
      ctx = ctx.parent.parent;
      return this.type.decode(stream2, ctx);
    }
    size(val, ctx) {
      ctx = ctx.parent.parent;
      return this.type.size(val, ctx);
    }
    encode(stream2, val, ctx) {
      ctx = ctx.parent.parent;
      return this.type.encode(stream2, val, ctx);
    }
    constructor(type2) {
      this.type = type2;
    }
  }
  ValueType = new Shadow(ValueType);
  let BinarySearchHeader = new Struct({
    unitSize: uint16,
    nUnits: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16
  });
  let LookupSegmentSingle = new Struct({
    lastGlyph: uint16,
    firstGlyph: uint16,
    value: ValueType
  });
  let LookupSegmentArray = new Struct({
    lastGlyph: uint16,
    firstGlyph: uint16,
    values: new Pointer(uint16, new ArrayT(ValueType, (t4) => t4.lastGlyph - t4.firstGlyph + 1), {
      type: "parent"
    })
  });
  let LookupSingle = new Struct({
    glyph: uint16,
    value: ValueType
  });
  return new VersionedStruct(uint16, {
    0: {
      values: new $6cb7dd5f47d82580$export$c5af1eebc882e39a(ValueType)
      // length == number of glyphs maybe?
    },
    2: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSegmentSingle, (t4) => t4.binarySearchHeader.nUnits)
    },
    4: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSegmentArray, (t4) => t4.binarySearchHeader.nUnits)
    },
    6: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSingle, (t4) => t4.binarySearchHeader.nUnits)
    },
    8: {
      firstGlyph: uint16,
      count: uint16,
      values: new ArrayT(ValueType, "count")
    }
  });
}, "$6cb7dd5f47d82580$export$8351f8c2ae2f103c");
function $6cb7dd5f47d82580$export$79f7d93d790934ba(entryData = {}, lookupType = uint16) {
  let entry = Object.assign({
    newState: uint16,
    flags: uint16
  }, entryData);
  let Entry = new Struct(entry);
  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint16, (t4) => t4.nClasses));
  let StateHeader = new Struct({
    nClasses: uint32,
    classTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$8351f8c2ae2f103c(lookupType)),
    stateArray: new Pointer(uint32, StateArray),
    entryTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
  });
  return StateHeader;
}
__name($6cb7dd5f47d82580$export$79f7d93d790934ba, "$6cb7dd5f47d82580$export$79f7d93d790934ba");
function $6cb7dd5f47d82580$export$105027425199cc51(entryData = {}, lookupType = uint16) {
  let ClassLookupTable = new Struct({
    version() {
      return 8;
    },
    firstGlyph: uint16,
    values: new ArrayT(uint8, uint16)
  });
  let entry = Object.assign({
    newStateOffset: uint16,
    // convert offset to stateArray index
    newState: /* @__PURE__ */ __name((t4) => (t4.newStateOffset - (t4.parent.stateArray.base - t4.parent._startOffset)) / t4.parent.nClasses, "newState"),
    flags: uint16
  }, entryData);
  let Entry = new Struct(entry);
  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint8, (t4) => t4.nClasses));
  let StateHeader1 = new Struct({
    nClasses: uint16,
    classTable: new Pointer(uint16, ClassLookupTable),
    stateArray: new Pointer(uint16, StateArray),
    entryTable: new Pointer(uint16, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
  });
  return StateHeader1;
}
__name($6cb7dd5f47d82580$export$105027425199cc51, "$6cb7dd5f47d82580$export$105027425199cc51");
var $6a3746e8c708f5a3$var$BslnSubtable = new VersionedStruct("format", {
  0: {
    deltas: new ArrayT(int16, 32)
  },
  1: {
    deltas: new ArrayT(int16, 32),
    mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(uint16)
  },
  2: {
    standardGlyph: uint16,
    controlPoints: new ArrayT(uint16, 32)
  },
  3: {
    standardGlyph: uint16,
    controlPoints: new ArrayT(uint16, 32),
    mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(uint16)
  }
});
var $6a3746e8c708f5a3$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  format: uint16,
  defaultBaseline: uint16,
  subtable: $6a3746e8c708f5a3$var$BslnSubtable
});
var $d0c76fac617b308a$var$Setting = new Struct({
  setting: uint16,
  nameIndex: int16,
  name: /* @__PURE__ */ __name((t4) => t4.parent.parent.parent.name.records.fontFeatures[t4.nameIndex], "name")
});
var $d0c76fac617b308a$var$FeatureName = new Struct({
  feature: uint16,
  nSettings: uint16,
  settingTable: new Pointer(uint32, new ArrayT($d0c76fac617b308a$var$Setting, "nSettings"), {
    type: "parent"
  }),
  featureFlags: new Bitfield(uint8, [
    null,
    null,
    null,
    null,
    null,
    null,
    "hasDefault",
    "exclusive"
  ]),
  defaultSetting: uint8,
  nameIndex: int16,
  name: /* @__PURE__ */ __name((t4) => t4.parent.parent.name.records.fontFeatures[t4.nameIndex], "name")
});
var $d0c76fac617b308a$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  featureNameCount: uint16,
  reserved1: new Reserved(uint16),
  reserved2: new Reserved(uint32),
  featureNames: new ArrayT($d0c76fac617b308a$var$FeatureName, "featureNameCount")
});
var $e83fd065f00fcd01$var$Axis = new Struct({
  axisTag: new StringT(4),
  minValue: fixed32,
  defaultValue: fixed32,
  maxValue: fixed32,
  flags: uint16,
  nameID: uint16,
  name: /* @__PURE__ */ __name((t4) => t4.parent.parent.name.records.fontFeatures[t4.nameID], "name")
});
var $e83fd065f00fcd01$var$Instance = new Struct({
  nameID: uint16,
  name: /* @__PURE__ */ __name((t4) => t4.parent.parent.name.records.fontFeatures[t4.nameID], "name"),
  flags: uint16,
  coord: new ArrayT(fixed32, (t4) => t4.parent.axisCount),
  postscriptNameID: new Optional(uint16, (t4) => t4.parent.instanceSize - t4._currentOffset > 0)
});
var $e83fd065f00fcd01$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  offsetToData: uint16,
  countSizePairs: uint16,
  axisCount: uint16,
  axisSize: uint16,
  instanceCount: uint16,
  instanceSize: uint16,
  axis: new ArrayT($e83fd065f00fcd01$var$Axis, "axisCount"),
  instance: new ArrayT($e83fd065f00fcd01$var$Instance, "instanceCount")
});
var $dbe33c8d3a7f131c$var$shortFrac = new Fixed(16, "BE", 14);
var $dbe33c8d3a7f131c$var$Offset = class {
  static {
    __name(this, "$dbe33c8d3a7f131c$var$Offset");
  }
  static decode(stream2, parent) {
    return parent.flags ? stream2.readUInt32BE() : stream2.readUInt16BE() * 2;
  }
};
var $dbe33c8d3a7f131c$var$gvar = new Struct({
  version: uint16,
  reserved: new Reserved(uint16),
  axisCount: uint16,
  globalCoordCount: uint16,
  globalCoords: new Pointer(uint32, new ArrayT(new ArrayT($dbe33c8d3a7f131c$var$shortFrac, "axisCount"), "globalCoordCount")),
  glyphCount: uint16,
  flags: uint16,
  offsetToData: uint32,
  offsets: new ArrayT(new Pointer($dbe33c8d3a7f131c$var$Offset, "void", {
    relativeTo: /* @__PURE__ */ __name((ctx) => ctx.offsetToData, "relativeTo"),
    allowNull: false
  }), (t4) => t4.glyphCount + 1)
});
var $dbe33c8d3a7f131c$export$2e2bcd8739ae039 = $dbe33c8d3a7f131c$var$gvar;
var $05b01887df96c4ee$var$ClassTable = new Struct({
  length: uint16,
  coverage: uint16,
  subFeatureFlags: uint32,
  stateTable: new (0, $6cb7dd5f47d82580$export$105027425199cc51)()
});
var $05b01887df96c4ee$var$WidthDeltaRecord = new Struct({
  justClass: uint32,
  beforeGrowLimit: fixed32,
  beforeShrinkLimit: fixed32,
  afterGrowLimit: fixed32,
  afterShrinkLimit: fixed32,
  growFlags: uint16,
  shrinkFlags: uint16
});
var $05b01887df96c4ee$var$WidthDeltaCluster = new ArrayT($05b01887df96c4ee$var$WidthDeltaRecord, uint32);
var $05b01887df96c4ee$var$ActionData = new VersionedStruct("actionType", {
  0: {
    lowerLimit: fixed32,
    upperLimit: fixed32,
    order: uint16,
    glyphs: new ArrayT(uint16, uint16)
  },
  1: {
    addGlyph: uint16
  },
  2: {
    substThreshold: fixed32,
    addGlyph: uint16,
    substGlyph: uint16
  },
  3: {},
  4: {
    variationAxis: uint32,
    minimumLimit: fixed32,
    noStretchValue: fixed32,
    maximumLimit: fixed32
  },
  5: {
    flags: uint16,
    glyph: uint16
  }
});
var $05b01887df96c4ee$var$Action = new Struct({
  actionClass: uint16,
  actionType: uint16,
  actionLength: uint32,
  actionData: $05b01887df96c4ee$var$ActionData,
  padding: new Reserved(uint8, (t4) => t4.actionLength - t4._currentOffset)
});
var $05b01887df96c4ee$var$PostcompensationAction = new ArrayT($05b01887df96c4ee$var$Action, uint32);
var $05b01887df96c4ee$var$PostCompensationTable = new Struct({
  lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new Pointer(uint16, $05b01887df96c4ee$var$PostcompensationAction))
});
var $05b01887df96c4ee$var$JustificationTable = new Struct({
  classTable: new Pointer(uint16, $05b01887df96c4ee$var$ClassTable, {
    type: "parent"
  }),
  wdcOffset: uint16,
  postCompensationTable: new Pointer(uint16, $05b01887df96c4ee$var$PostCompensationTable, {
    type: "parent"
  }),
  widthDeltaClusters: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new Pointer(uint16, $05b01887df96c4ee$var$WidthDeltaCluster, {
    type: "parent",
    relativeTo: /* @__PURE__ */ __name((ctx) => ctx.wdcOffset, "relativeTo")
  }))
});
var $05b01887df96c4ee$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  format: uint16,
  horizontal: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable),
  vertical: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable)
});
var $03ee6ebd54db1053$var$LigatureData = {
  action: uint16
};
var $03ee6ebd54db1053$var$ContextualData = {
  markIndex: uint16,
  currentIndex: uint16
};
var $03ee6ebd54db1053$var$InsertionData = {
  currentInsertIndex: uint16,
  markedInsertIndex: uint16
};
var $03ee6ebd54db1053$var$SubstitutionTable = new Struct({
  items: new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()))
});
var $03ee6ebd54db1053$var$SubtableData = new VersionedStruct("type", {
  0: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)()
  },
  1: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$ContextualData),
    substitutionTable: new Pointer(uint32, $03ee6ebd54db1053$var$SubstitutionTable)
  },
  2: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$LigatureData),
    ligatureActions: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint32)),
    components: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16)),
    ligatureList: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16))
  },
  4: {
    lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()
  },
  5: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$InsertionData),
    insertionActions: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16))
  }
});
var $03ee6ebd54db1053$var$Subtable = new Struct({
  length: uint32,
  coverage: uint24,
  type: uint8,
  subFeatureFlags: uint32,
  table: $03ee6ebd54db1053$var$SubtableData,
  padding: new Reserved(uint8, (t4) => t4.length - t4._currentOffset)
});
var $03ee6ebd54db1053$var$FeatureEntry = new Struct({
  featureType: uint16,
  featureSetting: uint16,
  enableFlags: uint32,
  disableFlags: uint32
});
var $03ee6ebd54db1053$var$MorxChain = new Struct({
  defaultFlags: uint32,
  chainLength: uint32,
  nFeatureEntries: uint32,
  nSubtables: uint32,
  features: new ArrayT($03ee6ebd54db1053$var$FeatureEntry, "nFeatureEntries"),
  subtables: new ArrayT($03ee6ebd54db1053$var$Subtable, "nSubtables")
});
var $03ee6ebd54db1053$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  unused: new Reserved(uint16),
  nChains: uint32,
  chains: new ArrayT($03ee6ebd54db1053$var$MorxChain, "nChains")
});
var $b7492a80b0d1a056$var$OpticalBounds = new Struct({
  left: int16,
  top: int16,
  right: int16,
  bottom: int16
});
var $b7492a80b0d1a056$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  format: uint16,
  lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)($b7492a80b0d1a056$var$OpticalBounds)
});
var $c3395722bea751e2$var$tables = {};
var $c3395722bea751e2$export$2e2bcd8739ae039 = $c3395722bea751e2$var$tables;
$c3395722bea751e2$var$tables.cmap = (0, $26a62205ad06574e$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.head = (0, $f2612a29f92ac062$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hhea = (0, $2c179dd593583073$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hmtx = (0, $bdc9060542264b85$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.maxp = (0, $dbf51cb3d3fe409d$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.name = (0, $2bcf221753ec8e32$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["OS/2"] = (0, $84b272aa31b70606$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.post = (0, $32d9e2eb9565d93c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.fpgm = (0, $5c0f37ca5ffb1850$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.loca = (0, $2b2b260902b1c57e$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.prep = (0, $7afb878c7bea4f66$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["cvt "] = (0, $5202bd9d9ad8eaac$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.glyf = (0, $6c92b6371bce8bd9$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["CFF "] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["CFF2"] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.VORG = (0, $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.EBLC = (0, $9911c4c7201c13de$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.CBLC = $c3395722bea751e2$var$tables.EBLC;
$c3395722bea751e2$var$tables.sbix = (0, $abb847051efd51b1$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.COLR = (0, $eb629188f3dfefdd$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.CPAL = (0, $08734b8e7dc64587$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.BASE = (0, $497cef411d884e34$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GDEF = (0, $cf5f33c63ef209e6$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GPOS = (0, $47e0e8ef515d9903$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GSUB = (0, $d3f442064af66e06$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.JSTF = (0, $71cfb3c4767fbd0c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.HVAR = (0, $d059a6bd2d3b5b63$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.DSIG = (0, $dceeca3e1977ce30$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.gasp = (0, $8acd740a9435aad0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hdmx = (0, $b5f380243c34d6a0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.kern = (0, $ca2df1256966e313$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.LTSH = (0, $7a9f92b0c46ebe33$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.PCLT = (0, $2b2ccc419d152631$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.VDMX = (0, $ca5b40b9bcda9c9b$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.vhea = (0, $69530a3c40755af0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.vmtx = (0, $344073dd270f0e62$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.avar = (0, $3793b781918cfced$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.bsln = (0, $6a3746e8c708f5a3$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.feat = (0, $d0c76fac617b308a$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.fvar = (0, $e83fd065f00fcd01$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.gvar = (0, $dbe33c8d3a7f131c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.just = (0, $05b01887df96c4ee$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.morx = (0, $03ee6ebd54db1053$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.opbd = (0, $b7492a80b0d1a056$export$2e2bcd8739ae039);
var $816c07a04b6dba87$var$TableEntry = new Struct({
  tag: new StringT(4),
  checkSum: uint32,
  offset: new Pointer(uint32, "void", {
    type: "global"
  }),
  length: uint32
});
var $816c07a04b6dba87$var$Directory = new Struct({
  tag: new StringT(4),
  numTables: uint16,
  searchRange: uint16,
  entrySelector: uint16,
  rangeShift: uint16,
  tables: new ArrayT($816c07a04b6dba87$var$TableEntry, "numTables")
});
$816c07a04b6dba87$var$Directory.process = function() {
  let tables = {};
  for (let table3 of this.tables) tables[table3.tag] = table3;
  this.tables = tables;
};
$816c07a04b6dba87$var$Directory.preEncode = function() {
  if (!Array.isArray(this.tables)) {
    let tables = [];
    for (let tag in this.tables) {
      let table3 = this.tables[tag];
      if (table3) tables.push({
        tag,
        checkSum: 0,
        offset: new VoidPointer((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag], table3),
        length: (0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag].size(table3)
      });
    }
    this.tables = tables;
  }
  this.tag = "true";
  this.numTables = this.tables.length;
  let maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);
  let maxPowerOf2 = Math.pow(2, maxExponentFor2);
  this.searchRange = maxPowerOf2 * 16;
  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;
  this.rangeShift = this.numTables * 16 - this.searchRange;
};
var $816c07a04b6dba87$export$2e2bcd8739ae039 = $816c07a04b6dba87$var$Directory;
function $12727730ddfc8bfe$export$2e0ae67339d5f1ac(arr, cmp) {
  let min2 = 0;
  let max2 = arr.length - 1;
  while (min2 <= max2) {
    let mid = min2 + max2 >> 1;
    let res = cmp(arr[mid]);
    if (res < 0) max2 = mid - 1;
    else if (res > 0) min2 = mid + 1;
    else return mid;
  }
  return -1;
}
__name($12727730ddfc8bfe$export$2e0ae67339d5f1ac, "$12727730ddfc8bfe$export$2e0ae67339d5f1ac");
function $12727730ddfc8bfe$export$d02631cccf789723(index2, end2) {
  let range2 = [];
  while (index2 < end2) range2.push(index2++);
  return range2;
}
__name($12727730ddfc8bfe$export$d02631cccf789723, "$12727730ddfc8bfe$export$d02631cccf789723");
var $12727730ddfc8bfe$export$3d28c1996ced1f14 = new TextDecoder("ascii");
var $12727730ddfc8bfe$var$CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var $12727730ddfc8bfe$var$LOOKUP = new Uint8Array(256);
for (let i2 = 0; i2 < $12727730ddfc8bfe$var$CHARS.length; i2++) $12727730ddfc8bfe$var$LOOKUP[$12727730ddfc8bfe$var$CHARS.charCodeAt(i2)] = i2;
function $12727730ddfc8bfe$export$94fdf11bafc8de6b(base64) {
  let bufferLength = base64.length * 0.75;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") bufferLength--;
  }
  let bytes = new Uint8Array(bufferLength);
  let p3 = 0;
  for (let i2 = 0, len = base64.length; i2 < len; i2 += 4) {
    let encoded1 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i2)];
    let encoded2 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i2 + 1)];
    let encoded3 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i2 + 2)];
    let encoded4 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i2 + 3)];
    bytes[p3++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p3++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p3++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes;
}
__name($12727730ddfc8bfe$export$94fdf11bafc8de6b, "$12727730ddfc8bfe$export$94fdf11bafc8de6b");
var $f08dd41ef10b694c$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$f08dd41ef10b694c$export$2e2bcd8739ae039");
  }
  findSubtable(cmapTable, pairs2) {
    for (let [platformID, encodingID] of pairs2) for (let cmap of cmapTable.tables) {
      if (cmap.platformID === platformID && cmap.encodingID === encodingID) return cmap.table;
    }
    return null;
  }
  lookup(codepoint, variationSelector) {
    if (this.encoding) codepoint = this.encoding.get(codepoint) || codepoint;
    else if (variationSelector) {
      let gid = this.getVariationSelector(codepoint, variationSelector);
      if (gid) return gid;
    }
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0:
        return cmap.codeMap.get(codepoint) || 0;
      case 4: {
        let min2 = 0;
        let max2 = cmap.segCount - 1;
        while (min2 <= max2) {
          let mid = min2 + max2 >> 1;
          if (codepoint < cmap.startCode.get(mid)) max2 = mid - 1;
          else if (codepoint > cmap.endCode.get(mid)) min2 = mid + 1;
          else {
            let rangeOffset = cmap.idRangeOffset.get(mid);
            let gid;
            if (rangeOffset === 0) gid = codepoint + cmap.idDelta.get(mid);
            else {
              let index2 = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);
              gid = cmap.glyphIndexArray.get(index2) || 0;
              if (gid !== 0) gid += cmap.idDelta.get(mid);
            }
            return gid & 65535;
          }
        }
        return 0;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;
      case 12:
      case 13: {
        let min2 = 0;
        let max2 = cmap.nGroups - 1;
        while (min2 <= max2) {
          let mid = min2 + max2 >> 1;
          let group3 = cmap.groups.get(mid);
          if (codepoint < group3.startCharCode) max2 = mid - 1;
          else if (codepoint > group3.endCharCode) min2 = mid + 1;
          else {
            if (cmap.version === 12) return group3.glyphID + (codepoint - group3.startCharCode);
            else return group3.glyphID;
          }
        }
        return 0;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  getVariationSelector(codepoint, variationSelector) {
    if (!this.uvs) return 0;
    let selectors = this.uvs.varSelectors.toArray();
    let i2 = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(selectors, (x) => variationSelector - x.varSelector);
    let sel = selectors[i2];
    if (i2 !== -1 && sel.defaultUVS) i2 = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.defaultUVS, (x) => codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? 1 : 0);
    if (i2 !== -1 && sel.nonDefaultUVS) {
      i2 = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.nonDefaultUVS, (x) => codepoint - x.unicodeValue);
      if (i2 !== -1) return sel.nonDefaultUVS[i2].glyphID;
    }
    return 0;
  }
  getCharacterSet() {
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0:
        return (0, $12727730ddfc8bfe$export$d02631cccf789723)(0, cmap.codeMap.length);
      case 4: {
        let res = [];
        let endCodes = cmap.endCode.toArray();
        for (let i2 = 0; i2 < endCodes.length; i2++) {
          let tail = endCodes[i2] + 1;
          let start2 = cmap.startCode.get(i2);
          res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(start2, tail));
        }
        return res;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return (0, $12727730ddfc8bfe$export$d02631cccf789723)(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);
      case 12:
      case 13: {
        let res = [];
        for (let group3 of cmap.groups.toArray()) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group3.startCharCode, group3.endCharCode + 1));
        return res;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  codePointsForGlyph(gid) {
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0: {
        let res = [];
        for (let i2 = 0; i2 < 256; i2++) if (cmap.codeMap.get(i2) === gid) res.push(i2);
        return res;
      }
      case 4: {
        let res = [];
        for (let i2 = 0; i2 < cmap.segCount; i2++) {
          let end2 = cmap.endCode.get(i2);
          let start2 = cmap.startCode.get(i2);
          let rangeOffset = cmap.idRangeOffset.get(i2);
          let delta = cmap.idDelta.get(i2);
          for (var c2 = start2; c2 <= end2; c2++) {
            let g = 0;
            if (rangeOffset === 0) g = c2 + delta;
            else {
              let index2 = rangeOffset / 2 + (c2 - start2) - (cmap.segCount - i2);
              g = cmap.glyphIndexArray.get(index2) || 0;
              if (g !== 0) g += delta;
            }
            if (g === gid) res.push(c2);
          }
        }
        return res;
      }
      case 12: {
        let res = [];
        for (let group3 of cmap.groups.toArray()) if (gid >= group3.glyphID && gid <= group3.glyphID + (group3.endCharCode - group3.startCharCode)) res.push(group3.startCharCode + (gid - group3.glyphID));
        return res;
      }
      case 13: {
        let res = [];
        for (let group3 of cmap.groups.toArray()) if (gid === group3.glyphID) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group3.startCharCode, group3.endCharCode + 1));
        return res;
      }
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  constructor(cmapTable) {
    this.encoding = null;
    this.cmap = this.findSubtable(cmapTable, [
      // 32-bit subtables
      [
        3,
        10
      ],
      [
        0,
        6
      ],
      [
        0,
        4
      ],
      // 16-bit subtables
      [
        3,
        1
      ],
      [
        0,
        3
      ],
      [
        0,
        2
      ],
      [
        0,
        1
      ],
      [
        0,
        0
      ]
    ]);
    if (!this.cmap) for (let cmap of cmapTable.tables) {
      let encoding = (0, $e449ad78d50845fe$export$badc544e0651b6b1)(cmap.platformID, cmap.encodingID, cmap.table.language - 1);
      let mapping = (0, $e449ad78d50845fe$export$1dceb3c14ed68bee)(encoding);
      if (mapping) {
        this.cmap = cmap.table;
        this.encoding = mapping;
      }
    }
    if (!this.cmap) throw new Error("Could not find a supported cmap table");
    this.uvs = this.findSubtable(cmapTable, [
      [
        0,
        5
      ]
    ]);
    if (this.uvs && this.uvs.version !== 14) this.uvs = null;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "getCharacterSet", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "codePointsForGlyph", null);
var $0bba3a9db57637f3$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$0bba3a9db57637f3$export$2e2bcd8739ae039");
  }
  process(glyphs, positions) {
    for (let glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {
      let left = glyphs[glyphIndex].id;
      let right = glyphs[glyphIndex + 1].id;
      positions[glyphIndex].xAdvance += this.getKerning(left, right);
    }
  }
  getKerning(left, right) {
    let res = 0;
    for (let table3 of this.kern.tables) {
      if (table3.coverage.crossStream) continue;
      switch (table3.version) {
        case 0:
          if (!table3.coverage.horizontal) continue;
          break;
        case 1:
          if (table3.coverage.vertical || table3.coverage.variation) continue;
          break;
        default:
          throw new Error(`Unsupported kerning table version ${table3.version}`);
      }
      let val = 0;
      let s4 = table3.subtable;
      switch (table3.format) {
        case 0:
          let pairIdx = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(s4.pairs, function(pair) {
            return left - pair.left || right - pair.right;
          });
          if (pairIdx >= 0) val = s4.pairs[pairIdx].value;
          break;
        case 2:
          let leftOffset = 0, rightOffset = 0;
          if (left >= s4.leftTable.firstGlyph && left < s4.leftTable.firstGlyph + s4.leftTable.nGlyphs) leftOffset = s4.leftTable.offsets[left - s4.leftTable.firstGlyph];
          else leftOffset = s4.array.off;
          if (right >= s4.rightTable.firstGlyph && right < s4.rightTable.firstGlyph + s4.rightTable.nGlyphs) rightOffset = s4.rightTable.offsets[right - s4.rightTable.firstGlyph];
          let index2 = (leftOffset + rightOffset - s4.array.off) / 2;
          val = s4.array.values.get(index2);
          break;
        case 3:
          if (left >= s4.glyphCount || right >= s4.glyphCount) return 0;
          val = s4.kernValue[s4.kernIndex[s4.leftClass[left] * s4.rightClassCount + s4.rightClass[right]]];
          break;
        default:
          throw new Error(`Unsupported kerning sub-table format ${table3.format}`);
      }
      if (table3.coverage.override) res = val;
      else res += val;
    }
    return res;
  }
  constructor(font) {
    this.kern = font.kern;
  }
};
var $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039");
  }
  positionGlyphs(glyphs, positions) {
    let clusterStart = 0;
    let clusterEnd = 0;
    for (let index2 = 0; index2 < glyphs.length; index2++) {
      let glyph = glyphs[index2];
      if (glyph.isMark) clusterEnd = index2;
      else {
        if (clusterStart !== clusterEnd) this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
        clusterStart = clusterEnd = index2;
      }
    }
    if (clusterStart !== clusterEnd) this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
    return positions;
  }
  positionCluster(glyphs, positions, clusterStart, clusterEnd) {
    let base = glyphs[clusterStart];
    let baseBox = base.cbox.copy();
    if (base.codePoints.length > 1)
      baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
    let xOffset = -positions[clusterStart].xAdvance;
    let yOffset = 0;
    let yGap = this.font.unitsPerEm / 16;
    for (let index2 = clusterStart + 1; index2 <= clusterEnd; index2++) {
      let mark = glyphs[index2];
      let markBox = mark.cbox;
      let position = positions[index2];
      let combiningClass = this.getCombiningClass(mark.codePoints[0]);
      if (combiningClass !== "Not_Reordered") {
        position.xOffset = position.yOffset = 0;
        switch (combiningClass) {
          case "Double_Above":
          case "Double_Below":
            position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
            break;
          case "Attached_Below_Left":
          case "Below_Left":
          case "Above_Left":
            position.xOffset += baseBox.minX - markBox.minX;
            break;
          case "Attached_Above_Right":
          case "Below_Right":
          case "Above_Right":
            position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
            break;
          default:
            position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
        }
        switch (combiningClass) {
          case "Double_Below":
          case "Below_Left":
          case "Below":
          case "Below_Right":
          case "Attached_Below_Left":
          case "Attached_Below":
            if (combiningClass === "Attached_Below_Left" || combiningClass === "Attached_Below") baseBox.minY += yGap;
            position.yOffset = -baseBox.minY - markBox.maxY;
            baseBox.minY += markBox.height;
            break;
          case "Double_Above":
          case "Above_Left":
          case "Above":
          case "Above_Right":
          case "Attached_Above":
          case "Attached_Above_Right":
            if (combiningClass === "Attached_Above" || combiningClass === "Attached_Above_Right") baseBox.maxY += yGap;
            position.yOffset = baseBox.maxY - markBox.minY;
            baseBox.maxY += markBox.height;
            break;
        }
        position.xAdvance = position.yAdvance = 0;
        position.xOffset += xOffset;
        position.yOffset += yOffset;
      } else {
        xOffset -= position.xAdvance;
        yOffset -= position.yAdvance;
      }
    }
    return;
  }
  getCombiningClass(codePoint) {
    let combiningClass = (0, $747425b437e121da$export$c03b919c6651ed55)(codePoint);
    if ((codePoint & -256) === 3584) {
      if (combiningClass === "Not_Reordered") switch (codePoint) {
        case 3633:
        case 3636:
        case 3637:
        case 3638:
        case 3639:
        case 3655:
        case 3660:
        case 3645:
        case 3662:
          return "Above_Right";
        case 3761:
        case 3764:
        case 3765:
        case 3766:
        case 3767:
        case 3771:
        case 3788:
        case 3789:
          return "Above";
        case 3772:
          return "Below";
      }
      else if (codePoint === 3642) return "Below_Right";
    }
    switch (combiningClass) {
      // Hebrew
      case "CCC10":
      case "CCC11":
      case "CCC12":
      case "CCC13":
      case "CCC14":
      case "CCC15":
      case "CCC16":
      case "CCC17":
      case "CCC18":
      case "CCC20":
      case "CCC22":
        return "Below";
      case "CCC23":
        return "Attached_Above";
      case "CCC24":
        return "Above_Right";
      case "CCC25":
      case "CCC19":
        return "Above_Left";
      case "CCC26":
        return "Above";
      case "CCC21":
        break;
      // Arabic and Syriac
      case "CCC27":
      case "CCC28":
      case "CCC30":
      case "CCC31":
      case "CCC33":
      case "CCC34":
      case "CCC35":
      case "CCC36":
        return "Above";
      case "CCC29":
      case "CCC32":
        return "Below";
      // Thai
      case "CCC103":
        return "Below_Right";
      case "CCC107":
        return "Above_Right";
      // Lao
      case "CCC118":
        return "Below";
      case "CCC122":
        return "Above";
      // Tibetan
      case "CCC129":
      case "CCC132":
        return "Below";
      case "CCC130":
        return "Above";
    }
    return combiningClass;
  }
  constructor(font) {
    this.font = font;
  }
};
var $f34600ab9d7f70d8$export$2e2bcd8739ae039 = class _$f34600ab9d7f70d8$export$2e2bcd8739ae039 {
  static {
    __name(this, "$f34600ab9d7f70d8$export$2e2bcd8739ae039");
  }
  /**
  * The width of the bounding box
  * @type {number}
  */
  get width() {
    return this.maxX - this.minX;
  }
  /**
  * The height of the bounding box
  * @type {number}
  */
  get height() {
    return this.maxY - this.minY;
  }
  addPoint(x, y3) {
    if (Math.abs(x) !== Infinity) {
      if (x < this.minX) this.minX = x;
      if (x > this.maxX) this.maxX = x;
    }
    if (Math.abs(y3) !== Infinity) {
      if (y3 < this.minY) this.minY = y3;
      if (y3 > this.maxY) this.maxY = y3;
    }
  }
  copy() {
    return new _$f34600ab9d7f70d8$export$2e2bcd8739ae039(this.minX, this.minY, this.maxX, this.maxY);
  }
  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
};
var $130d1a642ebcd2b7$var$UNICODE_SCRIPTS = {
  Caucasian_Albanian: "aghb",
  Arabic: "arab",
  Imperial_Aramaic: "armi",
  Armenian: "armn",
  Avestan: "avst",
  Balinese: "bali",
  Bamum: "bamu",
  Bassa_Vah: "bass",
  Batak: "batk",
  Bengali: [
    "bng2",
    "beng"
  ],
  Bopomofo: "bopo",
  Brahmi: "brah",
  Braille: "brai",
  Buginese: "bugi",
  Buhid: "buhd",
  Chakma: "cakm",
  Canadian_Aboriginal: "cans",
  Carian: "cari",
  Cham: "cham",
  Cherokee: "cher",
  Coptic: "copt",
  Cypriot: "cprt",
  Cyrillic: "cyrl",
  Devanagari: [
    "dev2",
    "deva"
  ],
  Deseret: "dsrt",
  Duployan: "dupl",
  Egyptian_Hieroglyphs: "egyp",
  Elbasan: "elba",
  Ethiopic: "ethi",
  Georgian: "geor",
  Glagolitic: "glag",
  Gothic: "goth",
  Grantha: "gran",
  Greek: "grek",
  Gujarati: [
    "gjr2",
    "gujr"
  ],
  Gurmukhi: [
    "gur2",
    "guru"
  ],
  Hangul: "hang",
  Han: "hani",
  Hanunoo: "hano",
  Hebrew: "hebr",
  Hiragana: "hira",
  Pahawh_Hmong: "hmng",
  Katakana_Or_Hiragana: "hrkt",
  Old_Italic: "ital",
  Javanese: "java",
  Kayah_Li: "kali",
  Katakana: "kana",
  Kharoshthi: "khar",
  Khmer: "khmr",
  Khojki: "khoj",
  Kannada: [
    "knd2",
    "knda"
  ],
  Kaithi: "kthi",
  Tai_Tham: "lana",
  Lao: "lao ",
  Latin: "latn",
  Lepcha: "lepc",
  Limbu: "limb",
  Linear_A: "lina",
  Linear_B: "linb",
  Lisu: "lisu",
  Lycian: "lyci",
  Lydian: "lydi",
  Mahajani: "mahj",
  Mandaic: "mand",
  Manichaean: "mani",
  Mende_Kikakui: "mend",
  Meroitic_Cursive: "merc",
  Meroitic_Hieroglyphs: "mero",
  Malayalam: [
    "mlm2",
    "mlym"
  ],
  Modi: "modi",
  Mongolian: "mong",
  Mro: "mroo",
  Meetei_Mayek: "mtei",
  Myanmar: [
    "mym2",
    "mymr"
  ],
  Old_North_Arabian: "narb",
  Nabataean: "nbat",
  Nko: "nko ",
  Ogham: "ogam",
  Ol_Chiki: "olck",
  Old_Turkic: "orkh",
  Oriya: [
    "ory2",
    "orya"
  ],
  Osmanya: "osma",
  Palmyrene: "palm",
  Pau_Cin_Hau: "pauc",
  Old_Permic: "perm",
  Phags_Pa: "phag",
  Inscriptional_Pahlavi: "phli",
  Psalter_Pahlavi: "phlp",
  Phoenician: "phnx",
  Miao: "plrd",
  Inscriptional_Parthian: "prti",
  Rejang: "rjng",
  Runic: "runr",
  Samaritan: "samr",
  Old_South_Arabian: "sarb",
  Saurashtra: "saur",
  Shavian: "shaw",
  Sharada: "shrd",
  Siddham: "sidd",
  Khudawadi: "sind",
  Sinhala: "sinh",
  Sora_Sompeng: "sora",
  Sundanese: "sund",
  Syloti_Nagri: "sylo",
  Syriac: "syrc",
  Tagbanwa: "tagb",
  Takri: "takr",
  Tai_Le: "tale",
  New_Tai_Lue: "talu",
  Tamil: [
    "tml2",
    "taml"
  ],
  Tai_Viet: "tavt",
  Telugu: [
    "tel2",
    "telu"
  ],
  Tifinagh: "tfng",
  Tagalog: "tglg",
  Thaana: "thaa",
  Thai: "thai",
  Tibetan: "tibt",
  Tirhuta: "tirh",
  Ugaritic: "ugar",
  Vai: "vai ",
  Warang_Citi: "wara",
  Old_Persian: "xpeo",
  Cuneiform: "xsux",
  Yi: "yi  ",
  Inherited: "zinh",
  Common: "zyyy",
  Unknown: "zzzz"
};
var $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS = {};
for (let script in $130d1a642ebcd2b7$var$UNICODE_SCRIPTS) {
  let tag = $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  if (Array.isArray(tag)) for (let t4 of tag) $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[t4] = script;
  else $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag] = script;
}
function $130d1a642ebcd2b7$export$ce50e82f12a827a4(tag) {
  return $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag];
}
__name($130d1a642ebcd2b7$export$ce50e82f12a827a4, "$130d1a642ebcd2b7$export$ce50e82f12a827a4");
function $130d1a642ebcd2b7$export$e5cb25e204fb8450(string) {
  let len = string.length;
  let idx = 0;
  while (idx < len) {
    let code = string.charCodeAt(idx++);
    if (55296 <= code && code <= 56319 && idx < len) {
      let next = string.charCodeAt(idx);
      if (56320 <= next && next <= 57343) {
        idx++;
        code = ((code & 1023) << 10) + (next & 1023) + 65536;
      }
    }
    let script = (0, $747425b437e121da$export$941569448d136665)(code);
    if (script !== "Common" && script !== "Inherited" && script !== "Unknown") return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  }
  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
}
__name($130d1a642ebcd2b7$export$e5cb25e204fb8450, "$130d1a642ebcd2b7$export$e5cb25e204fb8450");
function $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints) {
  for (let i2 = 0; i2 < codePoints.length; i2++) {
    let codePoint = codePoints[i2];
    let script = (0, $747425b437e121da$export$941569448d136665)(codePoint);
    if (script !== "Common" && script !== "Inherited" && script !== "Unknown") return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  }
  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
}
__name($130d1a642ebcd2b7$export$16fab0757cfc223d, "$130d1a642ebcd2b7$export$16fab0757cfc223d");
var $130d1a642ebcd2b7$var$RTL = {
  arab: true,
  hebr: true,
  syrc: true,
  thaa: true,
  cprt: true,
  khar: true,
  phnx: true,
  "nko ": true,
  lydi: true,
  avst: true,
  armi: true,
  phli: true,
  prti: true,
  sarb: true,
  orkh: true,
  samr: true,
  mand: true,
  merc: true,
  mero: true,
  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)
  mani: true,
  mend: true,
  nbat: true,
  narb: true,
  palm: true,
  phlp: true
  // Psalter Pahlavi
};
function $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script) {
  if ($130d1a642ebcd2b7$var$RTL[script]) return "rtl";
  return "ltr";
}
__name($130d1a642ebcd2b7$export$9fddb9d0dd7d8a54, "$130d1a642ebcd2b7$export$9fddb9d0dd7d8a54");
var $be07b3e97a42687a$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$be07b3e97a42687a$export$2e2bcd8739ae039");
  }
  /**
  * The total advance width of the run.
  * @type {number}
  */
  get advanceWidth() {
    let width = 0;
    for (let position of this.positions) width += position.xAdvance;
    return width;
  }
  /**
  * The total advance height of the run.
  * @type {number}
  */
  get advanceHeight() {
    let height2 = 0;
    for (let position of this.positions) height2 += position.yAdvance;
    return height2;
  }
  /**
  * The bounding box containing all glyphs in the run.
  * @type {BBox}
  */
  get bbox() {
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    let x = 0;
    let y3 = 0;
    for (let index2 = 0; index2 < this.glyphs.length; index2++) {
      let glyph = this.glyphs[index2];
      let p3 = this.positions[index2];
      let b3 = glyph.bbox;
      bbox.addPoint(b3.minX + x + p3.xOffset, b3.minY + y3 + p3.yOffset);
      bbox.addPoint(b3.maxX + x + p3.xOffset, b3.maxY + y3 + p3.yOffset);
      x += p3.xAdvance;
      y3 += p3.yAdvance;
    }
    return bbox;
  }
  constructor(glyphs, features2, script, language, direction) {
    this.glyphs = glyphs;
    this.positions = null;
    this.script = script;
    this.language = language || null;
    this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
    this.features = {};
    if (Array.isArray(features2)) for (let tag of features2) this.features[tag] = true;
    else if (typeof features2 === "object") this.features = features2;
  }
};
var $1ac75d9a55b67f01$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$1ac75d9a55b67f01$export$2e2bcd8739ae039");
  }
  constructor(xAdvance = 0, yAdvance = 0, xOffset = 0, yOffset = 0) {
    this.xAdvance = xAdvance;
    this.yAdvance = yAdvance;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
  }
};
var $3b6302b64eccc32c$var$features = {
  allTypographicFeatures: {
    code: 0,
    exclusive: false,
    allTypeFeatures: 0
  },
  ligatures: {
    code: 1,
    exclusive: false,
    requiredLigatures: 0,
    commonLigatures: 2,
    rareLigatures: 4,
    // logos: 6
    rebusPictures: 8,
    diphthongLigatures: 10,
    squaredLigatures: 12,
    abbrevSquaredLigatures: 14,
    symbolLigatures: 16,
    contextualLigatures: 18,
    historicalLigatures: 20
  },
  cursiveConnection: {
    code: 2,
    exclusive: true,
    unconnected: 0,
    partiallyConnected: 1,
    cursive: 2
  },
  letterCase: {
    code: 3,
    exclusive: true
  },
  // upperAndLowerCase: 0          # deprecated
  // allCaps: 1                    # deprecated
  // allLowerCase: 2               # deprecated
  // smallCaps: 3                  # deprecated
  // initialCaps: 4                # deprecated
  // initialCapsAndSmallCaps: 5    # deprecated
  verticalSubstitution: {
    code: 4,
    exclusive: false,
    substituteVerticalForms: 0
  },
  linguisticRearrangement: {
    code: 5,
    exclusive: false,
    linguisticRearrangement: 0
  },
  numberSpacing: {
    code: 6,
    exclusive: true,
    monospacedNumbers: 0,
    proportionalNumbers: 1,
    thirdWidthNumbers: 2,
    quarterWidthNumbers: 3
  },
  smartSwash: {
    code: 8,
    exclusive: false,
    wordInitialSwashes: 0,
    wordFinalSwashes: 2,
    // lineInitialSwashes: 4
    // lineFinalSwashes: 6
    nonFinalSwashes: 8
  },
  diacritics: {
    code: 9,
    exclusive: true,
    showDiacritics: 0,
    hideDiacritics: 1,
    decomposeDiacritics: 2
  },
  verticalPosition: {
    code: 10,
    exclusive: true,
    normalPosition: 0,
    superiors: 1,
    inferiors: 2,
    ordinals: 3,
    scientificInferiors: 4
  },
  fractions: {
    code: 11,
    exclusive: true,
    noFractions: 0,
    verticalFractions: 1,
    diagonalFractions: 2
  },
  overlappingCharacters: {
    code: 13,
    exclusive: false,
    preventOverlap: 0
  },
  typographicExtras: {
    code: 14,
    exclusive: false,
    // hyphensToEmDash: 0
    // hyphenToEnDash: 2
    slashedZero: 4
  },
  // formInterrobang: 6
  // smartQuotes: 8
  // periodsToEllipsis: 10
  mathematicalExtras: {
    code: 15,
    exclusive: false,
    // hyphenToMinus: 0
    // asteristoMultiply: 2
    // slashToDivide: 4
    // inequalityLigatures: 6
    // exponents: 8
    mathematicalGreek: 10
  },
  ornamentSets: {
    code: 16,
    exclusive: true,
    noOrnaments: 0,
    dingbats: 1,
    piCharacters: 2,
    fleurons: 3,
    decorativeBorders: 4,
    internationalSymbols: 5,
    mathSymbols: 6
  },
  characterAlternatives: {
    code: 17,
    exclusive: true,
    noAlternates: 0
  },
  // user defined options
  designComplexity: {
    code: 18,
    exclusive: true,
    designLevel1: 0,
    designLevel2: 1,
    designLevel3: 2,
    designLevel4: 3,
    designLevel5: 4
  },
  styleOptions: {
    code: 19,
    exclusive: true,
    noStyleOptions: 0,
    displayText: 1,
    engravedText: 2,
    illuminatedCaps: 3,
    titlingCaps: 4,
    tallCaps: 5
  },
  characterShape: {
    code: 20,
    exclusive: true,
    traditionalCharacters: 0,
    simplifiedCharacters: 1,
    JIS1978Characters: 2,
    JIS1983Characters: 3,
    JIS1990Characters: 4,
    traditionalAltOne: 5,
    traditionalAltTwo: 6,
    traditionalAltThree: 7,
    traditionalAltFour: 8,
    traditionalAltFive: 9,
    expertCharacters: 10,
    JIS2004Characters: 11,
    hojoCharacters: 12,
    NLCCharacters: 13,
    traditionalNamesCharacters: 14
  },
  numberCase: {
    code: 21,
    exclusive: true,
    lowerCaseNumbers: 0,
    upperCaseNumbers: 1
  },
  textSpacing: {
    code: 22,
    exclusive: true,
    proportionalText: 0,
    monospacedText: 1,
    halfWidthText: 2,
    thirdWidthText: 3,
    quarterWidthText: 4,
    altProportionalText: 5,
    altHalfWidthText: 6
  },
  transliteration: {
    code: 23,
    exclusive: true,
    noTransliteration: 0
  },
  // hanjaToHangul: 1
  // hiraganaToKatakana: 2
  // katakanaToHiragana: 3
  // kanaToRomanization: 4
  // romanizationToHiragana: 5
  // romanizationToKatakana: 6
  // hanjaToHangulAltOne: 7
  // hanjaToHangulAltTwo: 8
  // hanjaToHangulAltThree: 9
  annotation: {
    code: 24,
    exclusive: true,
    noAnnotation: 0,
    boxAnnotation: 1,
    roundedBoxAnnotation: 2,
    circleAnnotation: 3,
    invertedCircleAnnotation: 4,
    parenthesisAnnotation: 5,
    periodAnnotation: 6,
    romanNumeralAnnotation: 7,
    diamondAnnotation: 8,
    invertedBoxAnnotation: 9,
    invertedRoundedBoxAnnotation: 10
  },
  kanaSpacing: {
    code: 25,
    exclusive: true,
    fullWidthKana: 0,
    proportionalKana: 1
  },
  ideographicSpacing: {
    code: 26,
    exclusive: true,
    fullWidthIdeographs: 0,
    proportionalIdeographs: 1,
    halfWidthIdeographs: 2
  },
  unicodeDecomposition: {
    code: 27,
    exclusive: false,
    canonicalComposition: 0,
    compatibilityComposition: 2,
    transcodingComposition: 4
  },
  rubyKana: {
    code: 28,
    exclusive: false,
    // noRubyKana: 0     # deprecated - use rubyKanaOff instead
    // rubyKana: 1     # deprecated - use rubyKanaOn instead
    rubyKana: 2
  },
  CJKSymbolAlternatives: {
    code: 29,
    exclusive: true,
    noCJKSymbolAlternatives: 0,
    CJKSymbolAltOne: 1,
    CJKSymbolAltTwo: 2,
    CJKSymbolAltThree: 3,
    CJKSymbolAltFour: 4,
    CJKSymbolAltFive: 5
  },
  ideographicAlternatives: {
    code: 30,
    exclusive: true,
    noIdeographicAlternatives: 0,
    ideographicAltOne: 1,
    ideographicAltTwo: 2,
    ideographicAltThree: 3,
    ideographicAltFour: 4,
    ideographicAltFive: 5
  },
  CJKVerticalRomanPlacement: {
    code: 31,
    exclusive: true,
    CJKVerticalRomanCentered: 0,
    CJKVerticalRomanHBaseline: 1
  },
  italicCJKRoman: {
    code: 32,
    exclusive: false,
    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead
    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead
    CJKItalicRoman: 2
  },
  caseSensitiveLayout: {
    code: 33,
    exclusive: false,
    caseSensitiveLayout: 0,
    caseSensitiveSpacing: 2
  },
  alternateKana: {
    code: 34,
    exclusive: false,
    alternateHorizKana: 0,
    alternateVertKana: 2
  },
  stylisticAlternatives: {
    code: 35,
    exclusive: false,
    noStylisticAlternates: 0,
    stylisticAltOne: 2,
    stylisticAltTwo: 4,
    stylisticAltThree: 6,
    stylisticAltFour: 8,
    stylisticAltFive: 10,
    stylisticAltSix: 12,
    stylisticAltSeven: 14,
    stylisticAltEight: 16,
    stylisticAltNine: 18,
    stylisticAltTen: 20,
    stylisticAltEleven: 22,
    stylisticAltTwelve: 24,
    stylisticAltThirteen: 26,
    stylisticAltFourteen: 28,
    stylisticAltFifteen: 30,
    stylisticAltSixteen: 32,
    stylisticAltSeventeen: 34,
    stylisticAltEighteen: 36,
    stylisticAltNineteen: 38,
    stylisticAltTwenty: 40
  },
  contextualAlternates: {
    code: 36,
    exclusive: false,
    contextualAlternates: 0,
    swashAlternates: 2,
    contextualSwashAlternates: 4
  },
  lowerCase: {
    code: 37,
    exclusive: true,
    defaultLowerCase: 0,
    lowerCaseSmallCaps: 1,
    lowerCasePetiteCaps: 2
  },
  upperCase: {
    code: 38,
    exclusive: true,
    defaultUpperCase: 0,
    upperCaseSmallCaps: 1,
    upperCasePetiteCaps: 2
  },
  languageTag: {
    code: 39,
    exclusive: true
  },
  CJKRomanSpacing: {
    code: 103,
    exclusive: true,
    halfWidthCJKRoman: 0,
    proportionalCJKRoman: 1,
    defaultCJKRoman: 2,
    fullWidthCJKRoman: 3
  }
};
var $3b6302b64eccc32c$var$feature = /* @__PURE__ */ __name((name, selector) => [
  $3b6302b64eccc32c$var$features[name].code,
  $3b6302b64eccc32c$var$features[name][selector]
], "$3b6302b64eccc32c$var$feature");
var $3b6302b64eccc32c$var$OTMapping = {
  rlig: $3b6302b64eccc32c$var$feature("ligatures", "requiredLigatures"),
  clig: $3b6302b64eccc32c$var$feature("ligatures", "contextualLigatures"),
  dlig: $3b6302b64eccc32c$var$feature("ligatures", "rareLigatures"),
  hlig: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
  liga: $3b6302b64eccc32c$var$feature("ligatures", "commonLigatures"),
  hist: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
  smcp: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCaseSmallCaps"),
  pcap: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCasePetiteCaps"),
  frac: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  dnom: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  numr: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  afrc: $3b6302b64eccc32c$var$feature("fractions", "verticalFractions"),
  // aalt
  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?
  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?
  // unic, vatu, vhal, vjmo, vpal, vrt2
  // dist -> trak table?
  // kern, vkrn -> kern table
  // lfbd + opbd + rtbd -> opbd table?
  // mark, mkmk -> acnt table?
  // locl -> languageTag + ltag table
  case: $3b6302b64eccc32c$var$feature("caseSensitiveLayout", "caseSensitiveLayout"),
  ccmp: $3b6302b64eccc32c$var$feature("unicodeDecomposition", "canonicalComposition"),
  cpct: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  valt: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  swsh: $3b6302b64eccc32c$var$feature("contextualAlternates", "swashAlternates"),
  cswh: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualSwashAlternates"),
  curs: $3b6302b64eccc32c$var$feature("cursiveConnection", "cursive"),
  c2pc: $3b6302b64eccc32c$var$feature("upperCase", "upperCasePetiteCaps"),
  c2sc: $3b6302b64eccc32c$var$feature("upperCase", "upperCaseSmallCaps"),
  init: $3b6302b64eccc32c$var$feature("smartSwash", "wordInitialSwashes"),
  fin2: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  medi: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
  med2: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
  fin3: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  fina: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  pkna: $3b6302b64eccc32c$var$feature("kanaSpacing", "proportionalKana"),
  half: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
  halt: $3b6302b64eccc32c$var$feature("textSpacing", "altHalfWidthText"),
  hkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateHorizKana"),
  vkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateVertKana"),
  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated
  ital: $3b6302b64eccc32c$var$feature("italicCJKRoman", "CJKItalicRoman"),
  lnum: $3b6302b64eccc32c$var$feature("numberCase", "upperCaseNumbers"),
  onum: $3b6302b64eccc32c$var$feature("numberCase", "lowerCaseNumbers"),
  mgrk: $3b6302b64eccc32c$var$feature("mathematicalExtras", "mathematicalGreek"),
  // nalt: not enough info. what type of annotation?
  // ornm: ditto, which ornament style?
  calt: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualAlternates"),
  vrt2: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
  vert: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
  tnum: $3b6302b64eccc32c$var$feature("numberSpacing", "monospacedNumbers"),
  pnum: $3b6302b64eccc32c$var$feature("numberSpacing", "proportionalNumbers"),
  sups: $3b6302b64eccc32c$var$feature("verticalPosition", "superiors"),
  subs: $3b6302b64eccc32c$var$feature("verticalPosition", "inferiors"),
  ordn: $3b6302b64eccc32c$var$feature("verticalPosition", "ordinals"),
  pwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
  hwid: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
  qwid: $3b6302b64eccc32c$var$feature("textSpacing", "quarterWidthText"),
  twid: $3b6302b64eccc32c$var$feature("textSpacing", "thirdWidthText"),
  fwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
  palt: $3b6302b64eccc32c$var$feature("textSpacing", "altProportionalText"),
  trad: $3b6302b64eccc32c$var$feature("characterShape", "traditionalCharacters"),
  smpl: $3b6302b64eccc32c$var$feature("characterShape", "simplifiedCharacters"),
  jp78: $3b6302b64eccc32c$var$feature("characterShape", "JIS1978Characters"),
  jp83: $3b6302b64eccc32c$var$feature("characterShape", "JIS1983Characters"),
  jp90: $3b6302b64eccc32c$var$feature("characterShape", "JIS1990Characters"),
  jp04: $3b6302b64eccc32c$var$feature("characterShape", "JIS2004Characters"),
  expt: $3b6302b64eccc32c$var$feature("characterShape", "expertCharacters"),
  hojo: $3b6302b64eccc32c$var$feature("characterShape", "hojoCharacters"),
  nlck: $3b6302b64eccc32c$var$feature("characterShape", "NLCCharacters"),
  tnam: $3b6302b64eccc32c$var$feature("characterShape", "traditionalNamesCharacters"),
  ruby: $3b6302b64eccc32c$var$feature("rubyKana", "rubyKana"),
  titl: $3b6302b64eccc32c$var$feature("styleOptions", "titlingCaps"),
  zero: $3b6302b64eccc32c$var$feature("typographicExtras", "slashedZero"),
  ss01: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltOne"),
  ss02: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwo"),
  ss03: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThree"),
  ss04: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFour"),
  ss05: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFive"),
  ss06: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSix"),
  ss07: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeven"),
  ss08: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEight"),
  ss09: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNine"),
  ss10: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTen"),
  ss11: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEleven"),
  ss12: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwelve"),
  ss13: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThirteen"),
  ss14: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFourteen"),
  ss15: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFifteen"),
  ss16: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSixteen"),
  ss17: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeventeen"),
  ss18: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEighteen"),
  ss19: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNineteen"),
  ss20: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwenty")
};
for (let i2 = 1; i2 <= 99; i2++) $3b6302b64eccc32c$var$OTMapping[`cv${`00${i2}`.slice(-2)}`] = [
  $3b6302b64eccc32c$var$features.characterAlternatives.code,
  i2
];
var $3b6302b64eccc32c$var$AATMapping = {};
for (let ot in $3b6302b64eccc32c$var$OTMapping) {
  let aat = $3b6302b64eccc32c$var$OTMapping[ot];
  if ($3b6302b64eccc32c$var$AATMapping[aat[0]] == null) $3b6302b64eccc32c$var$AATMapping[aat[0]] = {};
  $3b6302b64eccc32c$var$AATMapping[aat[0]][aat[1]] = ot;
}
function $3b6302b64eccc32c$export$b813f7d2a1677c16(features2) {
  let res = {};
  for (let k3 in features2) {
    let r5;
    if (r5 = $3b6302b64eccc32c$var$OTMapping[k3]) {
      if (res[r5[0]] == null) res[r5[0]] = {};
      res[r5[0]][r5[1]] = features2[k3];
    }
  }
  return res;
}
__name($3b6302b64eccc32c$export$b813f7d2a1677c16, "$3b6302b64eccc32c$export$b813f7d2a1677c16");
function $3b6302b64eccc32c$var$mapFeatureStrings(f4) {
  let [type2, setting] = f4;
  if (isNaN(type2)) var typeCode = $3b6302b64eccc32c$var$features[type2] && $3b6302b64eccc32c$var$features[type2].code;
  else var typeCode = type2;
  if (isNaN(setting)) var settingCode = $3b6302b64eccc32c$var$features[type2] && $3b6302b64eccc32c$var$features[type2][setting];
  else var settingCode = setting;
  return [
    typeCode,
    settingCode
  ];
}
__name($3b6302b64eccc32c$var$mapFeatureStrings, "$3b6302b64eccc32c$var$mapFeatureStrings");
function $3b6302b64eccc32c$export$bd6df347a4f391c4(features2) {
  let res = {};
  if (Array.isArray(features2)) for (let k3 = 0; k3 < features2.length; k3++) {
    let r5;
    let f4 = $3b6302b64eccc32c$var$mapFeatureStrings(features2[k3]);
    if (r5 = $3b6302b64eccc32c$var$AATMapping[f4[0]] && $3b6302b64eccc32c$var$AATMapping[f4[0]][f4[1]]) res[r5] = true;
  }
  else if (typeof features2 === "object") for (let type2 in features2) {
    let feature = features2[type2];
    for (let setting in feature) {
      let r5;
      let f4 = $3b6302b64eccc32c$var$mapFeatureStrings([
        type2,
        setting
      ]);
      if (feature[setting] && (r5 = $3b6302b64eccc32c$var$AATMapping[f4[0]] && $3b6302b64eccc32c$var$AATMapping[f4[0]][f4[1]])) res[r5] = true;
    }
  }
  return Object.keys(res);
}
__name($3b6302b64eccc32c$export$bd6df347a4f391c4, "$3b6302b64eccc32c$export$bd6df347a4f391c4");
var $ff5ce077dae0f144$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$ff5ce077dae0f144$export$2e2bcd8739ae039");
  }
  lookup(glyph) {
    switch (this.table.version) {
      case 0:
        return this.table.values.getItem(glyph);
      case 2:
      case 4: {
        let min2 = 0;
        let max2 = this.table.binarySearchHeader.nUnits - 1;
        while (min2 <= max2) {
          var mid = min2 + max2 >> 1;
          var seg = this.table.segments[mid];
          if (seg.firstGlyph === 65535) return null;
          if (glyph < seg.firstGlyph) max2 = mid - 1;
          else if (glyph > seg.lastGlyph) min2 = mid + 1;
          else {
            if (this.table.version === 2) return seg.value;
            else return seg.values[glyph - seg.firstGlyph];
          }
        }
        return null;
      }
      case 6: {
        let min2 = 0;
        let max2 = this.table.binarySearchHeader.nUnits - 1;
        while (min2 <= max2) {
          var mid = min2 + max2 >> 1;
          var seg = this.table.segments[mid];
          if (seg.glyph === 65535) return null;
          if (glyph < seg.glyph) max2 = mid - 1;
          else if (glyph > seg.glyph) min2 = mid + 1;
          else return seg.value;
        }
        return null;
      }
      case 8:
        return this.table.values[glyph - this.table.firstGlyph];
      default:
        throw new Error(`Unknown lookup table format: ${this.table.version}`);
    }
  }
  glyphsForValue(classValue) {
    let res = [];
    switch (this.table.version) {
      case 2:
      case 4:
        for (let segment of this.table.segments) if (this.table.version === 2 && segment.value === classValue) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(segment.firstGlyph, segment.lastGlyph + 1));
        else {
          for (let index2 = 0; index2 < segment.values.length; index2++) if (segment.values[index2] === classValue) res.push(segment.firstGlyph + index2);
        }
        break;
      case 6:
        for (let segment of this.table.segments) if (segment.value === classValue) res.push(segment.glyph);
        break;
      case 8:
        for (let i2 = 0; i2 < this.table.values.length; i2++) if (this.table.values[i2] === classValue) res.push(this.table.firstGlyph + i2);
        break;
      default:
        throw new Error(`Unknown lookup table format: ${this.table.version}`);
    }
    return res;
  }
  constructor(table3) {
    this.table = table3;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $ff5ce077dae0f144$export$2e2bcd8739ae039.prototype, "glyphsForValue", null);
var $50c7aac9316f2948$var$START_OF_TEXT_STATE = 0;
var $50c7aac9316f2948$var$END_OF_TEXT_CLASS = 0;
var $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS = 1;
var $50c7aac9316f2948$var$DELETED_GLYPH_CLASS = 2;
var $50c7aac9316f2948$var$DONT_ADVANCE = 16384;
var $50c7aac9316f2948$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$50c7aac9316f2948$export$2e2bcd8739ae039");
  }
  process(glyphs, reverse2, processEntry) {
    let currentState = $50c7aac9316f2948$var$START_OF_TEXT_STATE;
    let index2 = reverse2 ? glyphs.length - 1 : 0;
    let dir3 = reverse2 ? -1 : 1;
    while (dir3 === 1 && index2 <= glyphs.length || dir3 === -1 && index2 >= -1) {
      let glyph = null;
      let classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
      let shouldAdvance = true;
      if (index2 === glyphs.length || index2 === -1) classCode = $50c7aac9316f2948$var$END_OF_TEXT_CLASS;
      else {
        glyph = glyphs[index2];
        if (glyph.id === 65535) classCode = $50c7aac9316f2948$var$DELETED_GLYPH_CLASS;
        else {
          classCode = this.lookupTable.lookup(glyph.id);
          if (classCode == null) classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
        }
      }
      let row = this.stateTable.stateArray.getItem(currentState);
      let entryIndex = row[classCode];
      let entry = this.stateTable.entryTable.getItem(entryIndex);
      if (classCode !== $50c7aac9316f2948$var$END_OF_TEXT_CLASS && classCode !== $50c7aac9316f2948$var$DELETED_GLYPH_CLASS) {
        processEntry(glyph, entry, index2);
        shouldAdvance = !(entry.flags & $50c7aac9316f2948$var$DONT_ADVANCE);
      }
      currentState = entry.newState;
      if (shouldAdvance) index2 += dir3;
    }
    return glyphs;
  }
  /**
  * Performs a depth-first traversal of the glyph strings
  * represented by the state machine.
  */
  traverse(opts2, state2 = 0, visited = /* @__PURE__ */ new Set()) {
    if (visited.has(state2)) return;
    visited.add(state2);
    let { nClasses, stateArray, entryTable } = this.stateTable;
    let row = stateArray.getItem(state2);
    for (let classCode = 4; classCode < nClasses; classCode++) {
      let entryIndex = row[classCode];
      let entry = entryTable.getItem(entryIndex);
      for (let glyph of this.lookupTable.glyphsForValue(classCode)) {
        if (opts2.enter) opts2.enter(glyph, entry);
        if (entry.newState !== 0) this.traverse(opts2, entry.newState, visited);
        if (opts2.exit) opts2.exit(glyph, entry);
      }
    }
  }
  constructor(stateTable) {
    this.stateTable = stateTable;
    this.lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(stateTable.classTable);
  }
};
var $55f71433a605c87d$var$MARK_FIRST = 32768;
var $55f71433a605c87d$var$MARK_LAST = 8192;
var $55f71433a605c87d$var$VERB = 15;
var $55f71433a605c87d$var$SET_MARK = 32768;
var $55f71433a605c87d$var$SET_COMPONENT = 32768;
var $55f71433a605c87d$var$PERFORM_ACTION = 8192;
var $55f71433a605c87d$var$LAST_MASK = 2147483648;
var $55f71433a605c87d$var$STORE_MASK = 1073741824;
var $55f71433a605c87d$var$OFFSET_MASK = 1073741823;
var $55f71433a605c87d$var$REVERSE_DIRECTION = 4194304;
var $55f71433a605c87d$var$CURRENT_INSERT_BEFORE = 2048;
var $55f71433a605c87d$var$MARKED_INSERT_BEFORE = 1024;
var $55f71433a605c87d$var$CURRENT_INSERT_COUNT = 992;
var $55f71433a605c87d$var$MARKED_INSERT_COUNT = 31;
var $55f71433a605c87d$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$55f71433a605c87d$export$2e2bcd8739ae039");
  }
  // Processes an array of glyphs and applies the specified features
  // Features should be in the form of {featureType:{featureSetting:boolean}}
  process(glyphs, features2 = {}) {
    for (let chain of this.morx.chains) {
      let flags = chain.defaultFlags;
      for (let feature of chain.features) {
        let f4;
        if (f4 = features2[feature.featureType]) {
          if (f4[feature.featureSetting]) {
            flags &= feature.disableFlags;
            flags |= feature.enableFlags;
          } else if (f4[feature.featureSetting] === false) {
            flags |= ~feature.disableFlags;
            flags &= ~feature.enableFlags;
          }
        }
      }
      for (let subtable of chain.subtables) if (subtable.subFeatureFlags & flags) this.processSubtable(subtable, glyphs);
    }
    let index2 = glyphs.length - 1;
    while (index2 >= 0) {
      if (glyphs[index2].id === 65535) glyphs.splice(index2, 1);
      index2--;
    }
    return glyphs;
  }
  processSubtable(subtable, glyphs) {
    this.subtable = subtable;
    this.glyphs = glyphs;
    if (this.subtable.type === 4) {
      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
      return;
    }
    this.ligatureStack = [];
    this.markedGlyph = null;
    this.firstGlyph = null;
    this.lastGlyph = null;
    this.markedIndex = null;
    let stateMachine = this.getStateMachine(subtable);
    let process2 = this.getProcessor();
    let reverse2 = !!(this.subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
    return stateMachine.process(this.glyphs, reverse2, process2);
  }
  getStateMachine(subtable) {
    return new (0, $50c7aac9316f2948$export$2e2bcd8739ae039)(subtable.table.stateTable);
  }
  getProcessor() {
    switch (this.subtable.type) {
      case 0:
        return this.processIndicRearragement;
      case 1:
        return this.processContextualSubstitution;
      case 2:
        return this.processLigature;
      case 4:
        return this.processNoncontextualSubstitutions;
      case 5:
        return this.processGlyphInsertion;
      default:
        throw new Error(`Invalid morx subtable type: ${this.subtable.type}`);
    }
  }
  processIndicRearragement(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$MARK_FIRST) this.firstGlyph = index2;
    if (entry.flags & $55f71433a605c87d$var$MARK_LAST) this.lastGlyph = index2;
    $55f71433a605c87d$var$reorderGlyphs(this.glyphs, entry.flags & $55f71433a605c87d$var$VERB, this.firstGlyph, this.lastGlyph);
  }
  processContextualSubstitution(glyph, entry, index2) {
    let subsitutions = this.subtable.table.substitutionTable.items;
    if (entry.markIndex !== 65535) {
      let lookup4 = subsitutions.getItem(entry.markIndex);
      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup4);
      glyph = this.glyphs[this.markedGlyph];
      var gid = lookupTable.lookup(glyph.id);
      if (gid) this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);
    }
    if (entry.currentIndex !== 65535) {
      let lookup4 = subsitutions.getItem(entry.currentIndex);
      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup4);
      glyph = this.glyphs[index2];
      var gid = lookupTable.lookup(glyph.id);
      if (gid) this.glyphs[index2] = this.font.getGlyph(gid, glyph.codePoints);
    }
    if (entry.flags & $55f71433a605c87d$var$SET_MARK) this.markedGlyph = index2;
  }
  processLigature(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$SET_COMPONENT) this.ligatureStack.push(index2);
    if (entry.flags & $55f71433a605c87d$var$PERFORM_ACTION) {
      let actions = this.subtable.table.ligatureActions;
      let components = this.subtable.table.components;
      let ligatureList = this.subtable.table.ligatureList;
      let actionIndex = entry.action;
      let last2 = false;
      let ligatureIndex = 0;
      let codePoints = [];
      let ligatureGlyphs = [];
      while (!last2) {
        let componentGlyph = this.ligatureStack.pop();
        codePoints.unshift(...this.glyphs[componentGlyph].codePoints);
        let action = actions.getItem(actionIndex++);
        last2 = !!(action & $55f71433a605c87d$var$LAST_MASK);
        let store = !!(action & $55f71433a605c87d$var$STORE_MASK);
        let offset2 = (action & $55f71433a605c87d$var$OFFSET_MASK) << 2 >> 2;
        offset2 += this.glyphs[componentGlyph].id;
        let component = components.getItem(offset2);
        ligatureIndex += component;
        if (last2 || store) {
          let ligatureEntry = ligatureList.getItem(ligatureIndex);
          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
          ligatureGlyphs.push(componentGlyph);
          ligatureIndex = 0;
          codePoints = [];
        } else this.glyphs[componentGlyph] = this.font.getGlyph(65535);
      }
      this.ligatureStack.push(...ligatureGlyphs);
    }
  }
  processNoncontextualSubstitutions(subtable, glyphs, index2) {
    let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(subtable.table.lookupTable);
    for (index2 = 0; index2 < glyphs.length; index2++) {
      let glyph = glyphs[index2];
      if (glyph.id !== 65535) {
        let gid = lookupTable.lookup(glyph.id);
        if (gid) glyphs[index2] = this.font.getGlyph(gid, glyph.codePoints);
      }
    }
  }
  _insertGlyphs(glyphIndex, insertionActionIndex, count3, isBefore) {
    let insertions = [];
    while (count3--) {
      let gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
      insertions.push(this.font.getGlyph(gid));
    }
    if (!isBefore) glyphIndex++;
    this.glyphs.splice(glyphIndex, 0, ...insertions);
  }
  processGlyphInsertion(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$SET_MARK) this.markedIndex = index2;
    if (entry.markedInsertIndex !== 65535) {
      let count3 = (entry.flags & $55f71433a605c87d$var$MARKED_INSERT_COUNT) >>> 5;
      let isBefore = !!(entry.flags & $55f71433a605c87d$var$MARKED_INSERT_BEFORE);
      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count3, isBefore);
    }
    if (entry.currentInsertIndex !== 65535) {
      let count3 = (entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_COUNT) >>> 5;
      let isBefore = !!(entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_BEFORE);
      this._insertGlyphs(index2, entry.currentInsertIndex, count3, isBefore);
    }
  }
  getSupportedFeatures() {
    let features2 = [];
    for (let chain of this.morx.chains) for (let feature of chain.features) features2.push([
      feature.featureType,
      feature.featureSetting
    ]);
    return features2;
  }
  generateInputs(gid) {
    if (!this.inputCache) this.generateInputCache();
    return this.inputCache[gid] || [];
  }
  generateInputCache() {
    this.inputCache = {};
    for (let chain of this.morx.chains) {
      let flags = chain.defaultFlags;
      for (let subtable of chain.subtables) if (subtable.subFeatureFlags & flags) this.generateInputsForSubtable(subtable);
    }
  }
  generateInputsForSubtable(subtable) {
    if (subtable.type !== 2) return;
    let reverse2 = !!(subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
    if (reverse2) throw new Error("Reverse subtable, not supported.");
    this.subtable = subtable;
    this.ligatureStack = [];
    let stateMachine = this.getStateMachine(subtable);
    let process2 = this.getProcessor();
    let input = [];
    let stack = [];
    this.glyphs = [];
    stateMachine.traverse({
      enter: /* @__PURE__ */ __name((glyph, entry) => {
        let glyphs = this.glyphs;
        stack.push({
          glyphs: glyphs.slice(),
          ligatureStack: this.ligatureStack.slice()
        });
        let g = this.font.getGlyph(glyph);
        input.push(g);
        glyphs.push(input[input.length - 1]);
        process2(glyphs[glyphs.length - 1], entry, glyphs.length - 1);
        let count3 = 0;
        let found = 0;
        for (let i2 = 0; i2 < glyphs.length && count3 <= 1; i2++) if (glyphs[i2].id !== 65535) {
          count3++;
          found = glyphs[i2].id;
        }
        if (count3 === 1) {
          let result = input.map((g2) => g2.id);
          let cache2 = this.inputCache[found];
          if (cache2) cache2.push(result);
          else this.inputCache[found] = [
            result
          ];
        }
      }, "enter"),
      exit: /* @__PURE__ */ __name(() => {
        ({ glyphs: this.glyphs, ligatureStack: this.ligatureStack } = stack.pop());
        input.pop();
      }, "exit")
    });
  }
  constructor(font) {
    this.processIndicRearragement = this.processIndicRearragement.bind(this);
    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);
    this.processLigature = this.processLigature.bind(this);
    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);
    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);
    this.font = font;
    this.morx = font.morx;
    this.inputCache = null;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $55f71433a605c87d$export$2e2bcd8739ae039.prototype, "getStateMachine", null);
function $55f71433a605c87d$var$swap(glyphs, rangeA, rangeB, reverseA = false, reverseB = false) {
  let end2 = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
  if (reverseB) end2.reverse();
  let start2 = glyphs.splice(rangeA[0], rangeA[1], ...end2);
  if (reverseA) start2.reverse();
  glyphs.splice(rangeB[0] - (rangeA[1] - 1), 0, ...start2);
  return glyphs;
}
__name($55f71433a605c87d$var$swap, "$55f71433a605c87d$var$swap");
function $55f71433a605c87d$var$reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {
  let length2 = lastGlyph - firstGlyph + 1;
  switch (verb) {
    case 0:
      return glyphs;
    case 1:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        0
      ]);
    case 2:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        1
      ]);
    case 3:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        1
      ]);
    case 4:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        0
      ]);
    case 5:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        0
      ], true, false);
    case 6:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        2
      ]);
    case 7:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        2
      ], false, true);
    case 8:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        2
      ]);
    case 9:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        2
      ], false, true);
    case 10:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        1
      ]);
    case 11:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        1
      ], true, false);
    case 12:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ]);
    case 13:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], true, false);
    case 14:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], false, true);
    case 15:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], true, true);
    default:
      throw new Error(`Unknown verb: ${verb}`);
  }
}
__name($55f71433a605c87d$var$reorderGlyphs, "$55f71433a605c87d$var$reorderGlyphs");
var $ba6dd74203be8728$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$ba6dd74203be8728$export$2e2bcd8739ae039");
  }
  substitute(glyphRun) {
    if (glyphRun.direction === "rtl") glyphRun.glyphs.reverse();
    this.morxProcessor.process(glyphRun.glyphs, $3b6302b64eccc32c$export$b813f7d2a1677c16(glyphRun.features));
  }
  getAvailableFeatures(script, language) {
    return $3b6302b64eccc32c$export$bd6df347a4f391c4(this.morxProcessor.getSupportedFeatures());
  }
  stringsForGlyph(gid) {
    let glyphStrings = this.morxProcessor.generateInputs(gid);
    let result = /* @__PURE__ */ new Set();
    for (let glyphs of glyphStrings) this._addStrings(glyphs, 0, result, "");
    return result;
  }
  _addStrings(glyphs, index2, strings, string) {
    let codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index2]);
    for (let codePoint of codePoints) {
      let s4 = string + String.fromCodePoint(codePoint);
      if (index2 < glyphs.length - 1) this._addStrings(glyphs, index2 + 1, strings, s4);
      else strings.add(s4);
    }
  }
  constructor(font) {
    this.font = font;
    this.morxProcessor = new (0, $55f71433a605c87d$export$2e2bcd8739ae039)(font);
    this.fallbackPosition = false;
  }
};
var $94d7a73bd2edfc9a$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$94d7a73bd2edfc9a$export$2e2bcd8739ae039");
  }
  /**
  * Adds the given features to the last stage.
  * Ignores features that have already been applied.
  */
  _addFeatures(features2, global2) {
    let stageIndex = this.stages.length - 1;
    let stage = this.stages[stageIndex];
    for (let feature of features2) if (this.allFeatures[feature] == null) {
      stage.push(feature);
      this.allFeatures[feature] = stageIndex;
      if (global2) this.globalFeatures[feature] = true;
    }
  }
  /**
  * Add features to the last stage
  */
  add(arg, global2 = true) {
    if (this.stages.length === 0) this.stages.push([]);
    if (typeof arg === "string") arg = [
      arg
    ];
    if (Array.isArray(arg)) this._addFeatures(arg, global2);
    else if (typeof arg === "object") {
      this._addFeatures(arg.global || [], true);
      this._addFeatures(arg.local || [], false);
    } else throw new Error("Unsupported argument to ShapingPlan#add");
  }
  /**
  * Add a new stage
  */
  addStage(arg, global2) {
    if (typeof arg === "function") this.stages.push(arg, []);
    else {
      this.stages.push([]);
      this.add(arg, global2);
    }
  }
  setFeatureOverrides(features2) {
    if (Array.isArray(features2)) this.add(features2);
    else if (typeof features2 === "object") for (let tag in features2) {
      if (features2[tag]) this.add(tag);
      else if (this.allFeatures[tag] != null) {
        let stage = this.stages[this.allFeatures[tag]];
        stage.splice(stage.indexOf(tag), 1);
        delete this.allFeatures[tag];
        delete this.globalFeatures[tag];
      }
    }
  }
  /**
  * Assigns the global features to the given glyphs
  */
  assignGlobalFeatures(glyphs) {
    for (let glyph of glyphs) for (let feature in this.globalFeatures) glyph.features[feature] = true;
  }
  /**
  * Executes the planned stages using the given OTProcessor
  */
  process(processor, glyphs, positions) {
    for (let stage of this.stages) {
      if (typeof stage === "function") {
        if (!positions) stage(this.font, glyphs, this);
      } else if (stage.length > 0) processor.applyFeatures(stage, glyphs, positions);
    }
  }
  constructor(font, script, direction) {
    this.font = font;
    this.script = script;
    this.direction = direction;
    this.stages = [];
    this.globalFeatures = {};
    this.allFeatures = {};
  }
};
var $649970d87335b30f$var$VARIATION_FEATURES = [
  "rvrn"
];
var $649970d87335b30f$var$COMMON_FEATURES = [
  "ccmp",
  "locl",
  "rlig",
  "mark",
  "mkmk"
];
var $649970d87335b30f$var$FRACTIONAL_FEATURES = [
  "frac",
  "numr",
  "dnom"
];
var $649970d87335b30f$var$HORIZONTAL_FEATURES = [
  "calt",
  "clig",
  "liga",
  "rclt",
  "curs",
  "kern"
];
var $649970d87335b30f$var$DIRECTIONAL_FEATURES = {
  ltr: [
    "ltra",
    "ltrm"
  ],
  rtl: [
    "rtla",
    "rtlm"
  ]
};
var $649970d87335b30f$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$649970d87335b30f$export$2e2bcd8739ae039");
  }
  static plan(plan, glyphs, features2) {
    this.planPreprocessing(plan);
    this.planFeatures(plan);
    this.planPostprocessing(plan, features2);
    plan.assignGlobalFeatures(glyphs);
    this.assignFeatures(plan, glyphs);
  }
  static planPreprocessing(plan) {
    plan.add({
      global: [
        ...$649970d87335b30f$var$VARIATION_FEATURES,
        ...$649970d87335b30f$var$DIRECTIONAL_FEATURES[plan.direction]
      ],
      local: $649970d87335b30f$var$FRACTIONAL_FEATURES
    });
  }
  static planFeatures(plan) {
  }
  static planPostprocessing(plan, userFeatures) {
    plan.add([
      ...$649970d87335b30f$var$COMMON_FEATURES,
      ...$649970d87335b30f$var$HORIZONTAL_FEATURES
    ]);
    plan.setFeatureOverrides(userFeatures);
  }
  static assignFeatures(plan, glyphs) {
    for (let i2 = 0; i2 < glyphs.length; i2++) {
      let glyph = glyphs[i2];
      if (glyph.codePoints[0] === 8260) {
        let start2 = i2;
        let end2 = i2 + 1;
        while (start2 > 0 && (0, $747425b437e121da$export$727d9dbc4fbb948f)(glyphs[start2 - 1].codePoints[0])) {
          glyphs[start2 - 1].features.numr = true;
          glyphs[start2 - 1].features.frac = true;
          start2--;
        }
        while (end2 < glyphs.length && (0, $747425b437e121da$export$727d9dbc4fbb948f)(glyphs[end2].codePoints[0])) {
          glyphs[end2].features.dnom = true;
          glyphs[end2].features.frac = true;
          end2++;
        }
        glyph.features.frac = true;
        i2 = end2 - 1;
      }
    }
  }
};
(0, _define_property)($649970d87335b30f$export$2e2bcd8739ae039, "zeroMarkWidths", "AFTER_GPOS");
var $764eb544bbe1ccf0$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("APABAAAAAAAAOAAAAf0BAv7tmi1MxDAUx7vtvjhAgcDgkEgEAnmXEBIMCYaEcygEiqBQ4FAkCE4ikUgMiiBJSAgSiUQSDMn9L9eSl6bddddug9t7yS/trevre+3r27pcNxZiG+yCfdCVv/9LeQxOwRm4AJegD27ALbgD9+ABPJF+z+BN/h7yDj5k/VOWX6SdmU5+wLWknggxDxaS8u0qiiX4uiz9XamQ3wzDMAzDMAzDMAzDVI/h959V/v7BMAzDMAzDMLlyNTNiMSdewVxbiA44B4/guz1qW58VYlMI0WsJ0W+N6kXw0spvPtdwhtkwnGM6uLaV4Xyzg3v3PM9DPfQ/sOg4xPWjipy31P8LTqbU304c/cLCUmWJLNB2Uz2U1KTeRKNmKHVMfbJC+/0loTZRH/W5cvEvBJPMbREkWt3FD1NcqXZBSpuE2Ad0PBehPtNrPtIEdYP+hiRt/V1jIiE69X4NT/uVZI3PUHE9bm5M7ePGdZWy951v7Nn6j8v1WWKP3mt6ttnsigx6VN7Vc0VomSSGqW2mGNP1muZPl7LfjNUaKNFtDGVf2fvE9O7VlBS5j333c5p/eeoOqcs1R/hIqDWLJ7TTlksirVT1SI7l8k4Yp+g3jafGcrU1RM6l9th80XOpnlN97bDNY4i4s61B0Si/ipa0uHMl6zqEjlFfCZm/TM8KmzQDjmuTAQ=="));
var $764eb544bbe1ccf0$var$FEATURES = [
  "isol",
  "fina",
  "fin2",
  "fin3",
  "medi",
  "med2",
  "init"
];
var $764eb544bbe1ccf0$var$ShapingClasses = {
  Non_Joining: 0,
  Left_Joining: 1,
  Right_Joining: 2,
  Dual_Joining: 3,
  Join_Causing: 3,
  ALAPH: 4,
  "DALATH RISH": 5,
  Transparent: 6
};
var $764eb544bbe1ccf0$var$ISOL = "isol";
var $764eb544bbe1ccf0$var$FINA = "fina";
var $764eb544bbe1ccf0$var$FIN2 = "fin2";
var $764eb544bbe1ccf0$var$FIN3 = "fin3";
var $764eb544bbe1ccf0$var$MEDI = "medi";
var $764eb544bbe1ccf0$var$MED2 = "med2";
var $764eb544bbe1ccf0$var$INIT = "init";
var $764eb544bbe1ccf0$var$NONE = null;
var $764eb544bbe1ccf0$var$STATE_TABLE = [
  //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH
  // State 0: prev was U,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 1: prev was R or ISOL/ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 2: prev was D/L in ISOL form,  willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      1
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      3
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      4
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      6
    ]
  ],
  // State 3: prev was D in FINA form,  willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      1
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      3
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      4
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      6
    ]
  ],
  // State 4: prev was FINA ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 6: prev was DALATH/RISH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$FIN3,
      5
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ]
];
var $764eb544bbe1ccf0$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static {
    __name(this, "$764eb544bbe1ccf0$export$2e2bcd8739ae039");
  }
  static planFeatures(plan) {
    plan.add([
      "ccmp",
      "locl"
    ]);
    for (let i2 = 0; i2 < $764eb544bbe1ccf0$var$FEATURES.length; i2++) {
      let feature = $764eb544bbe1ccf0$var$FEATURES[i2];
      plan.addStage(feature, false);
    }
    plan.addStage("mset");
  }
  static assignFeatures(plan, glyphs) {
    super.assignFeatures(plan, glyphs);
    let prev = -1;
    let state2 = 0;
    let actions = [];
    for (let i2 = 0; i2 < glyphs.length; i2++) {
      let curAction, prevAction;
      var glyph = glyphs[i2];
      let type2 = $764eb544bbe1ccf0$var$getShapingClass(glyph.codePoints[0]);
      if (type2 === $764eb544bbe1ccf0$var$ShapingClasses.Transparent) {
        actions[i2] = $764eb544bbe1ccf0$var$NONE;
        continue;
      }
      [prevAction, curAction, state2] = $764eb544bbe1ccf0$var$STATE_TABLE[state2][type2];
      if (prevAction !== $764eb544bbe1ccf0$var$NONE && prev !== -1) actions[prev] = prevAction;
      actions[i2] = curAction;
      prev = i2;
    }
    for (let index2 = 0; index2 < glyphs.length; index2++) {
      let feature;
      var glyph = glyphs[index2];
      if (feature = actions[index2]) glyph.features[feature] = true;
    }
  }
};
function $764eb544bbe1ccf0$var$getShapingClass(codePoint) {
  let res = $764eb544bbe1ccf0$var$trie.get(codePoint);
  if (res) return res - 1;
  let category = (0, $747425b437e121da$export$410364bbb673ddbc)(codePoint);
  if (category === "Mn" || category === "Me" || category === "Cf") return $764eb544bbe1ccf0$var$ShapingClasses.Transparent;
  return $764eb544bbe1ccf0$var$ShapingClasses.Non_Joining;
}
__name($764eb544bbe1ccf0$var$getShapingClass, "$764eb544bbe1ccf0$var$getShapingClass");
var $85d408632270248b$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$85d408632270248b$export$2e2bcd8739ae039");
  }
  reset(options = {}, index2 = 0) {
    this.options = options;
    this.flags = options.flags || {};
    this.markAttachmentType = options.markAttachmentType || 0;
    this.index = index2;
  }
  get cur() {
    return this.glyphs[this.index] || null;
  }
  shouldIgnore(glyph) {
    return this.flags.ignoreMarks && glyph.isMark || this.flags.ignoreBaseGlyphs && glyph.isBase || this.flags.ignoreLigatures && glyph.isLigature || this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType;
  }
  move(dir3) {
    this.index += dir3;
    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) this.index += dir3;
    if (0 > this.index || this.index >= this.glyphs.length) return null;
    return this.glyphs[this.index];
  }
  next() {
    return this.move(1);
  }
  prev() {
    return this.move(-1);
  }
  peek(count3 = 1) {
    let idx = this.index;
    let res = this.increment(count3);
    this.index = idx;
    return res;
  }
  peekIndex(count3 = 1) {
    let idx = this.index;
    this.increment(count3);
    let res = this.index;
    this.index = idx;
    return res;
  }
  increment(count3 = 1) {
    let dir3 = count3 < 0 ? -1 : 1;
    count3 = Math.abs(count3);
    while (count3--) this.move(dir3);
    return this.glyphs[this.index];
  }
  constructor(glyphs, options) {
    this.glyphs = glyphs;
    this.reset(options);
  }
};
var $a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS = [
  "DFLT",
  "dflt",
  "latn"
];
var $a83b9c36aaa94fd3$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$a83b9c36aaa94fd3$export$2e2bcd8739ae039");
  }
  findScript(script) {
    if (this.table.scriptList == null) return null;
    if (!Array.isArray(script)) script = [
      script
    ];
    for (let s4 of script) for (let entry of this.table.scriptList) {
      if (entry.tag === s4) return entry;
    }
    return null;
  }
  selectScript(script, language, direction) {
    let changed = false;
    let entry;
    if (!this.script || script !== this.scriptTag) {
      entry = this.findScript(script);
      if (!entry) entry = this.findScript($a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS);
      if (!entry) return this.scriptTag;
      this.scriptTag = entry.tag;
      this.script = entry.script;
      this.language = null;
      this.languageTag = null;
      changed = true;
    }
    if (!direction || direction !== this.direction) this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
    if (language && language.length < 4) language += " ".repeat(4 - language.length);
    if (!language || language !== this.languageTag) {
      this.language = null;
      for (let lang of this.script.langSysRecords) if (lang.tag === language) {
        this.language = lang.langSys;
        this.languageTag = lang.tag;
        break;
      }
      if (!this.language) {
        this.language = this.script.defaultLangSys;
        this.languageTag = null;
      }
      changed = true;
    }
    if (changed) {
      this.features = {};
      if (this.language) for (let featureIndex of this.language.featureIndexes) {
        let record = this.table.featureList[featureIndex];
        let substituteFeature = this.substituteFeatureForVariations(featureIndex);
        this.features[record.tag] = substituteFeature || record.feature;
      }
    }
    return this.scriptTag;
  }
  lookupsForFeatures(userFeatures = [], exclude) {
    let lookups = [];
    for (let tag of userFeatures) {
      let feature = this.features[tag];
      if (!feature) continue;
      for (let lookupIndex of feature.lookupListIndexes) {
        if (exclude && exclude.indexOf(lookupIndex) !== -1) continue;
        lookups.push({
          feature: tag,
          index: lookupIndex,
          lookup: this.table.lookupList.get(lookupIndex)
        });
      }
    }
    lookups.sort((a4, b3) => a4.index - b3.index);
    return lookups;
  }
  substituteFeatureForVariations(featureIndex) {
    if (this.variationsIndex === -1) return null;
    let record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];
    let substitutions = record.featureTableSubstitution.substitutions;
    for (let substitution of substitutions) {
      if (substitution.featureIndex === featureIndex) return substitution.alternateFeatureTable;
    }
    return null;
  }
  findVariationsIndex(coords) {
    let variations = this.table.featureVariations;
    if (!variations) return -1;
    let records = variations.featureVariationRecords;
    for (let i2 = 0; i2 < records.length; i2++) {
      let conditions = records[i2].conditionSet.conditionTable;
      if (this.variationConditionsMatch(conditions, coords)) return i2;
    }
    return -1;
  }
  variationConditionsMatch(conditions, coords) {
    return conditions.every((condition) => {
      let coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;
      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;
    });
  }
  applyFeatures(userFeatures, glyphs, advances) {
    let lookups = this.lookupsForFeatures(userFeatures);
    this.applyLookups(lookups, glyphs, advances);
  }
  applyLookups(lookups, glyphs, positions) {
    this.glyphs = glyphs;
    this.positions = positions;
    this.glyphIterator = new (0, $85d408632270248b$export$2e2bcd8739ae039)(glyphs);
    for (let { feature, lookup: lookup4 } of lookups) {
      this.currentFeature = feature;
      this.glyphIterator.reset(lookup4.flags);
      while (this.glyphIterator.index < glyphs.length) {
        if (!(feature in this.glyphIterator.cur.features)) {
          this.glyphIterator.next();
          continue;
        }
        for (let table3 of lookup4.subTables) {
          let res = this.applyLookup(lookup4.lookupType, table3);
          if (res) break;
        }
        this.glyphIterator.next();
      }
    }
  }
  applyLookup(lookup4, table3) {
    throw new Error("applyLookup must be implemented by subclasses");
  }
  applyLookupList(lookupRecords) {
    let options = this.glyphIterator.options;
    let glyphIndex = this.glyphIterator.index;
    for (let lookupRecord of lookupRecords) {
      this.glyphIterator.reset(options, glyphIndex);
      this.glyphIterator.increment(lookupRecord.sequenceIndex);
      let lookup4 = this.table.lookupList.get(lookupRecord.lookupListIndex);
      this.glyphIterator.reset(lookup4.flags, this.glyphIterator.index);
      for (let table3 of lookup4.subTables) {
        if (this.applyLookup(lookup4.lookupType, table3)) break;
      }
    }
    this.glyphIterator.reset(options, glyphIndex);
    return true;
  }
  coverageIndex(coverage, glyph) {
    if (glyph == null) glyph = this.glyphIterator.cur.id;
    switch (coverage.version) {
      case 1:
        return coverage.glyphs.indexOf(glyph);
      case 2:
        for (let range2 of coverage.rangeRecords) {
          if (range2.start <= glyph && glyph <= range2.end) return range2.startCoverageIndex + glyph - range2.start;
        }
        break;
    }
    return -1;
  }
  match(sequenceIndex, sequence, fn, matched) {
    let pos = this.glyphIterator.index;
    let glyph = this.glyphIterator.increment(sequenceIndex);
    let idx = 0;
    while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {
      if (matched) matched.push(this.glyphIterator.index);
      idx++;
      glyph = this.glyphIterator.next();
    }
    this.glyphIterator.index = pos;
    if (idx < sequence.length) return false;
    return matched || true;
  }
  sequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (component, glyph) => component === glyph.id);
  }
  sequenceMatchIndices(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (component, glyph) => {
      if (!(this.currentFeature in glyph.features)) return false;
      return component === glyph.id;
    }, []);
  }
  coverageSequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (coverage, glyph) => this.coverageIndex(coverage, glyph.id) >= 0);
  }
  getClassID(glyph, classDef) {
    switch (classDef.version) {
      case 1:
        let i2 = glyph - classDef.startGlyph;
        if (i2 >= 0 && i2 < classDef.classValueArray.length) return classDef.classValueArray[i2];
        break;
      case 2:
        for (let range2 of classDef.classRangeRecord) {
          if (range2.start <= glyph && glyph <= range2.end) return range2.class;
        }
        break;
    }
    return 0;
  }
  classSequenceMatches(sequenceIndex, sequence, classDef) {
    return this.match(sequenceIndex, sequence, (classID, glyph) => classID === this.getClassID(glyph.id, classDef));
  }
  applyContext(table3) {
    let index2, set5;
    switch (table3.version) {
      case 1:
        index2 = this.coverageIndex(table3.coverage);
        if (index2 === -1) return false;
        set5 = table3.ruleSets[index2];
        for (let rule of set5) {
          if (this.sequenceMatches(1, rule.input)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 2:
        if (this.coverageIndex(table3.coverage) === -1) return false;
        index2 = this.getClassID(this.glyphIterator.cur.id, table3.classDef);
        if (index2 === -1) return false;
        set5 = table3.classSet[index2];
        for (let rule of set5) {
          if (this.classSequenceMatches(1, rule.classes, table3.classDef)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(0, table3.coverages)) return this.applyLookupList(table3.lookupRecords);
        break;
    }
    return false;
  }
  applyChainingContext(table3) {
    let index2;
    switch (table3.version) {
      case 1:
        index2 = this.coverageIndex(table3.coverage);
        if (index2 === -1) return false;
        let set5 = table3.chainRuleSets[index2];
        for (let rule of set5) {
          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 2:
        if (this.coverageIndex(table3.coverage) === -1) return false;
        index2 = this.getClassID(this.glyphIterator.cur.id, table3.inputClassDef);
        let rules = table3.chainClassSet[index2];
        if (!rules) return false;
        for (let rule of rules) {
          if (this.classSequenceMatches(-rule.backtrack.length, rule.backtrack, table3.backtrackClassDef) && this.classSequenceMatches(1, rule.input, table3.inputClassDef) && this.classSequenceMatches(1 + rule.input.length, rule.lookahead, table3.lookaheadClassDef)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(-table3.backtrackGlyphCount, table3.backtrackCoverage) && this.coverageSequenceMatches(0, table3.inputCoverage) && this.coverageSequenceMatches(table3.inputGlyphCount, table3.lookaheadCoverage)) return this.applyLookupList(table3.lookupRecords);
        break;
    }
    return false;
  }
  constructor(font, table3) {
    this.font = font;
    this.table = table3;
    this.script = null;
    this.scriptTag = null;
    this.language = null;
    this.languageTag = null;
    this.features = {};
    this.lookups = {};
    this.variationsIndex = font._variationProcessor ? this.findVariationsIndex(font._variationProcessor.normalizedCoords) : -1;
    this.selectScript();
    this.glyphs = [];
    this.positions = [];
    this.ligatureID = 1;
    this.currentFeature = null;
  }
};
var $10e7b257e1a9a756$export$2e2bcd8739ae039 = class _$10e7b257e1a9a756$export$2e2bcd8739ae039 {
  static {
    __name(this, "$10e7b257e1a9a756$export$2e2bcd8739ae039");
  }
  get id() {
    return this._id;
  }
  set id(id) {
    this._id = id;
    this.substituted = true;
    let GDEF = this._font.GDEF;
    if (GDEF && GDEF.glyphClassDef) {
      let classID = (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.glyphClassDef);
      this.isBase = classID === 1;
      this.isLigature = classID === 2;
      this.isMark = classID === 3;
      this.markAttachmentType = GDEF.markAttachClassDef ? (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.markAttachClassDef) : 0;
    } else {
      this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $747425b437e121da$export$e33ad6871e762338));
      this.isBase = !this.isMark;
      this.isLigature = this.codePoints.length > 1;
      this.markAttachmentType = 0;
    }
  }
  copy() {
    return new _$10e7b257e1a9a756$export$2e2bcd8739ae039(this._font, this.id, this.codePoints, this.features);
  }
  constructor(font, id, codePoints = [], features2) {
    this._font = font;
    this.codePoints = codePoints;
    this.id = id;
    this.features = {};
    if (Array.isArray(features2)) for (let i2 = 0; i2 < features2.length; i2++) {
      let feature = features2[i2];
      this.features[feature] = true;
    }
    else if (typeof features2 === "object") Object.assign(this.features, features2);
    this.ligatureID = null;
    this.ligatureComponent = null;
    this.isLigated = false;
    this.cursiveAttachment = null;
    this.markAttachment = null;
    this.shaperInfo = null;
    this.substituted = false;
    this.isMultiplied = false;
  }
};
var $e1c6bbc8cb416f8c$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static {
    __name(this, "$e1c6bbc8cb416f8c$export$2e2bcd8739ae039");
  }
  static planFeatures(plan) {
    plan.add([
      "ljmo",
      "vjmo",
      "tjmo"
    ], false);
  }
  static assignFeatures(plan, glyphs) {
    let state2 = 0;
    let i2 = 0;
    while (i2 < glyphs.length) {
      let action;
      let glyph = glyphs[i2];
      let code = glyph.codePoints[0];
      let type2 = $e1c6bbc8cb416f8c$var$getType(code);
      [action, state2] = $e1c6bbc8cb416f8c$var$STATE_TABLE[state2][type2];
      switch (action) {
        case $e1c6bbc8cb416f8c$var$DECOMPOSE:
          if (!plan.font.hasGlyphForCodePoint(code)) i2 = $e1c6bbc8cb416f8c$var$decompose(glyphs, i2, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$COMPOSE:
          i2 = $e1c6bbc8cb416f8c$var$compose(glyphs, i2, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$TONE_MARK:
          $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i2, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$INVALID:
          i2 = $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i2, plan.font);
          break;
      }
      i2++;
    }
  }
};
(0, _define_property)($e1c6bbc8cb416f8c$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
var $e1c6bbc8cb416f8c$var$HANGUL_BASE = 44032;
var $e1c6bbc8cb416f8c$var$HANGUL_END = 55204;
var $e1c6bbc8cb416f8c$var$HANGUL_COUNT = $e1c6bbc8cb416f8c$var$HANGUL_END - $e1c6bbc8cb416f8c$var$HANGUL_BASE + 1;
var $e1c6bbc8cb416f8c$var$L_BASE = 4352;
var $e1c6bbc8cb416f8c$var$V_BASE = 4449;
var $e1c6bbc8cb416f8c$var$T_BASE = 4519;
var $e1c6bbc8cb416f8c$var$L_COUNT = 19;
var $e1c6bbc8cb416f8c$var$V_COUNT = 21;
var $e1c6bbc8cb416f8c$var$T_COUNT = 28;
var $e1c6bbc8cb416f8c$var$L_END = $e1c6bbc8cb416f8c$var$L_BASE + $e1c6bbc8cb416f8c$var$L_COUNT - 1;
var $e1c6bbc8cb416f8c$var$V_END = $e1c6bbc8cb416f8c$var$V_BASE + $e1c6bbc8cb416f8c$var$V_COUNT - 1;
var $e1c6bbc8cb416f8c$var$T_END = $e1c6bbc8cb416f8c$var$T_BASE + $e1c6bbc8cb416f8c$var$T_COUNT - 1;
var $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE = 9676;
var $e1c6bbc8cb416f8c$var$isL = /* @__PURE__ */ __name((code) => 4352 <= code && code <= 4447 || 43360 <= code && code <= 43388, "$e1c6bbc8cb416f8c$var$isL");
var $e1c6bbc8cb416f8c$var$isV = /* @__PURE__ */ __name((code) => 4448 <= code && code <= 4519 || 55216 <= code && code <= 55238, "$e1c6bbc8cb416f8c$var$isV");
var $e1c6bbc8cb416f8c$var$isT = /* @__PURE__ */ __name((code) => 4520 <= code && code <= 4607 || 55243 <= code && code <= 55291, "$e1c6bbc8cb416f8c$var$isT");
var $e1c6bbc8cb416f8c$var$isTone = /* @__PURE__ */ __name((code) => 12334 <= code && code <= 12335, "$e1c6bbc8cb416f8c$var$isTone");
var $e1c6bbc8cb416f8c$var$isLVT = /* @__PURE__ */ __name((code) => $e1c6bbc8cb416f8c$var$HANGUL_BASE <= code && code <= $e1c6bbc8cb416f8c$var$HANGUL_END, "$e1c6bbc8cb416f8c$var$isLVT");
var $e1c6bbc8cb416f8c$var$isLV = /* @__PURE__ */ __name((code) => code - $e1c6bbc8cb416f8c$var$HANGUL_BASE < $e1c6bbc8cb416f8c$var$HANGUL_COUNT && (code - $e1c6bbc8cb416f8c$var$HANGUL_BASE) % $e1c6bbc8cb416f8c$var$T_COUNT === 0, "$e1c6bbc8cb416f8c$var$isLV");
var $e1c6bbc8cb416f8c$var$isCombiningL = /* @__PURE__ */ __name((code) => $e1c6bbc8cb416f8c$var$L_BASE <= code && code <= $e1c6bbc8cb416f8c$var$L_END, "$e1c6bbc8cb416f8c$var$isCombiningL");
var $e1c6bbc8cb416f8c$var$isCombiningV = /* @__PURE__ */ __name((code) => $e1c6bbc8cb416f8c$var$V_BASE <= code && code <= $e1c6bbc8cb416f8c$var$V_END, "$e1c6bbc8cb416f8c$var$isCombiningV");
var $e1c6bbc8cb416f8c$var$isCombiningT = /* @__PURE__ */ __name((code) => $e1c6bbc8cb416f8c$var$T_BASE + 1 && 1 <= code && code <= $e1c6bbc8cb416f8c$var$T_END, "$e1c6bbc8cb416f8c$var$isCombiningT");
var $e1c6bbc8cb416f8c$var$X = 0;
var $e1c6bbc8cb416f8c$var$L = 1;
var $e1c6bbc8cb416f8c$var$V = 2;
var $e1c6bbc8cb416f8c$var$T = 3;
var $e1c6bbc8cb416f8c$var$LV = 4;
var $e1c6bbc8cb416f8c$var$LVT = 5;
var $e1c6bbc8cb416f8c$var$M = 6;
function $e1c6bbc8cb416f8c$var$getType(code) {
  if ($e1c6bbc8cb416f8c$var$isL(code)) return $e1c6bbc8cb416f8c$var$L;
  if ($e1c6bbc8cb416f8c$var$isV(code)) return $e1c6bbc8cb416f8c$var$V;
  if ($e1c6bbc8cb416f8c$var$isT(code)) return $e1c6bbc8cb416f8c$var$T;
  if ($e1c6bbc8cb416f8c$var$isLV(code)) return $e1c6bbc8cb416f8c$var$LV;
  if ($e1c6bbc8cb416f8c$var$isLVT(code)) return $e1c6bbc8cb416f8c$var$LVT;
  if ($e1c6bbc8cb416f8c$var$isTone(code)) return $e1c6bbc8cb416f8c$var$M;
  return $e1c6bbc8cb416f8c$var$X;
}
__name($e1c6bbc8cb416f8c$var$getType, "$e1c6bbc8cb416f8c$var$getType");
var $e1c6bbc8cb416f8c$var$NO_ACTION = 0;
var $e1c6bbc8cb416f8c$var$DECOMPOSE = 1;
var $e1c6bbc8cb416f8c$var$COMPOSE = 2;
var $e1c6bbc8cb416f8c$var$TONE_MARK = 4;
var $e1c6bbc8cb416f8c$var$INVALID = 5;
var $e1c6bbc8cb416f8c$var$STATE_TABLE = [
  //       X                 L                 V                T                  LV                LVT               M
  // State 0: start state
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$INVALID,
      0
    ]
  ],
  // State 1: <L>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$COMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$INVALID,
      0
    ]
  ],
  // State 2: <L,V> or <LV>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$COMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$TONE_MARK,
      0
    ]
  ],
  // State 3: <L,V,T> or <LVT>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$TONE_MARK,
      0
    ]
  ]
];
function $e1c6bbc8cb416f8c$var$getGlyph(font, code, features2) {
  return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, font.glyphForCodePoint(code).id, [
    code
  ], features2);
}
__name($e1c6bbc8cb416f8c$var$getGlyph, "$e1c6bbc8cb416f8c$var$getGlyph");
function $e1c6bbc8cb416f8c$var$decompose(glyphs, i2, font) {
  let glyph = glyphs[i2];
  let code = glyph.codePoints[0];
  let s4 = code - $e1c6bbc8cb416f8c$var$HANGUL_BASE;
  let t4 = $e1c6bbc8cb416f8c$var$T_BASE + s4 % $e1c6bbc8cb416f8c$var$T_COUNT;
  s4 = s4 / $e1c6bbc8cb416f8c$var$T_COUNT | 0;
  let l4 = $e1c6bbc8cb416f8c$var$L_BASE + s4 / $e1c6bbc8cb416f8c$var$V_COUNT | 0;
  let v3 = $e1c6bbc8cb416f8c$var$V_BASE + s4 % $e1c6bbc8cb416f8c$var$V_COUNT;
  if (!font.hasGlyphForCodePoint(l4) || !font.hasGlyphForCodePoint(v3) || t4 !== $e1c6bbc8cb416f8c$var$T_BASE && !font.hasGlyphForCodePoint(t4)) return i2;
  let ljmo = $e1c6bbc8cb416f8c$var$getGlyph(font, l4, glyph.features);
  ljmo.features.ljmo = true;
  let vjmo = $e1c6bbc8cb416f8c$var$getGlyph(font, v3, glyph.features);
  vjmo.features.vjmo = true;
  let insert2 = [
    ljmo,
    vjmo
  ];
  if (t4 > $e1c6bbc8cb416f8c$var$T_BASE) {
    let tjmo = $e1c6bbc8cb416f8c$var$getGlyph(font, t4, glyph.features);
    tjmo.features.tjmo = true;
    insert2.push(tjmo);
  }
  glyphs.splice(i2, 1, ...insert2);
  return i2 + insert2.length - 1;
}
__name($e1c6bbc8cb416f8c$var$decompose, "$e1c6bbc8cb416f8c$var$decompose");
function $e1c6bbc8cb416f8c$var$compose(glyphs, i2, font) {
  let glyph = glyphs[i2];
  let code = glyphs[i2].codePoints[0];
  let type2 = $e1c6bbc8cb416f8c$var$getType(code);
  let prev = glyphs[i2 - 1].codePoints[0];
  let prevType = $e1c6bbc8cb416f8c$var$getType(prev);
  let lv, ljmo, vjmo, tjmo;
  if (prevType === $e1c6bbc8cb416f8c$var$LV && type2 === $e1c6bbc8cb416f8c$var$T) {
    lv = prev;
    tjmo = glyph;
  } else {
    if (type2 === $e1c6bbc8cb416f8c$var$V) {
      ljmo = glyphs[i2 - 1];
      vjmo = glyph;
    } else {
      ljmo = glyphs[i2 - 2];
      vjmo = glyphs[i2 - 1];
      tjmo = glyph;
    }
    let l4 = ljmo.codePoints[0];
    let v3 = vjmo.codePoints[0];
    if ($e1c6bbc8cb416f8c$var$isCombiningL(l4) && $e1c6bbc8cb416f8c$var$isCombiningV(v3)) lv = $e1c6bbc8cb416f8c$var$HANGUL_BASE + ((l4 - $e1c6bbc8cb416f8c$var$L_BASE) * $e1c6bbc8cb416f8c$var$V_COUNT + (v3 - $e1c6bbc8cb416f8c$var$V_BASE)) * $e1c6bbc8cb416f8c$var$T_COUNT;
  }
  let t4 = tjmo && tjmo.codePoints[0] || $e1c6bbc8cb416f8c$var$T_BASE;
  if (lv != null && (t4 === $e1c6bbc8cb416f8c$var$T_BASE || $e1c6bbc8cb416f8c$var$isCombiningT(t4))) {
    let s4 = lv + (t4 - $e1c6bbc8cb416f8c$var$T_BASE);
    if (font.hasGlyphForCodePoint(s4)) {
      let del = prevType === $e1c6bbc8cb416f8c$var$V ? 3 : 2;
      glyphs.splice(i2 - del + 1, del, $e1c6bbc8cb416f8c$var$getGlyph(font, s4, glyph.features));
      return i2 - del + 1;
    }
  }
  if (ljmo) ljmo.features.ljmo = true;
  if (vjmo) vjmo.features.vjmo = true;
  if (tjmo) tjmo.features.tjmo = true;
  if (prevType === $e1c6bbc8cb416f8c$var$LV) {
    $e1c6bbc8cb416f8c$var$decompose(glyphs, i2 - 1, font);
    return i2 + 1;
  }
  return i2;
}
__name($e1c6bbc8cb416f8c$var$compose, "$e1c6bbc8cb416f8c$var$compose");
function $e1c6bbc8cb416f8c$var$getLength(code) {
  switch ($e1c6bbc8cb416f8c$var$getType(code)) {
    case $e1c6bbc8cb416f8c$var$LV:
    case $e1c6bbc8cb416f8c$var$LVT:
      return 1;
    case $e1c6bbc8cb416f8c$var$V:
      return 2;
    case $e1c6bbc8cb416f8c$var$T:
      return 3;
  }
}
__name($e1c6bbc8cb416f8c$var$getLength, "$e1c6bbc8cb416f8c$var$getLength");
function $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i2, font) {
  let glyph = glyphs[i2];
  let code = glyphs[i2].codePoints[0];
  if (font.glyphForCodePoint(code).advanceWidth === 0) return;
  let prev = glyphs[i2 - 1].codePoints[0];
  let len = $e1c6bbc8cb416f8c$var$getLength(prev);
  glyphs.splice(i2, 1);
  return glyphs.splice(i2 - len, 0, glyph);
}
__name($e1c6bbc8cb416f8c$var$reorderToneMark, "$e1c6bbc8cb416f8c$var$reorderToneMark");
function $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i2, font) {
  let glyph = glyphs[i2];
  let code = glyphs[i2].codePoints[0];
  if (font.hasGlyphForCodePoint($e1c6bbc8cb416f8c$var$DOTTED_CIRCLE)) {
    let dottedCircle = $e1c6bbc8cb416f8c$var$getGlyph(font, $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE, glyph.features);
    let idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i2 : i2 + 1;
    glyphs.splice(idx, 0, dottedCircle);
    i2++;
  }
  return i2;
}
__name($e1c6bbc8cb416f8c$var$insertDottedCircle, "$e1c6bbc8cb416f8c$var$insertDottedCircle");
var $4b0735ca6c692ea5$exports = {};
$4b0735ca6c692ea5$exports = JSON.parse('{"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,14,15,16,17],[0,0,0,18,19,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,28,29,30,31,32,33,0,34,0,0,35,36,0,0,37,0],[0,0,0,38,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,39,0,0,0,40,41,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,12,43,0,0,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,0,43,0,0,0,0],[0,0,0,45,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,50,0,0,51,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,0],[0,0,0,53,54,55,56,57,58,0,59,0,0,60,61,0,0,62,0],[0,0,0,4,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,63,64,0,0,40,41,0,9,0,10,0,0,0,42,0,63,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,0,2,16,0],[0,0,0,18,65,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,0,0],[0,0,0,69,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,73,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,75,0,0,0,76,77,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,25,79,0,0,0,0],[0,0,0,18,19,20,74,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,81,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,86,0,0,87,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,0],[0,0,0,18,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,89,90,0,0,76,77,0,23,0,24,0,0,0,78,0,89,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,0,0],[0,0,0,94,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,96,0,0,0,97,98,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,35,100,0,0,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,102,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,107,0,0,108,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,109,0,0,0,0,0,0,0,0],[0,0,0,28,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,110,111,0,0,97,98,0,33,0,34,0,0,0,99,0,110,0,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,0,0],[0,0,0,0,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,0,0,115,116,117,118,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,39,0,122,0,123,123,8,9,0,10,0,0,0,42,0,39,0,0],[0,124,64,0,0,0,0,0,0,0,0,0,0,0,0,0,124,0,0],[0,39,0,0,0,121,125,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,126,126,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,47,47,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,128,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,129,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,50,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,134,0,0,0,0,0,0,0,0],[0,0,0,135,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,136,0,0,0,137,138,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,60,140,0,0,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,0,140,0,0,0,0],[0,0,0,142,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,147,0,0,148,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,149,0,0,0,0,0,0,0,0],[0,0,0,53,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,150,151,0,0,137,138,0,58,0,59,0,0,0,139,0,150,0,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,0,0],[0,0,0,155,116,156,157,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,75,3,4,5,159,160,8,161,0,162,0,11,12,163,0,75,16,0],[0,0,0,0,0,40,164,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,0,165,0,0,0,0],[0,124,64,0,0,40,164,0,9,0,10,0,0,0,42,0,124,0,0],[0,0,0,0,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,167,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,168,0,0,0,0,0,0,0,0],[0,0,0,0,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,0,79,0,0,0,0],[0,0,0,169,170,171,172,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,75,0,176,0,177,177,22,23,0,24,0,0,0,78,0,75,0,0],[0,178,90,0,0,0,0,0,0,0,0,0,0,0,0,0,178,0,0],[0,75,0,0,0,175,179,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,180,180,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,83,83,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,182,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,183,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,86,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,188,0,0,0,0,0,0,0,0],[0,0,0,189,170,190,191,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,76,193,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,0,194,0,0,0,0],[0,178,90,0,0,76,193,0,23,0,24,0,0,0,78,0,178,0,0],[0,0,0,0,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,195,196,197,198,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,96,0,202,0,203,203,32,33,0,34,0,0,0,99,0,96,0,0],[0,204,111,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0],[0,96,0,0,0,201,205,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,206,206,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,104,104,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,208,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,209,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,107,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,0,0,0],[0,0,0,215,196,216,217,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,97,219,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,0,220,0,0,0,0],[0,204,111,0,0,97,219,0,33,0,34,0,0,0,99,0,204,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,223,0,0,0,40,224,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,119,225,0,0,0,0],[0,0,0,115,116,117,222,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,115,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,226,64,0,0,40,224,0,9,0,10,0,0,0,42,0,226,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,39,0,0,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,44,44,8,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,227,0,228,229,0,9,0,10,0,0,230,0,0,0,0,0],[0,39,0,122,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,231,231,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,131,131,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,234,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,235,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,0,0,240,241,242,243,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,136,0,247,0,248,248,57,58,0,59,0,0,0,139,0,136,0,0],[0,249,151,0,0,0,0,0,0,0,0,0,0,0,0,0,249,0,0],[0,136,0,0,0,246,250,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,251,251,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,144,144,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,253,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,254,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,147,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,259,0,0,0,0,0,0,0,0],[0,0,0,260,241,261,262,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,137,264,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,0,265,0,0,0,0],[0,249,151,0,0,137,264,0,58,0,59,0,0,0,139,0,249,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,158,225,0,0,0,0],[0,0,0,155,116,156,222,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,155,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,43,266,266,8,161,0,24,0,0,12,267,0,0,0,0],[0,75,0,176,43,268,268,269,161,0,24,0,0,0,267,0,75,0,0],[0,0,0,0,0,270,0,0,271,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,272,0,0,0,0,0,0,0,0],[0,273,274,0,0,40,41,0,9,0,10,0,0,0,42,0,273,0,0],[0,0,0,40,0,123,123,8,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,121,275,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,276,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,279,0,0,0,76,280,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,173,281,0,0,0,0],[0,0,0,169,170,171,278,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,169,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,282,90,0,0,76,280,0,23,0,24,0,0,0,78,0,282,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,75,0,0,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,80,80,22,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,283,0,284,285,0,23,0,24,0,0,286,0,0,0,0,0],[0,75,0,176,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,287,287,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,288,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,185,185,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,290,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,291,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,192,281,0,0,0,0],[0,0,0,189,170,190,278,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,189,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,76,0,177,177,22,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,175,296,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,299,0,0,0,97,300,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,199,301,0,0,0,0],[0,0,0,195,196,197,298,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,195,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,302,111,0,0,97,300,0,33,0,34,0,0,0,99,0,302,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,96,0,0,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,101,101,32,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,303,0,304,305,0,33,0,34,0,0,306,0,0,0,0,0],[0,96,0,202,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,307,307,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,308,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,211,211,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,310,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,311,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,218,301,0,0,0,0],[0,0,0,215,196,216,298,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,215,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,97,0,203,203,32,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,201,316,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,0,225,0,0,0,0],[0,0,0,317,318,319,320,8,9,0,10,0,0,321,322,0,0,16,0],[0,223,0,323,0,123,123,8,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,0,0,121,324,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,325,318,326,327,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,64,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,230,0,0,0,0,0],[0,0,0,227,0,228,121,0,9,0,10,0,0,230,0,0,0,0,0],[0,0,0,227,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,0,0],[0,0,0,0,0,329,329,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,330,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,237,237,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,332,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,333,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,337,0,0,0,137,338,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,244,339,0,0,0,0],[0,0,0,240,241,242,336,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,240,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,340,151,0,0,137,338,0,58,0,59,0,0,0,139,0,340,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,136,0,0,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,141,141,57,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,341,0,342,343,0,58,0,59,0,0,344,0,0,0,0,0],[0,136,0,247,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,345,345,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,346,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,256,256,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,348,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,349,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,263,339,0,0,0,0],[0,0,0,260,241,261,336,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,260,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,137,0,248,248,57,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,246,354,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,126,126,8,23,0,0,0,0,0,0,0,0,0,0],[0,355,90,0,0,121,125,0,9,0,10,0,0,0,42,0,355,0,0],[0,0,0,0,0,356,356,269,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,357,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,270,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,363,0,0,0,0,0,0,0,0],[0,0,0,364,116,365,366,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,40,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,0,281,0,0,0,0],[0,0,0,369,370,371,372,22,23,0,24,0,0,373,374,0,0,27,0],[0,279,0,375,0,177,177,22,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,0,0,175,376,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,377,370,378,379,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,90,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,286,0,0,0,0,0],[0,0,0,283,0,284,175,0,23,0,24,0,0,286,0,0,0,0,0],[0,0,0,283,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,82,0,0],[0,0,0,0,0,381,381,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,382,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,293,293,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,384,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,385,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,76,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,0,301,0,0,0,0],[0,0,0,387,388,389,390,32,33,0,34,0,0,391,392,0,0,37,0],[0,299,0,393,0,203,203,32,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,0,0,201,394,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,395,388,396,397,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,111,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,306,0,0,0,0,0],[0,0,0,303,0,304,201,0,33,0,34,0,0,306,0,0,0,0,0],[0,0,0,303,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,0,0],[0,0,0,0,0,399,399,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,400,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,313,313,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,402,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,403,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,97,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,407,0,0,0,40,408,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,321,409,0,0,0,0],[0,0,0,317,318,319,406,8,9,0,10,0,0,321,322,0,0,16,0],[0,0,0,317,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,410,64,0,0,40,408,0,9,0,10,0,0,0,42,0,410,0,0],[0,223,0,0,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,323,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,328,409,0,0,0,0],[0,0,0,325,318,326,406,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,325,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,0,0,0,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0],[0,0,0,0,0,411,411,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,412,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,413,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,0,339,0,0,0,0],[0,0,0,414,415,416,417,57,58,0,59,0,0,418,419,0,0,62,0],[0,337,0,420,0,248,248,57,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,0,0,246,421,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,422,415,423,424,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,151,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,344,0,0,0,0,0],[0,0,0,341,0,342,246,0,58,0,59,0,0,344,0,0,0,0,0],[0,0,0,341,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,143,0,0],[0,0,0,0,0,426,426,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,427,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,351,351,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,429,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,430,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,137,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,432,116,433,434,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,0,0,180,180,269,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,359,359,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,437,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,438,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,443,274,0,0,0,0,0,0,0,0,0,0,0,0,0,443,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,367,225,0,0,0,0],[0,0,0,364,116,365,445,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,364,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,448,0,0,0,76,449,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,373,450,0,0,0,0],[0,0,0,369,370,371,447,22,23,0,24,0,0,373,374,0,0,27,0],[0,0,0,369,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,451,90,0,0,76,449,0,23,0,24,0,0,0,78,0,451,0,0],[0,279,0,0,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,375,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,380,450,0,0,0,0],[0,0,0,377,370,378,447,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,377,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,0,0,0,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,184,0,0],[0,0,0,0,0,452,452,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,453,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,454,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,457,0,0,0,97,458,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,391,459,0,0,0,0],[0,0,0,387,388,389,456,32,33,0,34,0,0,391,392,0,0,37,0],[0,0,0,387,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,460,111,0,0,97,458,0,33,0,34,0,0,0,99,0,460,0,0],[0,299,0,0,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,393,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,398,459,0,0,0,0],[0,0,0,395,388,396,456,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,395,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,0,0,0,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,210,0,0],[0,0,0,0,0,461,461,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,462,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,463,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,0,409,0,0,0,0],[0,0,0,464,465,466,467,8,9,0,10,0,0,468,469,0,0,16,0],[0,407,0,470,0,123,123,8,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,0,0,121,471,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,472,465,473,474,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,0,0,0,0,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,236,0,0],[0,0,0,0,0,0,476,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,479,0,0,0,137,480,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,418,481,0,0,0,0],[0,0,0,414,415,416,478,57,58,0,59,0,0,418,419,0,0,62,0],[0,0,0,414,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,482,151,0,0,137,480,0,58,0,59,0,0,0,139,0,482,0,0],[0,337,0,0,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,420,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,425,481,0,0,0,0],[0,0,0,422,415,423,478,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,422,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,0,0,0,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0],[0,0,0,0,0,483,483,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,484,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,485,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,435,225,0,0,0,0],[0,0,0,432,116,433,445,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,432,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,486,486,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,487,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,440,440,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,489,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,490,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,495,0,496,497,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,0,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,0,225,0,0,0,0],[0,0,0,0,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,0,450,0,0,0,0],[0,0,0,499,500,501,502,22,23,0,24,0,0,503,504,0,0,27,0],[0,448,0,505,0,177,177,22,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,0,0,175,506,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,507,500,508,509,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,0,0,0,0,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,292,0,0],[0,0,0,0,0,0,511,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,0,459,0,0,0,0],[0,0,0,512,513,514,515,32,33,0,34,0,0,516,517,0,0,37,0],[0,457,0,518,0,203,203,32,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,0,0,201,519,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,520,513,521,522,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,0,0,0,0,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,312,0,0],[0,0,0,0,0,0,524,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,527,0,0,0,40,528,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,468,529,0,0,0,0],[0,0,0,464,465,466,526,8,9,0,10,0,0,468,469,0,0,16,0],[0,0,0,464,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,530,64,0,0,40,528,0,9,0,10,0,0,0,42,0,530,0,0],[0,407,0,0,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,470,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,475,529,0,0,0,0],[0,0,0,472,465,473,526,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,472,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0],[0,0,0,0,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,0,481,0,0,0,0],[0,0,0,531,532,533,534,57,58,0,59,0,0,535,536,0,0,62,0],[0,479,0,537,0,248,248,57,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,0,0,246,538,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,539,532,540,541,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,0,0,0,0,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,350,0,0],[0,0,0,0,0,0,543,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,358,0,0],[0,0,0,0,0,544,544,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,545,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,492,492,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,547,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,548,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,274,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,498,0,0,0,0,0],[0,0,0,495,0,496,368,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,495,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,553,0,0,0,76,554,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,503,555,0,0,0,0],[0,0,0,499,500,501,552,22,23,0,24,0,0,503,504,0,0,27,0],[0,0,0,499,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,556,90,0,0,76,554,0,23,0,24,0,0,0,78,0,556,0,0],[0,448,0,0,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,505,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,510,555,0,0,0,0],[0,0,0,507,500,508,552,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,507,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,76,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,559,0,0,0,97,560,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,516,561,0,0,0,0],[0,0,0,512,513,514,558,32,33,0,34,0,0,516,517,0,0,37,0],[0,0,0,512,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,562,111,0,0,97,560,0,33,0,34,0,0,0,99,0,562,0,0],[0,457,0,0,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,518,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,523,561,0,0,0,0],[0,0,0,520,513,521,558,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,520,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,0,0],[0,0,0,0,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,0,529,0,0,0,0],[0,0,0,563,66,564,565,8,9,0,10,0,0,566,68,0,0,16,0],[0,527,0,567,0,123,123,8,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,0,0,121,568,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,569,66,570,571,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,575,0,0,0,137,576,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,535,577,0,0,0,0],[0,0,0,531,532,533,574,57,58,0,59,0,0,535,536,0,0,62,0],[0,0,0,531,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,578,151,0,0,137,576,0,58,0,59,0,0,0,139,0,578,0,0],[0,479,0,0,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,537,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,542,577,0,0,0,0],[0,0,0,539,532,540,574,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,539,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,137,0,0],[0,0,0,0,0,0,0,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,439,0,0],[0,0,0,0,0,579,579,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,580,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,581,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,0,555,0,0,0,0],[0,0,0,582,91,583,584,22,23,0,24,0,0,585,93,0,0,27,0],[0,553,0,586,0,177,177,22,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,0,0,175,587,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,588,91,589,590,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,0,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,0,561,0,0,0,0],[0,0,0,592,112,593,594,32,33,0,34,0,0,595,114,0,0,37,0],[0,559,0,596,0,203,203,32,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,0,0,201,597,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,598,112,599,600,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,566,165,0,0,0,0],[0,0,0,563,66,564,67,8,9,0,10,0,0,566,68,0,0,16,0],[0,0,0,563,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,527,0,0,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,567,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,572,165,0,0,0,0],[0,0,0,569,66,570,67,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,569,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,0,577,0,0,0,0],[0,0,0,603,152,604,605,57,58,0,59,0,0,606,154,0,0,62,0],[0,575,0,607,0,248,248,57,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,0,0,246,608,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,609,152,610,611,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,0,0,0,0,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,491,0,0],[0,0,0,0,0,0,613,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,585,194,0,0,0,0],[0,0,0,582,91,583,92,22,23,0,24,0,0,585,93,0,0,27,0],[0,0,0,582,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,553,0,0,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,586,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,591,194,0,0,0,0],[0,0,0,588,91,589,92,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,588,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,595,220,0,0,0,0],[0,0,0,592,112,593,113,32,33,0,34,0,0,595,114,0,0,37,0],[0,0,0,592,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,559,0,0,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,596,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,601,220,0,0,0,0],[0,0,0,598,112,599,113,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,598,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,606,265,0,0,0,0],[0,0,0,603,152,604,153,57,58,0,59,0,0,606,154,0,0,62,0],[0,0,0,603,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,575,0,0,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,607,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,612,265,0,0,0,0],[0,0,0,609,152,610,153,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,609,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,549,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0]],"accepting":[false,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,false,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,false,false,true,false,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,false,false,true,true,false,false,true,true,true,false,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,false,false,false,false,false,false,false,true,true,false,false,true,true,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,false,true,true,false,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,false,true,true,true,true,true,false,true,true,false,true,true,true],"tags":[[],["broken_cluster"],["consonant_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],[],["broken_cluster"],["symbol_cluster"],[],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["symbol_cluster"],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],[],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],[],[],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],["consonant_syllable"],["vowel_syllable"],["standalone_cluster"]]}');
var $aa333a9607471296$exports = {};
$aa333a9607471296$exports = JSON.parse('{"categories":["O","IND","S","GB","B","FM","CGJ","VMAbv","VMPst","VAbv","VPst","CMBlw","VPre","VBlw","H","VMBlw","CMAbv","MBlw","CS","R","SUB","MPst","MPre","FAbv","FPst","FBlw","null","SMAbv","SMBlw","VMPre","ZWNJ","ZWJ","WJ","M","VS","N","HN","MAbv"],"decompositions":{"2507":[2503,2494],"2508":[2503,2519],"2888":[2887,2902],"2891":[2887,2878],"2892":[2887,2903],"3018":[3014,3006],"3019":[3015,3006],"3020":[3014,3031],"3144":[3142,3158],"3264":[3263,3285],"3271":[3270,3285],"3272":[3270,3286],"3274":[3270,3266],"3275":[3270,3266,3285],"3402":[3398,3390],"3403":[3399,3390],"3404":[3398,3415],"3546":[3545,3530],"3548":[3545,3535],"3549":[3545,3535,3530],"3550":[3545,3551],"3635":[3661,3634],"3763":[3789,3762],"3955":[3953,3954],"3957":[3953,3956],"3958":[4018,3968],"3959":[4018,3953,3968],"3960":[4019,3968],"3961":[4019,3953,3968],"3969":[3953,3968],"6971":[6970,6965],"6973":[6972,6965],"6976":[6974,6965],"6977":[6975,6965],"6979":[6978,6965],"69934":[69937,69927],"69935":[69938,69927],"70475":[70471,70462],"70476":[70471,70487],"70843":[70841,70842],"70844":[70841,70832],"70846":[70841,70845],"71098":[71096,71087],"71099":[71097,71087]},"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,3,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,17,18,11,19,20,21,22,0,0,0,23,0,0,2,0,0,24,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,27,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,39,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,49,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,53,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,54,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0]],"accepting":[false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true],"tags":[[],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["symbol_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["virama_terminated_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["number_joiner_terminated_cluster"],["standard_cluster"],["standard_cluster"],["numeral_cluster"]]}');
var $90a9d3398ee54fe5$export$a513ea61a7bee91c = {
  X: 1,
  C: 2,
  V: 4,
  N: 8,
  H: 16,
  ZWNJ: 32,
  ZWJ: 64,
  M: 128,
  SM: 256,
  VD: 512,
  A: 1024,
  Placeholder: 2048,
  Dotted_Circle: 4096,
  RS: 8192,
  Coeng: 16384,
  Repha: 32768,
  Ra: 65536,
  CM: 131072,
  Symbol: 262144
  // Avagraha, etc that take marks (SM,A,VD).
};
var $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0 = {
  Start: 1,
  Ra_To_Become_Reph: 2,
  Pre_M: 4,
  Pre_C: 8,
  Base_C: 16,
  After_Main: 32,
  Above_C: 64,
  Before_Sub: 128,
  Below_C: 256,
  After_Sub: 512,
  Before_Post: 1024,
  Post_C: 2048,
  After_Post: 4096,
  Final_C: 8192,
  SMVD: 16384,
  End: 32768
};
var $90a9d3398ee54fe5$export$8519deaa7de2b07 = $90a9d3398ee54fe5$export$a513ea61a7bee91c.C | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Ra | $90a9d3398ee54fe5$export$a513ea61a7bee91c.CM | $90a9d3398ee54fe5$export$a513ea61a7bee91c.V | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Placeholder | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Dotted_Circle;
var $90a9d3398ee54fe5$export$bbcd928767338e0d = $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWJ | $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWNJ;
var $90a9d3398ee54fe5$export$ca9599b2a300afc = $90a9d3398ee54fe5$export$a513ea61a7bee91c.H | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Coeng;
var $90a9d3398ee54fe5$export$e99d119da76a0fc5 = {
  Default: {
    hasOldSpec: false,
    virama: 0,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Devanagari: {
    hasOldSpec: true,
    virama: 2381,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Bengali: {
    hasOldSpec: true,
    virama: 2509,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gurmukhi: {
    hasOldSpec: true,
    virama: 2637,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gujarati: {
    hasOldSpec: true,
    virama: 2765,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Oriya: {
    hasOldSpec: true,
    virama: 2893,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Tamil: {
    hasOldSpec: true,
    virama: 3021,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Telugu: {
    hasOldSpec: true,
    virama: 3149,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Explicit",
    blwfMode: "Post_Only"
  },
  Kannada: {
    hasOldSpec: true,
    virama: 3277,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Implicit",
    blwfMode: "Post_Only"
  },
  Malayalam: {
    hasOldSpec: true,
    virama: 3405,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
    rephMode: "Log_Repha",
    blwfMode: "Pre_And_Post"
  },
  // Handled by UniversalShaper
  // Sinhala: {
  //   hasOldSpec: false,
  //   virama: 0x0DCA,
  //   basePos: 'Last_Sinhala',
  //   rephPos: POSITIONS.After_Main,
  //   rephMode: 'Explicit',
  //   blwfMode: 'Pre_And_Post'
  // },
  Khmer: {
    hasOldSpec: false,
    virama: 6098,
    basePos: "First",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Ra_To_Become_Reph,
    rephMode: "Vis_Repha",
    blwfMode: "Pre_And_Post"
  }
};
var $90a9d3398ee54fe5$export$f647c9cfdd77d95a = {
  // Khmer
  6078: [
    6081,
    6078
  ],
  6079: [
    6081,
    6079
  ],
  6080: [
    6081,
    6080
  ],
  6084: [
    6081,
    6084
  ],
  6085: [
    6081,
    6085
  ]
};
var { decompositions: $7826f90f6f0cecc9$var$decompositions } = (0, /* @__PURE__ */ $parcel$interopDefault2($aa333a9607471296$exports));
var $7826f90f6f0cecc9$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("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"));
var $7826f90f6f0cecc9$var$stateMachine = new (0, import_dfa.default)((0, /* @__PURE__ */ $parcel$interopDefault2($4b0735ca6c692ea5$exports)));
var $7826f90f6f0cecc9$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static {
    __name(this, "$7826f90f6f0cecc9$export$2e2bcd8739ae039");
  }
  static planFeatures(plan) {
    plan.addStage($7826f90f6f0cecc9$var$setupSyllables);
    plan.addStage([
      "locl",
      "ccmp"
    ]);
    plan.addStage($7826f90f6f0cecc9$var$initialReordering);
    plan.addStage("nukt");
    plan.addStage("akhn");
    plan.addStage("rphf", false);
    plan.addStage("rkrf");
    plan.addStage("pref", false);
    plan.addStage("blwf", false);
    plan.addStage("abvf", false);
    plan.addStage("half", false);
    plan.addStage("pstf", false);
    plan.addStage("vatu");
    plan.addStage("cjct");
    plan.addStage("cfar", false);
    plan.addStage($7826f90f6f0cecc9$var$finalReordering);
    plan.addStage({
      local: [
        "init"
      ],
      global: [
        "pres",
        "abvs",
        "blws",
        "psts",
        "haln",
        "dist",
        "abvm",
        "blwm",
        "calt",
        "clig"
      ]
    });
    plan.unicodeScript = $130d1a642ebcd2b7$export$ce50e82f12a827a4(plan.script);
    plan.indicConfig = (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5)[plan.unicodeScript] || (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5).Default;
    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== "2";
  }
  static assignFeatures(plan, glyphs) {
    for (let i2 = glyphs.length - 1; i2 >= 0; i2--) {
      let codepoint = glyphs[i2].codePoints[0];
      let d3 = (0, $90a9d3398ee54fe5$export$f647c9cfdd77d95a)[codepoint] || $7826f90f6f0cecc9$var$decompositions[codepoint];
      if (d3) {
        let decomposed = d3.map((c2) => {
          let g = plan.font.glyphForCodePoint(c2);
          return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g.id, [
            c2
          ], glyphs[i2].features);
        });
        glyphs.splice(i2, 1, ...decomposed);
      }
    }
  }
};
(0, _define_property)($7826f90f6f0cecc9$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
function $7826f90f6f0cecc9$var$indicCategory(glyph) {
  return $7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) >> 8;
}
__name($7826f90f6f0cecc9$var$indicCategory, "$7826f90f6f0cecc9$var$indicCategory");
function $7826f90f6f0cecc9$var$indicPosition(glyph) {
  return 1 << ($7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) & 255);
}
__name($7826f90f6f0cecc9$var$indicPosition, "$7826f90f6f0cecc9$var$indicPosition");
var $7826f90f6f0cecc9$var$IndicInfo = class {
  static {
    __name(this, "$7826f90f6f0cecc9$var$IndicInfo");
  }
  constructor(category, position, syllableType, syllable) {
    this.category = category;
    this.position = position;
    this.syllableType = syllableType;
    this.syllable = syllable;
  }
};
function $7826f90f6f0cecc9$var$setupSyllables(font, glyphs) {
  let syllable = 0;
  let last2 = 0;
  for (let [start2, end2, tags2] of $7826f90f6f0cecc9$var$stateMachine.match(glyphs.map($7826f90f6f0cecc9$var$indicCategory))) {
    if (start2 > last2) {
      ++syllable;
      for (let i2 = last2; i2 < start2; i2++) glyphs[i2].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
    }
    ++syllable;
    for (let i2 = start2; i2 <= end2; i2++) glyphs[i2].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(glyphs[i2]), $7826f90f6f0cecc9$var$indicPosition(glyphs[i2]), tags2[0], syllable);
    last2 = end2 + 1;
  }
  if (last2 < glyphs.length) {
    ++syllable;
    for (let i2 = last2; i2 < glyphs.length; i2++) glyphs[i2].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
  }
}
__name($7826f90f6f0cecc9$var$setupSyllables, "$7826f90f6f0cecc9$var$setupSyllables");
function $7826f90f6f0cecc9$var$isConsonant(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$8519deaa7de2b07);
}
__name($7826f90f6f0cecc9$var$isConsonant, "$7826f90f6f0cecc9$var$isConsonant");
function $7826f90f6f0cecc9$var$isJoiner(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$bbcd928767338e0d);
}
__name($7826f90f6f0cecc9$var$isJoiner, "$7826f90f6f0cecc9$var$isJoiner");
function $7826f90f6f0cecc9$var$isHalantOrCoeng(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$ca9599b2a300afc);
}
__name($7826f90f6f0cecc9$var$isHalantOrCoeng, "$7826f90f6f0cecc9$var$isHalantOrCoeng");
function $7826f90f6f0cecc9$var$wouldSubstitute(glyphs, feature) {
  for (let glyph of glyphs) glyph.features = {
    [feature]: true
  };
  let GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;
  GSUB.applyFeatures([
    feature
  ], glyphs);
  return glyphs.length === 1;
}
__name($7826f90f6f0cecc9$var$wouldSubstitute, "$7826f90f6f0cecc9$var$wouldSubstitute");
function $7826f90f6f0cecc9$var$consonantPosition(font, consonant, virama) {
  let glyphs = [
    virama,
    consonant,
    virama
  ];
  if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "blwf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "blwf")) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;
  else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pstf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pstf")) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;
  else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pref") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pref")) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;
  return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
}
__name($7826f90f6f0cecc9$var$consonantPosition, "$7826f90f6f0cecc9$var$consonantPosition");
function $7826f90f6f0cecc9$var$initialReordering(font, glyphs, plan) {
  let indicConfig = plan.indicConfig;
  let features2 = font._layoutEngine.engine.GSUBProcessor.features;
  let dottedCircle = font.glyphForCodePoint(9676).id;
  let virama = font.glyphForCodePoint(indicConfig.virama).id;
  if (virama) {
    let info3 = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, virama, [
      indicConfig.virama
    ]);
    for (let i2 = 0; i2 < glyphs.length; i2++) if (glyphs[i2].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) glyphs[i2].shaperInfo.position = $7826f90f6f0cecc9$var$consonantPosition(font, glyphs[i2].copy(), info3);
  }
  for (let start2 = 0, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start2 < glyphs.length; start2 = end2, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start2)) {
    let { category, syllableType } = glyphs[start2].shaperInfo;
    if (syllableType === "symbol_cluster" || syllableType === "non_indic_cluster") continue;
    if (syllableType === "broken_cluster" && dottedCircle) {
      let g = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, dottedCircle, [
        9676
      ]);
      g.shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(g), $7826f90f6f0cecc9$var$indicPosition(g), glyphs[start2].shaperInfo.syllableType, glyphs[start2].shaperInfo.syllable);
      let i2 = start2;
      while (i2 < end2 && glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha) i2++;
      glyphs.splice(i2++, 0, g);
      end2++;
    }
    let base = end2;
    let limit = start2;
    let hasReph = false;
    if (indicConfig.rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && features2.rphf && start2 + 3 <= end2 && (indicConfig.rephMode === "Implicit" && !$7826f90f6f0cecc9$var$isJoiner(glyphs[start2 + 2]) || indicConfig.rephMode === "Explicit" && glyphs[start2 + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {
      let g = [
        glyphs[start2].copy(),
        glyphs[start2 + 1].copy(),
        glyphs[start2 + 2].copy()
      ];
      if ($7826f90f6f0cecc9$var$wouldSubstitute(g.slice(0, 2), "rphf") || indicConfig.rephMode === "Explicit" && $7826f90f6f0cecc9$var$wouldSubstitute(g, "rphf")) {
        limit += 2;
        while (limit < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit])) limit++;
        base = start2;
        hasReph = true;
      }
    } else if (indicConfig.rephMode === "Log_Repha" && glyphs[start2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha) {
      limit++;
      while (limit < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit])) limit++;
      base = start2;
      hasReph = true;
    }
    switch (indicConfig.basePos) {
      case "Last": {
        let i2 = end2;
        let seenBelow = false;
        do {
          let info3 = glyphs[--i2].shaperInfo;
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i2])) {
            if (info3.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C && (info3.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C || seenBelow)) {
              base = i2;
              break;
            }
            if (info3.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C) seenBelow = true;
            base = i2;
          } else if (start2 < i2 && info3.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ && glyphs[i2 - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) break;
        } while (i2 > limit);
        break;
      }
      case "First":
        base = start2;
        for (let i2 = base + 1; i2 < end2; i2++) if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i2])) glyphs[i2].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;
    }
    if (hasReph && base === start2 && limit - base <= 2) hasReph = false;
    for (let i2 = start2; i2 < base; i2++) {
      let info3 = glyphs[i2].shaperInfo;
      info3.position = Math.min((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_C, info3.position);
    }
    if (base < end2) glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
    for (let i2 = base + 1; i2 < end2; i2++) if (glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
      for (let j = i2 + 1; j < end2; j++) if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j])) {
        glyphs[j].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Final_C;
        break;
      }
      break;
    }
    if (hasReph) glyphs[start2].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph;
    if (plan.isOldSpec) {
      let disallowDoubleHalants = plan.unicodeScript !== "Malayalam";
      for (let i2 = base + 1; i2 < end2; i2++) if (glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) {
        let j;
        for (j = end2 - 1; j > i2; j--) {
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j]) || disallowDoubleHalants && glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) break;
        }
        if (glyphs[j].shaperInfo.category !== (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && j > i2) {
          let t4 = glyphs[i2];
          glyphs.splice(i2, 0, ...glyphs.splice(i2 + 1, j - i2));
          glyphs[j] = t4;
        }
        break;
      }
    }
    let lastPos = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Start;
    for (let i2 = start2; i2 < end2; i2++) {
      let info3 = glyphs[i2].shaperInfo;
      if (info3.category & ((0, $90a9d3398ee54fe5$export$bbcd928767338e0d) | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).RS | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).CM | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc) & info3.category)) {
        info3.position = lastPos;
        if (info3.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && info3.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          for (let j = i2; j > start2; j--) if (glyphs[j - 1].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
            info3.position = glyphs[j - 1].shaperInfo.position;
            break;
          }
        }
      } else if (info3.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) lastPos = info3.position;
    }
    let last2 = base;
    for (let i2 = base + 1; i2 < end2; i2++) {
      if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i2])) {
        for (let j = last2 + 1; j < i2; j++) if (glyphs[j].shaperInfo.position < (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) glyphs[j].shaperInfo.position = glyphs[i2].shaperInfo.position;
        last2 = i2;
      } else if (glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) last2 = i2;
    }
    let arr = glyphs.slice(start2, end2);
    arr.sort((a4, b3) => a4.shaperInfo.position - b3.shaperInfo.position);
    glyphs.splice(start2, arr.length, ...arr);
    for (let i2 = start2; i2 < end2; i2++) if (glyphs[i2].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {
      base = i2;
      break;
    }
    for (let i2 = start2; i2 < end2 && glyphs[i2].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph; i2++) glyphs[i2].features.rphf = true;
    let blwf = !plan.isOldSpec && indicConfig.blwfMode === "Pre_And_Post";
    for (let i2 = start2; i2 < base; i2++) {
      glyphs[i2].features.half = true;
      if (blwf) glyphs[i2].features.blwf = true;
    }
    for (let i2 = base + 1; i2 < end2; i2++) {
      glyphs[i2].features.abvf = true;
      glyphs[i2].features.pstf = true;
      glyphs[i2].features.blwf = true;
    }
    if (plan.isOldSpec && plan.unicodeScript === "Devanagari") {
      for (let i2 = start2; i2 + 1 < base; i2++) if (glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Ra && glyphs[i2 + 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && (i2 + 1 === base || glyphs[i2 + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {
        glyphs[i2].features.blwf = true;
        glyphs[i2 + 1].features.blwf = true;
      }
    }
    let prefLen = 2;
    if (features2.pref && base + prefLen < end2)
      for (let i2 = base + 1; i2 + prefLen - 1 < end2; i2++) {
        let g = [
          glyphs[i2].copy(),
          glyphs[i2 + 1].copy()
        ];
        if ($7826f90f6f0cecc9$var$wouldSubstitute(g, "pref")) {
          for (let j = 0; j < prefLen; j++) glyphs[i2++].features.pref = true;
          if (features2.cfar) for (; i2 < end2; i2++) glyphs[i2].features.cfar = true;
          break;
        }
      }
    for (let i2 = start2 + 1; i2 < end2; i2++) if ($7826f90f6f0cecc9$var$isJoiner(glyphs[i2])) {
      let nonJoiner = glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWNJ;
      let j = i2;
      do {
        j--;
        if (nonJoiner) delete glyphs[j].features.half;
      } while (j > start2 && !$7826f90f6f0cecc9$var$isConsonant(glyphs[j]));
    }
  }
}
__name($7826f90f6f0cecc9$var$initialReordering, "$7826f90f6f0cecc9$var$initialReordering");
function $7826f90f6f0cecc9$var$finalReordering(font, glyphs, plan) {
  let indicConfig = plan.indicConfig;
  let features2 = font._layoutEngine.engine.GSUBProcessor.features;
  for (let start2 = 0, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start2 < glyphs.length; start2 = end2, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start2)) {
    let tryPref = !!features2.pref;
    let base = start2;
    for (; base < end2; base++) if (glyphs[base].shaperInfo.position >= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {
      if (tryPref && base + 1 < end2) {
        for (let i2 = base + 1; i2 < end2; i2++) if (glyphs[i2].features.pref) {
          if (!(glyphs[i2].substituted && glyphs[i2].isLigated && !glyphs[i2].isMultiplied)) {
            base = i2;
            while (base < end2 && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[base])) base++;
            glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).BASE_C;
            tryPref = false;
          }
          break;
        }
      }
      if (plan.unicodeScript === "Malayalam") for (let i2 = base + 1; i2 < end2; i2++) {
        while (i2 < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[i2])) i2++;
        if (i2 === end2 || !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[i2])) break;
        i2++;
        while (i2 < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[i2])) i2++;
        if (i2 < end2 && $7826f90f6f0cecc9$var$isConsonant(glyphs[i2]) && glyphs[i2].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C) {
          base = i2;
          glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
        }
      }
      if (start2 < base && glyphs[base].shaperInfo.position > (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) base--;
      break;
    }
    if (base === end2 && start2 < base && glyphs[base - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ) base--;
    if (base < end2) while (start2 < base && glyphs[base].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc))) base--;
    if (start2 + 1 < end2 && start2 < base) {
      let newPos = base === end2 ? base - 2 : base - 1;
      if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
        while (newPos > start2 && !(glyphs[newPos].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc)))) newPos--;
        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          if (newPos + 1 < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos + 1])) newPos++;
        } else newPos = start2;
      }
      if (start2 < newPos && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
        for (let i2 = newPos; i2 > start2; i2--) if (glyphs[i2 - 1].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          let oldPos = i2 - 1;
          if (oldPos < base && base <= newPos) base--;
          let tmp = glyphs[oldPos];
          glyphs.splice(oldPos, 0, ...glyphs.splice(oldPos + 1, newPos - oldPos));
          glyphs[newPos] = tmp;
          newPos--;
        }
      }
    }
    if (start2 + 1 < end2 && glyphs[start2].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && glyphs[start2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha !== (glyphs[start2].isLigated && !glyphs[start2].isMultiplied)) {
      let newRephPos;
      let rephPos = indicConfig.rephPos;
      let found = false;
      if (rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post) {
        newRephPos = start2 + 1;
        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) newRephPos++;
        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1])) newRephPos++;
          found = true;
        }
        if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main) {
          newRephPos = base;
          while (newRephPos + 1 < end2 && glyphs[newRephPos + 1].shaperInfo.position <= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main) newRephPos++;
          found = newRephPos < end2;
        }
        if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Sub) {
          newRephPos = base;
          while (newRephPos + 1 < end2 && !(glyphs[newRephPos + 1].shaperInfo.position & ((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD))) newRephPos++;
          found = newRephPos < end2;
        }
      }
      if (!found) {
        newRephPos = start2 + 1;
        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) newRephPos++;
        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1])) newRephPos++;
          found = true;
        }
      }
      if (!found) {
        newRephPos = end2 - 1;
        while (newRephPos > start2 && glyphs[newRephPos].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) newRephPos--;
        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          for (let i2 = base + 1; i2 < newRephPos; i2++) if (glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) newRephPos--;
        }
      }
      let reph = glyphs[start2];
      glyphs.splice(start2, 0, ...glyphs.splice(start2 + 1, newRephPos - start2));
      glyphs[newRephPos] = reph;
      if (start2 < base && base <= newRephPos) base--;
    }
    if (tryPref && base + 1 < end2) {
      for (let i2 = base + 1; i2 < end2; i2++) if (glyphs[i2].features.pref) {
        if (glyphs[i2].isLigated && !glyphs[i2].isMultiplied) {
          let newPos = base;
          if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
            while (newPos > start2 && !(glyphs[newPos - 1].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc)))) newPos--;
            if (newPos > start2 && glyphs[newPos - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
              let oldPos2 = i2;
              for (let j = base + 1; j < oldPos2; j++) if (glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
                newPos--;
                break;
              }
            }
          }
          if (newPos > start2 && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos - 1])) {
            if (newPos < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos])) newPos++;
          }
          let oldPos = i2;
          let tmp = glyphs[oldPos];
          glyphs.splice(newPos + 1, 0, ...glyphs.splice(newPos, oldPos - newPos));
          glyphs[newPos] = tmp;
          if (newPos <= base && base < oldPos) base++;
        }
        break;
      }
    }
    if (glyphs[start2].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M && (!start2 || !/Cf|Mn/.test((0, $747425b437e121da$export$410364bbb673ddbc)(glyphs[start2 - 1].codePoints[0])))) glyphs[start2].features.init = true;
  }
}
__name($7826f90f6f0cecc9$var$finalReordering, "$7826f90f6f0cecc9$var$finalReordering");
function $7826f90f6f0cecc9$var$nextSyllable(glyphs, start2) {
  if (start2 >= glyphs.length) return start2;
  let syllable = glyphs[start2].shaperInfo.syllable;
  while (++start2 < glyphs.length && glyphs[start2].shaperInfo.syllable === syllable) ;
  return start2;
}
__name($7826f90f6f0cecc9$var$nextSyllable, "$7826f90f6f0cecc9$var$nextSyllable");
var { categories: $7ab494fe977143c6$var$categories, decompositions: $7ab494fe977143c6$var$decompositions } = (0, /* @__PURE__ */ $parcel$interopDefault2($aa333a9607471296$exports));
var $7ab494fe977143c6$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("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"));
var $7ab494fe977143c6$var$stateMachine = new (0, import_dfa.default)((0, /* @__PURE__ */ $parcel$interopDefault2($aa333a9607471296$exports)));
var $7ab494fe977143c6$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static {
    __name(this, "$7ab494fe977143c6$export$2e2bcd8739ae039");
  }
  static planFeatures(plan) {
    plan.addStage($7ab494fe977143c6$var$setupSyllables);
    plan.addStage([
      "locl",
      "ccmp",
      "nukt",
      "akhn"
    ]);
    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
    plan.addStage([
      "rphf"
    ], false);
    plan.addStage($7ab494fe977143c6$var$recordRphf);
    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
    plan.addStage([
      "pref"
    ]);
    plan.addStage($7ab494fe977143c6$var$recordPref);
    plan.addStage([
      "rkrf",
      "abvf",
      "blwf",
      "half",
      "pstf",
      "vatu",
      "cjct"
    ]);
    plan.addStage($7ab494fe977143c6$var$reorder);
    plan.addStage([
      "abvs",
      "blws",
      "pres",
      "psts",
      "dist",
      "abvm",
      "blwm"
    ]);
  }
  static assignFeatures(plan, glyphs) {
    for (let i2 = glyphs.length - 1; i2 >= 0; i2--) {
      let codepoint = glyphs[i2].codePoints[0];
      if ($7ab494fe977143c6$var$decompositions[codepoint]) {
        let decomposed = $7ab494fe977143c6$var$decompositions[codepoint].map((c2) => {
          let g = plan.font.glyphForCodePoint(c2);
          return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g.id, [
            c2
          ], glyphs[i2].features);
        });
        glyphs.splice(i2, 1, ...decomposed);
      }
    }
  }
};
(0, _define_property)($7ab494fe977143c6$export$2e2bcd8739ae039, "zeroMarkWidths", "BEFORE_GPOS");
function $7ab494fe977143c6$var$useCategory(glyph) {
  return $7ab494fe977143c6$var$trie.get(glyph.codePoints[0]);
}
__name($7ab494fe977143c6$var$useCategory, "$7ab494fe977143c6$var$useCategory");
var $7ab494fe977143c6$var$USEInfo = class {
  static {
    __name(this, "$7ab494fe977143c6$var$USEInfo");
  }
  constructor(category, syllableType, syllable) {
    this.category = category;
    this.syllableType = syllableType;
    this.syllable = syllable;
  }
};
function $7ab494fe977143c6$var$setupSyllables(font, glyphs) {
  let syllable = 0;
  for (let [start2, end2, tags2] of $7ab494fe977143c6$var$stateMachine.match(glyphs.map($7ab494fe977143c6$var$useCategory))) {
    ++syllable;
    for (let i2 = start2; i2 <= end2; i2++) glyphs[i2].shaperInfo = new $7ab494fe977143c6$var$USEInfo($7ab494fe977143c6$var$categories[$7ab494fe977143c6$var$useCategory(glyphs[i2])], tags2[0], syllable);
    let limit = glyphs[start2].shaperInfo.category === "R" ? 1 : Math.min(3, end2 - start2);
    for (let i2 = start2; i2 < start2 + limit; i2++) glyphs[i2].features.rphf = true;
  }
}
__name($7ab494fe977143c6$var$setupSyllables, "$7ab494fe977143c6$var$setupSyllables");
function $7ab494fe977143c6$var$clearSubstitutionFlags(font, glyphs) {
  for (let glyph of glyphs) glyph.substituted = false;
}
__name($7ab494fe977143c6$var$clearSubstitutionFlags, "$7ab494fe977143c6$var$clearSubstitutionFlags");
function $7ab494fe977143c6$var$recordRphf(font, glyphs) {
  for (let glyph of glyphs) if (glyph.substituted && glyph.features.rphf)
    glyph.shaperInfo.category = "R";
}
__name($7ab494fe977143c6$var$recordRphf, "$7ab494fe977143c6$var$recordRphf");
function $7ab494fe977143c6$var$recordPref(font, glyphs) {
  for (let glyph of glyphs) if (glyph.substituted)
    glyph.shaperInfo.category = "VPre";
}
__name($7ab494fe977143c6$var$recordPref, "$7ab494fe977143c6$var$recordPref");
function $7ab494fe977143c6$var$reorder(font, glyphs) {
  let dottedCircle = font.glyphForCodePoint(9676).id;
  for (let start2 = 0, end2 = $7ab494fe977143c6$var$nextSyllable(glyphs, 0); start2 < glyphs.length; start2 = end2, end2 = $7ab494fe977143c6$var$nextSyllable(glyphs, start2)) {
    let i2, j;
    let info3 = glyphs[start2].shaperInfo;
    let type2 = info3.syllableType;
    if (type2 !== "virama_terminated_cluster" && type2 !== "standard_cluster" && type2 !== "broken_cluster") continue;
    if (type2 === "broken_cluster" && dottedCircle) {
      let g = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, dottedCircle, [
        9676
      ]);
      g.shaperInfo = info3;
      for (i2 = start2; i2 < end2 && glyphs[i2].shaperInfo.category === "R"; i2++) ;
      glyphs.splice(++i2, 0, g);
      end2++;
    }
    if (info3.category === "R" && end2 - start2 > 1)
      for (i2 = start2 + 1; i2 < end2; i2++) {
        info3 = glyphs[i2].shaperInfo;
        if ($7ab494fe977143c6$var$isBase(info3) || $7ab494fe977143c6$var$isHalant(glyphs[i2])) {
          if ($7ab494fe977143c6$var$isHalant(glyphs[i2])) i2--;
          glyphs.splice(start2, 0, ...glyphs.splice(start2 + 1, i2 - start2), glyphs[i2]);
          break;
        }
      }
    for (i2 = start2, j = end2; i2 < end2; i2++) {
      info3 = glyphs[i2].shaperInfo;
      if ($7ab494fe977143c6$var$isBase(info3) || $7ab494fe977143c6$var$isHalant(glyphs[i2]))
        j = $7ab494fe977143c6$var$isHalant(glyphs[i2]) ? i2 + 1 : i2;
      else if ((info3.category === "VPre" || info3.category === "VMPre") && j < i2) glyphs.splice(j, 1, glyphs[i2], ...glyphs.splice(j, i2 - j));
    }
  }
}
__name($7ab494fe977143c6$var$reorder, "$7ab494fe977143c6$var$reorder");
function $7ab494fe977143c6$var$nextSyllable(glyphs, start2) {
  if (start2 >= glyphs.length) return start2;
  let syllable = glyphs[start2].shaperInfo.syllable;
  while (++start2 < glyphs.length && glyphs[start2].shaperInfo.syllable === syllable) ;
  return start2;
}
__name($7ab494fe977143c6$var$nextSyllable, "$7ab494fe977143c6$var$nextSyllable");
function $7ab494fe977143c6$var$isHalant(glyph) {
  return glyph.shaperInfo.category === "H" && !glyph.isLigated;
}
__name($7ab494fe977143c6$var$isHalant, "$7ab494fe977143c6$var$isHalant");
function $7ab494fe977143c6$var$isBase(info3) {
  return info3.category === "B" || info3.category === "GB";
}
__name($7ab494fe977143c6$var$isBase, "$7ab494fe977143c6$var$isBase");
var $102b6fe50f1d50b4$var$SHAPERS = {
  arab: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mong: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  syrc: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  "nko ": (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  phag: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mand: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mani: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  phlp: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  hang: (0, $e1c6bbc8cb416f8c$export$2e2bcd8739ae039),
  bng2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  beng: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  dev2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  deva: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gjr2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gujr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  guru: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gur2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  knda: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  knd2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  mlm2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  mlym: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  ory2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  orya: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  taml: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  tml2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  telu: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  tel2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  khmr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  bali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  batk: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  brah: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  bugi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  buhd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  cakm: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  cham: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  dupl: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  egyp: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  gran: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  hano: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  java: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  kthi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  kali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  khar: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  khoj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sind: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  lepc: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  limb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  mahj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // mand: UniversalShaper, // Mandaic
  // mani: UniversalShaper, // Manichaean
  mtei: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  modi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // mong: UniversalShaper, // Mongolian
  // 'nko ': UniversalShaper, // NKo
  hmng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // phag: UniversalShaper, // Phags-pa
  // phlp: UniversalShaper, // Psalter Pahlavi
  rjng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  saur: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  shrd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sidd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sinh: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  sund: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sylo: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tglg: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tagb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tale: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  lana: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tavt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  takr: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tibt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tfng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tirh: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  latn: (0, $649970d87335b30f$export$2e2bcd8739ae039),
  DFLT: (0, $649970d87335b30f$export$2e2bcd8739ae039)
};
function $102b6fe50f1d50b4$export$7877a478dd30fd3d(script) {
  if (!Array.isArray(script)) script = [
    script
  ];
  for (let s4 of script) {
    let shaper = $102b6fe50f1d50b4$var$SHAPERS[s4];
    if (shaper) return shaper;
  }
  return 0, $649970d87335b30f$export$2e2bcd8739ae039;
}
__name($102b6fe50f1d50b4$export$7877a478dd30fd3d, "$102b6fe50f1d50b4$export$7877a478dd30fd3d");
var $0a876c45f1f7c41c$export$2e2bcd8739ae039 = class extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {
  static {
    __name(this, "$0a876c45f1f7c41c$export$2e2bcd8739ae039");
  }
  applyLookup(lookupType, table3) {
    switch (lookupType) {
      case 1: {
        let index2 = this.coverageIndex(table3.coverage);
        if (index2 === -1) return false;
        let glyph = this.glyphIterator.cur;
        switch (table3.version) {
          case 1:
            glyph.id = glyph.id + table3.deltaGlyphID & 65535;
            break;
          case 2:
            glyph.id = table3.substitute.get(index2);
            break;
        }
        return true;
      }
      case 2: {
        let index2 = this.coverageIndex(table3.coverage);
        if (index2 !== -1) {
          let sequence = table3.sequences.get(index2);
          if (sequence.length === 0) {
            this.glyphs.splice(this.glyphIterator.index, 1);
            return true;
          }
          this.glyphIterator.cur.id = sequence[0];
          this.glyphIterator.cur.ligatureComponent = 0;
          let features2 = this.glyphIterator.cur.features;
          let curGlyph = this.glyphIterator.cur;
          let replacement = sequence.slice(1).map((gid, i2) => {
            let glyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, gid, void 0, features2);
            glyph.shaperInfo = curGlyph.shaperInfo;
            glyph.isLigated = curGlyph.isLigated;
            glyph.ligatureComponent = i2 + 1;
            glyph.substituted = true;
            glyph.isMultiplied = true;
            return glyph;
          });
          this.glyphs.splice(this.glyphIterator.index + 1, 0, ...replacement);
          return true;
        }
        return false;
      }
      case 3: {
        let index2 = this.coverageIndex(table3.coverage);
        if (index2 !== -1) {
          let USER_INDEX = 0;
          this.glyphIterator.cur.id = table3.alternateSet.get(index2)[USER_INDEX];
          return true;
        }
        return false;
      }
      case 4: {
        let index2 = this.coverageIndex(table3.coverage);
        if (index2 === -1) return false;
        for (let ligature of table3.ligatureSets.get(index2)) {
          let matched = this.sequenceMatchIndices(1, ligature.components);
          if (!matched) continue;
          let curGlyph = this.glyphIterator.cur;
          let characters2 = curGlyph.codePoints.slice();
          for (let index3 of matched) characters2.push(...this.glyphs[index3].codePoints);
          let ligatureGlyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, ligature.glyph, characters2, curGlyph.features);
          ligatureGlyph.shaperInfo = curGlyph.shaperInfo;
          ligatureGlyph.isLigated = true;
          ligatureGlyph.substituted = true;
          let isMarkLigature = curGlyph.isMark;
          for (let i2 = 0; i2 < matched.length && isMarkLigature; i2++) isMarkLigature = this.glyphs[matched[i2]].isMark;
          ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;
          let lastLigID = curGlyph.ligatureID;
          let lastNumComps = curGlyph.codePoints.length;
          let curComps = lastNumComps;
          let idx = this.glyphIterator.index + 1;
          for (let matchIndex of matched) {
            if (isMarkLigature) idx = matchIndex;
            else while (idx < matchIndex) {
              var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);
              this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;
              this.glyphs[idx].ligatureComponent = ligatureComponent;
              idx++;
            }
            lastLigID = this.glyphs[idx].ligatureID;
            lastNumComps = this.glyphs[idx].codePoints.length;
            curComps += lastNumComps;
            idx++;
          }
          if (lastLigID && !isMarkLigature) for (let i2 = idx; i2 < this.glyphs.length; i2++) {
            if (this.glyphs[i2].ligatureID === lastLigID) {
              var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i2].ligatureComponent || 1, lastNumComps);
              this.glyphs[i2].ligatureComponent = ligatureComponent;
            } else break;
          }
          for (let i2 = matched.length - 1; i2 >= 0; i2--) this.glyphs.splice(matched[i2], 1);
          this.glyphs[this.glyphIterator.index] = ligatureGlyph;
          return true;
        }
        return false;
      }
      case 5:
        return this.applyContext(table3);
      case 6:
        return this.applyChainingContext(table3);
      case 7:
        return this.applyLookup(table3.lookupType, table3.extension);
      default:
        throw new Error(`GSUB lookupType ${lookupType} is not supported`);
    }
  }
};
var $c96c93587d49c14d$export$2e2bcd8739ae039 = class extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {
  static {
    __name(this, "$c96c93587d49c14d$export$2e2bcd8739ae039");
  }
  applyPositionValue(sequenceIndex, value2) {
    let position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];
    if (value2.xAdvance != null) position.xAdvance += value2.xAdvance;
    if (value2.yAdvance != null) position.yAdvance += value2.yAdvance;
    if (value2.xPlacement != null) position.xOffset += value2.xPlacement;
    if (value2.yPlacement != null) position.yOffset += value2.yPlacement;
    let variationProcessor = this.font._variationProcessor;
    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (value2.xPlaDevice) position.xOffset += variationProcessor.getDelta(variationStore, value2.xPlaDevice.a, value2.xPlaDevice.b);
      if (value2.yPlaDevice) position.yOffset += variationProcessor.getDelta(variationStore, value2.yPlaDevice.a, value2.yPlaDevice.b);
      if (value2.xAdvDevice) position.xAdvance += variationProcessor.getDelta(variationStore, value2.xAdvDevice.a, value2.xAdvDevice.b);
      if (value2.yAdvDevice) position.yAdvance += variationProcessor.getDelta(variationStore, value2.yAdvDevice.a, value2.yAdvDevice.b);
    }
  }
  applyLookup(lookupType, table3) {
    switch (lookupType) {
      case 1: {
        let index2 = this.coverageIndex(table3.coverage);
        if (index2 === -1) return false;
        switch (table3.version) {
          case 1:
            this.applyPositionValue(0, table3.value);
            break;
          case 2:
            this.applyPositionValue(0, table3.values.get(index2));
            break;
        }
        return true;
      }
      case 2: {
        let nextGlyph = this.glyphIterator.peek();
        if (!nextGlyph) return false;
        let index2 = this.coverageIndex(table3.coverage);
        if (index2 === -1) return false;
        switch (table3.version) {
          case 1:
            let set5 = table3.pairSets.get(index2);
            for (let pair2 of set5) if (pair2.secondGlyph === nextGlyph.id) {
              this.applyPositionValue(0, pair2.value1);
              this.applyPositionValue(1, pair2.value2);
              return true;
            }
            return false;
          case 2:
            let class1 = this.getClassID(this.glyphIterator.cur.id, table3.classDef1);
            let class2 = this.getClassID(nextGlyph.id, table3.classDef2);
            if (class1 === -1 || class2 === -1) return false;
            var pair = table3.classRecords.get(class1).get(class2);
            this.applyPositionValue(0, pair.value1);
            this.applyPositionValue(1, pair.value2);
            return true;
        }
      }
      case 3: {
        let nextIndex = this.glyphIterator.peekIndex();
        let nextGlyph = this.glyphs[nextIndex];
        if (!nextGlyph) return false;
        let curRecord = table3.entryExitRecords[this.coverageIndex(table3.coverage)];
        if (!curRecord || !curRecord.exitAnchor) return false;
        let nextRecord = table3.entryExitRecords[this.coverageIndex(table3.coverage, nextGlyph.id)];
        if (!nextRecord || !nextRecord.entryAnchor) return false;
        let entry = this.getAnchor(nextRecord.entryAnchor);
        let exit2 = this.getAnchor(curRecord.exitAnchor);
        let cur = this.positions[this.glyphIterator.index];
        let next = this.positions[nextIndex];
        let d3;
        switch (this.direction) {
          case "ltr":
            cur.xAdvance = exit2.x + cur.xOffset;
            d3 = entry.x + next.xOffset;
            next.xAdvance -= d3;
            next.xOffset -= d3;
            break;
          case "rtl":
            d3 = exit2.x + cur.xOffset;
            cur.xAdvance -= d3;
            cur.xOffset -= d3;
            next.xAdvance = entry.x + next.xOffset;
            break;
        }
        if (this.glyphIterator.flags.rightToLeft) {
          this.glyphIterator.cur.cursiveAttachment = nextIndex;
          cur.yOffset = entry.y - exit2.y;
        } else {
          nextGlyph.cursiveAttachment = this.glyphIterator.index;
          cur.yOffset = exit2.y - entry.y;
        }
        return true;
      }
      case 4: {
        let markIndex = this.coverageIndex(table3.markCoverage);
        if (markIndex === -1) return false;
        let baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0)) ;
        if (baseGlyphIndex < 0) return false;
        let baseIndex = this.coverageIndex(table3.baseCoverage, this.glyphs[baseGlyphIndex].id);
        if (baseIndex === -1) return false;
        let markRecord = table3.markArray[markIndex];
        let baseAnchor = table3.baseArray[baseIndex][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 5: {
        let markIndex = this.coverageIndex(table3.markCoverage);
        if (markIndex === -1) return false;
        let baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && this.glyphs[baseGlyphIndex].isMark) ;
        if (baseGlyphIndex < 0) return false;
        let ligIndex = this.coverageIndex(table3.ligatureCoverage, this.glyphs[baseGlyphIndex].id);
        if (ligIndex === -1) return false;
        let ligAttach = table3.ligatureArray[ligIndex];
        let markGlyph = this.glyphIterator.cur;
        let ligGlyph = this.glyphs[baseGlyphIndex];
        let compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;
        let markRecord = table3.markArray[markIndex];
        let baseAnchor = ligAttach[compIndex][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 6: {
        let mark1Index = this.coverageIndex(table3.mark1Coverage);
        if (mark1Index === -1) return false;
        let prevIndex = this.glyphIterator.peekIndex(-1);
        let prev = this.glyphs[prevIndex];
        if (!prev || !prev.isMark) return false;
        let cur = this.glyphIterator.cur;
        let good = false;
        if (cur.ligatureID === prev.ligatureID) {
          if (!cur.ligatureID) good = true;
          else if (cur.ligatureComponent === prev.ligatureComponent) good = true;
        } else if (cur.ligatureID && !cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent) good = true;
        if (!good) return false;
        let mark2Index = this.coverageIndex(table3.mark2Coverage, prev.id);
        if (mark2Index === -1) return false;
        let markRecord = table3.mark1Array[mark1Index];
        let baseAnchor = table3.mark2Array[mark2Index][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, prevIndex);
        return true;
      }
      case 7:
        return this.applyContext(table3);
      case 8:
        return this.applyChainingContext(table3);
      case 9:
        return this.applyLookup(table3.lookupType, table3.extension);
      default:
        throw new Error(`Unsupported GPOS table: ${lookupType}`);
    }
  }
  applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {
    let baseCoords = this.getAnchor(baseAnchor);
    let markCoords = this.getAnchor(markRecord.markAnchor);
    let basePos = this.positions[baseGlyphIndex];
    let markPos = this.positions[this.glyphIterator.index];
    markPos.xOffset = baseCoords.x - markCoords.x;
    markPos.yOffset = baseCoords.y - markCoords.y;
    this.glyphIterator.cur.markAttachment = baseGlyphIndex;
  }
  getAnchor(anchor) {
    let x = anchor.xCoordinate;
    let y3 = anchor.yCoordinate;
    let variationProcessor = this.font._variationProcessor;
    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (anchor.xDeviceTable) x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);
      if (anchor.yDeviceTable) y3 += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);
    }
    return {
      x,
      y: y3
    };
  }
  applyFeatures(userFeatures, glyphs, advances) {
    super.applyFeatures(userFeatures, glyphs, advances);
    for (var i2 = 0; i2 < this.glyphs.length; i2++) this.fixCursiveAttachment(i2);
    this.fixMarkAttachment();
  }
  fixCursiveAttachment(i2) {
    let glyph = this.glyphs[i2];
    if (glyph.cursiveAttachment != null) {
      let j = glyph.cursiveAttachment;
      glyph.cursiveAttachment = null;
      this.fixCursiveAttachment(j);
      this.positions[i2].yOffset += this.positions[j].yOffset;
    }
  }
  fixMarkAttachment() {
    for (let i2 = 0; i2 < this.glyphs.length; i2++) {
      let glyph = this.glyphs[i2];
      if (glyph.markAttachment != null) {
        let j = glyph.markAttachment;
        this.positions[i2].xOffset += this.positions[j].xOffset;
        this.positions[i2].yOffset += this.positions[j].yOffset;
        if (this.direction === "ltr") for (let k3 = j; k3 < i2; k3++) {
          this.positions[i2].xOffset -= this.positions[k3].xAdvance;
          this.positions[i2].yOffset -= this.positions[k3].yAdvance;
        }
        else for (let k3 = j + 1; k3 < i2 + 1; k3++) {
          this.positions[i2].xOffset += this.positions[k3].xAdvance;
          this.positions[i2].yOffset += this.positions[k3].yAdvance;
        }
      }
    }
  }
};
var $a62492810de27e3d$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$a62492810de27e3d$export$2e2bcd8739ae039");
  }
  setup(glyphRun) {
    this.glyphInfos = glyphRun.glyphs.map((glyph) => new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, glyph.id, [
      ...glyph.codePoints
    ]));
    let script = null;
    if (this.GPOSProcessor) script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    if (this.GSUBProcessor) script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    this.shaper = $102b6fe50f1d50b4$export$7877a478dd30fd3d(script);
    this.plan = new (0, $94d7a73bd2edfc9a$export$2e2bcd8739ae039)(this.font, script, glyphRun.direction);
    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);
    for (let key in this.plan.allFeatures) glyphRun.features[key] = true;
  }
  substitute(glyphRun) {
    if (this.GSUBProcessor) {
      this.plan.process(this.GSUBProcessor, this.glyphInfos);
      glyphRun.glyphs = this.glyphInfos.map((glyphInfo) => this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints));
    }
  }
  position(glyphRun) {
    if (this.shaper.zeroMarkWidths === "BEFORE_GPOS") this.zeroMarkAdvances(glyphRun.positions);
    if (this.GPOSProcessor) this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);
    if (this.shaper.zeroMarkWidths === "AFTER_GPOS") this.zeroMarkAdvances(glyphRun.positions);
    if (glyphRun.direction === "rtl") {
      glyphRun.glyphs.reverse();
      glyphRun.positions.reverse();
    }
    return this.GPOSProcessor && this.GPOSProcessor.features;
  }
  zeroMarkAdvances(positions) {
    for (let i2 = 0; i2 < this.glyphInfos.length; i2++) if (this.glyphInfos[i2].isMark) {
      positions[i2].xAdvance = 0;
      positions[i2].yAdvance = 0;
    }
  }
  cleanup() {
    this.glyphInfos = null;
    this.plan = null;
    this.shaper = null;
  }
  getAvailableFeatures(script, language) {
    let features2 = [];
    if (this.GSUBProcessor) {
      this.GSUBProcessor.selectScript(script, language);
      features2.push(...Object.keys(this.GSUBProcessor.features));
    }
    if (this.GPOSProcessor) {
      this.GPOSProcessor.selectScript(script, language);
      features2.push(...Object.keys(this.GPOSProcessor.features));
    }
    return features2;
  }
  constructor(font) {
    this.font = font;
    this.glyphInfos = null;
    this.plan = null;
    this.GSUBProcessor = null;
    this.GPOSProcessor = null;
    this.fallbackPosition = true;
    if (font.GSUB) this.GSUBProcessor = new (0, $0a876c45f1f7c41c$export$2e2bcd8739ae039)(font, font.GSUB);
    if (font.GPOS) this.GPOSProcessor = new (0, $c96c93587d49c14d$export$2e2bcd8739ae039)(font, font.GPOS);
  }
};
var $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$4c0a7fa5df7a9ab1$export$2e2bcd8739ae039");
  }
  layout(string, features2, script, language, direction) {
    if (typeof features2 === "string") {
      direction = language;
      language = script;
      script = features2;
      features2 = [];
    }
    if (typeof string === "string") {
      if (script == null) script = $130d1a642ebcd2b7$export$e5cb25e204fb8450(string);
      var glyphs = this.font.glyphsForString(string);
    } else {
      if (script == null) {
        let codePoints = [];
        for (let glyph of string) codePoints.push(...glyph.codePoints);
        script = $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints);
      }
      var glyphs = string;
    }
    let glyphRun = new (0, $be07b3e97a42687a$export$2e2bcd8739ae039)(glyphs, features2, script, language, direction);
    if (glyphs.length === 0) {
      glyphRun.positions = [];
      return glyphRun;
    }
    if (this.engine && this.engine.setup) this.engine.setup(glyphRun);
    this.substitute(glyphRun);
    this.position(glyphRun);
    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);
    if (this.engine && this.engine.cleanup) this.engine.cleanup();
    return glyphRun;
  }
  substitute(glyphRun) {
    if (this.engine && this.engine.substitute) this.engine.substitute(glyphRun);
  }
  position(glyphRun) {
    glyphRun.positions = glyphRun.glyphs.map((glyph) => new (0, $1ac75d9a55b67f01$export$2e2bcd8739ae039)(glyph.advanceWidth));
    let positioned = null;
    if (this.engine && this.engine.position) positioned = this.engine.position(glyphRun);
    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {
      if (!this.unicodeLayoutEngine) this.unicodeLayoutEngine = new (0, $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039)(this.font);
      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);
    }
    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {
      if (!this.kernProcessor) this.kernProcessor = new (0, $0bba3a9db57637f3$export$2e2bcd8739ae039)(this.font);
      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);
      glyphRun.features.kern = true;
    }
  }
  hideDefaultIgnorables(glyphs, positions) {
    let space = this.font.glyphForCodePoint(32);
    for (let i2 = 0; i2 < glyphs.length; i2++) if (this.isDefaultIgnorable(glyphs[i2].codePoints[0])) {
      glyphs[i2] = space;
      positions[i2].xAdvance = 0;
      positions[i2].yAdvance = 0;
    }
  }
  isDefaultIgnorable(ch) {
    let plane = ch >> 16;
    if (plane === 0)
      switch (ch >> 8) {
        case 0:
          return ch === 173;
        case 3:
          return ch === 847;
        case 6:
          return ch === 1564;
        case 23:
          return 6068 <= ch && ch <= 6069;
        case 24:
          return 6155 <= ch && ch <= 6158;
        case 32:
          return 8203 <= ch && ch <= 8207 || 8234 <= ch && ch <= 8238 || 8288 <= ch && ch <= 8303;
        case 254:
          return 65024 <= ch && ch <= 65039 || ch === 65279;
        case 255:
          return 65520 <= ch && ch <= 65528;
        default:
          return false;
      }
    else
      switch (plane) {
        case 1:
          return 113824 <= ch && ch <= 113827 || 119155 <= ch && ch <= 119162;
        case 14:
          return 917504 <= ch && ch <= 921599;
        default:
          return false;
      }
  }
  getAvailableFeatures(script, language) {
    let features2 = [];
    if (this.engine) features2.push(...this.engine.getAvailableFeatures(script, language));
    if (this.font.kern && features2.indexOf("kern") === -1) features2.push("kern");
    return features2;
  }
  stringsForGlyph(gid) {
    let result = /* @__PURE__ */ new Set();
    let codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);
    for (let codePoint of codePoints) result.add(String.fromCodePoint(codePoint));
    if (this.engine && this.engine.stringsForGlyph) for (let string of this.engine.stringsForGlyph(gid)) result.add(string);
    return Array.from(result);
  }
  constructor(font) {
    this.font = font;
    this.unicodeLayoutEngine = null;
    this.kernProcessor = null;
    if (this.font.morx) this.engine = new (0, $ba6dd74203be8728$export$2e2bcd8739ae039)(this.font);
    else if (this.font.GSUB || this.font.GPOS) this.engine = new (0, $a62492810de27e3d$export$2e2bcd8739ae039)(this.font);
  }
};
var $f43aec954cdfdf21$var$SVG_COMMANDS = {
  moveTo: "M",
  lineTo: "L",
  quadraticCurveTo: "Q",
  bezierCurveTo: "C",
  closePath: "Z"
};
var $f43aec954cdfdf21$export$2e2bcd8739ae039 = class _$f43aec954cdfdf21$export$2e2bcd8739ae039 {
  static {
    __name(this, "$f43aec954cdfdf21$export$2e2bcd8739ae039");
  }
  /**
  * Compiles the path to a JavaScript function that can be applied with
  * a graphics context in order to render the path.
  * @return {string}
  */
  toFunction() {
    return (ctx) => {
      this.commands.forEach((c2) => {
        return ctx[c2.command].apply(ctx, c2.args);
      });
    };
  }
  /**
  * Converts the path to an SVG path data string
  * @return {string}
  */
  toSVG() {
    let cmds = this.commands.map((c2) => {
      let args = c2.args.map((arg) => Math.round(arg * 100) / 100);
      return `${$f43aec954cdfdf21$var$SVG_COMMANDS[c2.command]}${args.join(" ")}`;
    });
    return cmds.join("");
  }
  /**
  * Gets the "control box" of a path.
  * This is like the bounding box, but it includes all points including
  * control points of bezier segments and is much faster to compute than
  * the real bounding box.
  * @type {BBox}
  */
  get cbox() {
    if (!this._cbox) {
      let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
      for (let command of this.commands) for (let i2 = 0; i2 < command.args.length; i2 += 2) cbox.addPoint(command.args[i2], command.args[i2 + 1]);
      this._cbox = Object.freeze(cbox);
    }
    return this._cbox;
  }
  /**
  * Gets the exact bounding box of the path by evaluating curve segments.
  * Slower to compute than the control box, but more accurate.
  * @type {BBox}
  */
  get bbox() {
    if (this._bbox) return this._bbox;
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    let cx2 = 0, cy2 = 0;
    let f4 = /* @__PURE__ */ __name((t4) => Math.pow(1 - t4, 3) * p0[i2] + 3 * Math.pow(1 - t4, 2) * t4 * p1[i2] + 3 * (1 - t4) * Math.pow(t4, 2) * p22[i2] + Math.pow(t4, 3) * p3[i2], "f");
    for (let c2 of this.commands) switch (c2.command) {
      case "moveTo":
      case "lineTo":
        let [x, y3] = c2.args;
        bbox.addPoint(x, y3);
        cx2 = x;
        cy2 = y3;
        break;
      case "quadraticCurveTo":
      case "bezierCurveTo":
        if (c2.command === "quadraticCurveTo") {
          var [qp1x, qp1y, p3x, p3y] = c2.args;
          var cp1x = cx2 + 2 / 3 * (qp1x - cx2);
          var cp1y = cy2 + 2 / 3 * (qp1y - cy2);
          var cp2x = p3x + 2 / 3 * (qp1x - p3x);
          var cp2y = p3y + 2 / 3 * (qp1y - p3y);
        } else var [cp1x, cp1y, cp2x, cp2y, p3x, p3y] = c2.args;
        bbox.addPoint(p3x, p3y);
        var p0 = [
          cx2,
          cy2
        ];
        var p1 = [
          cp1x,
          cp1y
        ];
        var p22 = [
          cp2x,
          cp2y
        ];
        var p3 = [
          p3x,
          p3y
        ];
        for (var i2 = 0; i2 <= 1; i2++) {
          let b3 = 6 * p0[i2] - 12 * p1[i2] + 6 * p22[i2];
          let a4 = -3 * p0[i2] + 9 * p1[i2] - 9 * p22[i2] + 3 * p3[i2];
          c2 = 3 * p1[i2] - 3 * p0[i2];
          if (a4 === 0) {
            if (b3 === 0) continue;
            let t4 = -c2 / b3;
            if (0 < t4 && t4 < 1) {
              if (i2 === 0) bbox.addPoint(f4(t4), bbox.maxY);
              else if (i2 === 1) bbox.addPoint(bbox.maxX, f4(t4));
            }
            continue;
          }
          let b2ac = Math.pow(b3, 2) - 4 * c2 * a4;
          if (b2ac < 0) continue;
          let t1 = (-b3 + Math.sqrt(b2ac)) / (2 * a4);
          if (0 < t1 && t1 < 1) {
            if (i2 === 0) bbox.addPoint(f4(t1), bbox.maxY);
            else if (i2 === 1) bbox.addPoint(bbox.maxX, f4(t1));
          }
          let t22 = (-b3 - Math.sqrt(b2ac)) / (2 * a4);
          if (0 < t22 && t22 < 1) {
            if (i2 === 0) bbox.addPoint(f4(t22), bbox.maxY);
            else if (i2 === 1) bbox.addPoint(bbox.maxX, f4(t22));
          }
        }
        cx2 = p3x;
        cy2 = p3y;
        break;
    }
    return this._bbox = Object.freeze(bbox);
  }
  /**
  * Applies a mapping function to each point in the path.
  * @param {function} fn
  * @return {Path}
  */
  mapPoints(fn) {
    let path = new _$f43aec954cdfdf21$export$2e2bcd8739ae039();
    for (let c2 of this.commands) {
      let args = [];
      for (let i2 = 0; i2 < c2.args.length; i2 += 2) {
        let [x, y3] = fn(c2.args[i2], c2.args[i2 + 1]);
        args.push(x, y3);
      }
      path[c2.command](...args);
    }
    return path;
  }
  /**
  * Transforms the path by the given matrix.
  */
  transform(m0, m1, m22, m3, m4, m5) {
    return this.mapPoints((x, y3) => {
      const tx = m0 * x + m22 * y3 + m4;
      const ty = m1 * x + m3 * y3 + m5;
      return [
        tx,
        ty
      ];
    });
  }
  /**
  * Translates the path by the given offset.
  */
  translate(x, y3) {
    return this.transform(1, 0, 0, 1, x, y3);
  }
  /**
  * Rotates the path by the given angle (in radians).
  */
  rotate(angle) {
    let cos = Math.cos(angle);
    let sin = Math.sin(angle);
    return this.transform(cos, sin, -sin, cos, 0, 0);
  }
  /**
  * Scales the path.
  */
  scale(scaleX, scaleY = scaleX) {
    return this.transform(scaleX, 0, 0, scaleY, 0, 0);
  }
  constructor() {
    this.commands = [];
    this._bbox = null;
    this._cbox = null;
  }
};
for (let command of [
  "moveTo",
  "lineTo",
  "quadraticCurveTo",
  "bezierCurveTo",
  "closePath"
]) $f43aec954cdfdf21$export$2e2bcd8739ae039.prototype[command] = function(...args) {
  this._bbox = this._cbox = null;
  this.commands.push({
    command,
    args
  });
  return this;
};
var $7713b9b7b438dff8$export$2e2bcd8739ae039 = [
  ".notdef",
  ".null",
  "nonmarkingreturn",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quotesingle",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "grave",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "Adieresis",
  "Aring",
  "Ccedilla",
  "Eacute",
  "Ntilde",
  "Odieresis",
  "Udieresis",
  "aacute",
  "agrave",
  "acircumflex",
  "adieresis",
  "atilde",
  "aring",
  "ccedilla",
  "eacute",
  "egrave",
  "ecircumflex",
  "edieresis",
  "iacute",
  "igrave",
  "icircumflex",
  "idieresis",
  "ntilde",
  "oacute",
  "ograve",
  "ocircumflex",
  "odieresis",
  "otilde",
  "uacute",
  "ugrave",
  "ucircumflex",
  "udieresis",
  "dagger",
  "degree",
  "cent",
  "sterling",
  "section",
  "bullet",
  "paragraph",
  "germandbls",
  "registered",
  "copyright",
  "trademark",
  "acute",
  "dieresis",
  "notequal",
  "AE",
  "Oslash",
  "infinity",
  "plusminus",
  "lessequal",
  "greaterequal",
  "yen",
  "mu",
  "partialdiff",
  "summation",
  "product",
  "pi",
  "integral",
  "ordfeminine",
  "ordmasculine",
  "Omega",
  "ae",
  "oslash",
  "questiondown",
  "exclamdown",
  "logicalnot",
  "radical",
  "florin",
  "approxequal",
  "Delta",
  "guillemotleft",
  "guillemotright",
  "ellipsis",
  "nonbreakingspace",
  "Agrave",
  "Atilde",
  "Otilde",
  "OE",
  "oe",
  "endash",
  "emdash",
  "quotedblleft",
  "quotedblright",
  "quoteleft",
  "quoteright",
  "divide",
  "lozenge",
  "ydieresis",
  "Ydieresis",
  "fraction",
  "currency",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "daggerdbl",
  "periodcentered",
  "quotesinglbase",
  "quotedblbase",
  "perthousand",
  "Acircumflex",
  "Ecircumflex",
  "Aacute",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Oacute",
  "Ocircumflex",
  "apple",
  "Ograve",
  "Uacute",
  "Ucircumflex",
  "Ugrave",
  "dotlessi",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "Lslash",
  "lslash",
  "Scaron",
  "scaron",
  "Zcaron",
  "zcaron",
  "brokenbar",
  "Eth",
  "eth",
  "Yacute",
  "yacute",
  "Thorn",
  "thorn",
  "minus",
  "multiply",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "onehalf",
  "onequarter",
  "threequarters",
  "franc",
  "Gbreve",
  "gbreve",
  "Idotaccent",
  "Scedilla",
  "scedilla",
  "Cacute",
  "cacute",
  "Ccaron",
  "ccaron",
  "dcroat"
];
var $f92906be28e61769$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$f92906be28e61769$export$2e2bcd8739ae039");
  }
  _getPath() {
    return new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
  }
  _getCBox() {
    return this.path.cbox;
  }
  _getBBox() {
    return this.path.bbox;
  }
  _getTableMetrics(table3) {
    if (this.id < table3.metrics.length) return table3.metrics.get(this.id);
    let metric = table3.metrics.get(table3.metrics.length - 1);
    let res = {
      advance: metric ? metric.advance : 0,
      bearing: table3.bearings.get(this.id - table3.metrics.length) || 0
    };
    return res;
  }
  _getMetrics(cbox) {
    if (this._metrics) return this._metrics;
    let { advance: advanceWidth2, bearing: leftBearing } = this._getTableMetrics(this._font.hmtx);
    if (this._font.vmtx) var { advance: advanceHeight, bearing: topBearing } = this._getTableMetrics(this._font.vmtx);
    else {
      let os2;
      if (typeof cbox === "undefined" || cbox === null) ({ cbox } = this);
      if ((os2 = this._font["OS/2"]) && os2.version > 0) {
        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
        var topBearing = os2.typoAscender - cbox.maxY;
      } else {
        let { hhea } = this._font;
        var advanceHeight = Math.abs(hhea.ascent - hhea.descent);
        var topBearing = hhea.ascent - cbox.maxY;
      }
    }
    if (this._font._variationProcessor && this._font.HVAR) advanceWidth2 += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);
    return this._metrics = {
      advanceWidth: advanceWidth2,
      advanceHeight,
      leftBearing,
      topBearing
    };
  }
  /**
  * The glyphs control box.
  * This is often the same as the bounding box, but is faster to compute.
  * Because of the way bezier curves are defined, some of the control points
  * can be outside of the bounding box. Where `bbox` takes this into account,
  * `cbox` does not. Thus, cbox is less accurate, but faster to compute.
  * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)
  * for a more detailed description.
  *
  * @type {BBox}
  */
  get cbox() {
    return this._getCBox();
  }
  /**
  * The glyphs bounding box, i.e. the rectangle that encloses the
  * glyph outline as tightly as possible.
  * @type {BBox}
  */
  get bbox() {
    return this._getBBox();
  }
  /**
  * A vector Path object representing the glyph outline.
  * @type {Path}
  */
  get path() {
    return this._getPath();
  }
  /**
  * Returns a path scaled to the given font size.
  * @param {number} size
  * @return {Path}
  */
  getScaledPath(size) {
    let scale2 = 1 / this._font.unitsPerEm * size;
    return this.path.scale(scale2);
  }
  /**
  * The glyph's advance width.
  * @type {number}
  */
  get advanceWidth() {
    return this._getMetrics().advanceWidth;
  }
  /**
  * The glyph's advance height.
  * @type {number}
  */
  get advanceHeight() {
    return this._getMetrics().advanceHeight;
  }
  get ligatureCaretPositions() {
  }
  _getName() {
    let { post } = this._font;
    if (!post) return null;
    switch (post.version) {
      case 1:
        return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id];
      case 2:
        let id = post.glyphNameIndex[this.id];
        if (id < (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length) return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[id];
        return post.names[id - (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length];
      case 2.5:
        return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id + post.offsets[this.id]];
      case 4:
        return String.fromCharCode(post.map[this.id]);
    }
  }
  /**
  * The glyph's name
  * @type {string}
  */
  get name() {
    return this._getName();
  }
  /**
  * Renders the glyph to the given graphics context, at the specified font size.
  * @param {CanvasRenderingContext2d} ctx
  * @param {number} size
  */
  render(ctx, size) {
    ctx.save();
    let scale2 = 1 / this._font.head.unitsPerEm * size;
    ctx.scale(scale2, scale2);
    let fn = this.path.toFunction();
    fn(ctx);
    ctx.fill();
    ctx.restore();
  }
  constructor(id, codePoints, font) {
    this.id = id;
    this.codePoints = codePoints;
    this._font = font;
    this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $747425b437e121da$export$e33ad6871e762338));
    this.isLigature = this.codePoints.length > 1;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "cbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "bbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "path", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceWidth", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceHeight", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "name", null);
var $69aac16029968692$var$GlyfHeader = new Struct({
  numberOfContours: int16,
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16
});
var $69aac16029968692$var$ON_CURVE = 1;
var $69aac16029968692$var$X_SHORT_VECTOR = 2;
var $69aac16029968692$var$Y_SHORT_VECTOR = 4;
var $69aac16029968692$var$REPEAT = 8;
var $69aac16029968692$var$SAME_X = 16;
var $69aac16029968692$var$SAME_Y = 32;
var $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS = 1;
var $69aac16029968692$var$WE_HAVE_A_SCALE = 8;
var $69aac16029968692$var$MORE_COMPONENTS = 32;
var $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE = 64;
var $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO = 128;
var $69aac16029968692$var$WE_HAVE_INSTRUCTIONS = 256;
var $69aac16029968692$export$baf26146a414f24a = class _$69aac16029968692$export$baf26146a414f24a {
  static {
    __name(this, "$69aac16029968692$export$baf26146a414f24a");
  }
  copy() {
    return new _$69aac16029968692$export$baf26146a414f24a(this.onCurve, this.endContour, this.x, this.y);
  }
  constructor(onCurve, endContour, x = 0, y3 = 0) {
    this.onCurve = onCurve;
    this.endContour = endContour;
    this.x = x;
    this.y = y3;
  }
};
var $69aac16029968692$var$Component = class {
  static {
    __name(this, "$69aac16029968692$var$Component");
  }
  constructor(glyphID, dx, dy) {
    this.glyphID = glyphID;
    this.dx = dx;
    this.dy = dy;
    this.pos = 0;
    this.scaleX = this.scaleY = 1;
    this.scale01 = this.scale10 = 0;
  }
};
var $69aac16029968692$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  static {
    __name(this, "$69aac16029968692$export$2e2bcd8739ae039");
  }
  // Parses just the glyph header and returns the bounding box
  _getCBox(internal) {
    if (this._font._variationProcessor && !internal) return this.path.cbox;
    let stream2 = this._font._getTableStream("glyf");
    stream2.pos += this._font.loca.offsets[this.id];
    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream2);
    let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
    return Object.freeze(cbox);
  }
  // Parses a single glyph coordinate
  _parseGlyphCoord(stream2, prev, short, same) {
    if (short) {
      var val = stream2.readUInt8();
      if (!same) val = -val;
      val += prev;
    } else if (same) var val = prev;
    else var val = prev + stream2.readInt16BE();
    return val;
  }
  // Decodes the glyph data into points for simple glyphs,
  // or components for composite glyphs
  _decode() {
    let glyfPos = this._font.loca.offsets[this.id];
    let nextPos = this._font.loca.offsets[this.id + 1];
    if (glyfPos === nextPos) return null;
    let stream2 = this._font._getTableStream("glyf");
    stream2.pos += glyfPos;
    let startPos = stream2.pos;
    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream2);
    if (glyph.numberOfContours > 0) this._decodeSimple(glyph, stream2);
    else if (glyph.numberOfContours < 0) this._decodeComposite(glyph, stream2, startPos);
    return glyph;
  }
  _decodeSimple(glyph, stream2) {
    glyph.points = [];
    let endPtsOfContours = new ArrayT(uint16, glyph.numberOfContours).decode(stream2);
    glyph.instructions = new ArrayT(uint8, uint16).decode(stream2);
    let flags = [];
    let numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
    while (flags.length < numCoords) {
      var flag = stream2.readUInt8();
      flags.push(flag);
      if (flag & $69aac16029968692$var$REPEAT) {
        let count3 = stream2.readUInt8();
        for (let j = 0; j < count3; j++) flags.push(flag);
      }
    }
    for (var i2 = 0; i2 < flags.length; i2++) {
      var flag = flags[i2];
      let point = new $69aac16029968692$export$baf26146a414f24a(!!(flag & $69aac16029968692$var$ON_CURVE), endPtsOfContours.indexOf(i2) >= 0, 0, 0);
      glyph.points.push(point);
    }
    let px2 = 0;
    for (var i2 = 0; i2 < flags.length; i2++) {
      var flag = flags[i2];
      glyph.points[i2].x = px2 = this._parseGlyphCoord(stream2, px2, flag & $69aac16029968692$var$X_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_X);
    }
    let py2 = 0;
    for (var i2 = 0; i2 < flags.length; i2++) {
      var flag = flags[i2];
      glyph.points[i2].y = py2 = this._parseGlyphCoord(stream2, py2, flag & $69aac16029968692$var$Y_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_Y);
    }
    if (this._font._variationProcessor) {
      let points = glyph.points.slice();
      points.push(...this._getPhantomPoints(glyph));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph.phantomPoints = points.slice(-4);
    }
    return;
  }
  _decodeComposite(glyph, stream2, offset2 = 0) {
    glyph.components = [];
    let haveInstructions = false;
    let flags = $69aac16029968692$var$MORE_COMPONENTS;
    while (flags & $69aac16029968692$var$MORE_COMPONENTS) {
      flags = stream2.readUInt16BE();
      let gPos = stream2.pos - offset2;
      let glyphID = stream2.readUInt16BE();
      if (!haveInstructions) haveInstructions = (flags & $69aac16029968692$var$WE_HAVE_INSTRUCTIONS) !== 0;
      if (flags & $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS) {
        var dx = stream2.readInt16BE();
        var dy = stream2.readInt16BE();
      } else {
        var dx = stream2.readInt8();
        var dy = stream2.readInt8();
      }
      var component = new $69aac16029968692$var$Component(glyphID, dx, dy);
      component.pos = gPos;
      if (flags & $69aac16029968692$var$WE_HAVE_A_SCALE)
        component.scaleX = component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      else if (flags & $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE) {
        component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      } else if (flags & $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO) {
        component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scale01 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scale10 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      }
      glyph.components.push(component);
    }
    if (this._font._variationProcessor) {
      let points = [];
      for (let j = 0; j < glyph.components.length; j++) {
        var component = glyph.components[j];
        points.push(new $69aac16029968692$export$baf26146a414f24a(true, true, component.dx, component.dy));
      }
      points.push(...this._getPhantomPoints(glyph));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph.phantomPoints = points.splice(-4, 4);
      for (let i2 = 0; i2 < points.length; i2++) {
        let point = points[i2];
        glyph.components[i2].dx = point.x;
        glyph.components[i2].dy = point.y;
      }
    }
    return haveInstructions;
  }
  _getPhantomPoints(glyph) {
    let cbox = this._getCBox(true);
    if (this._metrics == null) this._metrics = (0, $f92906be28e61769$export$2e2bcd8739ae039).prototype._getMetrics.call(this, cbox);
    let { advanceWidth: advanceWidth2, advanceHeight, leftBearing, topBearing } = this._metrics;
    return [
      new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing, 0),
      new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing + advanceWidth2, 0),
      new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing),
      new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing + advanceHeight)
    ];
  }
  // Decodes font data, resolves composite glyphs, and returns an array of contours
  _getContours() {
    let glyph = this._decode();
    if (!glyph) return [];
    let points = [];
    if (glyph.numberOfContours < 0)
      for (let component of glyph.components) {
        let contours2 = this._font.getGlyph(component.glyphID)._getContours();
        for (let i2 = 0; i2 < contours2.length; i2++) {
          let contour = contours2[i2];
          for (let j = 0; j < contour.length; j++) {
            let point2 = contour[j];
            let x = point2.x * component.scaleX + point2.y * component.scale01 + component.dx;
            let y3 = point2.y * component.scaleY + point2.x * component.scale10 + component.dy;
            points.push(new $69aac16029968692$export$baf26146a414f24a(point2.onCurve, point2.endContour, x, y3));
          }
        }
      }
    else points = glyph.points || [];
    if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {
      this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;
      this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;
      this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;
      this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;
    }
    let contours = [];
    let cur = [];
    for (let k3 = 0; k3 < points.length; k3++) {
      var point = points[k3];
      cur.push(point);
      if (point.endContour) {
        contours.push(cur);
        cur = [];
      }
    }
    return contours;
  }
  _getMetrics() {
    if (this._metrics) return this._metrics;
    let cbox = this._getCBox(true);
    super._getMetrics(cbox);
    if (this._font._variationProcessor && !this._font.HVAR)
      this.path;
    return this._metrics;
  }
  // Converts contours to a Path object that can be rendered
  _getPath() {
    let contours = this._getContours();
    let path = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
    for (let i2 = 0; i2 < contours.length; i2++) {
      let contour = contours[i2];
      let firstPt = contour[0];
      let lastPt = contour[contour.length - 1];
      let start2 = 0;
      if (firstPt.onCurve) {
        var curvePt = null;
        start2 = 1;
      } else {
        if (lastPt.onCurve)
          firstPt = lastPt;
        else
          firstPt = new $69aac16029968692$export$baf26146a414f24a(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
        var curvePt = firstPt;
      }
      path.moveTo(firstPt.x, firstPt.y);
      for (let j = start2; j < contour.length; j++) {
        let pt = contour[j];
        let prevPt = j === 0 ? firstPt : contour[j - 1];
        if (prevPt.onCurve && pt.onCurve) path.lineTo(pt.x, pt.y);
        else if (prevPt.onCurve && !pt.onCurve) var curvePt = pt;
        else if (!prevPt.onCurve && !pt.onCurve) {
          let midX = (prevPt.x + pt.x) / 2;
          let midY = (prevPt.y + pt.y) / 2;
          path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
          var curvePt = pt;
        } else if (!prevPt.onCurve && pt.onCurve) {
          path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
          var curvePt = null;
        } else throw new Error("Unknown TTF path state");
      }
      if (curvePt) path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
      path.closePath();
    }
    return path;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "TTF");
  }
};
var $62cc5109c6101893$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  static {
    __name(this, "$62cc5109c6101893$export$2e2bcd8739ae039");
  }
  _getName() {
    if (this._font.CFF2) return super._getName();
    return this._font["CFF "].getGlyphName(this.id);
  }
  bias(s4) {
    if (s4.length < 1240) return 107;
    else if (s4.length < 33900) return 1131;
    else return 32768;
  }
  _getPath() {
    let cff = this._font.CFF2 || this._font["CFF "];
    let { stream: stream2 } = cff;
    let str = cff.topDict.CharStrings[this.id];
    let end2 = str.offset + str.length;
    stream2.pos = str.offset;
    let path = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
    let stack = [];
    let trans = [];
    let width = null;
    let nStems = 0;
    let x = 0, y3 = 0;
    let usedGsubrs;
    let usedSubrs;
    let open3 = false;
    this._usedGsubrs = usedGsubrs = {};
    this._usedSubrs = usedSubrs = {};
    let gsubrs = cff.globalSubrIndex || [];
    let gsubrsBias = this.bias(gsubrs);
    let privateDict = cff.privateDictForGlyph(this.id) || {};
    let subrs = privateDict.Subrs || [];
    let subrsBias = this.bias(subrs);
    let vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;
    let vsindex = privateDict.vsindex;
    let variationProcessor = this._font._variationProcessor;
    function checkWidth() {
      if (width == null) width = stack.shift() + privateDict.nominalWidthX;
    }
    __name(checkWidth, "checkWidth");
    function parseStems() {
      if (stack.length % 2 !== 0) checkWidth();
      nStems += stack.length >> 1;
      return stack.length = 0;
    }
    __name(parseStems, "parseStems");
    function moveTo(x2, y4) {
      if (open3) path.closePath();
      path.moveTo(x2, y4);
      open3 = true;
    }
    __name(moveTo, "moveTo");
    let parse3 = /* @__PURE__ */ __name(function() {
      while (stream2.pos < end2) {
        let op = stream2.readUInt8();
        if (op < 32) {
          let index2, subr, phase;
          let c1x, c1y, c2x, c2y, c3x, c3y;
          let c4x, c4y, c5x, c5y, c6x, c6y;
          let pts;
          switch (op) {
            case 1:
            case 3:
            case 18:
            case 23:
              parseStems();
              break;
            case 4:
              if (stack.length > 1) checkWidth();
              y3 += stack.shift();
              moveTo(x, y3);
              break;
            case 5:
              while (stack.length >= 2) {
                x += stack.shift();
                y3 += stack.shift();
                path.lineTo(x, y3);
              }
              break;
            case 6:
            case 7:
              phase = op === 6;
              while (stack.length >= 1) {
                if (phase) x += stack.shift();
                else y3 += stack.shift();
                path.lineTo(x, y3);
                phase = !phase;
              }
              break;
            case 8:
              while (stack.length > 0) {
                c1x = x + stack.shift();
                c1y = y3 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y3 = c2y + stack.shift();
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y3);
              }
              break;
            case 10:
              index2 = stack.pop() + subrsBias;
              subr = subrs[index2];
              if (subr) {
                usedSubrs[index2] = true;
                let p3 = stream2.pos;
                let e4 = end2;
                stream2.pos = subr.offset;
                end2 = subr.offset + subr.length;
                parse3();
                stream2.pos = p3;
                end2 = e4;
              }
              break;
            case 11:
              if (cff.version >= 2) break;
              return;
            case 14:
              if (cff.version >= 2) break;
              if (stack.length > 0) checkWidth();
              if (open3) {
                path.closePath();
                open3 = false;
              }
              break;
            case 15:
              if (cff.version < 2) throw new Error("vsindex operator not supported in CFF v1");
              vsindex = stack.pop();
              break;
            case 16: {
              if (cff.version < 2) throw new Error("blend operator not supported in CFF v1");
              if (!variationProcessor) throw new Error("blend operator in non-variation font");
              let blendVector = variationProcessor.getBlendVector(vstore, vsindex);
              let numBlends = stack.pop();
              let numOperands = numBlends * blendVector.length;
              let delta = stack.length - numOperands;
              let base = delta - numBlends;
              for (let i2 = 0; i2 < numBlends; i2++) {
                let sum = stack[base + i2];
                for (let j = 0; j < blendVector.length; j++) sum += blendVector[j] * stack[delta++];
                stack[base + i2] = sum;
              }
              while (numOperands--) stack.pop();
              break;
            }
            case 19:
            case 20:
              parseStems();
              stream2.pos += nStems + 7 >> 3;
              break;
            case 21:
              if (stack.length > 2) checkWidth();
              x += stack.shift();
              y3 += stack.shift();
              moveTo(x, y3);
              break;
            case 22:
              if (stack.length > 1) checkWidth();
              x += stack.shift();
              moveTo(x, y3);
              break;
            case 24:
              while (stack.length >= 8) {
                c1x = x + stack.shift();
                c1y = y3 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y3 = c2y + stack.shift();
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y3);
              }
              x += stack.shift();
              y3 += stack.shift();
              path.lineTo(x, y3);
              break;
            case 25:
              while (stack.length >= 8) {
                x += stack.shift();
                y3 += stack.shift();
                path.lineTo(x, y3);
              }
              c1x = x + stack.shift();
              c1y = y3 + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              x = c2x + stack.shift();
              y3 = c2y + stack.shift();
              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y3);
              break;
            case 26:
              if (stack.length % 2) x += stack.shift();
              while (stack.length >= 4) {
                c1x = x;
                c1y = y3 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x;
                y3 = c2y + stack.shift();
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y3);
              }
              break;
            case 27:
              if (stack.length % 2) y3 += stack.shift();
              while (stack.length >= 4) {
                c1x = x + stack.shift();
                c1y = y3;
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y3 = c2y;
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y3);
              }
              break;
            case 28:
              stack.push(stream2.readInt16BE());
              break;
            case 29:
              index2 = stack.pop() + gsubrsBias;
              subr = gsubrs[index2];
              if (subr) {
                usedGsubrs[index2] = true;
                let p3 = stream2.pos;
                let e4 = end2;
                stream2.pos = subr.offset;
                end2 = subr.offset + subr.length;
                parse3();
                stream2.pos = p3;
                end2 = e4;
              }
              break;
            case 30:
            case 31:
              phase = op === 31;
              while (stack.length >= 4) {
                if (phase) {
                  c1x = x + stack.shift();
                  c1y = y3;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  y3 = c2y + stack.shift();
                  x = c2x + (stack.length === 1 ? stack.shift() : 0);
                } else {
                  c1x = x;
                  c1y = y3 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x + stack.shift();
                  y3 = c2y + (stack.length === 1 ? stack.shift() : 0);
                }
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y3);
                phase = !phase;
              }
              break;
            case 12:
              op = stream2.readUInt8();
              switch (op) {
                case 3:
                  let a4 = stack.pop();
                  let b3 = stack.pop();
                  stack.push(a4 && b3 ? 1 : 0);
                  break;
                case 4:
                  a4 = stack.pop();
                  b3 = stack.pop();
                  stack.push(a4 || b3 ? 1 : 0);
                  break;
                case 5:
                  a4 = stack.pop();
                  stack.push(a4 ? 0 : 1);
                  break;
                case 9:
                  a4 = stack.pop();
                  stack.push(Math.abs(a4));
                  break;
                case 10:
                  a4 = stack.pop();
                  b3 = stack.pop();
                  stack.push(a4 + b3);
                  break;
                case 11:
                  a4 = stack.pop();
                  b3 = stack.pop();
                  stack.push(a4 - b3);
                  break;
                case 12:
                  a4 = stack.pop();
                  b3 = stack.pop();
                  stack.push(a4 / b3);
                  break;
                case 14:
                  a4 = stack.pop();
                  stack.push(-a4);
                  break;
                case 15:
                  a4 = stack.pop();
                  b3 = stack.pop();
                  stack.push(a4 === b3 ? 1 : 0);
                  break;
                case 18:
                  stack.pop();
                  break;
                case 20:
                  let val = stack.pop();
                  let idx = stack.pop();
                  trans[idx] = val;
                  break;
                case 21:
                  idx = stack.pop();
                  stack.push(trans[idx] || 0);
                  break;
                case 22:
                  let s1 = stack.pop();
                  let s22 = stack.pop();
                  let v1 = stack.pop();
                  let v22 = stack.pop();
                  stack.push(v1 <= v22 ? s1 : s22);
                  break;
                case 23:
                  stack.push(Math.random());
                  break;
                case 24:
                  a4 = stack.pop();
                  b3 = stack.pop();
                  stack.push(a4 * b3);
                  break;
                case 26:
                  a4 = stack.pop();
                  stack.push(Math.sqrt(a4));
                  break;
                case 27:
                  a4 = stack.pop();
                  stack.push(a4, a4);
                  break;
                case 28:
                  a4 = stack.pop();
                  b3 = stack.pop();
                  stack.push(b3, a4);
                  break;
                case 29:
                  idx = stack.pop();
                  if (idx < 0) idx = 0;
                  else if (idx > stack.length - 1) idx = stack.length - 1;
                  stack.push(stack[idx]);
                  break;
                case 30:
                  let n5 = stack.pop();
                  let j = stack.pop();
                  if (j >= 0) while (j > 0) {
                    var t4 = stack[n5 - 1];
                    for (let i2 = n5 - 2; i2 >= 0; i2--) stack[i2 + 1] = stack[i2];
                    stack[0] = t4;
                    j--;
                  }
                  else while (j < 0) {
                    var t4 = stack[0];
                    for (let i2 = 0; i2 <= n5; i2++) stack[i2] = stack[i2 + 1];
                    stack[n5 - 1] = t4;
                    j++;
                  }
                  break;
                case 34:
                  c1x = x + stack.shift();
                  c1y = y3;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  c3x = c2x + stack.shift();
                  c3y = c2y;
                  c4x = c3x + stack.shift();
                  c4y = c3y;
                  c5x = c4x + stack.shift();
                  c5y = c4y;
                  c6x = c5x + stack.shift();
                  c6y = c5y;
                  x = c6x;
                  y3 = c6y;
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 35:
                  pts = [];
                  for (let i2 = 0; i2 <= 5; i2++) {
                    x += stack.shift();
                    y3 += stack.shift();
                    pts.push(x, y3);
                  }
                  path.bezierCurveTo(...pts.slice(0, 6));
                  path.bezierCurveTo(...pts.slice(6));
                  stack.shift();
                  break;
                case 36:
                  c1x = x + stack.shift();
                  c1y = y3 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  c3x = c2x + stack.shift();
                  c3y = c2y;
                  c4x = c3x + stack.shift();
                  c4y = c3y;
                  c5x = c4x + stack.shift();
                  c5y = c4y + stack.shift();
                  c6x = c5x + stack.shift();
                  c6y = c5y;
                  x = c6x;
                  y3 = c6y;
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 37:
                  let startx = x;
                  let starty = y3;
                  pts = [];
                  for (let i2 = 0; i2 <= 4; i2++) {
                    x += stack.shift();
                    y3 += stack.shift();
                    pts.push(x, y3);
                  }
                  if (Math.abs(x - startx) > Math.abs(y3 - starty)) {
                    x += stack.shift();
                    y3 = starty;
                  } else {
                    x = startx;
                    y3 += stack.shift();
                  }
                  pts.push(x, y3);
                  path.bezierCurveTo(...pts.slice(0, 6));
                  path.bezierCurveTo(...pts.slice(6));
                  break;
                default:
                  throw new Error(`Unknown op: 12 ${op}`);
              }
              break;
            default:
              throw new Error(`Unknown op: ${op}`);
          }
        } else if (op < 247) stack.push(op - 139);
        else if (op < 251) {
          var b1 = stream2.readUInt8();
          stack.push((op - 247) * 256 + b1 + 108);
        } else if (op < 255) {
          var b1 = stream2.readUInt8();
          stack.push(-(op - 251) * 256 - b1 - 108);
        } else stack.push(stream2.readInt32BE() / 65536);
      }
    }, "parse");
    parse3();
    if (open3) path.closePath();
    return path;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "CFF");
  }
};
var $25d8f049c222084c$var$SBIXImage = new Struct({
  originX: uint16,
  originY: uint16,
  type: new StringT(4),
  data: new BufferT((t4) => t4.parent.buflen - t4._currentOffset)
});
var $25d8f049c222084c$export$2e2bcd8739ae039 = class extends (0, $69aac16029968692$export$2e2bcd8739ae039) {
  static {
    __name(this, "$25d8f049c222084c$export$2e2bcd8739ae039");
  }
  /**
  * Returns an object representing a glyph image at the given point size.
  * The object has a data property with a Buffer containing the actual image data,
  * along with the image type, and origin.
  *
  * @param {number} size
  * @return {object}
  */
  getImageForSize(size) {
    for (let i2 = 0; i2 < this._font.sbix.imageTables.length; i2++) {
      var table3 = this._font.sbix.imageTables[i2];
      if (table3.ppem >= size) break;
    }
    let offsets = table3.imageOffsets;
    let start2 = offsets[this.id];
    let end2 = offsets[this.id + 1];
    if (start2 === end2) return null;
    this._font.stream.pos = start2;
    return $25d8f049c222084c$var$SBIXImage.decode(this._font.stream, {
      buflen: end2 - start2
    });
  }
  render(ctx, size) {
    let img = this.getImageForSize(size);
    if (img != null) {
      let scale2 = size / this._font.unitsPerEm;
      ctx.image(img.data, {
        height: size,
        x: img.originX,
        y: (this.bbox.minY - img.originY) * scale2
      });
    }
    if (this._font.sbix.flags.renderOutlines) super.render(ctx, size);
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "SBIX");
  }
};
var $0d411f0165859681$var$COLRLayer = class {
  static {
    __name(this, "$0d411f0165859681$var$COLRLayer");
  }
  constructor(glyph, color) {
    this.glyph = glyph;
    this.color = color;
  }
};
var $0d411f0165859681$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  static {
    __name(this, "$0d411f0165859681$export$2e2bcd8739ae039");
  }
  _getBBox() {
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    for (let i2 = 0; i2 < this.layers.length; i2++) {
      let layer = this.layers[i2];
      let b3 = layer.glyph.bbox;
      bbox.addPoint(b3.minX, b3.minY);
      bbox.addPoint(b3.maxX, b3.maxY);
    }
    return bbox;
  }
  /**
  * Returns an array of objects containing the glyph and color for
  * each layer in the composite color glyph.
  * @type {object[]}
  */
  get layers() {
    let cpal = this._font.CPAL;
    let colr = this._font.COLR;
    let low = 0;
    let high = colr.baseGlyphRecord.length - 1;
    while (low <= high) {
      let mid = low + high >> 1;
      var rec = colr.baseGlyphRecord[mid];
      if (this.id < rec.gid) high = mid - 1;
      else if (this.id > rec.gid) low = mid + 1;
      else {
        var baseLayer = rec;
        break;
      }
    }
    if (baseLayer == null) {
      var g = this._font._getBaseGlyph(this.id);
      var color = {
        red: 0,
        green: 0,
        blue: 0,
        alpha: 255
      };
      return [
        new $0d411f0165859681$var$COLRLayer(g, color)
      ];
    }
    let layers = [];
    for (let i2 = baseLayer.firstLayerIndex; i2 < baseLayer.firstLayerIndex + baseLayer.numLayers; i2++) {
      var rec = colr.layerRecords[i2];
      var color = cpal.colorRecords[rec.paletteIndex];
      var g = this._font._getBaseGlyph(rec.gid);
      layers.push(new $0d411f0165859681$var$COLRLayer(g, color));
    }
    return layers;
  }
  render(ctx, size) {
    for (let { glyph, color } of this.layers) {
      ctx.fillColor([
        color.red,
        color.green,
        color.blue
      ], color.alpha / 255 * 100);
      glyph.render(ctx, size);
    }
    return;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "COLR");
  }
};
var $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS = 32768;
var $0bb840cac04e911b$var$TUPLE_COUNT_MASK = 4095;
var $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD = 32768;
var $0bb840cac04e911b$var$INTERMEDIATE_TUPLE = 16384;
var $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS = 8192;
var $0bb840cac04e911b$var$TUPLE_INDEX_MASK = 4095;
var $0bb840cac04e911b$var$POINTS_ARE_WORDS = 128;
var $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK = 127;
var $0bb840cac04e911b$var$DELTAS_ARE_ZERO = 128;
var $0bb840cac04e911b$var$DELTAS_ARE_WORDS = 64;
var $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK = 63;
var $0bb840cac04e911b$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$0bb840cac04e911b$export$2e2bcd8739ae039");
  }
  normalizeCoords(coords) {
    let normalized = [];
    for (var i2 = 0; i2 < this.font.fvar.axis.length; i2++) {
      let axis = this.font.fvar.axis[i2];
      if (coords[i2] < axis.defaultValue) normalized.push((coords[i2] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));
      else normalized.push((coords[i2] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));
    }
    if (this.font.avar) for (var i2 = 0; i2 < this.font.avar.segment.length; i2++) {
      let segment = this.font.avar.segment[i2];
      for (let j = 0; j < segment.correspondence.length; j++) {
        let pair = segment.correspondence[j];
        if (j >= 1 && normalized[i2] < pair.fromCoord) {
          let prev = segment.correspondence[j - 1];
          normalized[i2] = ((normalized[i2] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) / (pair.fromCoord - prev.fromCoord + Number.EPSILON) + prev.toCoord;
          break;
        }
      }
    }
    return normalized;
  }
  transformPoints(gid, glyphPoints) {
    if (!this.font.fvar || !this.font.gvar) return;
    let { gvar } = this.font;
    if (gid >= gvar.glyphCount) return;
    let offset2 = gvar.offsets[gid];
    if (offset2 === gvar.offsets[gid + 1]) return;
    let { stream: stream2 } = this.font;
    stream2.pos = offset2;
    if (stream2.pos >= stream2.length) return;
    let tupleCount = stream2.readUInt16BE();
    let offsetToData = offset2 + stream2.readUInt16BE();
    if (tupleCount & $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS) {
      var here = stream2.pos;
      stream2.pos = offsetToData;
      var sharedPoints = this.decodePoints();
      offsetToData = stream2.pos;
      stream2.pos = here;
    }
    let origPoints = glyphPoints.map((pt) => pt.copy());
    tupleCount &= $0bb840cac04e911b$var$TUPLE_COUNT_MASK;
    for (let i2 = 0; i2 < tupleCount; i2++) {
      let tupleDataSize = stream2.readUInt16BE();
      let tupleIndex = stream2.readUInt16BE();
      if (tupleIndex & $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD) {
        var tupleCoords = [];
        for (let a4 = 0; a4 < gvar.axisCount; a4++) tupleCoords.push(stream2.readInt16BE() / 16384);
      } else {
        if ((tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK) >= gvar.globalCoordCount) throw new Error("Invalid gvar table");
        var tupleCoords = gvar.globalCoords[tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK];
      }
      if (tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) {
        var startCoords = [];
        for (let a4 = 0; a4 < gvar.axisCount; a4++) startCoords.push(stream2.readInt16BE() / 16384);
        var endCoords = [];
        for (let a4 = 0; a4 < gvar.axisCount; a4++) endCoords.push(stream2.readInt16BE() / 16384);
      }
      let factor2 = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
      if (factor2 === 0) {
        offsetToData += tupleDataSize;
        continue;
      }
      var here = stream2.pos;
      stream2.pos = offsetToData;
      if (tupleIndex & $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS) var points = this.decodePoints();
      else var points = sharedPoints;
      let nPoints = points.length === 0 ? glyphPoints.length : points.length;
      let xDeltas = this.decodeDeltas(nPoints);
      let yDeltas = this.decodeDeltas(nPoints);
      if (points.length === 0) for (let i3 = 0; i3 < glyphPoints.length; i3++) {
        var point = glyphPoints[i3];
        point.x += Math.round(xDeltas[i3] * factor2);
        point.y += Math.round(yDeltas[i3] * factor2);
      }
      else {
        let outPoints = origPoints.map((pt) => pt.copy());
        let hasDelta = glyphPoints.map(() => false);
        for (let i3 = 0; i3 < points.length; i3++) {
          let idx = points[i3];
          if (idx < glyphPoints.length) {
            let point2 = outPoints[idx];
            hasDelta[idx] = true;
            point2.x += xDeltas[i3] * factor2;
            point2.y += yDeltas[i3] * factor2;
          }
        }
        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);
        for (let i3 = 0; i3 < glyphPoints.length; i3++) {
          let deltaX = outPoints[i3].x - origPoints[i3].x;
          let deltaY = outPoints[i3].y - origPoints[i3].y;
          glyphPoints[i3].x = Math.round(glyphPoints[i3].x + deltaX);
          glyphPoints[i3].y = Math.round(glyphPoints[i3].y + deltaY);
        }
      }
      offsetToData += tupleDataSize;
      stream2.pos = here;
    }
  }
  decodePoints() {
    let stream2 = this.font.stream;
    let count3 = stream2.readUInt8();
    if (count3 & $0bb840cac04e911b$var$POINTS_ARE_WORDS) count3 = (count3 & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) << 8 | stream2.readUInt8();
    let points = new Uint16Array(count3);
    let i2 = 0;
    let point = 0;
    while (i2 < count3) {
      let run = stream2.readUInt8();
      let runCount = (run & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) + 1;
      let fn = run & $0bb840cac04e911b$var$POINTS_ARE_WORDS ? stream2.readUInt16 : stream2.readUInt8;
      for (let j = 0; j < runCount && i2 < count3; j++) {
        point += fn.call(stream2);
        points[i2++] = point;
      }
    }
    return points;
  }
  decodeDeltas(count3) {
    let stream2 = this.font.stream;
    let i2 = 0;
    let deltas = new Int16Array(count3);
    while (i2 < count3) {
      let run = stream2.readUInt8();
      let runCount = (run & $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK) + 1;
      if (run & $0bb840cac04e911b$var$DELTAS_ARE_ZERO) i2 += runCount;
      else {
        let fn = run & $0bb840cac04e911b$var$DELTAS_ARE_WORDS ? stream2.readInt16BE : stream2.readInt8;
        for (let j = 0; j < runCount && i2 < count3; j++) deltas[i2++] = fn.call(stream2);
      }
    }
    return deltas;
  }
  tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {
    let normalized = this.normalizedCoords;
    let { gvar } = this.font;
    let factor2 = 1;
    for (let i2 = 0; i2 < gvar.axisCount; i2++) {
      if (tupleCoords[i2] === 0) continue;
      if (normalized[i2] === 0) return 0;
      if ((tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) === 0) {
        if (normalized[i2] < Math.min(0, tupleCoords[i2]) || normalized[i2] > Math.max(0, tupleCoords[i2])) return 0;
        factor2 = (factor2 * normalized[i2] + Number.EPSILON) / (tupleCoords[i2] + Number.EPSILON);
      } else {
        if (normalized[i2] < startCoords[i2] || normalized[i2] > endCoords[i2]) return 0;
        else if (normalized[i2] < tupleCoords[i2]) factor2 = factor2 * (normalized[i2] - startCoords[i2] + Number.EPSILON) / (tupleCoords[i2] - startCoords[i2] + Number.EPSILON);
        else factor2 = factor2 * (endCoords[i2] - normalized[i2] + Number.EPSILON) / (endCoords[i2] - tupleCoords[i2] + Number.EPSILON);
      }
    }
    return factor2;
  }
  // Interpolates points without delta values.
  // Needed for the  and Q glyphs in Skia.
  // Algorithm from Freetype.
  interpolateMissingDeltas(points, inPoints, hasDelta) {
    if (points.length === 0) return;
    let point = 0;
    while (point < points.length) {
      let firstPoint = point;
      let endPoint = point;
      let pt = points[endPoint];
      while (!pt.endContour) pt = points[++endPoint];
      while (point <= endPoint && !hasDelta[point]) point++;
      if (point > endPoint) continue;
      let firstDelta = point;
      let curDelta = point;
      point++;
      while (point <= endPoint) {
        if (hasDelta[point]) {
          this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);
          curDelta = point;
        }
        point++;
      }
      if (curDelta === firstDelta) this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);
      else {
        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
        if (firstDelta > 0) this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);
      }
      point = endPoint + 1;
    }
  }
  deltaInterpolate(p1, p22, ref1, ref2, inPoints, outPoints) {
    if (p1 > p22) return;
    let iterable = [
      "x",
      "y"
    ];
    for (let i2 = 0; i2 < iterable.length; i2++) {
      let k3 = iterable[i2];
      if (inPoints[ref1][k3] > inPoints[ref2][k3]) {
        var p3 = ref1;
        ref1 = ref2;
        ref2 = p3;
      }
      let in1 = inPoints[ref1][k3];
      let in2 = inPoints[ref2][k3];
      let out1 = outPoints[ref1][k3];
      let out2 = outPoints[ref2][k3];
      if (in1 !== in2 || out1 === out2) {
        let scale2 = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
        for (let p4 = p1; p4 <= p22; p4++) {
          let out = inPoints[p4][k3];
          if (out <= in1) out += out1 - in1;
          else if (out >= in2) out += out2 - in2;
          else out = out1 + (out - in1) * scale2;
          outPoints[p4][k3] = out;
        }
      }
    }
  }
  deltaShift(p1, p22, ref2, inPoints, outPoints) {
    let deltaX = outPoints[ref2].x - inPoints[ref2].x;
    let deltaY = outPoints[ref2].y - inPoints[ref2].y;
    if (deltaX === 0 && deltaY === 0) return;
    for (let p3 = p1; p3 <= p22; p3++) if (p3 !== ref2) {
      outPoints[p3].x += deltaX;
      outPoints[p3].y += deltaY;
    }
  }
  getAdvanceAdjustment(gid, table3) {
    let outerIndex, innerIndex;
    if (table3.advanceWidthMapping) {
      let idx = gid;
      if (idx >= table3.advanceWidthMapping.mapCount) idx = table3.advanceWidthMapping.mapCount - 1;
      let entryFormat = table3.advanceWidthMapping.entryFormat;
      ({ outerIndex, innerIndex } = table3.advanceWidthMapping.mapData[idx]);
    } else {
      outerIndex = 0;
      innerIndex = gid;
    }
    return this.getDelta(table3.itemVariationStore, outerIndex, innerIndex);
  }
  // See pseudo code from `Font Variations Overview'
  // in the OpenType specification.
  getDelta(itemStore, outerIndex, innerIndex) {
    if (outerIndex >= itemStore.itemVariationData.length) return 0;
    let varData = itemStore.itemVariationData[outerIndex];
    if (innerIndex >= varData.deltaSets.length) return 0;
    let deltaSet = varData.deltaSets[innerIndex];
    let blendVector = this.getBlendVector(itemStore, outerIndex);
    let netAdjustment = 0;
    for (let master = 0; master < varData.regionIndexCount; master++) netAdjustment += deltaSet.deltas[master] * blendVector[master];
    return netAdjustment;
  }
  getBlendVector(itemStore, outerIndex) {
    let varData = itemStore.itemVariationData[outerIndex];
    if (this.blendVectors.has(varData)) return this.blendVectors.get(varData);
    let normalizedCoords = this.normalizedCoords;
    let blendVector = [];
    for (let master = 0; master < varData.regionIndexCount; master++) {
      let scalar = 1;
      let regionIndex = varData.regionIndexes[master];
      let axes = itemStore.variationRegionList.variationRegions[regionIndex];
      for (let j = 0; j < axes.length; j++) {
        let axis = axes[j];
        let axisScalar;
        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) axisScalar = 1;
        else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) axisScalar = 1;
        else if (axis.peakCoord === 0) axisScalar = 1;
        else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) axisScalar = 0;
        else {
          if (normalizedCoords[j] === axis.peakCoord) axisScalar = 1;
          else if (normalizedCoords[j] < axis.peakCoord) axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) / (axis.peakCoord - axis.startCoord + Number.EPSILON);
          else axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) / (axis.endCoord - axis.peakCoord + Number.EPSILON);
        }
        scalar *= axisScalar;
      }
      blendVector[master] = scalar;
    }
    this.blendVectors.set(varData, blendVector);
    return blendVector;
  }
  constructor(font, coords) {
    this.font = font;
    this.normalizedCoords = this.normalizeCoords(coords);
    this.blendVectors = /* @__PURE__ */ new Map();
  }
};
var $5cc7476da92df375$var$resolved = Promise.resolve();
var $5cc7476da92df375$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$5cc7476da92df375$export$2e2bcd8739ae039");
  }
  includeGlyph(glyph) {
    if (typeof glyph === "object") glyph = glyph.id;
    if (this.mapping[glyph] == null) {
      this.glyphs.push(glyph);
      this.mapping[glyph] = this.glyphs.length - 1;
    }
    return this.mapping[glyph];
  }
  constructor(font) {
    this.font = font;
    this.glyphs = [];
    this.mapping = {};
    this.includeGlyph(0);
  }
};
var $807e58506be70005$var$ON_CURVE = 1;
var $807e58506be70005$var$X_SHORT_VECTOR = 2;
var $807e58506be70005$var$Y_SHORT_VECTOR = 4;
var $807e58506be70005$var$REPEAT = 8;
var $807e58506be70005$var$SAME_X = 16;
var $807e58506be70005$var$SAME_Y = 32;
var $807e58506be70005$var$Point = class {
  static {
    __name(this, "$807e58506be70005$var$Point");
  }
  static size(val) {
    return val >= 0 && val <= 255 ? 1 : 2;
  }
  static encode(stream2, value2) {
    if (value2 >= 0 && value2 <= 255) stream2.writeUInt8(value2);
    else stream2.writeInt16BE(value2);
  }
};
var $807e58506be70005$var$Glyf = new Struct({
  numberOfContours: int16,
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16,
  endPtsOfContours: new ArrayT(uint16, "numberOfContours"),
  instructions: new ArrayT(uint8, uint16),
  flags: new ArrayT(uint8, 0),
  xPoints: new ArrayT($807e58506be70005$var$Point, 0),
  yPoints: new ArrayT($807e58506be70005$var$Point, 0)
});
var $807e58506be70005$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$807e58506be70005$export$2e2bcd8739ae039");
  }
  encodeSimple(path, instructions = []) {
    let endPtsOfContours = [];
    let xPoints = [];
    let yPoints = [];
    let flags = [];
    let same = 0;
    let lastX = 0, lastY = 0, lastFlag = 0;
    let pointCount = 0;
    for (let i2 = 0; i2 < path.commands.length; i2++) {
      let c2 = path.commands[i2];
      for (let j = 0; j < c2.args.length; j += 2) {
        let x = c2.args[j];
        let y3 = c2.args[j + 1];
        let flag = 0;
        if (c2.command === "quadraticCurveTo" && j === 2) {
          let next = path.commands[i2 + 1];
          if (next && next.command === "quadraticCurveTo") {
            let midX = (lastX + next.args[0]) / 2;
            let midY = (lastY + next.args[1]) / 2;
            if (x === midX && y3 === midY) continue;
          }
        }
        if (!(c2.command === "quadraticCurveTo" && j === 0)) flag |= $807e58506be70005$var$ON_CURVE;
        flag = this._encodePoint(x, lastX, xPoints, flag, $807e58506be70005$var$X_SHORT_VECTOR, $807e58506be70005$var$SAME_X);
        flag = this._encodePoint(y3, lastY, yPoints, flag, $807e58506be70005$var$Y_SHORT_VECTOR, $807e58506be70005$var$SAME_Y);
        if (flag === lastFlag && same < 255) {
          flags[flags.length - 1] |= $807e58506be70005$var$REPEAT;
          same++;
        } else {
          if (same > 0) {
            flags.push(same);
            same = 0;
          }
          flags.push(flag);
          lastFlag = flag;
        }
        lastX = x;
        lastY = y3;
        pointCount++;
      }
      if (c2.command === "closePath") endPtsOfContours.push(pointCount - 1);
    }
    if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== "closePath") endPtsOfContours.push(pointCount - 1);
    let bbox = path.bbox;
    let glyf = {
      numberOfContours: endPtsOfContours.length,
      xMin: bbox.minX,
      yMin: bbox.minY,
      xMax: bbox.maxX,
      yMax: bbox.maxY,
      endPtsOfContours,
      instructions,
      flags,
      xPoints,
      yPoints
    };
    let size = $807e58506be70005$var$Glyf.size(glyf);
    let tail = 4 - size % 4;
    let stream2 = new EncodeStream(size + tail);
    $807e58506be70005$var$Glyf.encode(stream2, glyf);
    if (tail !== 0) stream2.fill(0, tail);
    return stream2.buffer;
  }
  _encodePoint(value2, last2, points, flag, shortFlag, sameFlag) {
    let diff = value2 - last2;
    if (value2 === last2) flag |= sameFlag;
    else {
      if (-255 <= diff && diff <= 255) {
        flag |= shortFlag;
        if (diff < 0) diff = -diff;
        else flag |= sameFlag;
      }
      points.push(diff);
    }
    return flag;
  }
};
var $4abbb6a5dbdc441a$export$2e2bcd8739ae039 = class extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {
  static {
    __name(this, "$4abbb6a5dbdc441a$export$2e2bcd8739ae039");
  }
  _addGlyph(gid) {
    let glyph = this.font.getGlyph(gid);
    let glyf = glyph._decode();
    let curOffset = this.font.loca.offsets[gid];
    let nextOffset = this.font.loca.offsets[gid + 1];
    let stream2 = this.font._getTableStream("glyf");
    stream2.pos += curOffset;
    let buffer = stream2.readBuffer(nextOffset - curOffset);
    if (glyf && glyf.numberOfContours < 0) {
      buffer = new Uint8Array(buffer);
      let view = new DataView(buffer.buffer);
      for (let component of glyf.components) {
        gid = this.includeGlyph(component.glyphID);
        view.setUint16(component.pos, gid);
      }
    } else if (glyf && this.font._variationProcessor)
      buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);
    this.glyf.push(buffer);
    this.loca.offsets.push(this.offset);
    this.hmtx.metrics.push({
      advance: glyph.advanceWidth,
      bearing: glyph._getMetrics().leftBearing
    });
    this.offset += buffer.length;
    return this.glyf.length - 1;
  }
  encode() {
    this.glyf = [];
    this.offset = 0;
    this.loca = {
      offsets: [],
      version: this.font.loca.version
    };
    this.hmtx = {
      metrics: [],
      bearings: []
    };
    let i2 = 0;
    while (i2 < this.glyphs.length) this._addGlyph(this.glyphs[i2++]);
    let maxp = (0, import_clone.default)(this.font.maxp);
    maxp.numGlyphs = this.glyf.length;
    this.loca.offsets.push(this.offset);
    let head = (0, import_clone.default)(this.font.head);
    head.indexToLocFormat = this.loca.version;
    let hhea = (0, import_clone.default)(this.font.hhea);
    hhea.numberOfMetrics = this.hmtx.metrics.length;
    return (0, $816c07a04b6dba87$export$2e2bcd8739ae039).toBuffer({
      tables: {
        head,
        hhea,
        loca: this.loca,
        maxp,
        "cvt ": this.font["cvt "],
        prep: this.font.prep,
        glyf: this.glyf,
        hmtx: this.hmtx,
        fpgm: this.font.fpgm
      }
    });
  }
  constructor(font) {
    super(font);
    this.glyphEncoder = new (0, $807e58506be70005$export$2e2bcd8739ae039)();
  }
};
var $001d739428a71d5a$export$2e2bcd8739ae039 = class extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {
  static {
    __name(this, "$001d739428a71d5a$export$2e2bcd8739ae039");
  }
  subsetCharstrings() {
    this.charstrings = [];
    let gsubrs = {};
    for (let gid of this.glyphs) {
      this.charstrings.push(this.cff.getCharString(gid));
      let glyph = this.font.getGlyph(gid);
      let path = glyph.path;
      for (let subr in glyph._usedGsubrs) gsubrs[subr] = true;
    }
    this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
  }
  subsetSubrs(subrs, used) {
    let res = [];
    for (let i2 = 0; i2 < subrs.length; i2++) {
      let subr = subrs[i2];
      if (used[i2]) {
        this.cff.stream.pos = subr.offset;
        res.push(this.cff.stream.readBuffer(subr.length));
      } else res.push(new Uint8Array([
        11
      ]));
    }
    return res;
  }
  subsetFontdict(topDict) {
    topDict.FDArray = [];
    topDict.FDSelect = {
      version: 0,
      fds: []
    };
    let used_fds = {};
    let used_subrs = [];
    let fd_select = {};
    for (let gid of this.glyphs) {
      let fd = this.cff.fdForGlyph(gid);
      if (fd == null) continue;
      if (!used_fds[fd]) {
        topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));
        used_subrs.push({});
        fd_select[fd] = topDict.FDArray.length - 1;
      }
      used_fds[fd] = true;
      topDict.FDSelect.fds.push(fd_select[fd]);
      let glyph = this.font.getGlyph(gid);
      let path = glyph.path;
      for (let subr in glyph._usedSubrs) used_subrs[fd_select[fd]][subr] = true;
    }
    for (let i2 = 0; i2 < topDict.FDArray.length; i2++) {
      let dict = topDict.FDArray[i2];
      delete dict.FontName;
      if (dict.Private && dict.Private.Subrs) {
        dict.Private = Object.assign({}, dict.Private);
        dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i2]);
      }
    }
    return;
  }
  createCIDFontdict(topDict) {
    let used_subrs = {};
    for (let gid of this.glyphs) {
      let glyph = this.font.getGlyph(gid);
      let path = glyph.path;
      for (let subr in glyph._usedSubrs) used_subrs[subr] = true;
    }
    let privateDict = Object.assign({}, this.cff.topDict.Private);
    if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
    topDict.FDArray = [
      {
        Private: privateDict
      }
    ];
    return topDict.FDSelect = {
      version: 3,
      nRanges: 1,
      ranges: [
        {
          first: 0,
          fd: 0
        }
      ],
      sentinel: this.charstrings.length
    };
  }
  addString(string) {
    if (!string) return null;
    if (!this.strings) this.strings = [];
    this.strings.push(string);
    return (0, $229224aec43783c5$export$2e2bcd8739ae039).length + this.strings.length - 1;
  }
  encode() {
    this.subsetCharstrings();
    let charset = {
      version: this.charstrings.length > 255 ? 2 : 1,
      ranges: [
        {
          first: 1,
          nLeft: this.charstrings.length - 2
        }
      ]
    };
    let topDict = Object.assign({}, this.cff.topDict);
    topDict.Private = null;
    topDict.charset = charset;
    topDict.Encoding = null;
    topDict.CharStrings = this.charstrings;
    for (let key of [
      "version",
      "Notice",
      "Copyright",
      "FullName",
      "FamilyName",
      "Weight",
      "PostScript",
      "BaseFontName",
      "FontName"
    ]) topDict[key] = this.addString(this.cff.string(topDict[key]));
    topDict.ROS = [
      this.addString("Adobe"),
      this.addString("Identity"),
      0
    ];
    topDict.CIDCount = this.charstrings.length;
    if (this.cff.isCIDFont) this.subsetFontdict(topDict);
    else this.createCIDFontdict(topDict);
    let top = {
      version: 1,
      hdrSize: this.cff.hdrSize,
      offSize: 4,
      header: this.cff.header,
      nameIndex: [
        this.cff.postscriptName
      ],
      topDictIndex: [
        topDict
      ],
      stringIndex: this.strings,
      globalSubrIndex: this.gsubrs
    };
    return (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).toBuffer(top);
  }
  constructor(font) {
    super(font);
    this.cff = this.font["CFF "];
    if (!this.cff) throw new Error("Not a CFF Font");
  }
};
var $4c1709dee528ea76$export$2e2bcd8739ae039 = class _$4c1709dee528ea76$export$2e2bcd8739ae039 {
  static {
    __name(this, "$4c1709dee528ea76$export$2e2bcd8739ae039");
  }
  static probe(buffer) {
    let format3 = (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4));
    return format3 === "true" || format3 === "OTTO" || format3 === String.fromCharCode(0, 1, 0, 0);
  }
  setDefaultLanguage(lang = null) {
    this.defaultLanguage = lang;
  }
  _getTable(table3) {
    if (!(table3.tag in this._tables)) try {
      this._tables[table3.tag] = this._decodeTable(table3);
    } catch (e4) {
      if ($d636bc798e7178db$export$bd5c5d8b8dcafd78) {
        console.error(`Error decoding table ${table3.tag}`);
        console.error(e4.stack);
      }
    }
    return this._tables[table3.tag];
  }
  _getTableStream(tag) {
    let table3 = this.directory.tables[tag];
    if (table3) {
      this.stream.pos = table3.offset;
      return this.stream;
    }
    return null;
  }
  _decodeDirectory() {
    return this.directory = (0, $816c07a04b6dba87$export$2e2bcd8739ae039).decode(this.stream, {
      _startOffset: 0
    });
  }
  _decodeTable(table3) {
    let pos = this.stream.pos;
    let stream2 = this._getTableStream(table3.tag);
    let result = (0, $c3395722bea751e2$export$2e2bcd8739ae039)[table3.tag].decode(stream2, this, table3.length);
    this.stream.pos = pos;
    return result;
  }
  /**
  * Gets a string from the font's `name` table
  * `lang` is a BCP-47 language code.
  * @return {string}
  */
  getName(key, lang = this.defaultLanguage || $d636bc798e7178db$export$42940898df819940) {
    let record = this.name && this.name.records[key];
    if (record)
      return record[lang] || record[this.defaultLanguage] || record[$d636bc798e7178db$export$42940898df819940] || record["en"] || record[Object.keys(record)[0]] || null;
    return null;
  }
  /**
  * The unique PostScript name for this font, e.g. "Helvetica-Bold"
  * @type {string}
  */
  get postscriptName() {
    return this.getName("postscriptName");
  }
  /**
  * The font's full name, e.g. "Helvetica Bold"
  * @type {string}
  */
  get fullName() {
    return this.getName("fullName");
  }
  /**
  * The font's family name, e.g. "Helvetica"
  * @type {string}
  */
  get familyName() {
    return this.getName("fontFamily");
  }
  /**
  * The font's sub-family, e.g. "Bold".
  * @type {string}
  */
  get subfamilyName() {
    return this.getName("fontSubfamily");
  }
  /**
  * The font's copyright information
  * @type {string}
  */
  get copyright() {
    return this.getName("copyright");
  }
  /**
  * The font's version number
  * @type {string}
  */
  get version() {
    return this.getName("version");
  }
  /**
  * The fonts [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))
  * @type {number}
  */
  get ascent() {
    return this.hhea.ascent;
  }
  /**
  * The fonts [descender](https://en.wikipedia.org/wiki/Descender)
  * @type {number}
  */
  get descent() {
    return this.hhea.descent;
  }
  /**
  * The amount of space that should be included between lines
  * @type {number}
  */
  get lineGap() {
    return this.hhea.lineGap;
  }
  /**
  * The offset from the normal underline position that should be used
  * @type {number}
  */
  get underlinePosition() {
    return this.post.underlinePosition;
  }
  /**
  * The weight of the underline that should be used
  * @type {number}
  */
  get underlineThickness() {
    return this.post.underlineThickness;
  }
  /**
  * If this is an italic font, the angle the cursor should be drawn at to match the font design
  * @type {number}
  */
  get italicAngle() {
    return this.post.italicAngle;
  }
  /**
  * The height of capital letters above the baseline.
  * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.
  * @type {number}
  */
  get capHeight() {
    let os2 = this["OS/2"];
    return os2 ? os2.capHeight : this.ascent;
  }
  /**
  * The height of lower case letters in the font.
  * See [here](https://en.wikipedia.org/wiki/X-height) for more details.
  * @type {number}
  */
  get xHeight() {
    let os2 = this["OS/2"];
    return os2 ? os2.xHeight : 0;
  }
  /**
  * The number of glyphs in the font.
  * @type {number}
  */
  get numGlyphs() {
    return this.maxp.numGlyphs;
  }
  /**
  * The size of the fonts internal coordinate grid
  * @type {number}
  */
  get unitsPerEm() {
    return this.head.unitsPerEm;
  }
  /**
  * The fonts bounding box, i.e. the box that encloses all glyphs in the font.
  * @type {BBox}
  */
  get bbox() {
    return Object.freeze(new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
  }
  get _cmapProcessor() {
    return new (0, $f08dd41ef10b694c$export$2e2bcd8739ae039)(this.cmap);
  }
  /**
  * An array of all of the unicode code points supported by the font.
  * @type {number[]}
  */
  get characterSet() {
    return this._cmapProcessor.getCharacterSet();
  }
  /**
  * Returns whether there is glyph in the font for the given unicode code point.
  *
  * @param {number} codePoint
  * @return {boolean}
  */
  hasGlyphForCodePoint(codePoint) {
    return !!this._cmapProcessor.lookup(codePoint);
  }
  /**
  * Maps a single unicode code point to a Glyph object.
  * Does not perform any advanced substitutions (there is no context to do so).
  *
  * @param {number} codePoint
  * @return {Glyph}
  */
  glyphForCodePoint(codePoint) {
    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [
      codePoint
    ]);
  }
  /**
  * Returns an array of Glyph objects for the given string.
  * This is only a one-to-one mapping from characters to glyphs.
  * For most uses, you should use font.layout (described below), which
  * provides a much more advanced mapping supporting AAT and OpenType shaping.
  *
  * @param {string} string
  * @return {Glyph[]}
  */
  glyphsForString(string) {
    let glyphs = [];
    let len = string.length;
    let idx = 0;
    let last2 = -1;
    let state2 = -1;
    while (idx <= len) {
      let code = 0;
      let nextState = 0;
      if (idx < len) {
        code = string.charCodeAt(idx++);
        if (55296 <= code && code <= 56319 && idx < len) {
          let next = string.charCodeAt(idx);
          if (56320 <= next && next <= 57343) {
            idx++;
            code = ((code & 1023) << 10) + (next & 1023) + 65536;
          }
        }
        nextState = 65024 <= code && code <= 65039 || 917760 <= code && code <= 917999 ? 1 : 0;
      } else idx++;
      if (state2 === 0 && nextState === 1)
        glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last2, code), [
          last2,
          code
        ]));
      else if (state2 === 0 && nextState === 0)
        glyphs.push(this.glyphForCodePoint(last2));
      last2 = code;
      state2 = nextState;
    }
    return glyphs;
  }
  get _layoutEngine() {
    return new (0, $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039)(this);
  }
  /**
  * Returns a GlyphRun object, which includes an array of Glyphs and GlyphPositions for the given string.
  *
  * @param {string} string
  * @param {string[]} [userFeatures]
  * @param {string} [script]
  * @param {string} [language]
  * @param {string} [direction]
  * @return {GlyphRun}
  */
  layout(string, userFeatures, script, language, direction) {
    return this._layoutEngine.layout(string, userFeatures, script, language, direction);
  }
  /**
  * Returns an array of strings that map to the given glyph id.
  * @param {number} gid - glyph id
  */
  stringsForGlyph(gid) {
    return this._layoutEngine.stringsForGlyph(gid);
  }
  /**
  * An array of all [OpenType feature tags](https://www.microsoft.com/typography/otspec/featuretags.htm)
  * (or mapped AAT tags) supported by the font.
  * The features parameter is an array of OpenType feature tags to be applied in addition to the default set.
  * If this is an AAT font, the OpenType feature tags are mapped to AAT features.
  *
  * @type {string[]}
  */
  get availableFeatures() {
    return this._layoutEngine.getAvailableFeatures();
  }
  getAvailableFeatures(script, language) {
    return this._layoutEngine.getAvailableFeatures(script, language);
  }
  _getBaseGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.glyf) this._glyphs[glyph] = new (0, $69aac16029968692$export$2e2bcd8739ae039)(glyph, characters2, this);
      else if (this.directory.tables["CFF "] || this.directory.tables.CFF2) this._glyphs[glyph] = new (0, $62cc5109c6101893$export$2e2bcd8739ae039)(glyph, characters2, this);
    }
    return this._glyphs[glyph] || null;
  }
  /**
  * Returns a glyph object for the given glyph id.
  * You can pass the array of code points this glyph represents for
  * your use later, and it will be stored in the glyph object.
  *
  * @param {number} glyph
  * @param {number[]} characters
  * @return {Glyph}
  */
  getGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.sbix) this._glyphs[glyph] = new (0, $25d8f049c222084c$export$2e2bcd8739ae039)(glyph, characters2, this);
      else if (this.directory.tables.COLR && this.directory.tables.CPAL) this._glyphs[glyph] = new (0, $0d411f0165859681$export$2e2bcd8739ae039)(glyph, characters2, this);
      else this._getBaseGlyph(glyph, characters2);
    }
    return this._glyphs[glyph] || null;
  }
  /**
  * Returns a Subset for this font.
  * @return {Subset}
  */
  createSubset() {
    if (this.directory.tables["CFF "]) return new (0, $001d739428a71d5a$export$2e2bcd8739ae039)(this);
    return new (0, $4abbb6a5dbdc441a$export$2e2bcd8739ae039)(this);
  }
  /**
  * Returns an object describing the available variation axes
  * that this font supports. Keys are setting tags, and values
  * contain the axis name, range, and default value.
  *
  * @type {object}
  */
  get variationAxes() {
    let res = {};
    if (!this.fvar) return res;
    for (let axis of this.fvar.axis) res[axis.axisTag.trim()] = {
      name: axis.name.en,
      min: axis.minValue,
      default: axis.defaultValue,
      max: axis.maxValue
    };
    return res;
  }
  /**
  * Returns an object describing the named variation instances
  * that the font designer has specified. Keys are variation names
  * and values are the variation settings for this instance.
  *
  * @type {object}
  */
  get namedVariations() {
    let res = {};
    if (!this.fvar) return res;
    for (let instance of this.fvar.instance) {
      let settings = {};
      for (let i2 = 0; i2 < this.fvar.axis.length; i2++) {
        let axis = this.fvar.axis[i2];
        settings[axis.axisTag.trim()] = instance.coord[i2];
      }
      res[instance.name.en] = settings;
    }
    return res;
  }
  /**
  * Returns a new font with the given variation settings applied.
  * Settings can either be an instance name, or an object containing
  * variation tags as specified by the `variationAxes` property.
  *
  * @param {object} settings
  * @return {TTFFont}
  */
  getVariation(settings) {
    if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2))) throw new Error("Variations require a font with the fvar, gvar and glyf, or CFF2 tables.");
    if (typeof settings === "string") settings = this.namedVariations[settings];
    if (typeof settings !== "object") throw new Error("Variation settings must be either a variation name or settings object.");
    let coords = this.fvar.axis.map((axis, i2) => {
      let axisTag = axis.axisTag.trim();
      if (axisTag in settings) return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));
      else return axis.defaultValue;
    });
    let stream2 = new DecodeStream(this.stream.buffer);
    stream2.pos = this._directoryPos;
    let font = new _$4c1709dee528ea76$export$2e2bcd8739ae039(stream2, coords);
    font._tables = this._tables;
    return font;
  }
  get _variationProcessor() {
    if (!this.fvar) return null;
    let variationCoords = this.variationCoords;
    if (!variationCoords && !this.CFF2) return null;
    if (!variationCoords) variationCoords = this.fvar.axis.map((axis) => axis.defaultValue);
    return new (0, $0bb840cac04e911b$export$2e2bcd8739ae039)(this, variationCoords);
  }
  // Standardized format plugin API
  getFont(name) {
    return this.getVariation(name);
  }
  constructor(stream2, variationCoords = null) {
    (0, _define_property)(this, "type", "TTF");
    this.defaultLanguage = null;
    this.stream = stream2;
    this.variationCoords = variationCoords;
    this._directoryPos = this.stream.pos;
    this._tables = {};
    this._glyphs = {};
    this._decodeDirectory();
    for (let tag in this.directory.tables) {
      let table3 = this.directory.tables[tag];
      if ((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag] && table3.length > 0) Object.defineProperty(this, tag, {
        get: this._getTable.bind(this, table3)
      });
    }
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "bbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_cmapProcessor", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "characterSet", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_layoutEngine", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "variationAxes", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "namedVariations", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_variationProcessor", null);
var $c1726355ecc5b889$var$WOFFDirectoryEntry = new Struct({
  tag: new StringT(4),
  offset: new Pointer(uint32, "void", {
    type: "global"
  }),
  compLength: uint32,
  length: uint32,
  origChecksum: uint32
});
var $c1726355ecc5b889$var$WOFFDirectory = new Struct({
  tag: new StringT(4),
  flavor: uint32,
  length: uint32,
  numTables: uint16,
  reserved: new Reserved(uint16),
  totalSfntSize: uint32,
  majorVersion: uint16,
  minorVersion: uint16,
  metaOffset: uint32,
  metaLength: uint32,
  metaOrigLength: uint32,
  privOffset: uint32,
  privLength: uint32,
  tables: new ArrayT($c1726355ecc5b889$var$WOFFDirectoryEntry, "numTables")
});
$c1726355ecc5b889$var$WOFFDirectory.process = function() {
  let tables = {};
  for (let table3 of this.tables) tables[table3.tag] = table3;
  this.tables = tables;
};
var $c1726355ecc5b889$export$2e2bcd8739ae039 = $c1726355ecc5b889$var$WOFFDirectory;
var $760785214b9fc52c$export$2e2bcd8739ae039 = class extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {
  static {
    __name(this, "$760785214b9fc52c$export$2e2bcd8739ae039");
  }
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "wOFF";
  }
  _decodeDirectory() {
    this.directory = (0, $c1726355ecc5b889$export$2e2bcd8739ae039).decode(this.stream, {
      _startOffset: 0
    });
  }
  _getTableStream(tag) {
    let table3 = this.directory.tables[tag];
    if (table3) {
      this.stream.pos = table3.offset;
      if (table3.compLength < table3.length) {
        this.stream.pos += 2;
        let outBuffer = new Uint8Array(table3.length);
        let buf = (0, import_tiny_inflate.default)(this.stream.readBuffer(table3.compLength - 2), outBuffer);
        return new DecodeStream(buf);
      } else return this.stream;
    }
    return null;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF");
  }
};
var $8046190c9f1ad19e$export$2e2bcd8739ae039 = class extends (0, $69aac16029968692$export$2e2bcd8739ae039) {
  static {
    __name(this, "$8046190c9f1ad19e$export$2e2bcd8739ae039");
  }
  _decode() {
    return this._font._transformedGlyphs[this.id];
  }
  _getCBox() {
    return this.path.bbox;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF2");
  }
};
var $c28ec7bbb3b8de3a$var$Base128 = {
  decode(stream2) {
    let result = 0;
    let iterable = [
      0,
      1,
      2,
      3,
      4
    ];
    for (let j = 0; j < iterable.length; j++) {
      let i2 = iterable[j];
      let code = stream2.readUInt8();
      if (result & 3758096384) throw new Error("Overflow");
      result = result << 7 | code & 127;
      if ((code & 128) === 0) return result;
    }
    throw new Error("Bad base 128 number");
  }
};
var $c28ec7bbb3b8de3a$var$knownTags = [
  "cmap",
  "head",
  "hhea",
  "hmtx",
  "maxp",
  "name",
  "OS/2",
  "post",
  "cvt ",
  "fpgm",
  "glyf",
  "loca",
  "prep",
  "CFF ",
  "VORG",
  "EBDT",
  "EBLC",
  "gasp",
  "hdmx",
  "kern",
  "LTSH",
  "PCLT",
  "VDMX",
  "vhea",
  "vmtx",
  "BASE",
  "GDEF",
  "GPOS",
  "GSUB",
  "EBSC",
  "JSTF",
  "MATH",
  "CBDT",
  "CBLC",
  "COLR",
  "CPAL",
  "SVG ",
  "sbix",
  "acnt",
  "avar",
  "bdat",
  "bloc",
  "bsln",
  "cvar",
  "fdsc",
  "feat",
  "fmtx",
  "fvar",
  "gvar",
  "hsty",
  "just",
  "lcar",
  "mort",
  "morx",
  "opbd",
  "prop",
  "trak",
  "Zapf",
  "Silf",
  "Glat",
  "Gloc",
  "Feat",
  "Sill"
];
var $c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry = new Struct({
  flags: uint8,
  customTag: new Optional(new StringT(4), (t4) => (t4.flags & 63) === 63),
  tag: /* @__PURE__ */ __name((t4) => t4.customTag || $c28ec7bbb3b8de3a$var$knownTags[t4.flags & 63], "tag"),
  length: $c28ec7bbb3b8de3a$var$Base128,
  transformVersion: /* @__PURE__ */ __name((t4) => t4.flags >>> 6 & 3, "transformVersion"),
  transformed: /* @__PURE__ */ __name((t4) => t4.tag === "glyf" || t4.tag === "loca" ? t4.transformVersion === 0 : t4.transformVersion !== 0, "transformed"),
  transformLength: new Optional($c28ec7bbb3b8de3a$var$Base128, (t4) => t4.transformed)
});
var $c28ec7bbb3b8de3a$var$WOFF2Directory = new Struct({
  tag: new StringT(4),
  flavor: uint32,
  length: uint32,
  numTables: uint16,
  reserved: new Reserved(uint16),
  totalSfntSize: uint32,
  totalCompressedSize: uint32,
  majorVersion: uint16,
  minorVersion: uint16,
  metaOffset: uint32,
  metaLength: uint32,
  metaOrigLength: uint32,
  privOffset: uint32,
  privLength: uint32,
  tables: new ArrayT($c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry, "numTables")
});
$c28ec7bbb3b8de3a$var$WOFF2Directory.process = function() {
  let tables = {};
  for (let i2 = 0; i2 < this.tables.length; i2++) {
    let table3 = this.tables[i2];
    tables[table3.tag] = table3;
  }
  return this.tables = tables;
};
var $c28ec7bbb3b8de3a$export$2e2bcd8739ae039 = $c28ec7bbb3b8de3a$var$WOFF2Directory;
var $21ee218f84ac7f32$export$2e2bcd8739ae039 = class extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {
  static {
    __name(this, "$21ee218f84ac7f32$export$2e2bcd8739ae039");
  }
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "wOF2";
  }
  _decodeDirectory() {
    this.directory = (0, $c28ec7bbb3b8de3a$export$2e2bcd8739ae039).decode(this.stream);
    this._dataPos = this.stream.pos;
  }
  _decompress() {
    if (!this._decompressed) {
      this.stream.pos = this._dataPos;
      let buffer = this.stream.readBuffer(this.directory.totalCompressedSize);
      let decompressedSize = 0;
      for (let tag in this.directory.tables) {
        let entry = this.directory.tables[tag];
        entry.offset = decompressedSize;
        decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;
      }
      let decompressed = (0, import_decompress.default)(buffer, decompressedSize);
      if (!decompressed) throw new Error("Error decoding compressed data in WOFF2");
      this.stream = new DecodeStream(decompressed);
      this._decompressed = true;
    }
  }
  _decodeTable(table3) {
    this._decompress();
    return super._decodeTable(table3);
  }
  // Override this method to get a glyph and return our
  // custom subclass if there is a glyf table.
  _getBaseGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {
        if (!this._transformedGlyphs) this._transformGlyfTable();
        return this._glyphs[glyph] = new (0, $8046190c9f1ad19e$export$2e2bcd8739ae039)(glyph, characters2, this);
      } else return super._getBaseGlyph(glyph, characters2);
    }
  }
  _transformGlyfTable() {
    this._decompress();
    this.stream.pos = this.directory.tables.glyf.offset;
    let table3 = $21ee218f84ac7f32$var$GlyfTable.decode(this.stream);
    let glyphs = [];
    for (let index2 = 0; index2 < table3.numGlyphs; index2++) {
      let glyph = {};
      let nContours = table3.nContours.readInt16BE();
      glyph.numberOfContours = nContours;
      if (nContours > 0) {
        let nPoints = [];
        let totalPoints = 0;
        for (let i2 = 0; i2 < nContours; i2++) {
          let r5 = $21ee218f84ac7f32$var$read255UInt16(table3.nPoints);
          totalPoints += r5;
          nPoints.push(totalPoints);
        }
        glyph.points = $21ee218f84ac7f32$var$decodeTriplet(table3.flags, table3.glyphs, totalPoints);
        for (let i2 = 0; i2 < nContours; i2++) glyph.points[nPoints[i2] - 1].endContour = true;
        var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table3.glyphs);
      } else if (nContours < 0) {
        let haveInstructions = (0, $69aac16029968692$export$2e2bcd8739ae039).prototype._decodeComposite.call({
          _font: this
        }, glyph, table3.composites);
        if (haveInstructions) var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table3.glyphs);
      }
      glyphs.push(glyph);
    }
    this._transformedGlyphs = glyphs;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF2");
  }
};
var $21ee218f84ac7f32$var$Substream = class {
  static {
    __name(this, "$21ee218f84ac7f32$var$Substream");
  }
  decode(stream2, parent) {
    return new DecodeStream(this._buf.decode(stream2, parent));
  }
  constructor(length2) {
    this.length = length2;
    this._buf = new BufferT(length2);
  }
};
var $21ee218f84ac7f32$var$GlyfTable = new Struct({
  version: uint32,
  numGlyphs: uint16,
  indexFormat: uint16,
  nContourStreamSize: uint32,
  nPointsStreamSize: uint32,
  flagStreamSize: uint32,
  glyphStreamSize: uint32,
  compositeStreamSize: uint32,
  bboxStreamSize: uint32,
  instructionStreamSize: uint32,
  nContours: new $21ee218f84ac7f32$var$Substream("nContourStreamSize"),
  nPoints: new $21ee218f84ac7f32$var$Substream("nPointsStreamSize"),
  flags: new $21ee218f84ac7f32$var$Substream("flagStreamSize"),
  glyphs: new $21ee218f84ac7f32$var$Substream("glyphStreamSize"),
  composites: new $21ee218f84ac7f32$var$Substream("compositeStreamSize"),
  bboxes: new $21ee218f84ac7f32$var$Substream("bboxStreamSize"),
  instructions: new $21ee218f84ac7f32$var$Substream("instructionStreamSize")
});
var $21ee218f84ac7f32$var$WORD_CODE = 253;
var $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2 = 254;
var $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1 = 255;
var $21ee218f84ac7f32$var$LOWEST_U_CODE = 253;
function $21ee218f84ac7f32$var$read255UInt16(stream2) {
  let code = stream2.readUInt8();
  if (code === $21ee218f84ac7f32$var$WORD_CODE) return stream2.readUInt16BE();
  if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1) return stream2.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE;
  if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2) return stream2.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE * 2;
  return code;
}
__name($21ee218f84ac7f32$var$read255UInt16, "$21ee218f84ac7f32$var$read255UInt16");
function $21ee218f84ac7f32$var$withSign(flag, baseval) {
  return flag & 1 ? baseval : -baseval;
}
__name($21ee218f84ac7f32$var$withSign, "$21ee218f84ac7f32$var$withSign");
function $21ee218f84ac7f32$var$decodeTriplet(flags, glyphs, nPoints) {
  let y3;
  let x = y3 = 0;
  let res = [];
  for (let i2 = 0; i2 < nPoints; i2++) {
    let dx = 0, dy = 0;
    let flag = flags.readUInt8();
    let onCurve = !(flag >> 7);
    flag &= 127;
    if (flag < 10) {
      dx = 0;
      dy = $21ee218f84ac7f32$var$withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());
    } else if (flag < 20) {
      dx = $21ee218f84ac7f32$var$withSign(flag, ((flag - 10 & 14) << 7) + glyphs.readUInt8());
      dy = 0;
    } else if (flag < 84) {
      var b0 = flag - 20;
      var b1 = glyphs.readUInt8();
      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b0 & 48) + (b1 >> 4));
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + ((b0 & 12) << 2) + (b1 & 15));
    } else if (flag < 120) {
      var b0 = flag - 84;
      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b0 / 12 << 8) + glyphs.readUInt8());
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphs.readUInt8());
    } else if (flag < 124) {
      var b1 = glyphs.readUInt8();
      let b22 = glyphs.readUInt8();
      dx = $21ee218f84ac7f32$var$withSign(flag, (b1 << 4) + (b22 >> 4));
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, ((b22 & 15) << 8) + glyphs.readUInt8());
    } else {
      dx = $21ee218f84ac7f32$var$withSign(flag, glyphs.readUInt16BE());
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, glyphs.readUInt16BE());
    }
    x += dx;
    y3 += dy;
    res.push(new (0, $69aac16029968692$export$baf26146a414f24a)(onCurve, false, x, y3));
  }
  return res;
}
__name($21ee218f84ac7f32$var$decodeTriplet, "$21ee218f84ac7f32$var$decodeTriplet");
var $cd5853a56c68fec7$var$TTCHeader = new VersionedStruct(uint32, {
  65536: {
    numFonts: uint32,
    offsets: new ArrayT(uint32, "numFonts")
  },
  131072: {
    numFonts: uint32,
    offsets: new ArrayT(uint32, "numFonts"),
    dsigTag: uint32,
    dsigLength: uint32,
    dsigOffset: uint32
  }
});
var $cd5853a56c68fec7$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$cd5853a56c68fec7$export$2e2bcd8739ae039");
  }
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "ttcf";
  }
  getFont(name) {
    for (let offset2 of this.header.offsets) {
      let stream2 = new DecodeStream(this.stream.buffer);
      stream2.pos = offset2;
      let font = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2);
      if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v3, i2) => name[i2] === v3)) return font;
    }
    return null;
  }
  get fonts() {
    let fonts = [];
    for (let offset2 of this.header.offsets) {
      let stream2 = new DecodeStream(this.stream.buffer);
      stream2.pos = offset2;
      fonts.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2));
    }
    return fonts;
  }
  constructor(stream2) {
    (0, _define_property)(this, "type", "TTC");
    this.stream = stream2;
    if (stream2.readString(4) !== "ttcf") throw new Error("Not a TrueType collection");
    this.header = $cd5853a56c68fec7$var$TTCHeader.decode(stream2);
  }
};
var $05f49f930186144e$var$DFontName = new StringT(uint8);
var $05f49f930186144e$var$DFontData = new Struct({
  len: uint32,
  buf: new BufferT("len")
});
var $05f49f930186144e$var$Ref = new Struct({
  id: uint16,
  nameOffset: int16,
  attr: uint8,
  dataOffset: uint24,
  handle: uint32
});
var $05f49f930186144e$var$Type = new Struct({
  name: new StringT(4),
  maxTypeIndex: uint16,
  refList: new Pointer(uint16, new ArrayT($05f49f930186144e$var$Ref, (t4) => t4.maxTypeIndex + 1), {
    type: "parent"
  })
});
var $05f49f930186144e$var$TypeList = new Struct({
  length: uint16,
  types: new ArrayT($05f49f930186144e$var$Type, (t4) => t4.length + 1)
});
var $05f49f930186144e$var$DFontMap = new Struct({
  reserved: new Reserved(uint8, 24),
  typeList: new Pointer(uint16, $05f49f930186144e$var$TypeList),
  nameListOffset: new Pointer(uint16, "void")
});
var $05f49f930186144e$var$DFontHeader = new Struct({
  dataOffset: uint32,
  map: new Pointer(uint32, $05f49f930186144e$var$DFontMap),
  dataLength: uint32,
  mapLength: uint32
});
var $05f49f930186144e$export$2e2bcd8739ae039 = class {
  static {
    __name(this, "$05f49f930186144e$export$2e2bcd8739ae039");
  }
  static probe(buffer) {
    let stream2 = new DecodeStream(buffer);
    try {
      var header = $05f49f930186144e$var$DFontHeader.decode(stream2);
    } catch (e4) {
      return false;
    }
    for (let type2 of header.map.typeList.types) {
      if (type2.name === "sfnt") return true;
    }
    return false;
  }
  getFont(name) {
    if (!this.sfnt) return null;
    for (let ref2 of this.sfnt.refList) {
      let pos = this.header.dataOffset + ref2.dataOffset + 4;
      let stream2 = new DecodeStream(this.stream.buffer.slice(pos));
      let font = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2);
      if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v3, i2) => name[i2] === v3)) return font;
    }
    return null;
  }
  get fonts() {
    let fonts = [];
    for (let ref2 of this.sfnt.refList) {
      let pos = this.header.dataOffset + ref2.dataOffset + 4;
      let stream2 = new DecodeStream(this.stream.buffer.slice(pos));
      fonts.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2));
    }
    return fonts;
  }
  constructor(stream2) {
    (0, _define_property)(this, "type", "DFont");
    this.stream = stream2;
    this.header = $05f49f930186144e$var$DFontHeader.decode(this.stream);
    for (let type2 of this.header.map.typeList.types) {
      for (let ref2 of type2.refList) if (ref2.nameOffset >= 0) {
        this.stream.pos = ref2.nameOffset + this.header.map.nameListOffset;
        ref2.name = $05f49f930186144e$var$DFontName.decode(this.stream);
      } else ref2.name = null;
      if (type2.name === "sfnt") this.sfnt = type2;
    }
  }
};
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $4c1709dee528ea76$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $760785214b9fc52c$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $21ee218f84ac7f32$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $cd5853a56c68fec7$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $05f49f930186144e$export$2e2bcd8739ae039));

// ../../node_modules/.pnpm/@react-pdf+pdfkit@4.1.0/node_modules/@react-pdf/pdfkit/lib/pdfkit.browser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_zstream = __toESM(require_zstream(), 1);
var import_deflate = __toESM(require_deflate(), 1);
var import_inflate = __toESM(require_inflate(), 1);
var import_constants3 = __toESM(require_constants(), 1);
var import_md5 = __toESM(require_md5(), 1);

// ../../node_modules/.pnpm/linebreak@1.1.0/node_modules/linebreak/dist/module.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_unicode_trie3 = __toESM(require_unicode_trie(), 1);
var import_base64_js2 = __toESM(require_b64(), 1);
var $557adaaeb0c7885f$exports = {};
var $1627905f8be2ef3f$export$fb4028874a74450 = 5;
var $1627905f8be2ef3f$export$1bb1140fe1358b00 = 12;
var $1627905f8be2ef3f$export$f3e416a182673355 = 13;
var $1627905f8be2ef3f$export$24aa617c849a894a = 16;
var $1627905f8be2ef3f$export$a73c4d14459b698d = 17;
var $1627905f8be2ef3f$export$9e5d732f3676a9ba = 22;
var $1627905f8be2ef3f$export$1dff41d5c0caca01 = 28;
var $1627905f8be2ef3f$export$30a74a373318dec6 = 31;
var $1627905f8be2ef3f$export$d710c5f50fc7496a = 33;
var $1627905f8be2ef3f$export$66498d28055820a9 = 34;
var $1627905f8be2ef3f$export$eb6c6d0b7c8826f2 = 35;
var $1627905f8be2ef3f$export$de92be486109a1df = 36;
var $1627905f8be2ef3f$export$606cfc2a8896c91f = 37;
var $1627905f8be2ef3f$export$e51d3c675bb0140d = 38;
var $1627905f8be2ef3f$export$da51c6332ad11d7b = 39;
var $1627905f8be2ef3f$export$bea437c40441867d = 40;
var $1627905f8be2ef3f$export$c4c7eecbfed13dc9 = 41;
var $1627905f8be2ef3f$export$98e1f8a379849661 = 42;
var $32627af916ac1b00$export$98f50d781a474745 = 0;
var $32627af916ac1b00$export$12ee1f8f5315ca7e = 1;
var $32627af916ac1b00$export$e4965ce242860454 = 2;
var $32627af916ac1b00$export$8f14048969dcd45e = 3;
var $32627af916ac1b00$export$133eb141bf58aff4 = 4;
var $32627af916ac1b00$export$5bdb8ccbf5c57afc = [
  //OP   , CL    , CP    , QU    , GL    , NS    , EX    , SY    , IS    , PR    , PO    , NU    , AL    , HL    , ID    , IN    , HY    , BA    , BB    , B2    , ZW    , CM    , WJ    , H2    , H3    , JL    , JV    , JT    , RI    , EB    , EM    , ZWJ   , CB
  [
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$8f14048969dcd45e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ]
  // CB
];
var $557adaaeb0c7885f$var$data = import_base64_js2.default.toByteArray("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");
var $557adaaeb0c7885f$var$classTrie = new import_unicode_trie3.default($557adaaeb0c7885f$var$data);
var $557adaaeb0c7885f$var$mapClass = /* @__PURE__ */ __name(function(c2) {
  switch (c2) {
    case $1627905f8be2ef3f$export$d710c5f50fc7496a:
      return $1627905f8be2ef3f$export$1bb1140fe1358b00;
    case $1627905f8be2ef3f$export$da51c6332ad11d7b:
    case $1627905f8be2ef3f$export$bea437c40441867d:
    case $1627905f8be2ef3f$export$98e1f8a379849661:
      return $1627905f8be2ef3f$export$1bb1140fe1358b00;
    case $1627905f8be2ef3f$export$eb6c6d0b7c8826f2:
      return $1627905f8be2ef3f$export$fb4028874a74450;
    default:
      return c2;
  }
}, "$557adaaeb0c7885f$var$mapClass");
var $557adaaeb0c7885f$var$mapFirst = /* @__PURE__ */ __name(function(c2) {
  switch (c2) {
    case $1627905f8be2ef3f$export$606cfc2a8896c91f:
    case $1627905f8be2ef3f$export$e51d3c675bb0140d:
      return $1627905f8be2ef3f$export$66498d28055820a9;
    case $1627905f8be2ef3f$export$c4c7eecbfed13dc9:
      return $1627905f8be2ef3f$export$9e5d732f3676a9ba;
    default:
      return c2;
  }
}, "$557adaaeb0c7885f$var$mapFirst");
var $557adaaeb0c7885f$var$Break = class {
  static {
    __name(this, "$557adaaeb0c7885f$var$Break");
  }
  constructor(position, required = false) {
    this.position = position;
    this.required = required;
  }
};
var $557adaaeb0c7885f$var$LineBreaker = class {
  static {
    __name(this, "$557adaaeb0c7885f$var$LineBreaker");
  }
  nextCodePoint() {
    const code = this.string.charCodeAt(this.pos++);
    const next = this.string.charCodeAt(this.pos);
    if (55296 <= code && code <= 56319 && 56320 <= next && next <= 57343) {
      this.pos++;
      return (code - 55296) * 1024 + (next - 56320) + 65536;
    }
    return code;
  }
  nextCharClass() {
    return $557adaaeb0c7885f$var$mapClass($557adaaeb0c7885f$var$classTrie.get(this.nextCodePoint()));
  }
  getSimpleBreak() {
    switch (this.nextClass) {
      case $1627905f8be2ef3f$export$c4c7eecbfed13dc9:
        return false;
      case $1627905f8be2ef3f$export$66498d28055820a9:
      case $1627905f8be2ef3f$export$606cfc2a8896c91f:
      case $1627905f8be2ef3f$export$e51d3c675bb0140d:
        this.curClass = $1627905f8be2ef3f$export$66498d28055820a9;
        return false;
      case $1627905f8be2ef3f$export$de92be486109a1df:
        this.curClass = $1627905f8be2ef3f$export$de92be486109a1df;
        return false;
    }
    return null;
  }
  getPairTableBreak(lastClass) {
    let shouldBreak2 = false;
    switch ($32627af916ac1b00$export$5bdb8ccbf5c57afc[this.curClass][this.nextClass]) {
      case $32627af916ac1b00$export$98f50d781a474745:
        shouldBreak2 = true;
        break;
      case $32627af916ac1b00$export$12ee1f8f5315ca7e:
        shouldBreak2 = lastClass === $1627905f8be2ef3f$export$c4c7eecbfed13dc9;
        break;
      case $32627af916ac1b00$export$e4965ce242860454:
        shouldBreak2 = lastClass === $1627905f8be2ef3f$export$c4c7eecbfed13dc9;
        if (!shouldBreak2) {
          shouldBreak2 = false;
          return shouldBreak2;
        }
        break;
      case $32627af916ac1b00$export$8f14048969dcd45e:
        if (lastClass !== $1627905f8be2ef3f$export$c4c7eecbfed13dc9) return shouldBreak2;
        break;
      case $32627af916ac1b00$export$133eb141bf58aff4:
        break;
    }
    if (this.LB8a) shouldBreak2 = false;
    if (this.LB21a && (this.curClass === $1627905f8be2ef3f$export$24aa617c849a894a || this.curClass === $1627905f8be2ef3f$export$a73c4d14459b698d)) {
      shouldBreak2 = false;
      this.LB21a = false;
    } else this.LB21a = this.curClass === $1627905f8be2ef3f$export$f3e416a182673355;
    if (this.curClass === $1627905f8be2ef3f$export$1dff41d5c0caca01) {
      this.LB30a++;
      if (this.LB30a == 2 && this.nextClass === $1627905f8be2ef3f$export$1dff41d5c0caca01) {
        shouldBreak2 = true;
        this.LB30a = 0;
      }
    } else this.LB30a = 0;
    this.curClass = this.nextClass;
    return shouldBreak2;
  }
  nextBreak() {
    if (this.curClass == null) {
      let firstClass = this.nextCharClass();
      this.curClass = $557adaaeb0c7885f$var$mapFirst(firstClass);
      this.nextClass = firstClass;
      this.LB8a = firstClass === $1627905f8be2ef3f$export$30a74a373318dec6;
      this.LB30a = 0;
    }
    while (this.pos < this.string.length) {
      this.lastPos = this.pos;
      const lastClass = this.nextClass;
      this.nextClass = this.nextCharClass();
      if (this.curClass === $1627905f8be2ef3f$export$66498d28055820a9 || this.curClass === $1627905f8be2ef3f$export$de92be486109a1df && this.nextClass !== $1627905f8be2ef3f$export$606cfc2a8896c91f) {
        this.curClass = $557adaaeb0c7885f$var$mapFirst($557adaaeb0c7885f$var$mapClass(this.nextClass));
        return new $557adaaeb0c7885f$var$Break(this.lastPos, true);
      }
      let shouldBreak2 = this.getSimpleBreak();
      if (shouldBreak2 === null) shouldBreak2 = this.getPairTableBreak(lastClass);
      this.LB8a = this.nextClass === $1627905f8be2ef3f$export$30a74a373318dec6;
      if (shouldBreak2) return new $557adaaeb0c7885f$var$Break(this.lastPos);
    }
    if (this.lastPos < this.string.length) {
      this.lastPos = this.string.length;
      return new $557adaaeb0c7885f$var$Break(this.string.length);
    }
    return null;
  }
  constructor(string) {
    this.string = string;
    this.pos = 0;
    this.lastPos = 0;
    this.curClass = null;
    this.nextClass = null;
    this.LB8a = false;
    this.LB21a = false;
    this.LB30a = 0;
  }
};
$557adaaeb0c7885f$exports = $557adaaeb0c7885f$var$LineBreaker;

// ../../node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/markers/dac.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DACTable = new Struct({
  identifier: new BufferT(1),
  value: new BufferT(1)
});
var DACMarker = {
  name: /* @__PURE__ */ __name(() => "DAC", "name"),
  length: uint16be,
  tables: new ArrayT(DACTable, (parent) => parent.length / 2)
};
var dac_default = DACMarker;

// ../../node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/markers/dht.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/markers/utils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var readUInt8 = /* @__PURE__ */ __name((array, offset2) => {
  return array[offset2];
}, "readUInt8");
var readUInt16BE = /* @__PURE__ */ __name((array, offset2) => {
  return array[offset2] << 8 | array[offset2 + 1];
}, "readUInt16BE");
var readUInt16LE = /* @__PURE__ */ __name((array, offset2) => {
  return array[offset2] | array[offset2 + 1] << 8;
}, "readUInt16LE");
var readUInt32BE = /* @__PURE__ */ __name((array, offset2) => {
  return readInt32BE(array, offset2) >>> 0;
}, "readUInt32BE");
var readUInt32LE = /* @__PURE__ */ __name((array, offset2) => {
  return readInt32LE(array, offset2) >>> 0;
}, "readUInt32LE");
var uint8ArrayToHexString = /* @__PURE__ */ __name((uint8Array) => {
  return Array.from(
    uint8Array,
    (byte) => byte.toString(16).padStart(2, "0")
  ).join("");
}, "uint8ArrayToHexString");
var decoder = new TextDecoder("utf-8");
var uint8ArrayToString = /* @__PURE__ */ __name((uint8Array) => {
  return decoder.decode(uint8Array);
}, "uint8ArrayToString");
var concatenateUint8Arrays = /* @__PURE__ */ __name((arrays) => {
  const totalLength = arrays.reduce((length2, arr) => length2 + arr.length, 0);
  const concatenatedArray = new Uint8Array(totalLength);
  let offset2 = 0;
  arrays.forEach((arr) => {
    concatenatedArray.set(arr, offset2);
    offset2 += arr.length;
  });
  return concatenatedArray;
}, "concatenateUint8Arrays");
var readInt32BE = /* @__PURE__ */ __name((array, offset2) => {
  return array[offset2] << 24 | array[offset2 + 1] << 16 | array[offset2 + 2] << 8 | array[offset2 + 3];
}, "readInt32BE");
var readInt32LE = /* @__PURE__ */ __name((array, offset2) => {
  return array[offset2] | array[offset2 + 1] << 8 | array[offset2 + 2] << 16 | array[offset2 + 3] << 24;
}, "readInt32LE");

// ../../node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/markers/dht.js
var HuffmanTableElements = class {
  static {
    __name(this, "HuffmanTableElements");
  }
  decode(stream2, parent) {
    const tables = {};
    let buffer = stream2.buffer.slice(
      stream2.pos,
      stream2.pos + parent.length - 2
    );
    while (buffer.length > 0) {
      let offset2 = 1;
      const elements = [];
      const identifier = readUInt8(buffer, 0);
      const lengths = buffer.slice(offset2, offset2 + 16);
      offset2 += 16;
      for (const length2 of lengths) {
        elements.push(buffer.slice(offset2, offset2 + length2));
        offset2 += length2;
      }
      buffer = buffer.slice(offset2);
      tables[identifier] = concatenateUint8Arrays(elements);
    }
    stream2.pos += parent.length - 2;
    return tables;
  }
};
var DefineHuffmanTableMarker = {
  name: /* @__PURE__ */ __name(() => "DHT", "name"),
  length: uint16be,
  tables: new HuffmanTableElements()
};
var dht_default = DefineHuffmanTableMarker;

// ../../node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/markers/dqt.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DQTMarker = {
  name: /* @__PURE__ */ __name(() => "DQT", "name"),
  length: uint16be,
  tables: new ArrayT(
    new Struct({
      identifier: new BufferT(1),
      data: new BufferT(64)
    }),
    (parent) => (parent.length - 2) / 65
  )
};
var dqt_default = DQTMarker;

// ../../node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/markers/dri.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DRIMarker = {
  name: /* @__PURE__ */ __name(() => "DRI", "name"),
  length: uint16be,
  restartInterval: uint16be
};
var dri_default = DRIMarker;

// ../../node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/markers/eoi.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var EndOfImageMarker = {
  name: /* @__PURE__ */ __name(() => "EOI", "name"),
  afterEOI: new Reserved(uint8, Infinity)
};
var eoi_default = EndOfImageMarker;

// ../../node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/markers/exif.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var tags = {
  ifd: {
    "010e": "imageDescription",
    "010f": "make",
    "011a": "xResolution",
    "011b": "yResolution",
    "011c": "planarConfiguration",
    "012d": "transferFunction",
    "013b": "artist",
    "013e": "whitePoint",
    "013f": "primaryChromaticities",
    "0100": "imageWidth",
    "0101": "imageHeight",
    "0102": "bitsPerSample",
    "0103": "compression",
    "0106": "photometricInterpretation",
    "0110": "model",
    "0111": "stripOffsets",
    "0112": "orientation",
    "0115": "samplesPerPixel",
    "0116": "rowsPerStrip",
    "0117": "stripByteCounts",
    "0128": "resolutionUnit",
    "0131": "software",
    "0132": "dateTime",
    "0201": "jpegInterchangeFormat",
    "0202": "jpegInterchangeFormatLength",
    "0211": "ycbCrCoefficients",
    "0212": "ycbCrSubSampling",
    "0213": "ycbCrPositioning",
    "0214": "referenceBlackWhite",
    "829a": "exposureTime",
    "829d": "fNumber",
    "920a": "focalLength",
    "927c": "makerNote",
    8298: "copyright",
    8769: "exifIFDPointer",
    8822: "exposureProgram",
    8824: "spectralSensitivity",
    8825: "gpsInfoIFDPointer",
    8827: "photographicSensitivity",
    8828: "oecf",
    8830: "sensitivityType",
    8831: "standardOutputSensitivity",
    8832: "recommendedExposureIndex",
    8833: "isoSpeed",
    8834: "isoSpeedLatitudeyyy",
    8835: "isoSpeedLatitudezzz",
    9e3: "exifVersion",
    9003: "dateTimeOriginal",
    9004: "dateTimeDigitized",
    9101: "componentsConfiguration",
    9102: "compressedBitsPerPixel",
    9201: "shutterSpeedValue",
    9202: "apertureValue",
    9203: "brightnessValue",
    9204: "exposureBiasValue",
    9205: "maxApertureValue",
    9206: "subjectDistance",
    9207: "meteringMode",
    9208: "lightSource",
    9209: "flash",
    9214: "subjectArea",
    9286: "userComment",
    9290: "subSecTime",
    9291: "subSecTimeOriginal",
    9292: "subSecTimeDigitized",
    a000: "flashpixVersion",
    a001: "colorSpace",
    a002: "pixelXDimension",
    a003: "pixelYDimension",
    a004: "relatedSoundFile",
    a005: "interoperabilityIFDPointer",
    a20b: "flashEnergy",
    a20c: "spatialFrequencyResponse",
    a20e: "focalPlaneXResolution",
    a20f: "focalPlaneYResolution",
    a40a: "sharpness",
    a40b: "deviceSettingDescription",
    a40c: "subjectDistanceRange",
    a210: "focalPlaneResolutionUnit",
    a214: "subjectLocation",
    a215: "exposureIndex",
    a217: "sensingMethod",
    a300: "fileSource",
    a301: "sceneType",
    a302: "cfaPattern",
    a401: "customRendered",
    a402: "exposureMode",
    a403: "whiteBalance",
    a404: "digitalZoomRatio",
    a405: "focalLengthIn35mmFilm",
    a406: "sceneCaptureType",
    a407: "gainControl",
    a408: "contrast",
    a409: "saturation",
    a420: "imageUniqueID",
    a430: "cameraOwnerName",
    a431: "bodySerialNumber",
    a432: "lensSpecification",
    a433: "lensMake",
    a434: "lensModel",
    a435: "lensSerialNumber",
    a500: "gamma"
  },
  gps: {
    "0000": "gpsVersionID",
    "0001": "gpsLatitudeRef",
    "0002": "gpsLatitude",
    "0003": "gpsLongitudeRef",
    "0004": "gpsLongitude",
    "0005": "gpsAltitudeRef",
    "0006": "gpsAltitude",
    "0007": "gpsTimeStamp",
    "0008": "gpsSatellites",
    "0009": "gpsStatus",
    "000a": "gpsMeasureMode",
    "000b": "gpsDOP",
    "000c": "gpsSpeedRef",
    "000d": "gpsSpeed",
    "000e": "gpsTrackRef",
    "000f": "gpsTrack",
    "0010": "gpsImgDirectionRef",
    "0011": "gpsImgDirection",
    "0012": "gpsMapDatum",
    "0013": "gpsDestLatitudeRef",
    "0014": "gpsDestLatitude",
    "0015": "gpsDestLongitudeRef",
    "0016": "gpsDestLongitude",
    "0017": "gpsDestBearingRef",
    "0018": "gpsDestBearing",
    "0019": "gpsDestDistanceRef",
    "001a": "gpsDestDistance",
    "001b": "gpsProcessingMethod",
    "001c": "gpsAreaInformation",
    "001d": "gpsDateStamp",
    "001e": "gpsDifferential",
    "001f": "gpsHPositioningError"
  }
};
var IDFEntries = class {
  static {
    __name(this, "IDFEntries");
  }
  constructor(bigEndian) {
    this.bigEndian = bigEndian;
    this.bytes = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8];
  }
  _getTagValue(dataValue, dataFormat, componentsNumber) {
    switch (dataFormat) {
      case 2:
        return dataValue.toString("ascii").replace(/\0+$/, "");
      case 129:
        return dataValue.toString("utf8").replace(/\0+$/, "");
      case 7:
        return "0x" + dataValue.toString("hex");
      default:
        return this._getTagValueForNumericalData(dataValue, dataFormat, componentsNumber);
    }
  }
  _getTagValueForNumericalData(dataValue, dataFormat, componentsNumber) {
    const tagValue = [];
    const componentsBytes = this.bytes[dataFormat];
    for (let i2 = 0; i2 < componentsNumber; i2 += 1) {
      tagValue.push(this._getSingleTagValueForNumericalData(dataValue, dataFormat, i2 * componentsBytes));
    }
    return tagValue.length === 1 ? tagValue[0] : tagValue;
  }
  _getSingleTagValueForNumericalData(dataValue, dataFormat, pos) {
    const uint162 = /* @__PURE__ */ __name((pos2) => this.bigEndian ? readUInt16BE(dataValue, pos2) : readUInt16LE(dataValue, pos2), "uint16");
    const uint322 = /* @__PURE__ */ __name((pos2) => this.bigEndian ? readUInt32BE(dataValue, pos2) : readUInt32LE(dataValue, pos2), "uint32");
    const int322 = /* @__PURE__ */ __name((pos2) => this.bigEndian ? readInt32BE(dataValue, pos2) : readInt32LE(dataValue, pos2), "int32");
    switch (dataFormat) {
      case 1:
        return readUInt8(dataValue, pos);
      case 3:
        return uint162(pos);
      case 4:
        return uint322(pos);
      case 5:
        return uint322(pos) / uint322(pos + 4);
      case 9:
        return int322(pos);
      case 10: {
        return int322(pos) / int322(pos + 4);
      }
    }
  }
  _decodeIDFEntries(buffer, tags2, offset2, log5 = false) {
    let pos = 2 + offset2;
    const entries = {};
    const uint162 = /* @__PURE__ */ __name((pos2) => this.bigEndian ? readUInt16BE(buffer, pos2) : readUInt16LE(buffer, pos2), "uint16");
    const uint322 = /* @__PURE__ */ __name((pos2) => this.bigEndian ? readUInt32BE(buffer, pos2) : readUInt32LE(buffer, pos2), "uint32");
    const numberOfEntries = uint162(offset2);
    for (let i2 = 0; i2 < numberOfEntries; i2++) {
      const tagAddress = buffer.slice(pos, pos + 2);
      const dataFormat = uint162(pos + 2);
      const componentsNumber = uint322(pos + 4);
      const componentsBytes = this.bytes[dataFormat];
      const dataLength = componentsNumber * componentsBytes;
      let dataValue = buffer.slice(pos + 8, pos + 12);
      if (dataLength > 4) {
        const dataOffset = this.bigEndian ? readUInt32BE(dataValue, 0) : readUInt32LE(dataValue, 0);
        dataValue = buffer.slice(dataOffset, dataOffset + dataLength);
      }
      const tagValue = this._getTagValue(dataValue, dataFormat, componentsNumber);
      const tagNumber = this.bigEndian ? uint8ArrayToHexString(tagAddress) : uint8ArrayToHexString(tagAddress.reverse());
      const tagName = tags2[tagNumber];
      entries[tagName] = tagValue;
      pos += 12;
    }
    return entries;
  }
  decode(stream2, parent) {
    const buffer = stream2.buffer.slice(stream2.pos - 8);
    const offsetToFirstIFD = parent.offsetToFirstIFD;
    if (offsetToFirstIFD > buffer.length) {
      stream2.pos += parent.parent.length - 16;
      return {};
    }
    const entries = this._decodeIDFEntries(buffer, tags.ifd, offsetToFirstIFD);
    const { exifIFDPointer, gpsInfoIFDPointer } = entries;
    if (exifIFDPointer) {
      entries.subExif = this._decodeIDFEntries(
        buffer,
        tags.ifd,
        exifIFDPointer
      );
    }
    if (gpsInfoIFDPointer) {
      const gps = gpsInfoIFDPointer;
      entries.gpsInfo = this._decodeIDFEntries(buffer, tags.gps, gps, true);
    }
    stream2.pos += parent.parent.length - 16;
    return entries;
  }
};
var IFDData = /* @__PURE__ */ __name((bigEndian) => {
  const uint162 = bigEndian ? uint16be : uint16le;
  const uint322 = bigEndian ? uint32be : uint32le;
  return new Struct({
    fortyTwo: uint162,
    offsetToFirstIFD: uint322,
    entries: new IDFEntries(bigEndian)
  });
}, "IFDData");
var TIFFHeader = class {
  static {
    __name(this, "TIFFHeader");
  }
  decode(stream2, parent) {
    const byteOrder = uint8ArrayToString(
      stream2.buffer.slice(stream2.pos, stream2.pos + 2)
    );
    const bigEndian = byteOrder === "MM";
    stream2.pos += 2;
    const data2 = IFDData(bigEndian).decode(stream2, parent);
    return data2.entries;
  }
};
var EXIFMarker = {
  name: /* @__PURE__ */ __name(() => "EXIF", "name"),
  length: uint16be,
  identifier: new StringT(6),
  entries: new TIFFHeader()
};
var exif_default = EXIFMarker;

// ../../node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/markers/jfif.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var JFIFMarker = {
  name: /* @__PURE__ */ __name(() => "JFIF", "name"),
  length: uint16be,
  identifier: new StringT(5),
  version: uint16be,
  units: uint8,
  xDensity: uint16be,
  yDensity: uint16be,
  thumbnailWidth: uint8,
  thumbnailHeight: uint8
};
var jfif_default = JFIFMarker;

// ../../node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/markers/sos.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ImageData = class {
  static {
    __name(this, "ImageData");
  }
  decode(stream2) {
    const buffer = stream2.buffer.slice(stream2.pos);
    let length2 = 0;
    let i2 = buffer.indexOf(255);
    while (i2 !== -1) {
      length2 = i2;
      const nextByte = buffer[length2 + 1];
      const comesRestart = nextByte >= 208 && nextByte <= 215;
      if (nextByte !== 0 && !comesRestart) break;
      i2 = buffer.indexOf(255, i2 + 1);
    }
    stream2.pos += length2;
    return buffer.slice(0, length2);
  }
};
var SOSComponentSpecification = new Struct({
  scanComponentSelector: uint8,
  entropyCodingTable: new BufferT(1)
});
var SOSMarker = {
  name: /* @__PURE__ */ __name(() => "SOS", "name"),
  length: uint16be,
  numberOfImageComponents: uint8,
  componentSpecifications: new ArrayT(
    SOSComponentSpecification,
    (parent) => parent.numberOfImageComponents
  ),
  startOfSpectral: uint8,
  endOfSpectral: uint8,
  successiveApproximationBit: new BufferT(1),
  data: new ImageData()
};
var sos_default = SOSMarker;

// ../../node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/markers/sof.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FrameColorComponent = new Struct({
  id: uint8,
  samplingFactors: uint8,
  quantizationTableId: uint8
});
var StartOfFrameMarker = {
  name: /* @__PURE__ */ __name(() => "SOF", "name"),
  length: uint16be,
  precision: uint8,
  height: uint16be,
  width: uint16be,
  numberOfComponents: uint8,
  components: new ArrayT(
    FrameColorComponent,
    (parent) => parent.numberOfComponents
  )
};
var sof_default = StartOfFrameMarker;

// ../../node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/markers/soi.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var StartOfImageMarker = {
  name: /* @__PURE__ */ __name(() => "SOI", "name")
};
var soi_default = StartOfImageMarker;

// ../../node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/index.js
var UnknownMarker = {
  length: uint16be,
  buf: new BufferT((parent) => parent.length - 2)
};
var unknownMarkers = Array(63).fill(0).reduce((acc, v3, i2) => ({ ...acc, [i2 + 65472]: UnknownMarker }), {});
var Marker = new VersionedStruct(uint16be, {
  ...unknownMarkers,
  65472: sof_default,
  65473: sof_default,
  65474: sof_default,
  65475: sof_default,
  65476: dht_default,
  65477: sof_default,
  65478: sof_default,
  65479: sof_default,
  65481: sof_default,
  65482: sof_default,
  65483: sof_default,
  65484: dac_default,
  65485: sof_default,
  65486: sof_default,
  65487: sof_default,
  65496: soi_default,
  65497: eoi_default,
  65498: sos_default,
  65499: dqt_default,
  65501: dri_default,
  65504: jfif_default,
  65505: exif_default
});
var JPEG = new ArrayT(Marker);
var decode = /* @__PURE__ */ __name((buffer) => {
  const markers = JPEG.fromBuffer(buffer);
  return markers.map(({ version: version6, ...rest }) => ({ type: version6, ...rest }));
}, "decode");
var src_default = { decode };

// ../../node_modules/.pnpm/@react-pdf+png-js@3.0.0/node_modules/@react-pdf/png-js/lib/png-js.browser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code.length; i2 < len; ++i2) {
    lookup[i2] = code[i2];
    revLookup[code.charCodeAt(i2)] = i2;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
__name(init, "init");
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i2, j, l4, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l4 = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i2 = 0, j = 0; i2 < l4; i2 += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
__name(toByteArray, "toByteArray");
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
__name(tripletToBase64, "tripletToBase64");
function encodeChunk(uint82, start2, end2) {
  var tmp;
  var output = [];
  for (var i2 = start2; i2 < end2; i2 += 3) {
    tmp = (uint82[i2] << 16) + (uint82[i2 + 1] << 8) + uint82[i2 + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
__name(encodeChunk, "encodeChunk");
function fromByteArray(uint82) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint82, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
__name(fromByteArray, "fromByteArray");
function read(buffer, offset2, isLE, mLen, nBytes) {
  var e4, m3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d3 = isLE ? -1 : 1;
  var s4 = buffer[offset2 + i2];
  i2 += d3;
  e4 = s4 & (1 << -nBits) - 1;
  s4 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e4 = e4 * 256 + buffer[offset2 + i2], i2 += d3, nBits -= 8) {
  }
  m3 = e4 & (1 << -nBits) - 1;
  e4 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m3 = m3 * 256 + buffer[offset2 + i2], i2 += d3, nBits -= 8) {
  }
  if (e4 === 0) {
    e4 = 1 - eBias;
  } else if (e4 === eMax) {
    return m3 ? NaN : (s4 ? -1 : 1) * Infinity;
  } else {
    m3 = m3 + Math.pow(2, mLen);
    e4 = e4 - eBias;
  }
  return (s4 ? -1 : 1) * m3 * Math.pow(2, e4 - mLen);
}
__name(read, "read");
function write(buffer, value2, offset2, isLE, mLen, nBytes) {
  var e4, m3, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d3 = isLE ? 1 : -1;
  var s4 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m3 = isNaN(value2) ? 1 : 0;
    e4 = eMax;
  } else {
    e4 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e4)) < 1) {
      e4--;
      c2 *= 2;
    }
    if (e4 + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e4++;
      c2 /= 2;
    }
    if (e4 + eBias >= eMax) {
      m3 = 0;
      e4 = eMax;
    } else if (e4 + eBias >= 1) {
      m3 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e4 = e4 + eBias;
    } else {
      m3 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e4 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset2 + i2] = m3 & 255, i2 += d3, m3 /= 256, mLen -= 8) {
  }
  e4 = e4 << mLen | m3;
  eLen += mLen;
  for (; eLen > 0; buffer[offset2 + i2] = e4 & 255, i2 += d3, e4 /= 256, eLen -= 8) {
  }
  buffer[offset2 + i2 - d3] |= s4 * 128;
}
__name(write, "write");
var toString = {}.toString;
var isArray$1 = Array.isArray || function(arr) {
  return toString.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES = 50;
Buffer2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
var _kMaxLength = kMaxLength();
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
__name(kMaxLength, "kMaxLength");
function createBuffer(that, length2) {
  if (kMaxLength() < length2) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length2);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length2);
    }
    that.length = length2;
  }
  return that;
}
__name(createBuffer, "createBuffer");
function Buffer2(arg, encodingOrOffset, length2) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length2);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length2);
}
__name(Buffer2, "Buffer");
Buffer2.poolSize = 8192;
Buffer2._augment = function(arr) {
  arr.__proto__ = Buffer2.prototype;
  return arr;
};
function from(that, value2, encodingOrOffset, length2) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value2, encodingOrOffset, length2);
  }
  if (typeof value2 === "string") {
    return fromString(that, value2, encodingOrOffset);
  }
  return fromObject(that, value2);
}
__name(from, "from");
Buffer2.from = function(value2, encodingOrOffset, length2) {
  return from(null, value2, encodingOrOffset, length2);
};
if (Buffer2.TYPED_ARRAY_SUPPORT) {
  Buffer2.prototype.__proto__ = Uint8Array.prototype;
  Buffer2.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) ;
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
__name(assertSize, "assertSize");
function alloc(that, size, fill4, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill4 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill4, encoding) : createBuffer(that, size).fill(fill4);
  }
  return createBuffer(that, size);
}
__name(alloc, "alloc");
Buffer2.alloc = function(size, fill4, encoding) {
  return alloc(null, size, fill4, encoding);
};
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i2 = 0; i2 < size; ++i2) {
      that[i2] = 0;
    }
  }
  return that;
}
__name(allocUnsafe, "allocUnsafe");
Buffer2.allocUnsafe = function(size) {
  return allocUnsafe(null, size);
};
Buffer2.allocUnsafeSlow = function(size) {
  return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length2 = byteLength2(string, encoding) | 0;
  that = createBuffer(that, length2);
  var actual = that.write(string, encoding);
  if (actual !== length2) {
    that = that.slice(0, actual);
  }
  return that;
}
__name(fromString, "fromString");
function fromArrayLike(that, array) {
  var length2 = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length2);
  for (var i2 = 0; i2 < length2; i2 += 1) {
    that[i2] = array[i2] & 255;
  }
  return that;
}
__name(fromArrayLike, "fromArrayLike");
function fromArrayBuffer(that, array, byteOffset, length2) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length2 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length2 === void 0) {
    array = new Uint8Array(array);
  } else if (length2 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length2);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
__name(fromArrayBuffer, "fromArrayBuffer");
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray$1(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
__name(fromObject, "fromObject");
function checked(length2) {
  if (length2 >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length2 | 0;
}
__name(checked, "checked");
function SlowBuffer(length2) {
  if (+length2 != length2) {
    length2 = 0;
  }
  return Buffer2.alloc(+length2);
}
__name(SlowBuffer, "SlowBuffer");
Buffer2.isBuffer = isBuffer$1;
function internalIsBuffer(b3) {
  return !!(b3 != null && b3._isBuffer);
}
__name(internalIsBuffer, "internalIsBuffer");
Buffer2.compare = /* @__PURE__ */ __name(function compare(a4, b3) {
  if (!internalIsBuffer(a4) || !internalIsBuffer(b3)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a4 === b3) return 0;
  var x = a4.length;
  var y3 = b3.length;
  for (var i2 = 0, len = Math.min(x, y3); i2 < len; ++i2) {
    if (a4[i2] !== b3[i2]) {
      x = a4[i2];
      y3 = b3[i2];
      break;
    }
  }
  if (x < y3) return -1;
  if (y3 < x) return 1;
  return 0;
}, "compare");
Buffer2.isEncoding = /* @__PURE__ */ __name(function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, "isEncoding");
Buffer2.concat = /* @__PURE__ */ __name(function concat(list, length2) {
  if (!isArray$1(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer2.alloc(0);
  }
  var i2;
  if (length2 === void 0) {
    length2 = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      length2 += list[i2].length;
    }
  }
  var buffer = Buffer2.allocUnsafe(length2);
  var pos = 0;
  for (i2 = 0; i2 < list.length; ++i2) {
    var buf = list[i2];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
}, "concat");
function byteLength2(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
__name(byteLength2, "byteLength");
Buffer2.byteLength = byteLength2;
function slowToString(encoding, start2, end2) {
  var loweredCase = false;
  if (start2 === void 0 || start2 < 0) {
    start2 = 0;
  }
  if (start2 > this.length) {
    return "";
  }
  if (end2 === void 0 || end2 > this.length) {
    end2 = this.length;
  }
  if (end2 <= 0) {
    return "";
  }
  end2 >>>= 0;
  start2 >>>= 0;
  if (end2 <= start2) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start2, end2);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start2, end2);
      case "ascii":
        return asciiSlice(this, start2, end2);
      case "latin1":
      case "binary":
        return latin1Slice(this, start2, end2);
      case "base64":
        return base64Slice(this, start2, end2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start2, end2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
__name(slowToString, "slowToString");
Buffer2.prototype._isBuffer = true;
function swap(b3, n5, m3) {
  var i2 = b3[n5];
  b3[n5] = b3[m3];
  b3[m3] = i2;
}
__name(swap, "swap");
Buffer2.prototype.swap16 = /* @__PURE__ */ __name(function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 2) {
    swap(this, i2, i2 + 1);
  }
  return this;
}, "swap16");
Buffer2.prototype.swap32 = /* @__PURE__ */ __name(function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 4) {
    swap(this, i2, i2 + 3);
    swap(this, i2 + 1, i2 + 2);
  }
  return this;
}, "swap32");
Buffer2.prototype.swap64 = /* @__PURE__ */ __name(function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 8) {
    swap(this, i2, i2 + 7);
    swap(this, i2 + 1, i2 + 6);
    swap(this, i2 + 2, i2 + 5);
    swap(this, i2 + 3, i2 + 4);
  }
  return this;
}, "swap64");
Buffer2.prototype.toString = /* @__PURE__ */ __name(function toString2() {
  var length2 = this.length | 0;
  if (length2 === 0) return "";
  if (arguments.length === 0) return utf8Slice(this, 0, length2);
  return slowToString.apply(this, arguments);
}, "toString");
Buffer2.prototype.equals = /* @__PURE__ */ __name(function equals(b3) {
  if (!internalIsBuffer(b3)) throw new TypeError("Argument must be a Buffer");
  if (this === b3) return true;
  return Buffer2.compare(this, b3) === 0;
}, "equals");
Buffer2.prototype.inspect = /* @__PURE__ */ __name(function inspect() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2) str += " ... ";
  }
  return "<Buffer " + str + ">";
}, "inspect");
Buffer2.prototype.compare = /* @__PURE__ */ __name(function compare2(target, start2, end2, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start2 === void 0) {
    start2 = 0;
  }
  if (end2 === void 0) {
    end2 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start2 >= end2) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start2 >= end2) {
    return 1;
  }
  start2 >>>= 0;
  end2 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y3 = end2 - start2;
  var len = Math.min(x, y3);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start2, end2);
  for (var i2 = 0; i2 < len; ++i2) {
    if (thisCopy[i2] !== targetCopy[i2]) {
      x = thisCopy[i2];
      y3 = targetCopy[i2];
      break;
    }
  }
  if (x < y3) return -1;
  if (y3 < x) return 1;
  return 0;
}, "compare");
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir3) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir3 ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir3) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir3) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir3);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir3) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir3);
  }
  throw new TypeError("val must be string, number or Buffer");
}
__name(bidirectionalIndexOf, "bidirectionalIndexOf");
function arrayIndexOf(arr, val, byteOffset, encoding, dir3) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read5(buf, i3) {
    if (indexSize === 1) {
      return buf[i3];
    } else {
      return buf.readUInt16BE(i3 * indexSize);
    }
  }
  __name(read5, "read");
  var i2;
  if (dir3) {
    var foundIndex = -1;
    for (i2 = byteOffset; i2 < arrLength; i2++) {
      if (read5(arr, i2) === read5(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1) foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i2 = byteOffset; i2 >= 0; i2--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read5(arr, i2 + j) !== read5(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i2;
    }
  }
  return -1;
}
__name(arrayIndexOf, "arrayIndexOf");
Buffer2.prototype.includes = /* @__PURE__ */ __name(function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
}, "includes");
Buffer2.prototype.indexOf = /* @__PURE__ */ __name(function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
}, "indexOf");
Buffer2.prototype.lastIndexOf = /* @__PURE__ */ __name(function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
}, "lastIndexOf");
function hexWrite(buf, string, offset2, length2) {
  offset2 = Number(offset2) || 0;
  var remaining = buf.length - offset2;
  if (!length2) {
    length2 = remaining;
  } else {
    length2 = Number(length2);
    if (length2 > remaining) {
      length2 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length2 > strLen / 2) {
    length2 = strLen / 2;
  }
  for (var i2 = 0; i2 < length2; ++i2) {
    var parsed = parseInt(string.substr(i2 * 2, 2), 16);
    if (isNaN(parsed)) return i2;
    buf[offset2 + i2] = parsed;
  }
  return i2;
}
__name(hexWrite, "hexWrite");
function utf8Write(buf, string, offset2, length2) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset2), buf, offset2, length2);
}
__name(utf8Write, "utf8Write");
function asciiWrite(buf, string, offset2, length2) {
  return blitBuffer(asciiToBytes(string), buf, offset2, length2);
}
__name(asciiWrite, "asciiWrite");
function latin1Write(buf, string, offset2, length2) {
  return asciiWrite(buf, string, offset2, length2);
}
__name(latin1Write, "latin1Write");
function base64Write(buf, string, offset2, length2) {
  return blitBuffer(base64ToBytes(string), buf, offset2, length2);
}
__name(base64Write, "base64Write");
function ucs2Write(buf, string, offset2, length2) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length2);
}
__name(ucs2Write, "ucs2Write");
Buffer2.prototype.write = /* @__PURE__ */ __name(function write2(string, offset2, length2, encoding) {
  if (offset2 === void 0) {
    encoding = "utf8";
    length2 = this.length;
    offset2 = 0;
  } else if (length2 === void 0 && typeof offset2 === "string") {
    encoding = offset2;
    length2 = this.length;
    offset2 = 0;
  } else if (isFinite(offset2)) {
    offset2 = offset2 | 0;
    if (isFinite(length2)) {
      length2 = length2 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length2;
      length2 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset2;
  if (length2 === void 0 || length2 > remaining) length2 = remaining;
  if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset2, length2);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset2, length2);
      case "ascii":
        return asciiWrite(this, string, offset2, length2);
      case "latin1":
      case "binary":
        return latin1Write(this, string, offset2, length2);
      case "base64":
        return base64Write(this, string, offset2, length2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset2, length2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}, "write");
Buffer2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
}, "toJSON");
function base64Slice(buf, start2, end2) {
  if (start2 === 0 && end2 === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start2, end2));
  }
}
__name(base64Slice, "base64Slice");
function utf8Slice(buf, start2, end2) {
  end2 = Math.min(buf.length, end2);
  var res = [];
  var i2 = start2;
  while (i2 < end2) {
    var firstByte = buf[i2];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end2) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i2 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          fourthByte = buf[i2 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i2 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
__name(utf8Slice, "utf8Slice");
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
__name(decodeCodePointsArray, "decodeCodePointsArray");
function asciiSlice(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i2 = start2; i2 < end2; ++i2) {
    ret += String.fromCharCode(buf[i2] & 127);
  }
  return ret;
}
__name(asciiSlice, "asciiSlice");
function latin1Slice(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i2 = start2; i2 < end2; ++i2) {
    ret += String.fromCharCode(buf[i2]);
  }
  return ret;
}
__name(latin1Slice, "latin1Slice");
function hexSlice(buf, start2, end2) {
  var len = buf.length;
  if (!start2 || start2 < 0) start2 = 0;
  if (!end2 || end2 < 0 || end2 > len) end2 = len;
  var out = "";
  for (var i2 = start2; i2 < end2; ++i2) {
    out += toHex(buf[i2]);
  }
  return out;
}
__name(hexSlice, "hexSlice");
function utf16leSlice(buf, start2, end2) {
  var bytes = buf.slice(start2, end2);
  var res = "";
  for (var i2 = 0; i2 < bytes.length; i2 += 2) {
    res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
  }
  return res;
}
__name(utf16leSlice, "utf16leSlice");
Buffer2.prototype.slice = /* @__PURE__ */ __name(function slice(start2, end2) {
  var len = this.length;
  start2 = ~~start2;
  end2 = end2 === void 0 ? len : ~~end2;
  if (start2 < 0) {
    start2 += len;
    if (start2 < 0) start2 = 0;
  } else if (start2 > len) {
    start2 = len;
  }
  if (end2 < 0) {
    end2 += len;
    if (end2 < 0) end2 = 0;
  } else if (end2 > len) {
    end2 = len;
  }
  if (end2 < start2) end2 = start2;
  var newBuf;
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start2, end2);
    newBuf.__proto__ = Buffer2.prototype;
  } else {
    var sliceLen = end2 - start2;
    newBuf = new Buffer2(sliceLen, void 0);
    for (var i2 = 0; i2 < sliceLen; ++i2) {
      newBuf[i2] = this[i2 + start2];
    }
  }
  return newBuf;
}, "slice");
function checkOffset(offset2, ext, length2) {
  if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
  if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
}
__name(checkOffset, "checkOffset");
Buffer2.prototype.readUIntLE = /* @__PURE__ */ __name(function readUIntLE(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i2] * mul;
  }
  return val;
}, "readUIntLE");
Buffer2.prototype.readUIntBE = /* @__PURE__ */ __name(function readUIntBE(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset(offset2, byteLength5, this.length);
  }
  var val = this[offset2 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset2 + --byteLength5] * mul;
  }
  return val;
}, "readUIntBE");
Buffer2.prototype.readUInt8 = /* @__PURE__ */ __name(function readUInt82(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 1, this.length);
  return this[offset2];
}, "readUInt8");
Buffer2.prototype.readUInt16LE = /* @__PURE__ */ __name(function readUInt16LE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  return this[offset2] | this[offset2 + 1] << 8;
}, "readUInt16LE");
Buffer2.prototype.readUInt16BE = /* @__PURE__ */ __name(function readUInt16BE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  return this[offset2] << 8 | this[offset2 + 1];
}, "readUInt16BE");
Buffer2.prototype.readUInt32LE = /* @__PURE__ */ __name(function readUInt32LE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
}, "readUInt32LE");
Buffer2.prototype.readUInt32BE = /* @__PURE__ */ __name(function readUInt32BE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
}, "readUInt32BE");
Buffer2.prototype.readIntLE = /* @__PURE__ */ __name(function readIntLE(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i2] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
}, "readIntLE");
Buffer2.prototype.readIntBE = /* @__PURE__ */ __name(function readIntBE(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset(offset2, byteLength5, this.length);
  var i2 = byteLength5;
  var mul = 1;
  var val = this[offset2 + --i2];
  while (i2 > 0 && (mul *= 256)) {
    val += this[offset2 + --i2] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
}, "readIntBE");
Buffer2.prototype.readInt8 = /* @__PURE__ */ __name(function readInt8(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 1, this.length);
  if (!(this[offset2] & 128)) return this[offset2];
  return (255 - this[offset2] + 1) * -1;
}, "readInt8");
Buffer2.prototype.readInt16LE = /* @__PURE__ */ __name(function readInt16LE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  var val = this[offset2] | this[offset2 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
}, "readInt16LE");
Buffer2.prototype.readInt16BE = /* @__PURE__ */ __name(function readInt16BE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  var val = this[offset2 + 1] | this[offset2] << 8;
  return val & 32768 ? val | 4294901760 : val;
}, "readInt16BE");
Buffer2.prototype.readInt32LE = /* @__PURE__ */ __name(function readInt32LE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
}, "readInt32LE");
Buffer2.prototype.readInt32BE = /* @__PURE__ */ __name(function readInt32BE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
}, "readInt32BE");
Buffer2.prototype.readFloatLE = /* @__PURE__ */ __name(function readFloatLE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return read(this, offset2, true, 23, 4);
}, "readFloatLE");
Buffer2.prototype.readFloatBE = /* @__PURE__ */ __name(function readFloatBE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return read(this, offset2, false, 23, 4);
}, "readFloatBE");
Buffer2.prototype.readDoubleLE = /* @__PURE__ */ __name(function readDoubleLE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 8, this.length);
  return read(this, offset2, true, 52, 8);
}, "readDoubleLE");
Buffer2.prototype.readDoubleBE = /* @__PURE__ */ __name(function readDoubleBE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 8, this.length);
  return read(this, offset2, false, 52, 8);
}, "readDoubleBE");
function checkInt(buf, value2, offset2, ext, max2, min2) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max2 || value2 < min2) throw new RangeError('"value" argument is out of bounds');
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
}
__name(checkInt, "checkInt");
Buffer2.prototype.writeUIntLE = /* @__PURE__ */ __name(function writeUIntLE(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i2 = 0;
  this[offset2] = value2 & 255;
  while (++i2 < byteLength5 && (mul *= 256)) {
    this[offset2 + i2] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
}, "writeUIntLE");
Buffer2.prototype.writeUIntBE = /* @__PURE__ */ __name(function writeUIntBE(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var i2 = byteLength5 - 1;
  var mul = 1;
  this[offset2 + i2] = value2 & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    this[offset2 + i2] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
}, "writeUIntBE");
Buffer2.prototype.writeUInt8 = /* @__PURE__ */ __name(function writeUInt8(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 1, 255, 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset2] = value2 & 255;
  return offset2 + 1;
}, "writeUInt8");
function objectWriteUInt16(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i2 = 0, j = Math.min(buf.length - offset2, 2); i2 < j; ++i2) {
    buf[offset2 + i2] = (value2 & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
  }
}
__name(objectWriteUInt16, "objectWriteUInt16");
Buffer2.prototype.writeUInt16LE = /* @__PURE__ */ __name(function writeUInt16LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16(this, value2, offset2, true);
  }
  return offset2 + 2;
}, "writeUInt16LE");
Buffer2.prototype.writeUInt16BE = /* @__PURE__ */ __name(function writeUInt16BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt16(this, value2, offset2, false);
  }
  return offset2 + 2;
}, "writeUInt16BE");
function objectWriteUInt32(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i2 = 0, j = Math.min(buf.length - offset2, 4); i2 < j; ++i2) {
    buf[offset2 + i2] = value2 >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
  }
}
__name(objectWriteUInt32, "objectWriteUInt32");
Buffer2.prototype.writeUInt32LE = /* @__PURE__ */ __name(function writeUInt32LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2 + 3] = value2 >>> 24;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset2, true);
  }
  return offset2 + 4;
}, "writeUInt32LE");
Buffer2.prototype.writeUInt32BE = /* @__PURE__ */ __name(function writeUInt32BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset2, false);
  }
  return offset2 + 4;
}, "writeUInt32BE");
Buffer2.prototype.writeIntLE = /* @__PURE__ */ __name(function writeIntLE(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i2 = 0;
  var mul = 1;
  var sub = 0;
  this[offset2] = value2 & 255;
  while (++i2 < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i2] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
}, "writeIntLE");
Buffer2.prototype.writeIntBE = /* @__PURE__ */ __name(function writeIntBE(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i2 = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset2 + i2] = value2 & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i2] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
}, "writeIntBE");
Buffer2.prototype.writeInt8 = /* @__PURE__ */ __name(function writeInt8(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 1, 127, -128);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset2] = value2 & 255;
  return offset2 + 1;
}, "writeInt8");
Buffer2.prototype.writeInt16LE = /* @__PURE__ */ __name(function writeInt16LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16(this, value2, offset2, true);
  }
  return offset2 + 2;
}, "writeInt16LE");
Buffer2.prototype.writeInt16BE = /* @__PURE__ */ __name(function writeInt16BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt16(this, value2, offset2, false);
  }
  return offset2 + 2;
}, "writeInt16BE");
Buffer2.prototype.writeInt32LE = /* @__PURE__ */ __name(function writeInt32LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt32(this, value2, offset2, true);
  }
  return offset2 + 4;
}, "writeInt32LE");
Buffer2.prototype.writeInt32BE = /* @__PURE__ */ __name(function writeInt32BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset2, false);
  }
  return offset2 + 4;
}, "writeInt32BE");
function checkIEEE754(buf, value2, offset2, ext, max2, min2) {
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset2 < 0) throw new RangeError("Index out of range");
}
__name(checkIEEE754, "checkIEEE754");
function writeFloat(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value2, offset2, 4);
  }
  write(buf, value2, offset2, littleEndian, 23, 4);
  return offset2 + 4;
}
__name(writeFloat, "writeFloat");
Buffer2.prototype.writeFloatLE = /* @__PURE__ */ __name(function writeFloatLE(value2, offset2, noAssert) {
  return writeFloat(this, value2, offset2, true, noAssert);
}, "writeFloatLE");
Buffer2.prototype.writeFloatBE = /* @__PURE__ */ __name(function writeFloatBE(value2, offset2, noAssert) {
  return writeFloat(this, value2, offset2, false, noAssert);
}, "writeFloatBE");
function writeDouble(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value2, offset2, 8);
  }
  write(buf, value2, offset2, littleEndian, 52, 8);
  return offset2 + 8;
}
__name(writeDouble, "writeDouble");
Buffer2.prototype.writeDoubleLE = /* @__PURE__ */ __name(function writeDoubleLE(value2, offset2, noAssert) {
  return writeDouble(this, value2, offset2, true, noAssert);
}, "writeDoubleLE");
Buffer2.prototype.writeDoubleBE = /* @__PURE__ */ __name(function writeDoubleBE(value2, offset2, noAssert) {
  return writeDouble(this, value2, offset2, false, noAssert);
}, "writeDoubleBE");
Buffer2.prototype.copy = /* @__PURE__ */ __name(function copy(target, targetStart, start2, end2) {
  if (!start2) start2 = 0;
  if (!end2 && end2 !== 0) end2 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end2 > 0 && end2 < start2) end2 = start2;
  if (end2 === start2) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start2 < 0 || start2 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end2 > this.length) end2 = this.length;
  if (target.length - targetStart < end2 - start2) {
    end2 = target.length - targetStart + start2;
  }
  var len = end2 - start2;
  var i2;
  if (this === target && start2 < targetStart && targetStart < end2) {
    for (i2 = len - 1; i2 >= 0; --i2) {
      target[i2 + targetStart] = this[i2 + start2];
    }
  } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
    for (i2 = 0; i2 < len; ++i2) {
      target[i2 + targetStart] = this[i2 + start2];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start2, start2 + len),
      targetStart
    );
  }
  return len;
}, "copy");
Buffer2.prototype.fill = /* @__PURE__ */ __name(function fill(val, start2, end2, encoding) {
  if (typeof val === "string") {
    if (typeof start2 === "string") {
      encoding = start2;
      start2 = 0;
      end2 = this.length;
    } else if (typeof end2 === "string") {
      encoding = end2;
      end2 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start2 < 0 || this.length < start2 || this.length < end2) {
    throw new RangeError("Out of range index");
  }
  if (end2 <= start2) {
    return this;
  }
  start2 = start2 >>> 0;
  end2 = end2 === void 0 ? this.length : end2 >>> 0;
  if (!val) val = 0;
  var i2;
  if (typeof val === "number") {
    for (i2 = start2; i2 < end2; ++i2) {
      this[i2] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
    var len = bytes.length;
    for (i2 = 0; i2 < end2 - start2; ++i2) {
      this[i2 + start2] = bytes[i2 % len];
    }
  }
  return this;
}, "fill");
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
__name(base64clean, "base64clean");
function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
__name(stringtrim, "stringtrim");
function toHex(n5) {
  if (n5 < 16) return "0" + n5.toString(16);
  return n5.toString(16);
}
__name(toHex, "toHex");
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length2 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i2 = 0; i2 < length2; ++i2) {
    codePoint = string.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length2) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
__name(utf8ToBytes, "utf8ToBytes");
function asciiToBytes(str) {
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    byteArray.push(str.charCodeAt(i2) & 255);
  }
  return byteArray;
}
__name(asciiToBytes, "asciiToBytes");
function utf16leToBytes(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    if ((units -= 2) < 0) break;
    c2 = str.charCodeAt(i2);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
__name(utf16leToBytes, "utf16leToBytes");
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
__name(base64ToBytes, "base64ToBytes");
function blitBuffer(src, dst, offset2, length2) {
  for (var i2 = 0; i2 < length2; ++i2) {
    if (i2 + offset2 >= dst.length || i2 >= src.length) break;
    dst[i2 + offset2] = src[i2];
  }
  return i2;
}
__name(blitBuffer, "blitBuffer");
function isnan(val) {
  return val !== val;
}
__name(isnan, "isnan");
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
__name(isBuffer$1, "isBuffer$1");
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
__name(isFastBuffer, "isFastBuffer");
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
__name(isSlowBuffer, "isSlowBuffer");
var _polyfillNode_buffer = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Buffer: Buffer2,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  isBuffer: isBuffer$1,
  kMaxLength: _kMaxLength
});
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
__name(defaultSetTimout, "defaultSetTimout");
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
__name(defaultClearTimeout, "defaultClearTimeout");
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e4) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e5) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
__name(runTimeout, "runTimeout");
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e4) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e5) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
__name(runClearTimeout, "runClearTimeout");
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
__name(cleanUpNextTick, "cleanUpNextTick");
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
__name(drainQueue, "drainQueue");
function nextTick2(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
__name(nextTick2, "nextTick");
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
__name(Item, "Item");
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title2 = "browser";
var platform2 = "browser";
var browser = true;
var env2 = {};
var argv2 = [];
var version2 = "";
var versions2 = {};
var release2 = {};
var config2 = {};
function noop() {
}
__name(noop, "noop");
var on2 = noop;
var addListener2 = noop;
var once2 = noop;
var off2 = noop;
var removeListener2 = noop;
var removeAllListeners2 = noop;
var emit2 = noop;
function binding$1(name) {
  throw new Error("process.binding is not supported");
}
__name(binding$1, "binding$1");
function cwd2() {
  return "/";
}
__name(cwd2, "cwd");
function chdir2(dir3) {
  throw new Error("process.chdir is not supported");
}
__name(chdir2, "chdir");
function umask2() {
  return 0;
}
__name(umask2, "umask");
var performance3 = global$1.performance || {};
var performanceNow = performance3.now || performance3.mozNow || performance3.msNow || performance3.oNow || performance3.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime4(previousTimestamp) {
  var clocktime = performanceNow.call(performance3) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
__name(hrtime4, "hrtime");
var startTime = /* @__PURE__ */ new Date();
function uptime2() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
__name(uptime2, "uptime");
var browser$1 = {
  nextTick: nextTick2,
  title: title2,
  browser,
  env: env2,
  argv: argv2,
  version: version2,
  versions: versions2,
  on: on2,
  addListener: addListener2,
  once: once2,
  off: off2,
  removeListener: removeListener2,
  removeAllListeners: removeAllListeners2,
  emit: emit2,
  binding: binding$1,
  cwd: cwd2,
  chdir: chdir2,
  umask: umask2,
  hrtime: hrtime4,
  platform: platform2,
  release: release2,
  config: config2,
  uptime: uptime2
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
function getAugmentedNamespace(n5) {
  if (n5.__esModule) return n5;
  var f4 = n5.default;
  if (typeof f4 == "function") {
    var a4 = /* @__PURE__ */ __name(function a5() {
      if (this instanceof a5) {
        return Reflect.construct(f4, arguments, this.constructor);
      }
      return f4.apply(this, arguments);
    }, "a");
    a4.prototype = f4.prototype;
  } else a4 = {};
  Object.defineProperty(a4, "__esModule", { value: true });
  Object.keys(n5).forEach(function(k3) {
    var d3 = Object.getOwnPropertyDescriptor(n5, k3);
    Object.defineProperty(a4, k3, d3.get ? d3 : {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return n5[k3];
      }, "get")
    });
  });
  return a4;
}
__name(getAugmentedNamespace, "getAugmentedNamespace");
var lib = {};
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_buffer);
var domain2;
function EventHandlers() {
}
__name(EventHandlers, "EventHandlers");
EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
function EventEmitter2() {
  EventEmitter2.init.call(this);
}
__name(EventEmitter2, "EventEmitter");
EventEmitter2.EventEmitter = EventEmitter2;
EventEmitter2.usingDomains = false;
EventEmitter2.prototype.domain = void 0;
EventEmitter2.prototype._events = void 0;
EventEmitter2.prototype._maxListeners = void 0;
EventEmitter2.defaultMaxListeners = 10;
EventEmitter2.init = function() {
  this.domain = null;
  if (EventEmitter2.usingDomains) {
    if (domain2.active) ;
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter2.prototype.setMaxListeners = /* @__PURE__ */ __name(function setMaxListeners2(n5) {
  if (typeof n5 !== "number" || n5 < 0 || isNaN(n5))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n5;
  return this;
}, "setMaxListeners");
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter2.defaultMaxListeners;
  return that._maxListeners;
}
__name($getMaxListeners, "$getMaxListeners");
EventEmitter2.prototype.getMaxListeners = /* @__PURE__ */ __name(function getMaxListeners2() {
  return $getMaxListeners(this);
}, "getMaxListeners");
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners4 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners4[i2].call(self2);
  }
}
__name(emitNone, "emitNone");
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners4 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners4[i2].call(self2, arg1);
  }
}
__name(emitOne, "emitOne");
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners4 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners4[i2].call(self2, arg1, arg2);
  }
}
__name(emitTwo, "emitTwo");
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners4 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners4[i2].call(self2, arg1, arg2, arg3);
  }
}
__name(emitThree, "emitThree");
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners4 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners4[i2].apply(self2, args);
  }
}
__name(emitMany, "emitMany");
EventEmitter2.prototype.emit = /* @__PURE__ */ __name(function emit3(type2) {
  var er, handler, len, args, i2, events2, domain4;
  var doError = type2 === "error";
  events2 = this._events;
  if (events2)
    doError = doError && events2.error == null;
  else if (!doError)
    return false;
  domain4 = this.domain;
  if (doError) {
    er = arguments[1];
    if (domain4) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain4;
      er.domainThrown = false;
      domain4.emit("error", er);
    } else if (er instanceof Error) {
      throw er;
    } else {
      var err2 = new Error('Uncaught, unspecified "error" event. (' + er + ")");
      err2.context = er;
      throw err2;
    }
    return false;
  }
  handler = events2[type2];
  if (!handler)
    return false;
  var isFn = typeof handler === "function";
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i2 = 1; i2 < len; i2++)
        args[i2 - 1] = arguments[i2];
      emitMany(handler, isFn, this, args);
  }
  return true;
}, "emit");
function _addListener(target, type2, listener, prepend) {
  var m3;
  var events2;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = target._events;
  if (!events2) {
    events2 = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events2.newListener) {
      target.emit(
        "newListener",
        type2,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type2];
  }
  if (!existing) {
    existing = events2[type2] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m3 = $getMaxListeners(target);
      if (m3 && m3 > 0 && existing.length > m3) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type2;
        w.count = existing.length;
        emitWarning2(w);
      }
    }
  }
  return target;
}
__name(_addListener, "_addListener");
function emitWarning2(e4) {
  typeof console.warn === "function" ? console.warn(e4) : console.log(e4);
}
__name(emitWarning2, "emitWarning");
EventEmitter2.prototype.addListener = /* @__PURE__ */ __name(function addListener3(type2, listener) {
  return _addListener(this, type2, listener, false);
}, "addListener");
EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
EventEmitter2.prototype.prependListener = /* @__PURE__ */ __name(function prependListener2(type2, listener) {
  return _addListener(this, type2, listener, true);
}, "prependListener");
function _onceWrap(target, type2, listener) {
  var fired = false;
  function g() {
    target.removeListener(type2, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  __name(g, "g");
  g.listener = listener;
  return g;
}
__name(_onceWrap, "_onceWrap");
EventEmitter2.prototype.once = /* @__PURE__ */ __name(function once3(type2, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.on(type2, _onceWrap(this, type2, listener));
  return this;
}, "once");
EventEmitter2.prototype.prependOnceListener = /* @__PURE__ */ __name(function prependOnceListener2(type2, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type2, _onceWrap(this, type2, listener));
  return this;
}, "prependOnceListener");
EventEmitter2.prototype.removeListener = /* @__PURE__ */ __name(function removeListener3(type2, listener) {
  var list, events2, position, i2, originalListener;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = this._events;
  if (!events2)
    return this;
  list = events2[type2];
  if (!list)
    return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events2[type2];
      if (events2.removeListener)
        this.emit("removeListener", type2, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length; i2-- > 0; ) {
      if (list[i2] === listener || list[i2].listener && list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (list.length === 1) {
      list[0] = void 0;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events2[type2];
      }
    } else {
      spliceOne(list, position);
    }
    if (events2.removeListener)
      this.emit("removeListener", type2, originalListener || listener);
  }
  return this;
}, "removeListener");
EventEmitter2.prototype.off = function(type2, listener) {
  return this.removeListener(type2, listener);
};
EventEmitter2.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners3(type2) {
  var listeners4, events2;
  events2 = this._events;
  if (!events2)
    return this;
  if (!events2.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events2[type2]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events2[type2];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    for (var i2 = 0, key; i2 < keys2.length; ++i2) {
      key = keys2[i2];
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }
  listeners4 = events2[type2];
  if (typeof listeners4 === "function") {
    this.removeListener(type2, listeners4);
  } else if (listeners4) {
    do {
      this.removeListener(type2, listeners4[listeners4.length - 1]);
    } while (listeners4[0]);
  }
  return this;
}, "removeAllListeners");
EventEmitter2.prototype.listeners = /* @__PURE__ */ __name(function listeners2(type2) {
  var evlistener;
  var ret;
  var events2 = this._events;
  if (!events2)
    ret = [];
  else {
    evlistener = events2[type2];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === "function")
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }
  return ret;
}, "listeners");
EventEmitter2.listenerCount = function(emitter, type2) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type2);
  } else {
    return listenerCount$1.call(emitter, type2);
  }
};
EventEmitter2.prototype.listenerCount = listenerCount$1;
function listenerCount$1(type2) {
  var events2 = this._events;
  if (events2) {
    var evlistener = events2[type2];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
__name(listenerCount$1, "listenerCount$1");
EventEmitter2.prototype.eventNames = /* @__PURE__ */ __name(function eventNames2() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
}, "eventNames");
function spliceOne(list, index2) {
  for (var i2 = index2, k3 = i2 + 1, n5 = list.length; k3 < n5; i2 += 1, k3 += 1)
    list[i2] = list[k3];
  list.pop();
}
__name(spliceOne, "spliceOne");
function arrayClone(arr, i2) {
  var copy5 = new Array(i2);
  while (i2--)
    copy5[i2] = arr[i2];
  return copy5;
}
__name(arrayClone, "arrayClone");
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
__name(unwrapListeners, "unwrapListeners");
var inherits2;
if (typeof Object.create === "function") {
  inherits2 = /* @__PURE__ */ __name(function inherits4(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  }, "inherits");
} else {
  inherits2 = /* @__PURE__ */ __name(function inherits4(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = /* @__PURE__ */ __name(function() {
    }, "TempCtor");
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }, "inherits");
}
var inherits$1 = inherits2;
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || /* @__PURE__ */ __name(function getOwnPropertyDescriptors2(obj) {
  var keys2 = Object.keys(obj);
  var descriptors = {};
  for (var i2 = 0; i2 < keys2.length; i2++) {
    descriptors[keys2[i2]] = Object.getOwnPropertyDescriptor(obj, keys2[i2]);
  }
  return descriptors;
}, "getOwnPropertyDescriptors");
var formatRegExp = /%[sdj%]/g;
function format(f4) {
  if (!isString(f4)) {
    var objects = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      objects.push(inspect$1(arguments[i2]));
    }
    return objects.join(" ");
  }
  var i2 = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f4).replace(formatRegExp, function(x2) {
    if (x2 === "%%") return "%";
    if (i2 >= len) return x2;
    switch (x2) {
      case "%s":
        return String(args[i2++]);
      case "%d":
        return Number(args[i2++]);
      case "%j":
        try {
          return JSON.stringify(args[i2++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i2]; i2 < len; x = args[++i2]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect$1(x);
    }
  }
  return str;
}
__name(format, "format");
function deprecate(fn, msg2) {
  if (isUndefined(global$1.process)) {
    return function() {
      return deprecate(fn, msg2).apply(this, arguments);
    };
  }
  if (browser$1.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1.throwDeprecation) {
        throw new Error(msg2);
      } else if (browser$1.traceDeprecation) {
        console.trace(msg2);
      } else {
        console.error(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  __name(deprecated, "deprecated");
  return deprecated;
}
__name(deprecate, "deprecate");
var debugs = {};
var debugEnviron;
function debuglog(set5) {
  if (isUndefined(debugEnviron))
    debugEnviron = browser$1.env.NODE_DEBUG || "";
  set5 = set5.toUpperCase();
  if (!debugs[set5]) {
    if (new RegExp("\\b" + set5 + "\\b", "i").test(debugEnviron)) {
      var pid2 = 0;
      debugs[set5] = function() {
        var msg2 = format.apply(null, arguments);
        console.error("%s %d: %s", set5, pid2, msg2);
      };
    } else {
      debugs[set5] = function() {
      };
    }
  }
  return debugs[set5];
}
__name(debuglog, "debuglog");
function inspect$1(obj, opts2) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts2)) {
    ctx.showHidden = opts2;
  } else if (opts2) {
    _extend(ctx, opts2);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
__name(inspect$1, "inspect$1");
inspect$1.colors = {
  "bold": [1, 22],
  "italic": [3, 23],
  "underline": [4, 24],
  "inverse": [7, 27],
  "white": [37, 39],
  "grey": [90, 39],
  "black": [30, 39],
  "blue": [34, 39],
  "cyan": [36, 39],
  "green": [32, 39],
  "magenta": [35, 39],
  "red": [31, 39],
  "yellow": [33, 39]
};
inspect$1.styles = {
  "special": "cyan",
  "number": "yellow",
  "boolean": "yellow",
  "undefined": "grey",
  "null": "bold",
  "string": "green",
  "date": "magenta",
  // "name": intentionally not styling
  "regexp": "red"
};
function stylizeWithColor(str, styleType) {
  var style = inspect$1.styles[styleType];
  if (style) {
    return "\x1B[" + inspect$1.colors[style][0] + "m" + str + "\x1B[" + inspect$1.colors[style][1] + "m";
  } else {
    return str;
  }
}
__name(stylizeWithColor, "stylizeWithColor");
function stylizeNoColor(str, styleType) {
  return str;
}
__name(stylizeNoColor, "stylizeNoColor");
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
__name(arrayToHash, "arrayToHash");
function formatValue(ctx, value2, recurseTimes) {
  if (ctx.customInspect && value2 && isFunction(value2.inspect) && // Filter out the util module, it's inspect function is special
  value2.inspect !== inspect$1 && // Also filter out any prototype objects using the circular check.
  !(value2.constructor && value2.constructor.prototype === value2)) {
    var ret = value2.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value2);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value2);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value2);
  }
  if (isError(value2) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value2);
  }
  if (keys2.length === 0) {
    if (isFunction(value2)) {
      var name = value2.name ? ": " + value2.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    }
    if (isDate(value2)) {
      return ctx.stylize(Date.prototype.toString.call(value2), "date");
    }
    if (isError(value2)) {
      return formatError(value2);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value2)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value2)) {
    var n5 = value2.name ? ": " + value2.name : "";
    base = " [Function" + n5 + "]";
  }
  if (isRegExp(value2)) {
    base = " " + RegExp.prototype.toString.call(value2);
  }
  if (isDate(value2)) {
    base = " " + Date.prototype.toUTCString.call(value2);
  }
  if (isError(value2)) {
    base = " " + formatError(value2);
  }
  if (keys2.length === 0 && (!array || value2.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value2);
  var output;
  if (array) {
    output = formatArray(ctx, value2, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
__name(formatValue, "formatValue");
function formatPrimitive(ctx, value2) {
  if (isUndefined(value2))
    return ctx.stylize("undefined", "undefined");
  if (isString(value2)) {
    var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value2))
    return ctx.stylize("" + value2, "number");
  if (isBoolean(value2))
    return ctx.stylize("" + value2, "boolean");
  if (isNull(value2))
    return ctx.stylize("null", "null");
}
__name(formatPrimitive, "formatPrimitive");
function formatError(value2) {
  return "[" + Error.prototype.toString.call(value2) + "]";
}
__name(formatError, "formatError");
function formatArray(ctx, value2, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i2 = 0, l4 = value2.length; i2 < l4; ++i2) {
    if (hasOwnProperty(value2, String(i2))) {
      output.push(formatProperty(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        String(i2),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
__name(formatArray, "formatArray");
function formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value2, key) || { value: value2[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line2) {
            return "  " + line2;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line2) {
            return "   " + line2;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
__name(formatProperty, "formatProperty");
function reduceToSingleString(output, base, braces) {
  var length2 = output.reduce(function(prev, cur) {
    if (cur.indexOf("\n") >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length2 > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
__name(reduceToSingleString, "reduceToSingleString");
function isArray(ar) {
  return Array.isArray(ar);
}
__name(isArray, "isArray");
function isBoolean(arg) {
  return typeof arg === "boolean";
}
__name(isBoolean, "isBoolean");
function isNull(arg) {
  return arg === null;
}
__name(isNull, "isNull");
function isNullOrUndefined(arg) {
  return arg == null;
}
__name(isNullOrUndefined, "isNullOrUndefined");
function isNumber(arg) {
  return typeof arg === "number";
}
__name(isNumber, "isNumber");
function isString(arg) {
  return typeof arg === "string";
}
__name(isString, "isString");
function isSymbol(arg) {
  return typeof arg === "symbol";
}
__name(isSymbol, "isSymbol");
function isUndefined(arg) {
  return arg === void 0;
}
__name(isUndefined, "isUndefined");
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
__name(isRegExp, "isRegExp");
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
__name(isObject, "isObject");
function isDate(d3) {
  return isObject(d3) && objectToString(d3) === "[object Date]";
}
__name(isDate, "isDate");
function isError(e4) {
  return isObject(e4) && (objectToString(e4) === "[object Error]" || e4 instanceof Error);
}
__name(isError, "isError");
function isFunction(arg) {
  return typeof arg === "function";
}
__name(isFunction, "isFunction");
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
__name(isPrimitive, "isPrimitive");
function isBuffer(maybeBuf) {
  return Buffer2.isBuffer(maybeBuf);
}
__name(isBuffer, "isBuffer");
function objectToString(o4) {
  return Object.prototype.toString.call(o4);
}
__name(objectToString, "objectToString");
function pad(n5) {
  return n5 < 10 ? "0" + n5.toString(10) : n5.toString(10);
}
__name(pad, "pad");
var months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp() {
  var d3 = /* @__PURE__ */ new Date();
  var time3 = [
    pad(d3.getHours()),
    pad(d3.getMinutes()),
    pad(d3.getSeconds())
  ].join(":");
  return [d3.getDate(), months[d3.getMonth()], time3].join(" ");
}
__name(timestamp, "timestamp");
function log3() {
  console.log("%s - %s", timestamp(), format.apply(null, arguments));
}
__name(log3, "log");
function _extend(origin, add2) {
  if (!add2 || !isObject(add2)) return origin;
  var keys2 = Object.keys(add2);
  var i2 = keys2.length;
  while (i2--) {
    origin[keys2[i2]] = add2[keys2[i2]];
  }
  return origin;
}
__name(_extend, "_extend");
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
__name(hasOwnProperty, "hasOwnProperty");
var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
function promisify(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== "function") {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }
  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function(resolve3, reject) {
      promiseResolve = resolve3;
      promiseReject = reject;
    });
    var args = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      args.push(arguments[i2]);
    }
    args.push(function(err2, value2) {
      if (err2) {
        promiseReject(err2);
      } else {
        promiseResolve(value2);
      }
    });
    try {
      original.apply(this, args);
    } catch (err2) {
      promiseReject(err2);
    }
    return promise;
  }
  __name(fn, "fn");
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}
__name(promisify, "promisify");
promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
  if (!reason) {
    var newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
__name(callbackifyOnRejected, "callbackifyOnRejected");
function callbackify(original) {
  if (typeof original !== "function") {
    throw new TypeError('The "original" argument must be of type Function');
  }
  function callbackified() {
    var args = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      args.push(arguments[i2]);
    }
    var maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new TypeError("The last argument must be of type Function");
    }
    var self2 = this;
    var cb = /* @__PURE__ */ __name(function() {
      return maybeCb.apply(self2, arguments);
    }, "cb");
    original.apply(this, args).then(
      function(ret) {
        browser$1.nextTick(cb.bind(null, null, ret));
      },
      function(rej) {
        browser$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
      }
    );
  }
  __name(callbackified, "callbackified");
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}
__name(callbackify, "callbackify");
var _polyfillNode_util = {
  inherits: inherits$1,
  _extend,
  log: log3,
  isBuffer,
  isPrimitive,
  isFunction,
  isError,
  isDate,
  isObject,
  isRegExp,
  isUndefined,
  isSymbol,
  isString,
  isNumber,
  isNullOrUndefined,
  isNull,
  isBoolean,
  isArray,
  inspect: inspect$1,
  deprecate,
  format,
  debuglog,
  promisify,
  callbackify
};
var _polyfillNode_util$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _extend,
  callbackify,
  debuglog,
  default: _polyfillNode_util,
  deprecate,
  format,
  inherits: inherits$1,
  inspect: inspect$1,
  isArray,
  isBoolean,
  isBuffer,
  isDate,
  isError,
  isFunction,
  isNull,
  isNullOrUndefined,
  isNumber,
  isObject,
  isPrimitive,
  isRegExp,
  isString,
  isSymbol,
  isUndefined,
  log: log3,
  promisify
});
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
__name(BufferList, "BufferList");
BufferList.prototype.push = function(v3) {
  var entry = { data: v3, next: null };
  if (this.length > 0) this.tail.next = entry;
  else this.head = entry;
  this.tail = entry;
  ++this.length;
};
BufferList.prototype.unshift = function(v3) {
  var entry = { data: v3, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};
BufferList.prototype.shift = function() {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;
  else this.head = this.head.next;
  --this.length;
  return ret;
};
BufferList.prototype.clear = function() {
  this.head = this.tail = null;
  this.length = 0;
};
BufferList.prototype.join = function(s4) {
  if (this.length === 0) return "";
  var p3 = this.head;
  var ret = "" + p3.data;
  while (p3 = p3.next) {
    ret += s4 + p3.data;
  }
  return ret;
};
BufferList.prototype.concat = function(n5) {
  if (this.length === 0) return Buffer2.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = Buffer2.allocUnsafe(n5 >>> 0);
  var p3 = this.head;
  var i2 = 0;
  while (p3) {
    p3.data.copy(ret, i2);
    i2 += p3.data.length;
    p3 = p3.next;
  }
  return ret;
};
var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
__name(assertEncoding, "assertEncoding");
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
__name(StringDecoder, "StringDecoder");
StringDecoder.prototype.write = function(buffer) {
  var charStr = "";
  while (this.charLength) {
    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;
    if (this.charReceived < this.charLength) {
      return "";
    }
    buffer = buffer.slice(available, buffer.length);
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 55296 && charCode <= 56319) {
      this.charLength += this.surrogateSize;
      charStr = "";
      continue;
    }
    this.charReceived = this.charLength = 0;
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }
  this.detectIncompleteChar(buffer);
  var end2 = buffer.length;
  if (this.charLength) {
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end2);
    end2 -= this.charReceived;
  }
  charStr += buffer.toString(this.encoding, 0, end2);
  var end2 = charStr.length - 1;
  var charCode = charStr.charCodeAt(end2);
  if (charCode >= 55296 && charCode <= 56319) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end2);
  }
  return charStr;
};
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  var i2 = buffer.length >= 3 ? 3 : buffer.length;
  for (; i2 > 0; i2--) {
    var c2 = buffer[buffer.length - i2];
    if (i2 == 1 && c2 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (i2 <= 2 && c2 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (i2 <= 3 && c2 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i2;
};
StringDecoder.prototype.end = function(buffer) {
  var res = "";
  if (buffer && buffer.length)
    res = this.write(buffer);
  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }
  return res;
};
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
__name(passThroughWrite, "passThroughWrite");
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
__name(utf16DetectIncompleteChar, "utf16DetectIncompleteChar");
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
__name(base64DetectIncompleteChar, "base64DetectIncompleteChar");
Readable.ReadableState = ReadableState;
var debug3 = debuglog("stream");
inherits$1(Readable, EventEmitter2);
function prependListener3(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
__name(prependListener3, "prependListener");
function listenerCount2(emitter, type2) {
  return emitter.listeners(type2).length;
}
__name(listenerCount2, "listenerCount");
function ReadableState(options, stream2) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream2 instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
__name(ReadableState, "ReadableState");
function Readable(options) {
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function") this._read = options.read;
  EventEmitter2.call(this);
}
__name(Readable, "Readable");
Readable.prototype.push = function(chunk, encoding) {
  var state2 = this._readableState;
  if (!state2.objectMode && typeof chunk === "string") {
    encoding = encoding || state2.defaultEncoding;
    if (encoding !== state2.encoding) {
      chunk = Buffer2.from(chunk, encoding);
      encoding = "";
    }
  }
  return readableAddChunk(this, state2, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk) {
  var state2 = this._readableState;
  return readableAddChunk(this, state2, chunk, "", true);
};
Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
function readableAddChunk(stream2, state2, chunk, encoding, addToFront) {
  var er = chunkInvalid(state2, chunk);
  if (er) {
    stream2.emit("error", er);
  } else if (chunk === null) {
    state2.reading = false;
    onEofChunk(stream2, state2);
  } else if (state2.objectMode || chunk && chunk.length > 0) {
    if (state2.ended && !addToFront) {
      var e4 = new Error("stream.push() after EOF");
      stream2.emit("error", e4);
    } else if (state2.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream2.emit("error", _e);
    } else {
      var skipAdd;
      if (state2.decoder && !addToFront && !encoding) {
        chunk = state2.decoder.write(chunk);
        skipAdd = !state2.objectMode && chunk.length === 0;
      }
      if (!addToFront) state2.reading = false;
      if (!skipAdd) {
        if (state2.flowing && state2.length === 0 && !state2.sync) {
          stream2.emit("data", chunk);
          stream2.read(0);
        } else {
          state2.length += state2.objectMode ? 1 : chunk.length;
          if (addToFront) state2.buffer.unshift(chunk);
          else state2.buffer.push(chunk);
          if (state2.needReadable) emitReadable(stream2);
        }
      }
      maybeReadMore(stream2, state2);
    }
  } else if (!addToFront) {
    state2.reading = false;
  }
  return needMoreData(state2);
}
__name(readableAddChunk, "readableAddChunk");
function needMoreData(state2) {
  return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
}
__name(needMoreData, "needMoreData");
Readable.prototype.setEncoding = function(enc) {
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};
var MAX_HWM = 8388608;
function computeNewHighWaterMark(n5) {
  if (n5 >= MAX_HWM) {
    n5 = MAX_HWM;
  } else {
    n5--;
    n5 |= n5 >>> 1;
    n5 |= n5 >>> 2;
    n5 |= n5 >>> 4;
    n5 |= n5 >>> 8;
    n5 |= n5 >>> 16;
    n5++;
  }
  return n5;
}
__name(computeNewHighWaterMark, "computeNewHighWaterMark");
function howMuchToRead(n5, state2) {
  if (n5 <= 0 || state2.length === 0 && state2.ended) return 0;
  if (state2.objectMode) return 1;
  if (n5 !== n5) {
    if (state2.flowing && state2.length) return state2.buffer.head.data.length;
    else return state2.length;
  }
  if (n5 > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n5);
  if (n5 <= state2.length) return n5;
  if (!state2.ended) {
    state2.needReadable = true;
    return 0;
  }
  return state2.length;
}
__name(howMuchToRead, "howMuchToRead");
Readable.prototype.read = function(n5) {
  debug3("read", n5);
  n5 = parseInt(n5, 10);
  var state2 = this._readableState;
  var nOrig = n5;
  if (n5 !== 0) state2.emittedReadable = false;
  if (n5 === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
    debug3("read: emitReadable", state2.length, state2.ended);
    if (state2.length === 0 && state2.ended) endReadable(this);
    else emitReadable(this);
    return null;
  }
  n5 = howMuchToRead(n5, state2);
  if (n5 === 0 && state2.ended) {
    if (state2.length === 0) endReadable(this);
    return null;
  }
  var doRead = state2.needReadable;
  debug3("need readable", doRead);
  if (state2.length === 0 || state2.length - n5 < state2.highWaterMark) {
    doRead = true;
    debug3("length less than watermark", doRead);
  }
  if (state2.ended || state2.reading) {
    doRead = false;
    debug3("reading or ended", doRead);
  } else if (doRead) {
    debug3("do read");
    state2.reading = true;
    state2.sync = true;
    if (state2.length === 0) state2.needReadable = true;
    this._read(state2.highWaterMark);
    state2.sync = false;
    if (!state2.reading) n5 = howMuchToRead(nOrig, state2);
  }
  var ret;
  if (n5 > 0) ret = fromList(n5, state2);
  else ret = null;
  if (ret === null) {
    state2.needReadable = true;
    n5 = 0;
  } else {
    state2.length -= n5;
  }
  if (state2.length === 0) {
    if (!state2.ended) state2.needReadable = true;
    if (nOrig !== n5 && state2.ended) endReadable(this);
  }
  if (ret !== null) this.emit("data", ret);
  return ret;
};
function chunkInvalid(state2, chunk) {
  var er = null;
  if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state2.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
__name(chunkInvalid, "chunkInvalid");
function onEofChunk(stream2, state2) {
  if (state2.ended) return;
  if (state2.decoder) {
    var chunk = state2.decoder.end();
    if (chunk && chunk.length) {
      state2.buffer.push(chunk);
      state2.length += state2.objectMode ? 1 : chunk.length;
    }
  }
  state2.ended = true;
  emitReadable(stream2);
}
__name(onEofChunk, "onEofChunk");
function emitReadable(stream2) {
  var state2 = stream2._readableState;
  state2.needReadable = false;
  if (!state2.emittedReadable) {
    debug3("emitReadable", state2.flowing);
    state2.emittedReadable = true;
    if (state2.sync) nextTick2(emitReadable_, stream2);
    else emitReadable_(stream2);
  }
}
__name(emitReadable, "emitReadable");
function emitReadable_(stream2) {
  debug3("emit readable");
  stream2.emit("readable");
  flow(stream2);
}
__name(emitReadable_, "emitReadable_");
function maybeReadMore(stream2, state2) {
  if (!state2.readingMore) {
    state2.readingMore = true;
    nextTick2(maybeReadMore_, stream2, state2);
  }
}
__name(maybeReadMore, "maybeReadMore");
function maybeReadMore_(stream2, state2) {
  var len = state2.length;
  while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
    debug3("maybeReadMore read 0");
    stream2.read(0);
    if (len === state2.length)
      break;
    else len = state2.length;
  }
  state2.readingMore = false;
}
__name(maybeReadMore_, "maybeReadMore_");
Readable.prototype._read = function(n5) {
  this.emit("error", new Error("not implemented"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state2 = this._readableState;
  switch (state2.pipesCount) {
    case 0:
      state2.pipes = dest;
      break;
    case 1:
      state2.pipes = [state2.pipes, dest];
      break;
    default:
      state2.pipes.push(dest);
      break;
  }
  state2.pipesCount += 1;
  debug3("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
  var doEnd = !pipeOpts || pipeOpts.end !== false;
  var endFn = doEnd ? onend3 : cleanup;
  if (state2.endEmitted) nextTick2(endFn);
  else src.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable) {
    debug3("onunpipe");
    if (readable === src) {
      cleanup();
    }
  }
  __name(onunpipe, "onunpipe");
  function onend3() {
    debug3("onend");
    dest.end();
  }
  __name(onend3, "onend");
  var ondrain = pipeOnDrain(src);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug3("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend3);
    src.removeListener("end", cleanup);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  __name(cleanup, "cleanup");
  var increasedAwaitDrain = false;
  src.on("data", ondata);
  function ondata(chunk) {
    debug3("ondata");
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
        debug3("false write response, pause", src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }
  __name(ondata, "ondata");
  function onerror(er) {
    debug3("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (listenerCount2(dest, "error") === 0) dest.emit("error", er);
  }
  __name(onerror, "onerror");
  prependListener3(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  __name(onclose, "onclose");
  dest.once("close", onclose);
  function onfinish() {
    debug3("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  __name(onfinish, "onfinish");
  dest.once("finish", onfinish);
  function unpipe() {
    debug3("unpipe");
    src.unpipe(dest);
  }
  __name(unpipe, "unpipe");
  dest.emit("pipe", src);
  if (!state2.flowing) {
    debug3("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function() {
    var state2 = src._readableState;
    debug3("pipeOnDrain", state2.awaitDrain);
    if (state2.awaitDrain) state2.awaitDrain--;
    if (state2.awaitDrain === 0 && src.listeners("data").length) {
      state2.flowing = true;
      flow(src);
    }
  };
}
__name(pipeOnDrain, "pipeOnDrain");
Readable.prototype.unpipe = function(dest) {
  var state2 = this._readableState;
  if (state2.pipesCount === 0) return this;
  if (state2.pipesCount === 1) {
    if (dest && dest !== state2.pipes) return this;
    if (!dest) dest = state2.pipes;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    if (dest) dest.emit("unpipe", this);
    return this;
  }
  if (!dest) {
    var dests = state2.pipes;
    var len = state2.pipesCount;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit("unpipe", this);
    }
    return this;
  }
  var i2 = indexOf2(state2.pipes, dest);
  if (i2 === -1) return this;
  state2.pipes.splice(i2, 1);
  state2.pipesCount -= 1;
  if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
  dest.emit("unpipe", this);
  return this;
};
Readable.prototype.on = function(ev, fn) {
  var res = EventEmitter2.prototype.on.call(this, ev, fn);
  if (ev === "data") {
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === "readable") {
    var state2 = this._readableState;
    if (!state2.endEmitted && !state2.readableListening) {
      state2.readableListening = state2.needReadable = true;
      state2.emittedReadable = false;
      if (!state2.reading) {
        nextTick2(nReadingNextTick, this);
      } else if (state2.length) {
        emitReadable(this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self2) {
  debug3("readable nexttick read 0");
  self2.read(0);
}
__name(nReadingNextTick, "nReadingNextTick");
Readable.prototype.resume = function() {
  var state2 = this._readableState;
  if (!state2.flowing) {
    debug3("resume");
    state2.flowing = true;
    resume(this, state2);
  }
  return this;
};
function resume(stream2, state2) {
  if (!state2.resumeScheduled) {
    state2.resumeScheduled = true;
    nextTick2(resume_, stream2, state2);
  }
}
__name(resume, "resume");
function resume_(stream2, state2) {
  if (!state2.reading) {
    debug3("resume read 0");
    stream2.read(0);
  }
  state2.resumeScheduled = false;
  state2.awaitDrain = 0;
  stream2.emit("resume");
  flow(stream2);
  if (state2.flowing && !state2.reading) stream2.read(0);
}
__name(resume_, "resume_");
Readable.prototype.pause = function() {
  debug3("call pause flowing=%j", this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug3("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  return this;
};
function flow(stream2) {
  var state2 = stream2._readableState;
  debug3("flow", state2.flowing);
  while (state2.flowing && stream2.read() !== null) {
  }
}
__name(flow, "flow");
Readable.prototype.wrap = function(stream2) {
  var state2 = this._readableState;
  var paused = false;
  var self2 = this;
  stream2.on("end", function() {
    debug3("wrapped end");
    if (state2.decoder && !state2.ended) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) self2.push(chunk);
    }
    self2.push(null);
  });
  stream2.on("data", function(chunk) {
    debug3("wrapped data");
    if (state2.decoder) chunk = state2.decoder.write(chunk);
    if (state2.objectMode && (chunk === null || chunk === void 0)) return;
    else if (!state2.objectMode && (!chunk || !chunk.length)) return;
    var ret = self2.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i2 in stream2) {
    if (this[i2] === void 0 && typeof stream2[i2] === "function") {
      this[i2] = /* @__PURE__ */ function(method) {
        return function() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i2);
    }
  }
  var events2 = ["error", "close", "destroy", "pause", "resume"];
  forEach(events2, function(ev) {
    stream2.on(ev, self2.emit.bind(self2, ev));
  });
  self2._read = function(n5) {
    debug3("wrapped _read", n5);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return self2;
};
Readable._fromList = fromList;
function fromList(n5, state2) {
  if (state2.length === 0) return null;
  var ret;
  if (state2.objectMode) ret = state2.buffer.shift();
  else if (!n5 || n5 >= state2.length) {
    if (state2.decoder) ret = state2.buffer.join("");
    else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
    else ret = state2.buffer.concat(state2.length);
    state2.buffer.clear();
  } else {
    ret = fromListPartial(n5, state2.buffer, state2.decoder);
  }
  return ret;
}
__name(fromList, "fromList");
function fromListPartial(n5, list, hasStrings) {
  var ret;
  if (n5 < list.head.data.length) {
    ret = list.head.data.slice(0, n5);
    list.head.data = list.head.data.slice(n5);
  } else if (n5 === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n5, list) : copyFromBuffer(n5, list);
  }
  return ret;
}
__name(fromListPartial, "fromListPartial");
function copyFromBufferString(n5, list) {
  var p3 = list.head;
  var c2 = 1;
  var ret = p3.data;
  n5 -= ret.length;
  while (p3 = p3.next) {
    var str = p3.data;
    var nb = n5 > str.length ? str.length : n5;
    if (nb === str.length) ret += str;
    else ret += str.slice(0, n5);
    n5 -= nb;
    if (n5 === 0) {
      if (nb === str.length) {
        ++c2;
        if (p3.next) list.head = p3.next;
        else list.head = list.tail = null;
      } else {
        list.head = p3;
        p3.data = str.slice(nb);
      }
      break;
    }
    ++c2;
  }
  list.length -= c2;
  return ret;
}
__name(copyFromBufferString, "copyFromBufferString");
function copyFromBuffer(n5, list) {
  var ret = Buffer2.allocUnsafe(n5);
  var p3 = list.head;
  var c2 = 1;
  p3.data.copy(ret);
  n5 -= p3.data.length;
  while (p3 = p3.next) {
    var buf = p3.data;
    var nb = n5 > buf.length ? buf.length : n5;
    buf.copy(ret, ret.length - n5, 0, nb);
    n5 -= nb;
    if (n5 === 0) {
      if (nb === buf.length) {
        ++c2;
        if (p3.next) list.head = p3.next;
        else list.head = list.tail = null;
      } else {
        list.head = p3;
        p3.data = buf.slice(nb);
      }
      break;
    }
    ++c2;
  }
  list.length -= c2;
  return ret;
}
__name(copyFromBuffer, "copyFromBuffer");
function endReadable(stream2) {
  var state2 = stream2._readableState;
  if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
  if (!state2.endEmitted) {
    state2.ended = true;
    nextTick2(endReadableNT, state2, stream2);
  }
}
__name(endReadable, "endReadable");
function endReadableNT(state2, stream2) {
  if (!state2.endEmitted && state2.length === 0) {
    state2.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
  }
}
__name(endReadableNT, "endReadableNT");
function forEach(xs, f4) {
  for (var i2 = 0, l4 = xs.length; i2 < l4; i2++) {
    f4(xs[i2], i2);
  }
}
__name(forEach, "forEach");
function indexOf2(xs, x) {
  for (var i2 = 0, l4 = xs.length; i2 < l4; i2++) {
    if (xs[i2] === x) return i2;
  }
  return -1;
}
__name(indexOf2, "indexOf");
Writable2.WritableState = WritableState;
inherits$1(Writable2, EventEmitter2);
function nop() {
}
__name(nop, "nop");
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
__name(WriteReq, "WriteReq");
function WritableState(options, stream2) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream2 instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream2, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
__name(WritableState, "WritableState");
WritableState.prototype.getBuffer = /* @__PURE__ */ __name(function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
}, "writableStateGetBuffer");
function Writable2(options) {
  if (!(this instanceof Writable2) && !(this instanceof Duplex)) return new Writable2(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function") this._write = options.write;
    if (typeof options.writev === "function") this._writev = options.writev;
  }
  EventEmitter2.call(this);
}
__name(Writable2, "Writable");
Writable2.prototype.pipe = function() {
  this.emit("error", new Error("Cannot pipe, not readable"));
};
function writeAfterEnd(stream2, cb) {
  var er = new Error("write after end");
  stream2.emit("error", er);
  nextTick2(cb, er);
}
__name(writeAfterEnd, "writeAfterEnd");
function validChunk(stream2, state2, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream2.emit("error", er);
    nextTick2(cb, er);
    valid = false;
  }
  return valid;
}
__name(validChunk, "validChunk");
Writable2.prototype.write = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  var ret = false;
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (Buffer2.isBuffer(chunk)) encoding = "buffer";
  else if (!encoding) encoding = state2.defaultEncoding;
  if (typeof cb !== "function") cb = nop;
  if (state2.ended) writeAfterEnd(this, cb);
  else if (validChunk(this, state2, chunk, cb)) {
    state2.pendingcb++;
    ret = writeOrBuffer(this, state2, chunk, encoding, cb);
  }
  return ret;
};
Writable2.prototype.cork = function() {
  var state2 = this._writableState;
  state2.corked++;
};
Writable2.prototype.uncork = function() {
  var state2 = this._writableState;
  if (state2.corked) {
    state2.corked--;
    if (!state2.writing && !state2.corked && !state2.finished && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
  }
};
Writable2.prototype.setDefaultEncoding = /* @__PURE__ */ __name(function setDefaultEncoding(encoding) {
  if (typeof encoding === "string") encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
}, "setDefaultEncoding");
function decodeChunk(state2, chunk, encoding) {
  if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer2.from(chunk, encoding);
  }
  return chunk;
}
__name(decodeChunk, "decodeChunk");
function writeOrBuffer(stream2, state2, chunk, encoding, cb) {
  chunk = decodeChunk(state2, chunk, encoding);
  if (Buffer2.isBuffer(chunk)) encoding = "buffer";
  var len = state2.objectMode ? 1 : chunk.length;
  state2.length += len;
  var ret = state2.length < state2.highWaterMark;
  if (!ret) state2.needDrain = true;
  if (state2.writing || state2.corked) {
    var last2 = state2.lastBufferedRequest;
    state2.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last2) {
      last2.next = state2.lastBufferedRequest;
    } else {
      state2.bufferedRequest = state2.lastBufferedRequest;
    }
    state2.bufferedRequestCount += 1;
  } else {
    doWrite(stream2, state2, false, len, chunk, encoding, cb);
  }
  return ret;
}
__name(writeOrBuffer, "writeOrBuffer");
function doWrite(stream2, state2, writev2, len, chunk, encoding, cb) {
  state2.writelen = len;
  state2.writecb = cb;
  state2.writing = true;
  state2.sync = true;
  if (writev2) stream2._writev(chunk, state2.onwrite);
  else stream2._write(chunk, encoding, state2.onwrite);
  state2.sync = false;
}
__name(doWrite, "doWrite");
function onwriteError(stream2, state2, sync, er, cb) {
  --state2.pendingcb;
  if (sync) nextTick2(cb, er);
  else cb(er);
  stream2._writableState.errorEmitted = true;
  stream2.emit("error", er);
}
__name(onwriteError, "onwriteError");
function onwriteStateUpdate(state2) {
  state2.writing = false;
  state2.writecb = null;
  state2.length -= state2.writelen;
  state2.writelen = 0;
}
__name(onwriteStateUpdate, "onwriteStateUpdate");
function onwrite(stream2, er) {
  var state2 = stream2._writableState;
  var sync = state2.sync;
  var cb = state2.writecb;
  onwriteStateUpdate(state2);
  if (er) onwriteError(stream2, state2, sync, er, cb);
  else {
    var finished = needFinish(state2);
    if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
      clearBuffer(stream2, state2);
    }
    if (sync) {
      nextTick2(afterWrite, stream2, state2, finished, cb);
    } else {
      afterWrite(stream2, state2, finished, cb);
    }
  }
}
__name(onwrite, "onwrite");
function afterWrite(stream2, state2, finished, cb) {
  if (!finished) onwriteDrain(stream2, state2);
  state2.pendingcb--;
  cb();
  finishMaybe(stream2, state2);
}
__name(afterWrite, "afterWrite");
function onwriteDrain(stream2, state2) {
  if (state2.length === 0 && state2.needDrain) {
    state2.needDrain = false;
    stream2.emit("drain");
  }
}
__name(onwriteDrain, "onwriteDrain");
function clearBuffer(stream2, state2) {
  state2.bufferProcessing = true;
  var entry = state2.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l4 = state2.bufferedRequestCount;
    var buffer = new Array(l4);
    var holder = state2.corkedRequestsFree;
    holder.entry = entry;
    var count3 = 0;
    while (entry) {
      buffer[count3] = entry;
      entry = entry.next;
      count3 += 1;
    }
    doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
    state2.pendingcb++;
    state2.lastBufferedRequest = null;
    if (holder.next) {
      state2.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state2.corkedRequestsFree = new CorkedRequest(state2);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state2.objectMode ? 1 : chunk.length;
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state2.writing) {
        break;
      }
    }
    if (entry === null) state2.lastBufferedRequest = null;
  }
  state2.bufferedRequestCount = 0;
  state2.bufferedRequest = entry;
  state2.bufferProcessing = false;
}
__name(clearBuffer, "clearBuffer");
Writable2.prototype._write = function(chunk, encoding, cb) {
  cb(new Error("not implemented"));
};
Writable2.prototype._writev = null;
Writable2.prototype.end = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
  if (state2.corked) {
    state2.corked = 1;
    this.uncork();
  }
  if (!state2.ending && !state2.finished) endWritable(this, state2, cb);
};
function needFinish(state2) {
  return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
}
__name(needFinish, "needFinish");
function prefinish(stream2, state2) {
  if (!state2.prefinished) {
    state2.prefinished = true;
    stream2.emit("prefinish");
  }
}
__name(prefinish, "prefinish");
function finishMaybe(stream2, state2) {
  var need = needFinish(state2);
  if (need) {
    if (state2.pendingcb === 0) {
      prefinish(stream2, state2);
      state2.finished = true;
      stream2.emit("finish");
    } else {
      prefinish(stream2, state2);
    }
  }
  return need;
}
__name(finishMaybe, "finishMaybe");
function endWritable(stream2, state2, cb) {
  state2.ending = true;
  finishMaybe(stream2, state2);
  if (cb) {
    if (state2.finished) nextTick2(cb);
    else stream2.once("finish", cb);
  }
  state2.ended = true;
  stream2.writable = false;
}
__name(endWritable, "endWritable");
function CorkedRequest(state2) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err2) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    if (state2.corkedRequestsFree) {
      state2.corkedRequestsFree.next = _this;
    } else {
      state2.corkedRequestsFree = _this;
    }
  };
}
__name(CorkedRequest, "CorkedRequest");
inherits$1(Duplex, Readable);
var keys = Object.keys(Writable2.prototype);
for (v3 = 0; v3 < keys.length; v3++) {
  method = keys[v3];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable2.prototype[method];
}
var method;
var v3;
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable2.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once("end", onend);
}
__name(Duplex, "Duplex");
function onend() {
  if (this.allowHalfOpen || this._writableState.ended) return;
  nextTick2(onEndNT, this);
}
__name(onend, "onend");
function onEndNT(self2) {
  self2.end();
}
__name(onEndNT, "onEndNT");
inherits$1(Transform2, Duplex);
function TransformState(stream2) {
  this.afterTransform = function(er, data2) {
    return afterTransform(stream2, er, data2);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
__name(TransformState, "TransformState");
function afterTransform(stream2, er, data2) {
  var ts = stream2._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb) return stream2.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 !== null && data2 !== void 0) stream2.push(data2);
  cb(er);
  var rs = stream2._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream2._read(rs.highWaterMark);
  }
}
__name(afterTransform, "afterTransform");
function Transform2(options) {
  if (!(this instanceof Transform2)) return new Transform2(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream2 = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function") this._transform = options.transform;
    if (typeof options.flush === "function") this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function") this._flush(function(er) {
      done(stream2, er);
    });
    else done(stream2);
  });
}
__name(Transform2, "Transform");
Transform2.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform2.prototype._transform = function(chunk, encoding, cb) {
  throw new Error("Not implemented");
};
Transform2.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};
Transform2.prototype._read = function(n5) {
  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
function done(stream2, er) {
  if (er) return stream2.emit("error", er);
  var ws = stream2._writableState;
  var ts = stream2._transformState;
  if (ws.length) throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming) throw new Error("Calling transform done when still transforming");
  return stream2.push(null);
}
__name(done, "done");
inherits$1(PassThrough, Transform2);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform2.call(this, options);
}
__name(PassThrough, "PassThrough");
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
inherits$1(Stream, EventEmitter2);
Stream.Readable = Readable;
Stream.Writable = Writable2;
Stream.Duplex = Duplex;
Stream.Transform = Transform2;
Stream.PassThrough = PassThrough;
Stream.Stream = Stream;
function Stream() {
  EventEmitter2.call(this);
}
__name(Stream, "Stream");
Stream.prototype.pipe = function(dest, options) {
  var source = this;
  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }
  __name(ondata, "ondata");
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  __name(ondrain, "ondrain");
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on("end", onend3);
    source.on("close", onclose);
  }
  var didOnEnd = false;
  function onend3() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }
  __name(onend3, "onend");
  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === "function") dest.destroy();
  }
  __name(onclose, "onclose");
  function onerror(er) {
    cleanup();
    if (EventEmitter2.listenerCount(this, "error") === 0) {
      throw er;
    }
  }
  __name(onerror, "onerror");
  source.on("error", onerror);
  dest.on("error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend3);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  __name(cleanup, "cleanup");
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
var _polyfillNode_stream = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Duplex,
  PassThrough,
  Readable,
  Stream,
  Transform: Transform2,
  Writable: Writable2,
  default: Stream
});
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_stream);
var binding2 = {};
function compare3(a4, b3) {
  if (a4 === b3) {
    return 0;
  }
  var x = a4.length;
  var y3 = b3.length;
  for (var i2 = 0, len = Math.min(x, y3); i2 < len; ++i2) {
    if (a4[i2] !== b3[i2]) {
      x = a4[i2];
      y3 = b3[i2];
      break;
    }
  }
  if (x < y3) {
    return -1;
  }
  if (y3 < x) {
    return 1;
  }
  return 0;
}
__name(compare3, "compare");
var hasOwn = Object.prototype.hasOwnProperty;
var objectKeys = Object.keys || function(obj) {
  var keys2 = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys2.push(key);
  }
  return keys2;
};
var pSlice = Array.prototype.slice;
var _functionsHaveNames;
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== "undefined") {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = function() {
    return (/* @__PURE__ */ __name(function foo() {
    }, "foo")).name === "foo";
  }();
}
__name(functionsHaveNames, "functionsHaveNames");
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
__name(pToString, "pToString");
function isView(arrbuf) {
  if (isBuffer$1(arrbuf)) {
    return false;
  }
  if (typeof global$1.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
__name(isView, "isView");
function assert3(value2, message) {
  if (!value2) fail(value2, true, message, "==", ok);
}
__name(assert3, "assert");
var regex = /\s*function\s+([^\(\s]*)\s*/;
function getName(func) {
  if (!isFunction(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match2 = str.match(regex);
  return match2 && match2[1];
}
__name(getName, "getName");
assert3.AssertionError = AssertionError;
function AssertionError(options) {
  this.name = "AssertionError";
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err2 = new Error();
    if (err2.stack) {
      var out = err2.stack;
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
__name(AssertionError, "AssertionError");
inherits$1(AssertionError, Error);
function truncate(s4, n5) {
  if (typeof s4 === "string") {
    return s4.length < n5 ? s4 : s4.slice(0, n5);
  } else {
    return s4;
  }
}
__name(truncate, "truncate");
function inspect2(something) {
  if (functionsHaveNames() || !isFunction(something)) {
    return inspect$1(something);
  }
  var rawname = getName(something);
  var name = rawname ? ": " + rawname : "";
  return "[Function" + name + "]";
}
__name(inspect2, "inspect");
function getMessage(self2) {
  return truncate(inspect2(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect2(self2.expected), 128);
}
__name(getMessage, "getMessage");
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
__name(fail, "fail");
assert3.fail = fail;
function ok(value2, message) {
  if (!value2) fail(value2, true, message, "==", ok);
}
__name(ok, "ok");
assert3.ok = ok;
assert3.equal = equal;
function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, "==", equal);
}
__name(equal, "equal");
assert3.notEqual = notEqual;
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, "!=", notEqual);
  }
}
__name(notEqual, "notEqual");
assert3.deepEqual = deepEqual;
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "deepEqual", deepEqual);
  }
}
__name(deepEqual, "deepEqual");
assert3.deepStrictEqual = deepStrictEqual;
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "deepStrictEqual", deepStrictEqual);
  }
}
__name(deepStrictEqual, "deepStrictEqual");
function _deepEqual(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer$1(actual) && isBuffer$1(expected)) {
    return compare3(actual, expected) === 0;
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare3(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (isBuffer$1(actual) !== isBuffer$1(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}
__name(_deepEqual, "_deepEqual");
function isArguments(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
__name(isArguments, "isArguments");
function objEquiv(a4, b3, strict, actualVisitedObjects) {
  if (a4 === null || a4 === void 0 || b3 === null || b3 === void 0)
    return false;
  if (isPrimitive(a4) || isPrimitive(b3))
    return a4 === b3;
  if (strict && Object.getPrototypeOf(a4) !== Object.getPrototypeOf(b3))
    return false;
  var aIsArgs = isArguments(a4);
  var bIsArgs = isArguments(b3);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a4 = pSlice.call(a4);
    b3 = pSlice.call(b3);
    return _deepEqual(a4, b3, strict);
  }
  var ka = objectKeys(a4);
  var kb = objectKeys(b3);
  var key, i2;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i2 = ka.length - 1; i2 >= 0; i2--) {
    if (ka[i2] !== kb[i2])
      return false;
  }
  for (i2 = ka.length - 1; i2 >= 0; i2--) {
    key = ka[i2];
    if (!_deepEqual(a4[key], b3[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
__name(objEquiv, "objEquiv");
assert3.notDeepEqual = notDeepEqual;
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "notDeepEqual", notDeepEqual);
  }
}
__name(notDeepEqual, "notDeepEqual");
assert3.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
  }
}
__name(notDeepStrictEqual, "notDeepStrictEqual");
assert3.strictEqual = strictEqual;
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, "===", strictEqual);
  }
}
__name(strictEqual, "strictEqual");
assert3.notStrictEqual = notStrictEqual;
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, "!==", notStrictEqual);
  }
}
__name(notStrictEqual, "notStrictEqual");
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e4) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
__name(expectedException, "expectedException");
function _tryBlock(block) {
  var error3;
  try {
    block();
  } catch (e4) {
    error3 = e4;
  }
  return error3;
}
__name(_tryBlock, "_tryBlock");
function _throws(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
__name(_throws, "_throws");
assert3.throws = throws;
function throws(block, error3, message) {
  _throws(true, block, error3, message);
}
__name(throws, "throws");
assert3.doesNotThrow = doesNotThrow;
function doesNotThrow(block, error3, message) {
  _throws(false, block, error3, message);
}
__name(doesNotThrow, "doesNotThrow");
assert3.ifError = ifError;
function ifError(err2) {
  if (err2) throw err2;
}
__name(ifError, "ifError");
var _polyfillNode_assert = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AssertionError,
  assert: ok,
  deepEqual,
  deepStrictEqual,
  default: assert3,
  doesNotThrow,
  equal,
  fail,
  ifError,
  notDeepEqual,
  notDeepStrictEqual,
  notEqual,
  notStrictEqual,
  ok,
  strictEqual,
  throws
});
var require$$4 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_assert);
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
__name(ZStream, "ZStream");
var zstream = ZStream;
var deflate$1 = {};
var common = {};
(function(exports) {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  __name(_has, "_has");
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p3 in source) {
        if (_has(source, p3)) {
          obj[p3] = source[p3];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: /* @__PURE__ */ __name(function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i2 = 0; i2 < len; i2++) {
        dest[dest_offs + i2] = src[src_offs + i2];
      }
    }, "arraySet"),
    // Join array of chunks to single array.
    flattenChunks: /* @__PURE__ */ __name(function(chunks) {
      var i2, l4, len, pos, chunk, result;
      len = 0;
      for (i2 = 0, l4 = chunks.length; i2 < l4; i2++) {
        len += chunks[i2].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i2 = 0, l4 = chunks.length; i2 < l4; i2++) {
        chunk = chunks[i2];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }, "flattenChunks")
  };
  var fnUntyped = {
    arraySet: /* @__PURE__ */ __name(function(dest, src, src_offs, len, dest_offs) {
      for (var i2 = 0; i2 < len; i2++) {
        dest[dest_offs + i2] = src[src_offs + i2];
      }
    }, "arraySet"),
    // Join array of chunks to single array.
    flattenChunks: /* @__PURE__ */ __name(function(chunks) {
      return [].concat.apply([], chunks);
    }, "flattenChunks")
  };
  exports.setTyped = function(on4) {
    if (on4) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
})(common);
var trees$1 = {};
var utils$3 = common;
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
__name(zero$1, "zero$1");
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
__name(StaticTreeDesc, "StaticTreeDesc");
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
__name(TreeDesc, "TreeDesc");
function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
__name(d_code, "d_code");
function put_short(s4, w) {
  s4.pending_buf[s4.pending++] = w & 255;
  s4.pending_buf[s4.pending++] = w >>> 8 & 255;
}
__name(put_short, "put_short");
function send_bits(s4, value2, length2) {
  if (s4.bi_valid > Buf_size - length2) {
    s4.bi_buf |= value2 << s4.bi_valid & 65535;
    put_short(s4, s4.bi_buf);
    s4.bi_buf = value2 >> Buf_size - s4.bi_valid;
    s4.bi_valid += length2 - Buf_size;
  } else {
    s4.bi_buf |= value2 << s4.bi_valid & 65535;
    s4.bi_valid += length2;
  }
}
__name(send_bits, "send_bits");
function send_code(s4, c2, tree) {
  send_bits(
    s4,
    tree[c2 * 2],
    tree[c2 * 2 + 1]
    /*.Len*/
  );
}
__name(send_code, "send_code");
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}
__name(bi_reverse, "bi_reverse");
function bi_flush(s4) {
  if (s4.bi_valid === 16) {
    put_short(s4, s4.bi_buf);
    s4.bi_buf = 0;
    s4.bi_valid = 0;
  } else if (s4.bi_valid >= 8) {
    s4.pending_buf[s4.pending++] = s4.bi_buf & 255;
    s4.bi_buf >>= 8;
    s4.bi_valid -= 8;
  }
}
__name(bi_flush, "bi_flush");
function gen_bitlen(s4, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  var n5, m3;
  var bits;
  var xbits;
  var f4;
  var overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s4.bl_count[bits] = 0;
  }
  tree[s4.heap[s4.heap_max] * 2 + 1] = 0;
  for (h = s4.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n5 = s4.heap[h];
    bits = tree[tree[n5 * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n5 * 2 + 1] = bits;
    if (n5 > max_code) {
      continue;
    }
    s4.bl_count[bits]++;
    xbits = 0;
    if (n5 >= base) {
      xbits = extra[n5 - base];
    }
    f4 = tree[n5 * 2];
    s4.opt_len += f4 * (bits + xbits);
    if (has_stree) {
      s4.static_len += f4 * (stree[n5 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s4.bl_count[bits] === 0) {
      bits--;
    }
    s4.bl_count[bits]--;
    s4.bl_count[bits + 1] += 2;
    s4.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n5 = s4.bl_count[bits];
    while (n5 !== 0) {
      m3 = s4.heap[--h];
      if (m3 > max_code) {
        continue;
      }
      if (tree[m3 * 2 + 1] !== bits) {
        s4.opt_len += (bits - tree[m3 * 2 + 1]) * tree[m3 * 2];
        tree[m3 * 2 + 1] = bits;
      }
      n5--;
    }
  }
}
__name(gen_bitlen, "gen_bitlen");
function gen_codes(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS$1 + 1);
  var code = 0;
  var bits;
  var n5;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  for (n5 = 0; n5 <= max_code; n5++) {
    var len = tree[n5 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n5 * 2] = bi_reverse(next_code[len]++, len);
  }
}
__name(gen_codes, "gen_codes");
function tr_static_init() {
  var n5;
  var bits;
  var length2;
  var code;
  var dist;
  var bl_count = new Array(MAX_BITS$1 + 1);
  length2 = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length2;
    for (n5 = 0; n5 < 1 << extra_lbits[code]; n5++) {
      _length_code[length2++] = code;
    }
  }
  _length_code[length2 - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n5 = 0; n5 < 1 << extra_dbits[code]; n5++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n5 = 0; n5 < 1 << extra_dbits[code] - 7; n5++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n5 = 0;
  while (n5 <= 143) {
    static_ltree[n5 * 2 + 1] = 8;
    n5++;
    bl_count[8]++;
  }
  while (n5 <= 255) {
    static_ltree[n5 * 2 + 1] = 9;
    n5++;
    bl_count[9]++;
  }
  while (n5 <= 279) {
    static_ltree[n5 * 2 + 1] = 7;
    n5++;
    bl_count[7]++;
  }
  while (n5 <= 287) {
    static_ltree[n5 * 2 + 1] = 8;
    n5++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n5 = 0; n5 < D_CODES$1; n5++) {
    static_dtree[n5 * 2 + 1] = 5;
    static_dtree[n5 * 2] = bi_reverse(n5, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
}
__name(tr_static_init, "tr_static_init");
function init_block(s4) {
  var n5;
  for (n5 = 0; n5 < L_CODES$1; n5++) {
    s4.dyn_ltree[n5 * 2] = 0;
  }
  for (n5 = 0; n5 < D_CODES$1; n5++) {
    s4.dyn_dtree[n5 * 2] = 0;
  }
  for (n5 = 0; n5 < BL_CODES$1; n5++) {
    s4.bl_tree[n5 * 2] = 0;
  }
  s4.dyn_ltree[END_BLOCK * 2] = 1;
  s4.opt_len = s4.static_len = 0;
  s4.last_lit = s4.matches = 0;
}
__name(init_block, "init_block");
function bi_windup(s4) {
  if (s4.bi_valid > 8) {
    put_short(s4, s4.bi_buf);
  } else if (s4.bi_valid > 0) {
    s4.pending_buf[s4.pending++] = s4.bi_buf;
  }
  s4.bi_buf = 0;
  s4.bi_valid = 0;
}
__name(bi_windup, "bi_windup");
function copy_block(s4, buf, len, header) {
  bi_windup(s4);
  if (header) {
    put_short(s4, len);
    put_short(s4, ~len);
  }
  utils$3.arraySet(s4.pending_buf, s4.window, buf, len, s4.pending);
  s4.pending += len;
}
__name(copy_block, "copy_block");
function smaller(tree, n5, m3, depth) {
  var _n2 = n5 * 2;
  var _m2 = m3 * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n5] <= depth[m3];
}
__name(smaller, "smaller");
function pqdownheap(s4, tree, k3) {
  var v3 = s4.heap[k3];
  var j = k3 << 1;
  while (j <= s4.heap_len) {
    if (j < s4.heap_len && smaller(tree, s4.heap[j + 1], s4.heap[j], s4.depth)) {
      j++;
    }
    if (smaller(tree, v3, s4.heap[j], s4.depth)) {
      break;
    }
    s4.heap[k3] = s4.heap[j];
    k3 = j;
    j <<= 1;
  }
  s4.heap[k3] = v3;
}
__name(pqdownheap, "pqdownheap");
function compress_block(s4, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code;
  var extra;
  if (s4.last_lit !== 0) {
    do {
      dist = s4.pending_buf[s4.d_buf + lx * 2] << 8 | s4.pending_buf[s4.d_buf + lx * 2 + 1];
      lc = s4.pending_buf[s4.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s4, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s4, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s4, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s4, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s4, dist, extra);
        }
      }
    } while (lx < s4.last_lit);
  }
  send_code(s4, END_BLOCK, ltree);
}
__name(compress_block, "compress_block");
function build_tree(s4, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n5, m3;
  var max_code = -1;
  var node;
  s4.heap_len = 0;
  s4.heap_max = HEAP_SIZE$1;
  for (n5 = 0; n5 < elems; n5++) {
    if (tree[n5 * 2] !== 0) {
      s4.heap[++s4.heap_len] = max_code = n5;
      s4.depth[n5] = 0;
    } else {
      tree[n5 * 2 + 1] = 0;
    }
  }
  while (s4.heap_len < 2) {
    node = s4.heap[++s4.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s4.depth[node] = 0;
    s4.opt_len--;
    if (has_stree) {
      s4.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n5 = s4.heap_len >> 1; n5 >= 1; n5--) {
    pqdownheap(s4, tree, n5);
  }
  node = elems;
  do {
    n5 = s4.heap[
      1
      /*SMALLEST*/
    ];
    s4.heap[
      1
      /*SMALLEST*/
    ] = s4.heap[s4.heap_len--];
    pqdownheap(
      s4,
      tree,
      1
      /*SMALLEST*/
    );
    m3 = s4.heap[
      1
      /*SMALLEST*/
    ];
    s4.heap[--s4.heap_max] = n5;
    s4.heap[--s4.heap_max] = m3;
    tree[node * 2] = tree[n5 * 2] + tree[m3 * 2];
    s4.depth[node] = (s4.depth[n5] >= s4.depth[m3] ? s4.depth[n5] : s4.depth[m3]) + 1;
    tree[n5 * 2 + 1] = tree[m3 * 2 + 1] = node;
    s4.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s4,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s4.heap_len >= 2);
  s4.heap[--s4.heap_max] = s4.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s4, desc);
  gen_codes(tree, max_code, s4.bl_count);
}
__name(build_tree, "build_tree");
function scan_tree(s4, tree, max_code) {
  var n5;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count3 = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n5 = 0; n5 <= max_code; n5++) {
    curlen = nextlen;
    nextlen = tree[(n5 + 1) * 2 + 1];
    if (++count3 < max_count && curlen === nextlen) {
      continue;
    } else if (count3 < min_count) {
      s4.bl_tree[curlen * 2] += count3;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s4.bl_tree[curlen * 2]++;
      }
      s4.bl_tree[REP_3_6 * 2]++;
    } else if (count3 <= 10) {
      s4.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s4.bl_tree[REPZ_11_138 * 2]++;
    }
    count3 = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
__name(scan_tree, "scan_tree");
function send_tree(s4, tree, max_code) {
  var n5;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count3 = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n5 = 0; n5 <= max_code; n5++) {
    curlen = nextlen;
    nextlen = tree[(n5 + 1) * 2 + 1];
    if (++count3 < max_count && curlen === nextlen) {
      continue;
    } else if (count3 < min_count) {
      do {
        send_code(s4, curlen, s4.bl_tree);
      } while (--count3 !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s4, curlen, s4.bl_tree);
        count3--;
      }
      send_code(s4, REP_3_6, s4.bl_tree);
      send_bits(s4, count3 - 3, 2);
    } else if (count3 <= 10) {
      send_code(s4, REPZ_3_10, s4.bl_tree);
      send_bits(s4, count3 - 3, 3);
    } else {
      send_code(s4, REPZ_11_138, s4.bl_tree);
      send_bits(s4, count3 - 11, 7);
    }
    count3 = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
__name(send_tree, "send_tree");
function build_bl_tree(s4) {
  var max_blindex;
  scan_tree(s4, s4.dyn_ltree, s4.l_desc.max_code);
  scan_tree(s4, s4.dyn_dtree, s4.d_desc.max_code);
  build_tree(s4, s4.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s4.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s4.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
__name(build_bl_tree, "build_bl_tree");
function send_all_trees(s4, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits(s4, lcodes - 257, 5);
  send_bits(s4, dcodes - 1, 5);
  send_bits(s4, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s4, s4.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s4, s4.dyn_ltree, lcodes - 1);
  send_tree(s4, s4.dyn_dtree, dcodes - 1);
}
__name(send_all_trees, "send_all_trees");
function detect_data_type(s4) {
  var black_mask = 4093624447;
  var n5;
  for (n5 = 0; n5 <= 31; n5++, black_mask >>>= 1) {
    if (black_mask & 1 && s4.dyn_ltree[n5 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s4.dyn_ltree[9 * 2] !== 0 || s4.dyn_ltree[10 * 2] !== 0 || s4.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n5 = 32; n5 < LITERALS$1; n5++) {
    if (s4.dyn_ltree[n5 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
}
__name(detect_data_type, "detect_data_type");
var static_init_done = false;
function _tr_init(s4) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s4.l_desc = new TreeDesc(s4.dyn_ltree, static_l_desc);
  s4.d_desc = new TreeDesc(s4.dyn_dtree, static_d_desc);
  s4.bl_desc = new TreeDesc(s4.bl_tree, static_bl_desc);
  s4.bi_buf = 0;
  s4.bi_valid = 0;
  init_block(s4);
}
__name(_tr_init, "_tr_init");
function _tr_stored_block(s4, buf, stored_len, last2) {
  send_bits(s4, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
  copy_block(s4, buf, stored_len, true);
}
__name(_tr_stored_block, "_tr_stored_block");
function _tr_align(s4) {
  send_bits(s4, STATIC_TREES << 1, 3);
  send_code(s4, END_BLOCK, static_ltree);
  bi_flush(s4);
}
__name(_tr_align, "_tr_align");
function _tr_flush_block(s4, buf, stored_len, last2) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s4.level > 0) {
    if (s4.strm.data_type === Z_UNKNOWN$1) {
      s4.strm.data_type = detect_data_type(s4);
    }
    build_tree(s4, s4.l_desc);
    build_tree(s4, s4.d_desc);
    max_blindex = build_bl_tree(s4);
    opt_lenb = s4.opt_len + 3 + 7 >>> 3;
    static_lenb = s4.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s4, buf, stored_len, last2);
  } else if (s4.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s4, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
    compress_block(s4, static_ltree, static_dtree);
  } else {
    send_bits(s4, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
    send_all_trees(s4, s4.l_desc.max_code + 1, s4.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s4, s4.dyn_ltree, s4.dyn_dtree);
  }
  init_block(s4);
  if (last2) {
    bi_windup(s4);
  }
}
__name(_tr_flush_block, "_tr_flush_block");
function _tr_tally(s4, dist, lc) {
  s4.pending_buf[s4.d_buf + s4.last_lit * 2] = dist >>> 8 & 255;
  s4.pending_buf[s4.d_buf + s4.last_lit * 2 + 1] = dist & 255;
  s4.pending_buf[s4.l_buf + s4.last_lit] = lc & 255;
  s4.last_lit++;
  if (dist === 0) {
    s4.dyn_ltree[lc * 2]++;
  } else {
    s4.matches++;
    dist--;
    s4.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s4.dyn_dtree[d_code(dist) * 2]++;
  }
  return s4.last_lit === s4.lit_bufsize - 1;
}
__name(_tr_tally, "_tr_tally");
trees$1._tr_init = _tr_init;
trees$1._tr_stored_block = _tr_stored_block;
trees$1._tr_flush_block = _tr_flush_block;
trees$1._tr_tally = _tr_tally;
trees$1._tr_align = _tr_align;
function adler32$2(adler, buf, len, pos) {
  var s1 = adler & 65535 | 0, s22 = adler >>> 16 & 65535 | 0, n5 = 0;
  while (len !== 0) {
    n5 = len > 2e3 ? 2e3 : len;
    len -= n5;
    do {
      s1 = s1 + buf[pos++] | 0;
      s22 = s22 + s1 | 0;
    } while (--n5);
    s1 %= 65521;
    s22 %= 65521;
  }
  return s1 | s22 << 16 | 0;
}
__name(adler32$2, "adler32$2");
var adler32_1 = adler32$2;
function makeTable() {
  var c2, table3 = [];
  for (var n5 = 0; n5 < 256; n5++) {
    c2 = n5;
    for (var k3 = 0; k3 < 8; k3++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table3[n5] = c2;
  }
  return table3;
}
__name(makeTable, "makeTable");
var crcTable = makeTable();
function crc32$2(crc, buf, len, pos) {
  var t4 = crcTable, end2 = pos + len;
  crc ^= -1;
  for (var i2 = pos; i2 < end2; i2++) {
    crc = crc >>> 8 ^ t4[(crc ^ buf[i2]) & 255];
  }
  return crc ^ -1;
}
__name(crc32$2, "crc32$2");
var crc32_1 = crc32$2;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var utils$2 = common;
var trees = trees$1;
var adler32$1 = adler32_1;
var crc32$1 = crc32_1;
var msg = messages;
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
var Z_FULL_FLUSH = 3;
var Z_FINISH$1 = 4;
var Z_BLOCK$1 = 5;
var Z_OK$1 = 0;
var Z_STREAM_END$1 = 1;
var Z_STREAM_ERROR$1 = -2;
var Z_DATA_ERROR$1 = -3;
var Z_BUF_ERROR$1 = -5;
var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
var Z_UNKNOWN = 2;
var Z_DEFLATED$1 = 8;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}
__name(err, "err");
function rank(f4) {
  return (f4 << 1) - (f4 > 4 ? 9 : 0);
}
__name(rank, "rank");
function zero(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
__name(zero, "zero");
function flush_pending(strm) {
  var s4 = strm.state;
  var len = s4.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  utils$2.arraySet(strm.output, s4.pending_buf, s4.pending_out, len, strm.next_out);
  strm.next_out += len;
  s4.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s4.pending -= len;
  if (s4.pending === 0) {
    s4.pending_out = 0;
  }
}
__name(flush_pending, "flush_pending");
function flush_block_only(s4, last2) {
  trees._tr_flush_block(s4, s4.block_start >= 0 ? s4.block_start : -1, s4.strstart - s4.block_start, last2);
  s4.block_start = s4.strstart;
  flush_pending(s4.strm);
}
__name(flush_block_only, "flush_block_only");
function put_byte(s4, b3) {
  s4.pending_buf[s4.pending++] = b3;
}
__name(put_byte, "put_byte");
function putShortMSB(s4, b3) {
  s4.pending_buf[s4.pending++] = b3 >>> 8 & 255;
  s4.pending_buf[s4.pending++] = b3 & 255;
}
__name(putShortMSB, "putShortMSB");
function read_buf(strm, buf, start2, size) {
  var len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  utils$2.arraySet(buf, strm.input, strm.next_in, len, start2);
  if (strm.state.wrap === 1) {
    strm.adler = adler32$1(strm.adler, buf, len, start2);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32$1(strm.adler, buf, len, start2);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
}
__name(read_buf, "read_buf");
function longest_match(s4, cur_match) {
  var chain_length = s4.max_chain_length;
  var scan = s4.strstart;
  var match2;
  var len;
  var best_len = s4.prev_length;
  var nice_match = s4.nice_match;
  var limit = s4.strstart > s4.w_size - MIN_LOOKAHEAD ? s4.strstart - (s4.w_size - MIN_LOOKAHEAD) : 0;
  var _win = s4.window;
  var wmask = s4.w_mask;
  var prev = s4.prev;
  var strend = s4.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s4.prev_length >= s4.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s4.lookahead) {
    nice_match = s4.lookahead;
  }
  do {
    match2 = cur_match;
    if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match2++;
    do {
    } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s4.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s4.lookahead) {
    return best_len;
  }
  return s4.lookahead;
}
__name(longest_match, "longest_match");
function fill_window(s4) {
  var _w_size = s4.w_size;
  var p3, n5, m3, more, str;
  do {
    more = s4.window_size - s4.lookahead - s4.strstart;
    if (s4.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      utils$2.arraySet(s4.window, s4.window, _w_size, _w_size, 0);
      s4.match_start -= _w_size;
      s4.strstart -= _w_size;
      s4.block_start -= _w_size;
      n5 = s4.hash_size;
      p3 = n5;
      do {
        m3 = s4.head[--p3];
        s4.head[p3] = m3 >= _w_size ? m3 - _w_size : 0;
      } while (--n5);
      n5 = _w_size;
      p3 = n5;
      do {
        m3 = s4.prev[--p3];
        s4.prev[p3] = m3 >= _w_size ? m3 - _w_size : 0;
      } while (--n5);
      more += _w_size;
    }
    if (s4.strm.avail_in === 0) {
      break;
    }
    n5 = read_buf(s4.strm, s4.window, s4.strstart + s4.lookahead, more);
    s4.lookahead += n5;
    if (s4.lookahead + s4.insert >= MIN_MATCH) {
      str = s4.strstart - s4.insert;
      s4.ins_h = s4.window[str];
      s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[str + 1]) & s4.hash_mask;
      while (s4.insert) {
        s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[str + MIN_MATCH - 1]) & s4.hash_mask;
        s4.prev[str & s4.w_mask] = s4.head[s4.ins_h];
        s4.head[s4.ins_h] = str;
        str++;
        s4.insert--;
        if (s4.lookahead + s4.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s4.lookahead < MIN_LOOKAHEAD && s4.strm.avail_in !== 0);
}
__name(fill_window, "fill_window");
function deflate_stored(s4, flush) {
  var max_block_size = 65535;
  if (max_block_size > s4.pending_buf_size - 5) {
    max_block_size = s4.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s4.lookahead <= 1) {
      fill_window(s4);
      if (s4.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s4.lookahead === 0) {
        break;
      }
    }
    s4.strstart += s4.lookahead;
    s4.lookahead = 0;
    var max_start = s4.block_start + max_block_size;
    if (s4.strstart === 0 || s4.strstart >= max_start) {
      s4.lookahead = s4.strstart - max_start;
      s4.strstart = max_start;
      flush_block_only(s4, false);
      if (s4.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s4.strstart - s4.block_start >= s4.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s4, false);
      if (s4.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s4.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s4, true);
    if (s4.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s4.strstart > s4.block_start) {
    flush_block_only(s4, false);
    if (s4.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
}
__name(deflate_stored, "deflate_stored");
function deflate_fast(s4, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s4.lookahead < MIN_LOOKAHEAD) {
      fill_window(s4);
      if (s4.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s4.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s4.lookahead >= MIN_MATCH) {
      s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + MIN_MATCH - 1]) & s4.hash_mask;
      hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
      s4.head[s4.ins_h] = s4.strstart;
    }
    if (hash_head !== 0 && s4.strstart - hash_head <= s4.w_size - MIN_LOOKAHEAD) {
      s4.match_length = longest_match(s4, hash_head);
    }
    if (s4.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s4, s4.strstart - s4.match_start, s4.match_length - MIN_MATCH);
      s4.lookahead -= s4.match_length;
      if (s4.match_length <= s4.max_lazy_match && s4.lookahead >= MIN_MATCH) {
        s4.match_length--;
        do {
          s4.strstart++;
          s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + MIN_MATCH - 1]) & s4.hash_mask;
          hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
          s4.head[s4.ins_h] = s4.strstart;
        } while (--s4.match_length !== 0);
        s4.strstart++;
      } else {
        s4.strstart += s4.match_length;
        s4.match_length = 0;
        s4.ins_h = s4.window[s4.strstart];
        s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + 1]) & s4.hash_mask;
      }
    } else {
      bflush = trees._tr_tally(s4, 0, s4.window[s4.strstart]);
      s4.lookahead--;
      s4.strstart++;
    }
    if (bflush) {
      flush_block_only(s4, false);
      if (s4.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s4.insert = s4.strstart < MIN_MATCH - 1 ? s4.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$1) {
    flush_block_only(s4, true);
    if (s4.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s4.last_lit) {
    flush_block_only(s4, false);
    if (s4.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
__name(deflate_fast, "deflate_fast");
function deflate_slow(s4, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s4.lookahead < MIN_LOOKAHEAD) {
      fill_window(s4);
      if (s4.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s4.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s4.lookahead >= MIN_MATCH) {
      s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + MIN_MATCH - 1]) & s4.hash_mask;
      hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
      s4.head[s4.ins_h] = s4.strstart;
    }
    s4.prev_length = s4.match_length;
    s4.prev_match = s4.match_start;
    s4.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s4.prev_length < s4.max_lazy_match && s4.strstart - hash_head <= s4.w_size - MIN_LOOKAHEAD) {
      s4.match_length = longest_match(s4, hash_head);
      if (s4.match_length <= 5 && (s4.strategy === Z_FILTERED || s4.match_length === MIN_MATCH && s4.strstart - s4.match_start > 4096)) {
        s4.match_length = MIN_MATCH - 1;
      }
    }
    if (s4.prev_length >= MIN_MATCH && s4.match_length <= s4.prev_length) {
      max_insert = s4.strstart + s4.lookahead - MIN_MATCH;
      bflush = trees._tr_tally(s4, s4.strstart - 1 - s4.prev_match, s4.prev_length - MIN_MATCH);
      s4.lookahead -= s4.prev_length - 1;
      s4.prev_length -= 2;
      do {
        if (++s4.strstart <= max_insert) {
          s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + MIN_MATCH - 1]) & s4.hash_mask;
          hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
          s4.head[s4.ins_h] = s4.strstart;
        }
      } while (--s4.prev_length !== 0);
      s4.match_available = 0;
      s4.match_length = MIN_MATCH - 1;
      s4.strstart++;
      if (bflush) {
        flush_block_only(s4, false);
        if (s4.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s4.match_available) {
      bflush = trees._tr_tally(s4, 0, s4.window[s4.strstart - 1]);
      if (bflush) {
        flush_block_only(s4, false);
      }
      s4.strstart++;
      s4.lookahead--;
      if (s4.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s4.match_available = 1;
      s4.strstart++;
      s4.lookahead--;
    }
  }
  if (s4.match_available) {
    bflush = trees._tr_tally(s4, 0, s4.window[s4.strstart - 1]);
    s4.match_available = 0;
  }
  s4.insert = s4.strstart < MIN_MATCH - 1 ? s4.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$1) {
    flush_block_only(s4, true);
    if (s4.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s4.last_lit) {
    flush_block_only(s4, false);
    if (s4.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
__name(deflate_slow, "deflate_slow");
function deflate_rle(s4, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s4.window;
  for (; ; ) {
    if (s4.lookahead <= MAX_MATCH) {
      fill_window(s4);
      if (s4.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s4.lookahead === 0) {
        break;
      }
    }
    s4.match_length = 0;
    if (s4.lookahead >= MIN_MATCH && s4.strstart > 0) {
      scan = s4.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s4.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s4.match_length = MAX_MATCH - (strend - scan);
        if (s4.match_length > s4.lookahead) {
          s4.match_length = s4.lookahead;
        }
      }
    }
    if (s4.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s4, 1, s4.match_length - MIN_MATCH);
      s4.lookahead -= s4.match_length;
      s4.strstart += s4.match_length;
      s4.match_length = 0;
    } else {
      bflush = trees._tr_tally(s4, 0, s4.window[s4.strstart]);
      s4.lookahead--;
      s4.strstart++;
    }
    if (bflush) {
      flush_block_only(s4, false);
      if (s4.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s4.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s4, true);
    if (s4.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s4.last_lit) {
    flush_block_only(s4, false);
    if (s4.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
__name(deflate_rle, "deflate_rle");
function deflate_huff(s4, flush) {
  var bflush;
  for (; ; ) {
    if (s4.lookahead === 0) {
      fill_window(s4);
      if (s4.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s4.match_length = 0;
    bflush = trees._tr_tally(s4, 0, s4.window[s4.strstart]);
    s4.lookahead--;
    s4.strstart++;
    if (bflush) {
      flush_block_only(s4, false);
      if (s4.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s4.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s4, true);
    if (s4.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s4.last_lit) {
    flush_block_only(s4, false);
    if (s4.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
__name(deflate_huff, "deflate_huff");
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
__name(Config, "Config");
var configuration_table;
configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
function lm_init(s4) {
  s4.window_size = 2 * s4.w_size;
  zero(s4.head);
  s4.max_lazy_match = configuration_table[s4.level].max_lazy;
  s4.good_match = configuration_table[s4.level].good_length;
  s4.nice_match = configuration_table[s4.level].nice_length;
  s4.max_chain_length = configuration_table[s4.level].max_chain;
  s4.strstart = 0;
  s4.block_start = 0;
  s4.lookahead = 0;
  s4.insert = 0;
  s4.match_length = s4.prev_length = MIN_MATCH - 1;
  s4.match_available = 0;
  s4.ins_h = 0;
}
__name(lm_init, "lm_init");
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$1;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new utils$2.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils$2.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils$2.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new utils$2.Buf16(MAX_BITS + 1);
  this.heap = new utils$2.Buf16(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new utils$2.Buf16(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
__name(DeflateState, "DeflateState");
function deflateResetKeep(strm) {
  var s4;
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s4 = strm.state;
  s4.pending = 0;
  s4.pending_out = 0;
  if (s4.wrap < 0) {
    s4.wrap = -s4.wrap;
  }
  s4.status = s4.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s4.wrap === 2 ? 0 : 1;
  s4.last_flush = Z_NO_FLUSH;
  trees._tr_init(s4);
  return Z_OK$1;
}
__name(deflateResetKeep, "deflateResetKeep");
function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK$1) {
    lm_init(strm.state);
  }
  return ret;
}
__name(deflateReset, "deflateReset");
function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$1;
  }
  strm.state.gzhead = head;
  return Z_OK$1;
}
__name(deflateSetHeader, "deflateSetHeader");
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  var wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$1 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s4 = new DeflateState();
  strm.state = s4;
  s4.strm = strm;
  s4.wrap = wrap;
  s4.gzhead = null;
  s4.w_bits = windowBits;
  s4.w_size = 1 << s4.w_bits;
  s4.w_mask = s4.w_size - 1;
  s4.hash_bits = memLevel + 7;
  s4.hash_size = 1 << s4.hash_bits;
  s4.hash_mask = s4.hash_size - 1;
  s4.hash_shift = ~~((s4.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s4.window = new utils$2.Buf8(s4.w_size * 2);
  s4.head = new utils$2.Buf16(s4.hash_size);
  s4.prev = new utils$2.Buf16(s4.w_size);
  s4.lit_bufsize = 1 << memLevel + 6;
  s4.pending_buf_size = s4.lit_bufsize * 4;
  s4.pending_buf = new utils$2.Buf8(s4.pending_buf_size);
  s4.d_buf = 1 * s4.lit_bufsize;
  s4.l_buf = (1 + 2) * s4.lit_bufsize;
  s4.level = level;
  s4.strategy = strategy;
  s4.method = method;
  return deflateReset(strm);
}
__name(deflateInit2, "deflateInit2");
function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED$1, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}
__name(deflateInit, "deflateInit");
function deflate(strm, flush) {
  var old_flush, s4;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$1) : Z_STREAM_ERROR$1;
  }
  s4 = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s4.status === FINISH_STATE && flush !== Z_FINISH$1) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$1);
  }
  s4.strm = strm;
  old_flush = s4.last_flush;
  s4.last_flush = flush;
  if (s4.status === INIT_STATE) {
    if (s4.wrap === 2) {
      strm.adler = 0;
      put_byte(s4, 31);
      put_byte(s4, 139);
      put_byte(s4, 8);
      if (!s4.gzhead) {
        put_byte(s4, 0);
        put_byte(s4, 0);
        put_byte(s4, 0);
        put_byte(s4, 0);
        put_byte(s4, 0);
        put_byte(s4, s4.level === 9 ? 2 : s4.strategy >= Z_HUFFMAN_ONLY || s4.level < 2 ? 4 : 0);
        put_byte(s4, OS_CODE);
        s4.status = BUSY_STATE;
      } else {
        put_byte(s4, (s4.gzhead.text ? 1 : 0) + (s4.gzhead.hcrc ? 2 : 0) + (!s4.gzhead.extra ? 0 : 4) + (!s4.gzhead.name ? 0 : 8) + (!s4.gzhead.comment ? 0 : 16));
        put_byte(s4, s4.gzhead.time & 255);
        put_byte(s4, s4.gzhead.time >> 8 & 255);
        put_byte(s4, s4.gzhead.time >> 16 & 255);
        put_byte(s4, s4.gzhead.time >> 24 & 255);
        put_byte(s4, s4.level === 9 ? 2 : s4.strategy >= Z_HUFFMAN_ONLY || s4.level < 2 ? 4 : 0);
        put_byte(s4, s4.gzhead.os & 255);
        if (s4.gzhead.extra && s4.gzhead.extra.length) {
          put_byte(s4, s4.gzhead.extra.length & 255);
          put_byte(s4, s4.gzhead.extra.length >> 8 & 255);
        }
        if (s4.gzhead.hcrc) {
          strm.adler = crc32$1(strm.adler, s4.pending_buf, s4.pending, 0);
        }
        s4.gzindex = 0;
        s4.status = EXTRA_STATE;
      }
    } else {
      var header = Z_DEFLATED$1 + (s4.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s4.strategy >= Z_HUFFMAN_ONLY || s4.level < 2) {
        level_flags = 0;
      } else if (s4.level < 6) {
        level_flags = 1;
      } else if (s4.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s4.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s4.status = BUSY_STATE;
      putShortMSB(s4, header);
      if (s4.strstart !== 0) {
        putShortMSB(s4, strm.adler >>> 16);
        putShortMSB(s4, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s4.status === EXTRA_STATE) {
    if (s4.gzhead.extra) {
      beg = s4.pending;
      while (s4.gzindex < (s4.gzhead.extra.length & 65535)) {
        if (s4.pending === s4.pending_buf_size) {
          if (s4.gzhead.hcrc && s4.pending > beg) {
            strm.adler = crc32$1(strm.adler, s4.pending_buf, s4.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s4.pending;
          if (s4.pending === s4.pending_buf_size) {
            break;
          }
        }
        put_byte(s4, s4.gzhead.extra[s4.gzindex] & 255);
        s4.gzindex++;
      }
      if (s4.gzhead.hcrc && s4.pending > beg) {
        strm.adler = crc32$1(strm.adler, s4.pending_buf, s4.pending - beg, beg);
      }
      if (s4.gzindex === s4.gzhead.extra.length) {
        s4.gzindex = 0;
        s4.status = NAME_STATE;
      }
    } else {
      s4.status = NAME_STATE;
    }
  }
  if (s4.status === NAME_STATE) {
    if (s4.gzhead.name) {
      beg = s4.pending;
      do {
        if (s4.pending === s4.pending_buf_size) {
          if (s4.gzhead.hcrc && s4.pending > beg) {
            strm.adler = crc32$1(strm.adler, s4.pending_buf, s4.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s4.pending;
          if (s4.pending === s4.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s4.gzindex < s4.gzhead.name.length) {
          val = s4.gzhead.name.charCodeAt(s4.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s4, val);
      } while (val !== 0);
      if (s4.gzhead.hcrc && s4.pending > beg) {
        strm.adler = crc32$1(strm.adler, s4.pending_buf, s4.pending - beg, beg);
      }
      if (val === 0) {
        s4.gzindex = 0;
        s4.status = COMMENT_STATE;
      }
    } else {
      s4.status = COMMENT_STATE;
    }
  }
  if (s4.status === COMMENT_STATE) {
    if (s4.gzhead.comment) {
      beg = s4.pending;
      do {
        if (s4.pending === s4.pending_buf_size) {
          if (s4.gzhead.hcrc && s4.pending > beg) {
            strm.adler = crc32$1(strm.adler, s4.pending_buf, s4.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s4.pending;
          if (s4.pending === s4.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s4.gzindex < s4.gzhead.comment.length) {
          val = s4.gzhead.comment.charCodeAt(s4.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s4, val);
      } while (val !== 0);
      if (s4.gzhead.hcrc && s4.pending > beg) {
        strm.adler = crc32$1(strm.adler, s4.pending_buf, s4.pending - beg, beg);
      }
      if (val === 0) {
        s4.status = HCRC_STATE;
      }
    } else {
      s4.status = HCRC_STATE;
    }
  }
  if (s4.status === HCRC_STATE) {
    if (s4.gzhead.hcrc) {
      if (s4.pending + 2 > s4.pending_buf_size) {
        flush_pending(strm);
      }
      if (s4.pending + 2 <= s4.pending_buf_size) {
        put_byte(s4, strm.adler & 255);
        put_byte(s4, strm.adler >> 8 & 255);
        strm.adler = 0;
        s4.status = BUSY_STATE;
      }
    } else {
      s4.status = BUSY_STATE;
    }
  }
  if (s4.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s4.last_flush = -1;
      return Z_OK$1;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$1) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s4.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (strm.avail_in !== 0 || s4.lookahead !== 0 || flush !== Z_NO_FLUSH && s4.status !== FINISH_STATE) {
    var bstate = s4.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s4, flush) : s4.strategy === Z_RLE ? deflate_rle(s4, flush) : configuration_table[s4.level].func(s4, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s4.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s4.last_flush = -1;
      }
      return Z_OK$1;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s4);
      } else if (flush !== Z_BLOCK$1) {
        trees._tr_stored_block(s4, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero(s4.head);
          if (s4.lookahead === 0) {
            s4.strstart = 0;
            s4.block_start = 0;
            s4.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s4.last_flush = -1;
        return Z_OK$1;
      }
    }
  }
  if (flush !== Z_FINISH$1) {
    return Z_OK$1;
  }
  if (s4.wrap <= 0) {
    return Z_STREAM_END$1;
  }
  if (s4.wrap === 2) {
    put_byte(s4, strm.adler & 255);
    put_byte(s4, strm.adler >> 8 & 255);
    put_byte(s4, strm.adler >> 16 & 255);
    put_byte(s4, strm.adler >> 24 & 255);
    put_byte(s4, strm.total_in & 255);
    put_byte(s4, strm.total_in >> 8 & 255);
    put_byte(s4, strm.total_in >> 16 & 255);
    put_byte(s4, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s4, strm.adler >>> 16);
    putShortMSB(s4, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s4.wrap > 0) {
    s4.wrap = -s4.wrap;
  }
  return s4.pending !== 0 ? Z_OK$1 : Z_STREAM_END$1;
}
__name(deflate, "deflate");
function deflateEnd(strm) {
  var status;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$1) : Z_OK$1;
}
__name(deflateEnd, "deflateEnd");
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s4;
  var str, n5;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  s4 = strm.state;
  wrap = s4.wrap;
  if (wrap === 2 || wrap === 1 && s4.status !== INIT_STATE || s4.lookahead) {
    return Z_STREAM_ERROR$1;
  }
  if (wrap === 1) {
    strm.adler = adler32$1(strm.adler, dictionary, dictLength, 0);
  }
  s4.wrap = 0;
  if (dictLength >= s4.w_size) {
    if (wrap === 0) {
      zero(s4.head);
      s4.strstart = 0;
      s4.block_start = 0;
      s4.insert = 0;
    }
    tmpDict = new utils$2.Buf8(s4.w_size);
    utils$2.arraySet(tmpDict, dictionary, dictLength - s4.w_size, s4.w_size, 0);
    dictionary = tmpDict;
    dictLength = s4.w_size;
  }
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s4);
  while (s4.lookahead >= MIN_MATCH) {
    str = s4.strstart;
    n5 = s4.lookahead - (MIN_MATCH - 1);
    do {
      s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[str + MIN_MATCH - 1]) & s4.hash_mask;
      s4.prev[str & s4.w_mask] = s4.head[s4.ins_h];
      s4.head[s4.ins_h] = str;
      str++;
    } while (--n5);
    s4.strstart = str;
    s4.lookahead = MIN_MATCH - 1;
    fill_window(s4);
  }
  s4.strstart += s4.lookahead;
  s4.block_start = s4.strstart;
  s4.insert = s4.lookahead;
  s4.lookahead = 0;
  s4.match_length = s4.prev_length = MIN_MATCH - 1;
  s4.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s4.wrap = wrap;
  return Z_OK$1;
}
__name(deflateSetDictionary, "deflateSetDictionary");
deflate$1.deflateInit = deflateInit;
deflate$1.deflateInit2 = deflateInit2;
deflate$1.deflateReset = deflateReset;
deflate$1.deflateResetKeep = deflateResetKeep;
deflate$1.deflateSetHeader = deflateSetHeader;
deflate$1.deflate = deflate;
deflate$1.deflateEnd = deflateEnd;
deflate$1.deflateSetDictionary = deflateSetDictionary;
deflate$1.deflateInfo = "pako deflate (from Nodeca project)";
var inflate$1 = {};
var BAD$1 = 30;
var TYPE$1 = 12;
var inffast = /* @__PURE__ */ __name(function inflate_fast(strm, start2) {
  var state2;
  var _in;
  var last2;
  var _out;
  var beg;
  var end2;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len;
  var dist;
  var from4;
  var from_source;
  var input, output;
  state2 = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start2 - strm.avail_out);
  end2 = _out + (strm.avail_out - 257);
  dmax = state2.dmax;
  wsize = state2.wsize;
  whave = state2.whave;
  wnext = state2.wnext;
  s_window = state2.window;
  hold = state2.hold;
  bits = state2.bits;
  lcode = state2.lencode;
  dcode = state2.distcode;
  lmask = (1 << state2.lenbits) - 1;
  dmask = (1 << state2.distbits) - 1;
  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }
    here = lcode[hold & lmask];
    dolen: for (; ; ) {
      op = here >>> 24;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 255;
      if (op === 0) {
        output[_out++] = here & 65535;
      } else if (op & 16) {
        len = here & 65535;
        op &= 15;
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        }
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];
        dodist: for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op & 16) {
            dist = here & 65535;
            op &= 15;
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & (1 << op) - 1;
            if (dist > dmax) {
              strm.msg = "invalid distance too far back";
              state2.mode = BAD$1;
              break top;
            }
            hold >>>= op;
            bits -= op;
            op = _out - beg;
            if (dist > op) {
              op = dist - op;
              if (op > whave) {
                if (state2.sane) {
                  strm.msg = "invalid distance too far back";
                  state2.mode = BAD$1;
                  break top;
                }
              }
              from4 = 0;
              from_source = s_window;
              if (wnext === 0) {
                from4 += wsize - op;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from4++];
                  } while (--op);
                  from4 = _out - dist;
                  from_source = output;
                }
              } else if (wnext < op) {
                from4 += wsize + wnext - op;
                op -= wnext;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from4++];
                  } while (--op);
                  from4 = 0;
                  if (wnext < len) {
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from4++];
                    } while (--op);
                    from4 = _out - dist;
                    from_source = output;
                  }
                }
              } else {
                from4 += wnext - op;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from4++];
                  } while (--op);
                  from4 = _out - dist;
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from4++];
                output[_out++] = from_source[from4++];
                output[_out++] = from_source[from4++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from4++];
                if (len > 1) {
                  output[_out++] = from_source[from4++];
                }
              }
            } else {
              from4 = _out - dist;
              do {
                output[_out++] = output[from4++];
                output[_out++] = output[from4++];
                output[_out++] = output[from4++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from4++];
                if (len > 1) {
                  output[_out++] = output[from4++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = "invalid distance code";
            state2.mode = BAD$1;
            break top;
          }
          break;
        }
      } else if ((op & 64) === 0) {
        here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        state2.mode = TYPE$1;
        break top;
      } else {
        strm.msg = "invalid literal/length code";
        state2.mode = BAD$1;
        break top;
      }
      break;
    }
  } while (_in < last2 && _out < end2);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end2 ? 257 + (end2 - _out) : 257 - (_out - end2);
  state2.hold = hold;
  state2.bits = bits;
  return;
}, "inflate_fast");
var utils$1 = common;
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
var inftrees = /* @__PURE__ */ __name(function inflate_table(type2, lens, lens_index, codes2, table3, table_index, work, opts2) {
  var bits = opts2.bits;
  var len = 0;
  var sym = 0;
  var min2 = 0, max2 = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill4;
  var low;
  var mask;
  var next;
  var base = null;
  var base_index = 0;
  var end2;
  var count3 = new utils$1.Buf16(MAXBITS + 1);
  var offs = new utils$1.Buf16(MAXBITS + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count3[len] = 0;
  }
  for (sym = 0; sym < codes2; sym++) {
    count3[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max2 = MAXBITS; max2 >= 1; max2--) {
    if (count3[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table3[table_index++] = 1 << 24 | 64 << 16 | 0;
    table3[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts2.bits = 1;
    return 0;
  }
  for (min2 = 1; min2 < max2; min2++) {
    if (count3[min2] !== 0) {
      break;
    }
  }
  if (root < min2) {
    root = min2;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count3[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type2 === CODES$1 || max2 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count3[len];
  }
  for (sym = 0; sym < codes2; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type2 === CODES$1) {
    base = extra = work;
    end2 = 19;
  } else if (type2 === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end2 = 256;
  } else {
    base = dbase;
    extra = dext;
    end2 = -1;
  }
  huff = 0;
  sym = 0;
  len = min2;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end2) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end2) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill4 = 1 << curr;
    min2 = fill4;
    do {
      fill4 -= incr;
      table3[next + (huff >> drop) + fill4] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill4 !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count3[len] === 0) {
      if (len === max2) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min2;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count3[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table3[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table3[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts2.bits = root;
  return 0;
}, "inflate_table");
var utils = common;
var adler32 = adler32_1;
var crc32 = crc32_1;
var inflate_fast2 = inffast;
var inflate_table2 = inftrees;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
var Z_DEFLATED = 8;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
function zswap32(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
__name(zswap32, "zswap32");
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new utils.Buf16(320);
  this.work = new utils.Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
__name(InflateState, "InflateState");
function inflateResetKeep(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  strm.total_in = strm.total_out = state2.total = 0;
  strm.msg = "";
  if (state2.wrap) {
    strm.adler = state2.wrap & 1;
  }
  state2.mode = HEAD;
  state2.last = 0;
  state2.havedict = 0;
  state2.dmax = 32768;
  state2.head = null;
  state2.hold = 0;
  state2.bits = 0;
  state2.lencode = state2.lendyn = new utils.Buf32(ENOUGH_LENS);
  state2.distcode = state2.distdyn = new utils.Buf32(ENOUGH_DISTS);
  state2.sane = 1;
  state2.back = -1;
  return Z_OK;
}
__name(inflateResetKeep, "inflateResetKeep");
function inflateReset(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  state2.wsize = 0;
  state2.whave = 0;
  state2.wnext = 0;
  return inflateResetKeep(strm);
}
__name(inflateReset, "inflateReset");
function inflateReset2(strm, windowBits) {
  var wrap;
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state2.window !== null && state2.wbits !== windowBits) {
    state2.window = null;
  }
  state2.wrap = wrap;
  state2.wbits = windowBits;
  return inflateReset(strm);
}
__name(inflateReset2, "inflateReset2");
function inflateInit2(strm, windowBits) {
  var ret;
  var state2;
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  state2 = new InflateState();
  strm.state = state2;
  state2.window = null;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null;
  }
  return ret;
}
__name(inflateInit2, "inflateInit2");
function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}
__name(inflateInit, "inflateInit");
var virgin = true;
var lenfix;
var distfix;
function fixedtables(state2) {
  if (virgin) {
    var sym;
    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);
    sym = 0;
    while (sym < 144) {
      state2.lens[sym++] = 8;
    }
    while (sym < 256) {
      state2.lens[sym++] = 9;
    }
    while (sym < 280) {
      state2.lens[sym++] = 7;
    }
    while (sym < 288) {
      state2.lens[sym++] = 8;
    }
    inflate_table2(LENS, state2.lens, 0, 288, lenfix, 0, state2.work, {
      bits: 9
    });
    sym = 0;
    while (sym < 32) {
      state2.lens[sym++] = 5;
    }
    inflate_table2(DISTS, state2.lens, 0, 32, distfix, 0, state2.work, {
      bits: 5
    });
    virgin = false;
  }
  state2.lencode = lenfix;
  state2.lenbits = 9;
  state2.distcode = distfix;
  state2.distbits = 5;
}
__name(fixedtables, "fixedtables");
function updatewindow(strm, src, end2, copy5) {
  var dist;
  var state2 = strm.state;
  if (state2.window === null) {
    state2.wsize = 1 << state2.wbits;
    state2.wnext = 0;
    state2.whave = 0;
    state2.window = new utils.Buf8(state2.wsize);
  }
  if (copy5 >= state2.wsize) {
    utils.arraySet(state2.window, src, end2 - state2.wsize, state2.wsize, 0);
    state2.wnext = 0;
    state2.whave = state2.wsize;
  } else {
    dist = state2.wsize - state2.wnext;
    if (dist > copy5) {
      dist = copy5;
    }
    utils.arraySet(state2.window, src, end2 - copy5, dist, state2.wnext);
    copy5 -= dist;
    if (copy5) {
      utils.arraySet(state2.window, src, end2 - copy5, copy5, 0);
      state2.wnext = copy5;
      state2.whave = state2.wsize;
    } else {
      state2.wnext += dist;
      if (state2.wnext === state2.wsize) {
        state2.wnext = 0;
      }
      if (state2.whave < state2.wsize) {
        state2.whave += dist;
      }
    }
  }
  return 0;
}
__name(updatewindow, "updatewindow");
function inflate(strm, flush) {
  var state2;
  var input, output;
  var next;
  var put;
  var have, left;
  var hold;
  var bits;
  var _in, _out;
  var copy5;
  var from4;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len;
  var ret;
  var hbuf = new utils.Buf8(4);
  var opts2;
  var n5;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (state2.mode === TYPE) {
    state2.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state2.hold;
  bits = state2.bits;
  _in = have;
  _out = left;
  ret = Z_OK;
  inf_leave:
    for (; ; ) {
      switch (state2.mode) {
        case HEAD:
          if (state2.wrap === 0) {
            state2.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.wrap & 2 && hold === 35615) {
            state2.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state2.mode = FLAGS;
            break;
          }
          state2.flags = 0;
          if (state2.head) {
            state2.head.done = false;
          }
          if (!(state2.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state2.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state2.wbits === 0) {
            state2.wbits = len;
          } else if (len > state2.wbits) {
            strm.msg = "invalid window size";
            state2.mode = BAD;
            break;
          }
          state2.dmax = 1 << len;
          strm.adler = state2.check = 1;
          state2.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.flags = hold;
          if ((state2.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          if (state2.flags & 57344) {
            strm.msg = "unknown header flags set";
            state2.mode = BAD;
            break;
          }
          if (state2.head) {
            state2.head.text = hold >> 8 & 1;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.time = hold;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state2.check = crc32(state2.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.xflags = hold & 255;
            state2.head.os = hold >> 8;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state2.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length = hold;
            if (state2.head) {
              state2.head.extra_len = hold;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state2.head) {
            state2.head.extra = null;
          }
          state2.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state2.flags & 1024) {
            copy5 = state2.length;
            if (copy5 > have) {
              copy5 = have;
            }
            if (copy5) {
              if (state2.head) {
                len = state2.head.extra_len - state2.length;
                if (!state2.head.extra) {
                  state2.head.extra = new Array(state2.head.extra_len);
                }
                utils.arraySet(
                  state2.head.extra,
                  input,
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy5,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state2.flags & 512) {
                state2.check = crc32(state2.check, input, copy5, next);
              }
              have -= copy5;
              next += copy5;
              state2.length -= copy5;
            }
            if (state2.length) {
              break inf_leave;
            }
          }
          state2.length = 0;
          state2.mode = NAME;
        /* falls through */
        case NAME:
          if (state2.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy5 = 0;
            do {
              len = input[next + copy5++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.name += String.fromCharCode(len);
              }
            } while (len && copy5 < have);
            if (state2.flags & 512) {
              state2.check = crc32(state2.check, input, copy5, next);
            }
            have -= copy5;
            next += copy5;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.name = null;
          }
          state2.length = 0;
          state2.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state2.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy5 = 0;
            do {
              len = input[next + copy5++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.comment += String.fromCharCode(len);
              }
            } while (len && copy5 < have);
            if (state2.flags & 512) {
              state2.check = crc32(state2.check, input, copy5, next);
            }
            have -= copy5;
            next += copy5;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.comment = null;
          }
          state2.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state2.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state2.check & 65535)) {
              strm.msg = "header crc mismatch";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state2.head) {
            state2.head.hcrc = state2.flags >> 9 & 1;
            state2.head.done = true;
          }
          strm.adler = state2.check = 0;
          state2.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state2.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state2.mode = DICT;
        /* falls through */
        case DICT:
          if (state2.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            return Z_NEED_DICT;
          }
          strm.adler = state2.check = 1;
          state2.mode = TYPE;
        /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state2.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state2.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state2.mode = STORED;
              break;
            case 1:
              fixedtables(state2);
              state2.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state2.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state2.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state2.mode = BAD;
            break;
          }
          state2.length = hold & 65535;
          hold = 0;
          bits = 0;
          state2.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state2.mode = COPY;
        /* falls through */
        case COPY:
          copy5 = state2.length;
          if (copy5) {
            if (copy5 > have) {
              copy5 = have;
            }
            if (copy5 > left) {
              copy5 = left;
            }
            if (copy5 === 0) {
              break inf_leave;
            }
            utils.arraySet(output, input, next, copy5, put);
            have -= copy5;
            next += copy5;
            left -= copy5;
            put += copy5;
            state2.length -= copy5;
            break;
          }
          state2.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state2.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state2.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state2.nlen > 286 || state2.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state2.have < state2.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.lens[order[state2.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state2.have < 19) {
            state2.lens[order[state2.have++]] = 0;
          }
          state2.lencode = state2.lendyn;
          state2.lenbits = 7;
          opts2 = {
            bits: state2.lenbits
          };
          ret = inflate_table2(CODES, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts2);
          state2.lenbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state2.have < state2.nlen + state2.ndist) {
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state2.lens[state2.have++] = here_val;
            } else {
              if (here_val === 16) {
                n5 = here_bits + 2;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state2.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD;
                  break;
                }
                len = state2.lens[state2.have - 1];
                copy5 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n5 = here_bits + 3;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy5 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n5 = here_bits + 7;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy5 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state2.have + copy5 > state2.nlen + state2.ndist) {
                strm.msg = "invalid bit length repeat";
                state2.mode = BAD;
                break;
              }
              while (copy5--) {
                state2.lens[state2.have++] = len;
              }
            }
          }
          if (state2.mode === BAD) {
            break;
          }
          if (state2.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state2.mode = BAD;
            break;
          }
          state2.lenbits = 9;
          opts2 = {
            bits: state2.lenbits
          };
          ret = inflate_table2(LENS, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts2);
          state2.lenbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state2.mode = BAD;
            break;
          }
          state2.distbits = 6;
          state2.distcode = state2.distdyn;
          opts2 = {
            bits: state2.distbits
          };
          ret = inflate_table2(DISTS, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts2);
          state2.distbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state2.mode = BAD;
            break;
          }
          state2.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state2.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            inflate_fast2(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state2.hold;
            bits = state2.bits;
            if (state2.mode === TYPE) {
              state2.back = -1;
            }
            break;
          }
          state2.back = 0;
          for (; ; ) {
            here = state2.lencode[hold & (1 << state2.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          state2.length = here_val;
          if (here_op === 0) {
            state2.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state2.back = -1;
            state2.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD;
            break;
          }
          state2.extra = here_op & 15;
          state2.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state2.extra) {
            n5 = state2.extra;
            while (bits < n5) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          state2.was = state2.length;
          state2.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state2.distcode[hold & (1 << state2.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state2.mode = BAD;
            break;
          }
          state2.offset = here_val;
          state2.extra = here_op & 15;
          state2.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state2.extra) {
            n5 = state2.extra;
            while (bits < n5) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.offset += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          if (state2.offset > state2.dmax) {
            strm.msg = "invalid distance too far back";
            state2.mode = BAD;
            break;
          }
          state2.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy5 = _out - left;
          if (state2.offset > copy5) {
            copy5 = state2.offset - copy5;
            if (copy5 > state2.whave) {
              if (state2.sane) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD;
                break;
              }
            }
            if (copy5 > state2.wnext) {
              copy5 -= state2.wnext;
              from4 = state2.wsize - copy5;
            } else {
              from4 = state2.wnext - copy5;
            }
            if (copy5 > state2.length) {
              copy5 = state2.length;
            }
            from_source = state2.window;
          } else {
            from_source = output;
            from4 = put - state2.offset;
            copy5 = state2.length;
          }
          if (copy5 > left) {
            copy5 = left;
          }
          left -= copy5;
          state2.length -= copy5;
          do {
            output[put++] = from_source[from4++];
          } while (--copy5);
          if (state2.length === 0) {
            state2.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state2.length;
          left--;
          state2.mode = LEN;
          break;
        case CHECK:
          if (state2.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state2.total += _out;
            if (_out) {
              strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
              state2.flags ? crc32(state2.check, output, _out, put - _out) : adler32(state2.check, output, _out, put - _out);
            }
            _out = left;
            if ((state2.flags ? hold : zswap32(hold)) !== state2.check) {
              strm.msg = "incorrect data check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state2.wrap && state2.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state2.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state2.hold = hold;
  state2.bits = bits;
  if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD && (state2.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state2.total += _out;
  if (state2.wrap && _out) {
    strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state2.flags ? crc32(state2.check, output, _out, strm.next_out - _out) : adler32(state2.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE ? 128 : 0) + (state2.mode === LEN_ || state2.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}
__name(inflate, "inflate");
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  var state2 = strm.state;
  if (state2.window) {
    state2.window = null;
  }
  strm.state = null;
  return Z_OK;
}
__name(inflateEnd, "inflateEnd");
function inflateGetHeader(strm, head) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if ((state2.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  state2.head = head;
  head.done = false;
  return Z_OK;
}
__name(inflateGetHeader, "inflateGetHeader");
function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state2;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (state2.wrap !== 0 && state2.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  if (state2.mode === DICT) {
    dictid = 1;
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state2.check) {
      return Z_DATA_ERROR;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state2.mode = MEM;
    return Z_MEM_ERROR;
  }
  state2.havedict = 1;
  return Z_OK;
}
__name(inflateSetDictionary, "inflateSetDictionary");
inflate$1.inflateReset = inflateReset;
inflate$1.inflateReset2 = inflateReset2;
inflate$1.inflateResetKeep = inflateResetKeep;
inflate$1.inflateInit = inflateInit;
inflate$1.inflateInit2 = inflateInit2;
inflate$1.inflate = inflate;
inflate$1.inflateEnd = inflateEnd;
inflate$1.inflateGetHeader = inflateGetHeader;
inflate$1.inflateSetDictionary = inflateSetDictionary;
inflate$1.inflateInfo = "pako inflate (from Nodeca project)";
var constants = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
(function(exports) {
  var assert5 = require$$4;
  var Zstream = zstream;
  var zlib_deflate = deflate$1;
  var zlib_inflate = inflate$1;
  var constants$1 = constants;
  for (var key in constants$1) {
    exports[key] = constants$1[key];
  }
  exports.NONE = 0;
  exports.DEFLATE = 1;
  exports.INFLATE = 2;
  exports.GZIP = 3;
  exports.GUNZIP = 4;
  exports.DEFLATERAW = 5;
  exports.INFLATERAW = 6;
  exports.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib(mode) {
    if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  __name(Zlib, "Zlib");
  Zlib.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert5(this.init_done, "close before init");
    assert5(this.mode <= exports.UNZIP);
    if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports.NONE;
    this.dictionary = null;
  };
  Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert5.equal(arguments.length, 8);
    assert5(this.init_done, "write before init");
    assert5(this.mode !== exports.NONE, "already finalized");
    assert5.equal(false, this.write_in_progress, "write already in progress");
    assert5.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert5.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer2.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    browser$1.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports.INFLATE;
              break;
            }
          // fallthrough
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports.GUNZIP;
            } else {
              this.mode = exports.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      // fallthrough
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports.Z_DATA_ERROR) {
            this.err = exports.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib.prototype._checkError = function() {
    switch (this.err) {
      case exports.Z_OK:
      case exports.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports.Z_STREAM_END:
        break;
      case exports.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    assert5(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert5(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert5(level >= -1 && level <= 9, "invalid compression level");
    assert5(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert5(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
  };
  Zlib.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports.Z_NO_FLUSH;
    this.err = exports.Z_OK;
    if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
      case exports.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib.prototype._reset = function() {
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
      case exports.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports.INFLATE:
      case exports.INFLATERAW:
      case exports.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports.Zlib = Zlib;
})(binding2);
var require$$3 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_util$1);
(function(exports) {
  var Buffer5 = require$$0.Buffer;
  var Transform3 = require$$1.Transform;
  var binding$13 = binding2;
  var util = require$$3;
  var assert5 = require$$4.ok;
  var kMaxLength4 = require$$0.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength4.toString(16) + " bytes";
  binding$13.Z_MIN_WINDOWBITS = 8;
  binding$13.Z_MAX_WINDOWBITS = 15;
  binding$13.Z_DEFAULT_WINDOWBITS = 15;
  binding$13.Z_MIN_CHUNK = 64;
  binding$13.Z_MAX_CHUNK = Infinity;
  binding$13.Z_DEFAULT_CHUNK = 16 * 1024;
  binding$13.Z_MIN_MEMLEVEL = 1;
  binding$13.Z_MAX_MEMLEVEL = 9;
  binding$13.Z_DEFAULT_MEMLEVEL = 8;
  binding$13.Z_MIN_LEVEL = -1;
  binding$13.Z_MAX_LEVEL = 9;
  binding$13.Z_DEFAULT_LEVEL = binding$13.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding$13);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports, bkey, {
        enumerable: true,
        value: binding$13[bkey],
        writable: false
      });
    }
  }
  var codes2 = {
    Z_OK: binding$13.Z_OK,
    Z_STREAM_END: binding$13.Z_STREAM_END,
    Z_NEED_DICT: binding$13.Z_NEED_DICT,
    Z_ERRNO: binding$13.Z_ERRNO,
    Z_STREAM_ERROR: binding$13.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding$13.Z_DATA_ERROR,
    Z_MEM_ERROR: binding$13.Z_MEM_ERROR,
    Z_BUF_ERROR: binding$13.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding$13.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes2);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes2[codes2[ckey]] = ckey;
  }
  Object.defineProperty(exports, "codes", {
    enumerable: true,
    value: Object.freeze(codes2),
    writable: false
  });
  exports.Deflate = Deflate;
  exports.Inflate = Inflate;
  exports.Gzip = Gzip;
  exports.Gunzip = Gunzip;
  exports.DeflateRaw = DeflateRaw;
  exports.InflateRaw = InflateRaw;
  exports.Unzip = Unzip;
  exports.createDeflate = function(o4) {
    return new Deflate(o4);
  };
  exports.createInflate = function(o4) {
    return new Inflate(o4);
  };
  exports.createDeflateRaw = function(o4) {
    return new DeflateRaw(o4);
  };
  exports.createInflateRaw = function(o4) {
    return new InflateRaw(o4);
  };
  exports.createGzip = function(o4) {
    return new Gzip(o4);
  };
  exports.createGunzip = function(o4) {
    return new Gunzip(o4);
  };
  exports.createUnzip = function(o4) {
    return new Unzip(o4);
  };
  exports.deflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Deflate(opts2), buffer, callback);
  };
  exports.deflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Deflate(opts2), buffer);
  };
  exports.gzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gzip(opts2), buffer, callback);
  };
  exports.gzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gzip(opts2), buffer);
  };
  exports.deflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new DeflateRaw(opts2), buffer, callback);
  };
  exports.deflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new DeflateRaw(opts2), buffer);
  };
  exports.unzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Unzip(opts2), buffer, callback);
  };
  exports.unzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Unzip(opts2), buffer);
  };
  exports.inflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Inflate(opts2), buffer, callback);
  };
  exports.inflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Inflate(opts2), buffer);
  };
  exports.gunzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gunzip(opts2), buffer, callback);
  };
  exports.gunzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gunzip(opts2), buffer);
  };
  exports.inflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new InflateRaw(opts2), buffer, callback);
  };
  exports.inflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new InflateRaw(opts2), buffer);
  };
  function zlibBuffer(engine2, buffer, callback) {
    var buffers = [];
    var nread = 0;
    engine2.on("error", onError);
    engine2.on("end", onEnd);
    engine2.end(buffer);
    flow3();
    function flow3() {
      var chunk;
      while (null !== (chunk = engine2.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine2.once("readable", flow3);
    }
    __name(flow3, "flow");
    function onError(err2) {
      engine2.removeListener("end", onEnd);
      engine2.removeListener("readable", flow3);
      callback(err2);
    }
    __name(onError, "onError");
    function onEnd() {
      var buf;
      var err2 = null;
      if (nread >= kMaxLength4) {
        err2 = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer5.concat(buffers, nread);
      }
      buffers = [];
      engine2.close();
      callback(err2, buf);
    }
    __name(onEnd, "onEnd");
  }
  __name(zlibBuffer, "zlibBuffer");
  function zlibBufferSync(engine2, buffer) {
    if (typeof buffer === "string") buffer = Buffer5.from(buffer);
    if (!Buffer5.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
    var flushFlag = engine2._finishFlushFlag;
    return engine2._processChunk(buffer, flushFlag);
  }
  __name(zlibBufferSync, "zlibBufferSync");
  function Deflate(opts2) {
    if (!(this instanceof Deflate)) return new Deflate(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATE);
  }
  __name(Deflate, "Deflate");
  function Inflate(opts2) {
    if (!(this instanceof Inflate)) return new Inflate(opts2);
    Zlib.call(this, opts2, binding$13.INFLATE);
  }
  __name(Inflate, "Inflate");
  function Gzip(opts2) {
    if (!(this instanceof Gzip)) return new Gzip(opts2);
    Zlib.call(this, opts2, binding$13.GZIP);
  }
  __name(Gzip, "Gzip");
  function Gunzip(opts2) {
    if (!(this instanceof Gunzip)) return new Gunzip(opts2);
    Zlib.call(this, opts2, binding$13.GUNZIP);
  }
  __name(Gunzip, "Gunzip");
  function DeflateRaw(opts2) {
    if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATERAW);
  }
  __name(DeflateRaw, "DeflateRaw");
  function InflateRaw(opts2) {
    if (!(this instanceof InflateRaw)) return new InflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.INFLATERAW);
  }
  __name(InflateRaw, "InflateRaw");
  function Unzip(opts2) {
    if (!(this instanceof Unzip)) return new Unzip(opts2);
    Zlib.call(this, opts2, binding$13.UNZIP);
  }
  __name(Unzip, "Unzip");
  function isValidFlushFlag(flag) {
    return flag === binding$13.Z_NO_FLUSH || flag === binding$13.Z_PARTIAL_FLUSH || flag === binding$13.Z_SYNC_FLUSH || flag === binding$13.Z_FULL_FLUSH || flag === binding$13.Z_FINISH || flag === binding$13.Z_BLOCK;
  }
  __name(isValidFlushFlag, "isValidFlushFlag");
  function Zlib(opts2, mode) {
    var _this = this;
    this._opts = opts2 = opts2 || {};
    this._chunkSize = opts2.chunkSize || exports.Z_DEFAULT_CHUNK;
    Transform3.call(this, opts2);
    if (opts2.flush && !isValidFlushFlag(opts2.flush)) {
      throw new Error("Invalid flush flag: " + opts2.flush);
    }
    if (opts2.finishFlush && !isValidFlushFlag(opts2.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts2.finishFlush);
    }
    this._flushFlag = opts2.flush || binding$13.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts2.finishFlush !== "undefined" ? opts2.finishFlush : binding$13.Z_FINISH;
    if (opts2.chunkSize) {
      if (opts2.chunkSize < exports.Z_MIN_CHUNK || opts2.chunkSize > exports.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts2.chunkSize);
      }
    }
    if (opts2.windowBits) {
      if (opts2.windowBits < exports.Z_MIN_WINDOWBITS || opts2.windowBits > exports.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts2.windowBits);
      }
    }
    if (opts2.level) {
      if (opts2.level < exports.Z_MIN_LEVEL || opts2.level > exports.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts2.level);
      }
    }
    if (opts2.memLevel) {
      if (opts2.memLevel < exports.Z_MIN_MEMLEVEL || opts2.memLevel > exports.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts2.memLevel);
      }
    }
    if (opts2.strategy) {
      if (opts2.strategy != exports.Z_FILTERED && opts2.strategy != exports.Z_HUFFMAN_ONLY && opts2.strategy != exports.Z_RLE && opts2.strategy != exports.Z_FIXED && opts2.strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts2.strategy);
      }
    }
    if (opts2.dictionary) {
      if (!Buffer5.isBuffer(opts2.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding$13.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno2) {
      _close(self2);
      self2._hadError = true;
      var error3 = new Error(message);
      error3.errno = errno2;
      error3.code = exports.codes[errno2];
      self2.emit("error", error3);
    };
    var level = exports.Z_DEFAULT_COMPRESSION;
    if (typeof opts2.level === "number") level = opts2.level;
    var strategy = exports.Z_DEFAULT_STRATEGY;
    if (typeof opts2.strategy === "number") strategy = opts2.strategy;
    this._handle.init(opts2.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts2.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts2.dictionary);
    this._buffer = Buffer5.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: /* @__PURE__ */ __name(function() {
        return !_this._handle;
      }, "get"),
      configurable: true,
      enumerable: true
    });
  }
  __name(Zlib, "Zlib");
  util.inherits(Zlib, Transform3);
  Zlib.prototype.params = function(level, strategy, callback) {
    if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding$13.Z_SYNC_FLUSH, function() {
        assert5(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback) callback();
        }
      });
    } else {
      browser$1.nextTick(callback);
    }
  };
  Zlib.prototype.reset = function() {
    assert5(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib.prototype._flush = function(callback) {
    this._transform(Buffer5.alloc(0), "", callback);
  };
  Zlib.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding$13.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback) browser$1.nextTick(callback);
    } else if (ws.ending) {
      if (callback) this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer5.alloc(0), "", callback);
    }
  };
  Zlib.prototype.close = function(callback) {
    _close(this, callback);
    browser$1.nextTick(emitCloseNT2, this);
  };
  function _close(engine2, callback) {
    if (callback) browser$1.nextTick(callback);
    if (!engine2._handle) return;
    engine2._handle.close();
    engine2._handle = null;
  }
  __name(_close, "_close");
  function emitCloseNT2(self2) {
    self2.emit("close");
  }
  __name(emitCloseNT2, "emitCloseNT");
  Zlib.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last2 = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer5.isBuffer(chunk)) return cb(new Error("invalid input"));
    if (!this._handle) return cb(new Error("zlib binding closed"));
    if (last2) flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding$13.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error3;
      this.on("error", function(er) {
        error3 = er;
      });
      assert5(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error3;
      }
      if (nread >= kMaxLength4) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer5.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert5(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError) return;
      var have = availOutBefore - availOutAfter;
      assert5(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer5.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async) return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async) return false;
      cb();
    }
    __name(callback, "callback");
  };
  util.inherits(Deflate, Zlib);
  util.inherits(Inflate, Zlib);
  util.inherits(Gzip, Zlib);
  util.inherits(Gunzip, Zlib);
  util.inherits(DeflateRaw, Zlib);
  util.inherits(InflateRaw, Zlib);
  util.inherits(Unzip, Zlib);
})(lib);
var zlib = /* @__PURE__ */ getDefaultExportFromCjs(lib);
var PNG = class {
  static {
    __name(this, "PNG");
  }
  static decode(path, fn) {
    {
      throw new Error("PNG.decode not available in browser build");
    }
  }
  static load(path) {
    {
      throw new Error("PNG.load not available in browser build");
    }
  }
  constructor(data2) {
    let i2;
    this.data = data2;
    this.pos = 8;
    this.palette = [];
    this.imgData = [];
    this.transparency = {};
    this.text = {};
    while (true) {
      const chunkSize = this.readUInt32();
      let section = "";
      for (i2 = 0; i2 < 4; i2++) {
        section += String.fromCharCode(this.data[this.pos++]);
      }
      switch (section) {
        case "IHDR":
          this.width = this.readUInt32();
          this.height = this.readUInt32();
          this.bits = this.data[this.pos++];
          this.colorType = this.data[this.pos++];
          this.compressionMethod = this.data[this.pos++];
          this.filterMethod = this.data[this.pos++];
          this.interlaceMethod = this.data[this.pos++];
          break;
        case "PLTE":
          this.palette = this.read(chunkSize);
          break;
        case "IDAT":
          for (i2 = 0; i2 < chunkSize; i2++) {
            this.imgData.push(this.data[this.pos++]);
          }
          break;
        case "tRNS":
          this.transparency = {};
          switch (this.colorType) {
            case 3:
              this.transparency.indexed = this.read(chunkSize);
              var short = 255 - this.transparency.indexed.length;
              if (short > 0) {
                for (i2 = 0; i2 < short; i2++) {
                  this.transparency.indexed.push(255);
                }
              }
              break;
            case 0:
              this.transparency.grayscale = this.read(chunkSize)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(chunkSize);
              break;
          }
          break;
        case "tEXt":
          var text = this.read(chunkSize);
          var index2 = text.indexOf(0);
          var key = String.fromCharCode.apply(String, text.slice(0, index2));
          this.text[key] = String.fromCharCode.apply(String, text.slice(index2 + 1));
          break;
        case "IEND":
          switch (this.colorType) {
            case 0:
            case 3:
            case 4:
              this.colors = 1;
              break;
            case 2:
            case 6:
              this.colors = 3;
              break;
          }
          this.hasAlphaChannel = [4, 6].includes(this.colorType);
          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
          this.pixelBitlength = this.bits * colors;
          switch (this.colors) {
            case 1:
              this.colorSpace = "DeviceGray";
              break;
            case 3:
              this.colorSpace = "DeviceRGB";
              break;
          }
          this.imgData = Buffer2.from(this.imgData);
          return;
        default:
          this.pos += chunkSize;
      }
      this.pos += 4;
      if (this.pos > this.data.length) {
        throw new Error("Incomplete or corrupt PNG file");
      }
    }
  }
  read(bytes) {
    const result = new Array(bytes);
    for (let i2 = 0; i2 < bytes; i2++) {
      result[i2] = this.data[this.pos++];
    }
    return result;
  }
  readUInt32() {
    const b1 = this.data[this.pos++] << 24;
    const b22 = this.data[this.pos++] << 16;
    const b3 = this.data[this.pos++] << 8;
    const b4 = this.data[this.pos++];
    return b1 | b22 | b3 | b4;
  }
  readUInt16() {
    const b1 = this.data[this.pos++] << 8;
    const b22 = this.data[this.pos++];
    return b1 | b22;
  }
  decodePixels(fn) {
    return zlib.inflate(this.imgData, (err2, data2) => {
      if (err2) throw err2;
      var pos = 0;
      const {
        width,
        height: height2
      } = this;
      var pixelBytes = this.pixelBitlength / 8;
      const pixels = Buffer2.alloc(width * height2 * pixelBytes);
      function pass(x0, y0, dx, dy, singlePass) {
        if (singlePass === void 0) {
          singlePass = false;
        }
        const w = Math.ceil((width - x0) / dx);
        const h = Math.ceil((height2 - y0) / dy);
        const scanlineLength = pixelBytes * w;
        const buffer = singlePass ? pixels : Buffer2.alloc(scanlineLength * h);
        let row = 0;
        let c2 = 0;
        while (row < h && pos < data2.length) {
          var byte;
          var col;
          var i2;
          var left;
          var upper;
          switch (data2[pos++]) {
            case 0:
              for (i2 = 0; i2 < scanlineLength; i2++) {
                buffer[c2++] = data2[pos++];
              }
              break;
            case 1:
              for (i2 = 0; i2 < scanlineLength; i2++) {
                byte = data2[pos++];
                left = i2 < pixelBytes ? 0 : buffer[c2 - pixelBytes];
                buffer[c2++] = (byte + left) % 256;
              }
              break;
            case 2:
              for (i2 = 0; i2 < scanlineLength; i2++) {
                byte = data2[pos++];
                col = (i2 - i2 % pixelBytes) / pixelBytes;
                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i2 % pixelBytes];
                buffer[c2++] = (upper + byte) % 256;
              }
              break;
            case 3:
              for (i2 = 0; i2 < scanlineLength; i2++) {
                byte = data2[pos++];
                col = (i2 - i2 % pixelBytes) / pixelBytes;
                left = i2 < pixelBytes ? 0 : buffer[c2 - pixelBytes];
                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i2 % pixelBytes];
                buffer[c2++] = (byte + Math.floor((left + upper) / 2)) % 256;
              }
              break;
            case 4:
              for (i2 = 0; i2 < scanlineLength; i2++) {
                var paeth;
                var upperLeft;
                byte = data2[pos++];
                col = (i2 - i2 % pixelBytes) / pixelBytes;
                left = i2 < pixelBytes ? 0 : buffer[c2 - pixelBytes];
                if (row === 0) {
                  upper = upperLeft = 0;
                } else {
                  upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i2 % pixelBytes];
                  upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i2 % pixelBytes];
                }
                const p3 = left + upper - upperLeft;
                const pa = Math.abs(p3 - left);
                const pb = Math.abs(p3 - upper);
                const pc = Math.abs(p3 - upperLeft);
                if (pa <= pb && pa <= pc) {
                  paeth = left;
                } else if (pb <= pc) {
                  paeth = upper;
                } else {
                  paeth = upperLeft;
                }
                buffer[c2++] = (byte + paeth) % 256;
              }
              break;
            default:
              throw new Error(`Invalid filter algorithm: ${data2[pos - 1]}`);
          }
          if (!singlePass) {
            let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;
            let bufferPos = row * scanlineLength;
            for (i2 = 0; i2 < w; i2++) {
              for (let j = 0; j < pixelBytes; j++) pixels[pixelsPos++] = buffer[bufferPos++];
              pixelsPos += (dx - 1) * pixelBytes;
            }
          }
          row++;
        }
      }
      __name(pass, "pass");
      if (this.interlaceMethod === 1) {
        pass(0, 0, 8, 8);
        pass(4, 0, 8, 8);
        pass(0, 4, 4, 8);
        pass(2, 0, 4, 4);
        pass(0, 2, 2, 4);
        pass(1, 0, 2, 2);
        pass(0, 1, 1, 2);
      } else {
        pass(0, 0, 1, 1, true);
      }
      return fn(pixels);
    });
  }
  decodePalette() {
    const {
      palette
    } = this;
    const {
      length: length2
    } = palette;
    const transparency = this.transparency.indexed || [];
    const ret = Buffer2.alloc(transparency.length + length2);
    let pos = 0;
    let c2 = 0;
    for (let i2 = 0; i2 < length2; i2 += 3) {
      var left;
      ret[pos++] = palette[i2];
      ret[pos++] = palette[i2 + 1];
      ret[pos++] = palette[i2 + 2];
      ret[pos++] = (left = transparency[c2++]) != null ? left : 255;
    }
    return ret;
  }
  copyToImageData(imageData, pixels) {
    let j;
    var k3;
    let {
      colors
    } = this;
    let palette = null;
    let alpha = this.hasAlphaChannel;
    if (this.palette.length) {
      palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());
      colors = 4;
      alpha = true;
    }
    const data2 = imageData.data || imageData;
    const {
      length: length2
    } = data2;
    const input = palette || pixels;
    let i2 = j = 0;
    if (colors === 1) {
      while (i2 < length2) {
        k3 = palette ? pixels[i2 / 4] * 4 : j;
        const v3 = input[k3++];
        data2[i2++] = v3;
        data2[i2++] = v3;
        data2[i2++] = v3;
        data2[i2++] = alpha ? input[k3++] : 255;
        j = k3;
      }
    } else {
      while (i2 < length2) {
        k3 = palette ? pixels[i2 / 4] * 4 : j;
        data2[i2++] = input[k3++];
        data2[i2++] = input[k3++];
        data2[i2++] = input[k3++];
        data2[i2++] = alpha ? input[k3++] : 255;
        j = k3;
      }
    }
  }
  decode(fn) {
    const ret = Buffer2.alloc(this.width * this.height * 4);
    return this.decodePixels((pixels) => {
      this.copyToImageData(ret, pixels);
      return fn(ret);
    });
  }
};

// ../../node_modules/.pnpm/@react-pdf+pdfkit@4.1.0/node_modules/@react-pdf/pdfkit/lib/pdfkit.browser.js
var import_crypto_js = __toESM(require_crypto_js(), 1);
var global$12 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup2 = [];
var revLookup2 = [];
var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited2 = false;
function init2() {
  inited2 = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code.length; i2 < len; ++i2) {
    lookup2[i2] = code[i2];
    revLookup2[code.charCodeAt(i2)] = i2;
  }
  revLookup2["-".charCodeAt(0)] = 62;
  revLookup2["_".charCodeAt(0)] = 63;
}
__name(init2, "init");
function toByteArray2(b64) {
  if (!inited2) {
    init2();
  }
  var i2, j, l4, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr2(len * 3 / 4 - placeHolders);
  l4 = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i2 = 0, j = 0; i2 < l4; i2 += 4, j += 3) {
    tmp = revLookup2[b64.charCodeAt(i2)] << 18 | revLookup2[b64.charCodeAt(i2 + 1)] << 12 | revLookup2[b64.charCodeAt(i2 + 2)] << 6 | revLookup2[b64.charCodeAt(i2 + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup2[b64.charCodeAt(i2)] << 2 | revLookup2[b64.charCodeAt(i2 + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup2[b64.charCodeAt(i2)] << 10 | revLookup2[b64.charCodeAt(i2 + 1)] << 4 | revLookup2[b64.charCodeAt(i2 + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
__name(toByteArray2, "toByteArray");
function tripletToBase642(num) {
  return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
}
__name(tripletToBase642, "tripletToBase64");
function encodeChunk2(uint82, start2, end2) {
  var tmp;
  var output = [];
  for (var i2 = start2; i2 < end2; i2 += 3) {
    tmp = (uint82[i2] << 16) + (uint82[i2 + 1] << 8) + uint82[i2 + 2];
    output.push(tripletToBase642(tmp));
  }
  return output.join("");
}
__name(encodeChunk2, "encodeChunk");
function fromByteArray2(uint82) {
  if (!inited2) {
    init2();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk2(uint82, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup2[tmp >> 2];
    output += lookup2[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup2[tmp >> 10];
    output += lookup2[tmp >> 4 & 63];
    output += lookup2[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
__name(fromByteArray2, "fromByteArray");
function read2(buffer, offset2, isLE, mLen, nBytes) {
  var e4, m3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d3 = isLE ? -1 : 1;
  var s4 = buffer[offset2 + i2];
  i2 += d3;
  e4 = s4 & (1 << -nBits) - 1;
  s4 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e4 = e4 * 256 + buffer[offset2 + i2], i2 += d3, nBits -= 8) {
  }
  m3 = e4 & (1 << -nBits) - 1;
  e4 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m3 = m3 * 256 + buffer[offset2 + i2], i2 += d3, nBits -= 8) {
  }
  if (e4 === 0) {
    e4 = 1 - eBias;
  } else if (e4 === eMax) {
    return m3 ? NaN : (s4 ? -1 : 1) * Infinity;
  } else {
    m3 = m3 + Math.pow(2, mLen);
    e4 = e4 - eBias;
  }
  return (s4 ? -1 : 1) * m3 * Math.pow(2, e4 - mLen);
}
__name(read2, "read");
function write3(buffer, value2, offset2, isLE, mLen, nBytes) {
  var e4, m3, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d3 = isLE ? 1 : -1;
  var s4 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m3 = isNaN(value2) ? 1 : 0;
    e4 = eMax;
  } else {
    e4 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e4)) < 1) {
      e4--;
      c2 *= 2;
    }
    if (e4 + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e4++;
      c2 /= 2;
    }
    if (e4 + eBias >= eMax) {
      m3 = 0;
      e4 = eMax;
    } else if (e4 + eBias >= 1) {
      m3 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e4 = e4 + eBias;
    } else {
      m3 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e4 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset2 + i2] = m3 & 255, i2 += d3, m3 /= 256, mLen -= 8) {
  }
  e4 = e4 << mLen | m3;
  eLen += mLen;
  for (; eLen > 0; buffer[offset2 + i2] = e4 & 255, i2 += d3, e4 /= 256, eLen -= 8) {
  }
  buffer[offset2 + i2 - d3] |= s4 * 128;
}
__name(write3, "write");
var toString3 = {}.toString;
var isArray$12 = Array.isArray || function(arr) {
  return toString3.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES2 = 50;
Buffer$2.TYPED_ARRAY_SUPPORT = global$12.TYPED_ARRAY_SUPPORT !== void 0 ? global$12.TYPED_ARRAY_SUPPORT : true;
var _kMaxLength2 = kMaxLength2();
function kMaxLength2() {
  return Buffer$2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
__name(kMaxLength2, "kMaxLength");
function createBuffer2(that, length2) {
  if (kMaxLength2() < length2) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length2);
    that.__proto__ = Buffer$2.prototype;
  } else {
    if (that === null) {
      that = new Buffer$2(length2);
    }
    that.length = length2;
  }
  return that;
}
__name(createBuffer2, "createBuffer");
function Buffer$2(arg, encodingOrOffset, length2) {
  if (!Buffer$2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$2)) {
    return new Buffer$2(arg, encodingOrOffset, length2);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe2(this, arg);
  }
  return from$1(this, arg, encodingOrOffset, length2);
}
__name(Buffer$2, "Buffer$2");
Buffer$2.poolSize = 8192;
Buffer$2._augment = function(arr) {
  arr.__proto__ = Buffer$2.prototype;
  return arr;
};
function from$1(that, value2, encodingOrOffset, length2) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer2(that, value2, encodingOrOffset, length2);
  }
  if (typeof value2 === "string") {
    return fromString2(that, value2, encodingOrOffset);
  }
  return fromObject2(that, value2);
}
__name(from$1, "from$1");
Buffer$2.from = function(value2, encodingOrOffset, length2) {
  return from$1(null, value2, encodingOrOffset, length2);
};
if (Buffer$2.TYPED_ARRAY_SUPPORT) {
  Buffer$2.prototype.__proto__ = Uint8Array.prototype;
  Buffer$2.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer$2[Symbol.species] === Buffer$2) ;
}
function assertSize2(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
__name(assertSize2, "assertSize");
function alloc2(that, size, fill4, encoding) {
  assertSize2(size);
  if (size <= 0) {
    return createBuffer2(that, size);
  }
  if (fill4 !== void 0) {
    return typeof encoding === "string" ? createBuffer2(that, size).fill(fill4, encoding) : createBuffer2(that, size).fill(fill4);
  }
  return createBuffer2(that, size);
}
__name(alloc2, "alloc");
Buffer$2.alloc = function(size, fill4, encoding) {
  return alloc2(null, size, fill4, encoding);
};
function allocUnsafe2(that, size) {
  assertSize2(size);
  that = createBuffer2(that, size < 0 ? 0 : checked2(size) | 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (var i2 = 0; i2 < size; ++i2) {
      that[i2] = 0;
    }
  }
  return that;
}
__name(allocUnsafe2, "allocUnsafe");
Buffer$2.allocUnsafe = function(size) {
  return allocUnsafe2(null, size);
};
Buffer$2.allocUnsafeSlow = function(size) {
  return allocUnsafe2(null, size);
};
function fromString2(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer$2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length2 = byteLength3(string, encoding) | 0;
  that = createBuffer2(that, length2);
  var actual = that.write(string, encoding);
  if (actual !== length2) {
    that = that.slice(0, actual);
  }
  return that;
}
__name(fromString2, "fromString");
function fromArrayLike2(that, array) {
  var length2 = array.length < 0 ? 0 : checked2(array.length) | 0;
  that = createBuffer2(that, length2);
  for (var i2 = 0; i2 < length2; i2 += 1) {
    that[i2] = array[i2] & 255;
  }
  return that;
}
__name(fromArrayLike2, "fromArrayLike");
function fromArrayBuffer2(that, array, byteOffset, length2) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length2 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length2 === void 0) {
    array = new Uint8Array(array);
  } else if (length2 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length2);
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer$2.prototype;
  } else {
    that = fromArrayLike2(that, array);
  }
  return that;
}
__name(fromArrayBuffer2, "fromArrayBuffer");
function fromObject2(that, obj) {
  if (internalIsBuffer2(obj)) {
    var len = checked2(obj.length) | 0;
    that = createBuffer2(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan2(obj.length)) {
        return createBuffer2(that, 0);
      }
      return fromArrayLike2(that, obj);
    }
    if (obj.type === "Buffer" && isArray$12(obj.data)) {
      return fromArrayLike2(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
__name(fromObject2, "fromObject");
function checked2(length2) {
  if (length2 >= kMaxLength2()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2().toString(16) + " bytes");
  }
  return length2 | 0;
}
__name(checked2, "checked");
function SlowBuffer2(length2) {
  if (+length2 != length2) {
    length2 = 0;
  }
  return Buffer$2.alloc(+length2);
}
__name(SlowBuffer2, "SlowBuffer");
Buffer$2.isBuffer = isBuffer$12;
function internalIsBuffer2(b3) {
  return !!(b3 != null && b3._isBuffer);
}
__name(internalIsBuffer2, "internalIsBuffer");
Buffer$2.compare = /* @__PURE__ */ __name(function compare4(a4, b3) {
  if (!internalIsBuffer2(a4) || !internalIsBuffer2(b3)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a4 === b3) return 0;
  var x = a4.length;
  var y3 = b3.length;
  for (var i2 = 0, len = Math.min(x, y3); i2 < len; ++i2) {
    if (a4[i2] !== b3[i2]) {
      x = a4[i2];
      y3 = b3[i2];
      break;
    }
  }
  if (x < y3) return -1;
  if (y3 < x) return 1;
  return 0;
}, "compare");
Buffer$2.isEncoding = /* @__PURE__ */ __name(function isEncoding2(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, "isEncoding");
Buffer$2.concat = /* @__PURE__ */ __name(function concat2(list, length2) {
  if (!isArray$12(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer$2.alloc(0);
  }
  var i2;
  if (length2 === void 0) {
    length2 = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      length2 += list[i2].length;
    }
  }
  var buffer = Buffer$2.allocUnsafe(length2);
  var pos = 0;
  for (i2 = 0; i2 < list.length; ++i2) {
    var buf = list[i2];
    if (!internalIsBuffer2(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
}, "concat");
function byteLength3(string, encoding) {
  if (internalIsBuffer2(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes2(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes2(string).length;
      default:
        if (loweredCase) return utf8ToBytes2(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
__name(byteLength3, "byteLength");
Buffer$2.byteLength = byteLength3;
function slowToString2(encoding, start2, end2) {
  var loweredCase = false;
  if (start2 === void 0 || start2 < 0) {
    start2 = 0;
  }
  if (start2 > this.length) {
    return "";
  }
  if (end2 === void 0 || end2 > this.length) {
    end2 = this.length;
  }
  if (end2 <= 0) {
    return "";
  }
  end2 >>>= 0;
  start2 >>>= 0;
  if (end2 <= start2) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice2(this, start2, end2);
      case "utf8":
      case "utf-8":
        return utf8Slice2(this, start2, end2);
      case "ascii":
        return asciiSlice2(this, start2, end2);
      case "latin1":
      case "binary":
        return latin1Slice2(this, start2, end2);
      case "base64":
        return base64Slice2(this, start2, end2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice2(this, start2, end2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
__name(slowToString2, "slowToString");
Buffer$2.prototype._isBuffer = true;
function swap2(b3, n5, m3) {
  var i2 = b3[n5];
  b3[n5] = b3[m3];
  b3[m3] = i2;
}
__name(swap2, "swap");
Buffer$2.prototype.swap16 = /* @__PURE__ */ __name(function swap162() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 2) {
    swap2(this, i2, i2 + 1);
  }
  return this;
}, "swap16");
Buffer$2.prototype.swap32 = /* @__PURE__ */ __name(function swap322() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 4) {
    swap2(this, i2, i2 + 3);
    swap2(this, i2 + 1, i2 + 2);
  }
  return this;
}, "swap32");
Buffer$2.prototype.swap64 = /* @__PURE__ */ __name(function swap642() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 8) {
    swap2(this, i2, i2 + 7);
    swap2(this, i2 + 1, i2 + 6);
    swap2(this, i2 + 2, i2 + 5);
    swap2(this, i2 + 3, i2 + 4);
  }
  return this;
}, "swap64");
Buffer$2.prototype.toString = /* @__PURE__ */ __name(function toString4() {
  var length2 = this.length | 0;
  if (length2 === 0) return "";
  if (arguments.length === 0) return utf8Slice2(this, 0, length2);
  return slowToString2.apply(this, arguments);
}, "toString");
Buffer$2.prototype.equals = /* @__PURE__ */ __name(function equals2(b3) {
  if (!internalIsBuffer2(b3)) throw new TypeError("Argument must be a Buffer");
  if (this === b3) return true;
  return Buffer$2.compare(this, b3) === 0;
}, "equals");
Buffer$2.prototype.inspect = /* @__PURE__ */ __name(function inspect3() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES2;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2) str += " ... ";
  }
  return "<Buffer " + str + ">";
}, "inspect");
Buffer$2.prototype.compare = /* @__PURE__ */ __name(function compare5(target, start2, end2, thisStart, thisEnd) {
  if (!internalIsBuffer2(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start2 === void 0) {
    start2 = 0;
  }
  if (end2 === void 0) {
    end2 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start2 >= end2) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start2 >= end2) {
    return 1;
  }
  start2 >>>= 0;
  end2 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y3 = end2 - start2;
  var len = Math.min(x, y3);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start2, end2);
  for (var i2 = 0; i2 < len; ++i2) {
    if (thisCopy[i2] !== targetCopy[i2]) {
      x = thisCopy[i2];
      y3 = targetCopy[i2];
      break;
    }
  }
  if (x < y3) return -1;
  if (y3 < x) return 1;
  return 0;
}, "compare");
function bidirectionalIndexOf2(buffer, val, byteOffset, encoding, dir3) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir3 ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir3) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir3) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer$2.from(val, encoding);
  }
  if (internalIsBuffer2(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf2(buffer, val, byteOffset, encoding, dir3);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer$2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir3) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf2(buffer, [val], byteOffset, encoding, dir3);
  }
  throw new TypeError("val must be string, number or Buffer");
}
__name(bidirectionalIndexOf2, "bidirectionalIndexOf");
function arrayIndexOf2(arr, val, byteOffset, encoding, dir3) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read5(buf, i3) {
    if (indexSize === 1) {
      return buf[i3];
    } else {
      return buf.readUInt16BE(i3 * indexSize);
    }
  }
  __name(read5, "read");
  var i2;
  if (dir3) {
    var foundIndex = -1;
    for (i2 = byteOffset; i2 < arrLength; i2++) {
      if (read5(arr, i2) === read5(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1) foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i2 = byteOffset; i2 >= 0; i2--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read5(arr, i2 + j) !== read5(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i2;
    }
  }
  return -1;
}
__name(arrayIndexOf2, "arrayIndexOf");
Buffer$2.prototype.includes = /* @__PURE__ */ __name(function includes2(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
}, "includes");
Buffer$2.prototype.indexOf = /* @__PURE__ */ __name(function indexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
}, "indexOf");
Buffer$2.prototype.lastIndexOf = /* @__PURE__ */ __name(function lastIndexOf2(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
}, "lastIndexOf");
function hexWrite2(buf, string, offset2, length2) {
  offset2 = Number(offset2) || 0;
  var remaining = buf.length - offset2;
  if (!length2) {
    length2 = remaining;
  } else {
    length2 = Number(length2);
    if (length2 > remaining) {
      length2 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length2 > strLen / 2) {
    length2 = strLen / 2;
  }
  for (var i2 = 0; i2 < length2; ++i2) {
    var parsed = parseInt(string.substr(i2 * 2, 2), 16);
    if (isNaN(parsed)) return i2;
    buf[offset2 + i2] = parsed;
  }
  return i2;
}
__name(hexWrite2, "hexWrite");
function utf8Write2(buf, string, offset2, length2) {
  return blitBuffer2(utf8ToBytes2(string, buf.length - offset2), buf, offset2, length2);
}
__name(utf8Write2, "utf8Write");
function asciiWrite2(buf, string, offset2, length2) {
  return blitBuffer2(asciiToBytes2(string), buf, offset2, length2);
}
__name(asciiWrite2, "asciiWrite");
function latin1Write2(buf, string, offset2, length2) {
  return asciiWrite2(buf, string, offset2, length2);
}
__name(latin1Write2, "latin1Write");
function base64Write2(buf, string, offset2, length2) {
  return blitBuffer2(base64ToBytes2(string), buf, offset2, length2);
}
__name(base64Write2, "base64Write");
function ucs2Write2(buf, string, offset2, length2) {
  return blitBuffer2(utf16leToBytes2(string, buf.length - offset2), buf, offset2, length2);
}
__name(ucs2Write2, "ucs2Write");
Buffer$2.prototype.write = /* @__PURE__ */ __name(function write4(string, offset2, length2, encoding) {
  if (offset2 === void 0) {
    encoding = "utf8";
    length2 = this.length;
    offset2 = 0;
  } else if (length2 === void 0 && typeof offset2 === "string") {
    encoding = offset2;
    length2 = this.length;
    offset2 = 0;
  } else if (isFinite(offset2)) {
    offset2 = offset2 | 0;
    if (isFinite(length2)) {
      length2 = length2 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length2;
      length2 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset2;
  if (length2 === void 0 || length2 > remaining) length2 = remaining;
  if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite2(this, string, offset2, length2);
      case "utf8":
      case "utf-8":
        return utf8Write2(this, string, offset2, length2);
      case "ascii":
        return asciiWrite2(this, string, offset2, length2);
      case "latin1":
      case "binary":
        return latin1Write2(this, string, offset2, length2);
      case "base64":
        return base64Write2(this, string, offset2, length2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write2(this, string, offset2, length2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}, "write");
Buffer$2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON2() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
}, "toJSON");
function base64Slice2(buf, start2, end2) {
  if (start2 === 0 && end2 === buf.length) {
    return fromByteArray2(buf);
  } else {
    return fromByteArray2(buf.slice(start2, end2));
  }
}
__name(base64Slice2, "base64Slice");
function utf8Slice2(buf, start2, end2) {
  end2 = Math.min(buf.length, end2);
  var res = [];
  var i2 = start2;
  while (i2 < end2) {
    var firstByte = buf[i2];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end2) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i2 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          fourthByte = buf[i2 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i2 += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
__name(utf8Slice2, "utf8Slice");
var MAX_ARGUMENTS_LENGTH2 = 4096;
function decodeCodePointsArray2(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH2)
    );
  }
  return res;
}
__name(decodeCodePointsArray2, "decodeCodePointsArray");
function asciiSlice2(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i2 = start2; i2 < end2; ++i2) {
    ret += String.fromCharCode(buf[i2] & 127);
  }
  return ret;
}
__name(asciiSlice2, "asciiSlice");
function latin1Slice2(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i2 = start2; i2 < end2; ++i2) {
    ret += String.fromCharCode(buf[i2]);
  }
  return ret;
}
__name(latin1Slice2, "latin1Slice");
function hexSlice2(buf, start2, end2) {
  var len = buf.length;
  if (!start2 || start2 < 0) start2 = 0;
  if (!end2 || end2 < 0 || end2 > len) end2 = len;
  var out = "";
  for (var i2 = start2; i2 < end2; ++i2) {
    out += toHex$1(buf[i2]);
  }
  return out;
}
__name(hexSlice2, "hexSlice");
function utf16leSlice2(buf, start2, end2) {
  var bytes = buf.slice(start2, end2);
  var res = "";
  for (var i2 = 0; i2 < bytes.length; i2 += 2) {
    res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
  }
  return res;
}
__name(utf16leSlice2, "utf16leSlice");
Buffer$2.prototype.slice = /* @__PURE__ */ __name(function slice2(start2, end2) {
  var len = this.length;
  start2 = ~~start2;
  end2 = end2 === void 0 ? len : ~~end2;
  if (start2 < 0) {
    start2 += len;
    if (start2 < 0) start2 = 0;
  } else if (start2 > len) {
    start2 = len;
  }
  if (end2 < 0) {
    end2 += len;
    if (end2 < 0) end2 = 0;
  } else if (end2 > len) {
    end2 = len;
  }
  if (end2 < start2) end2 = start2;
  var newBuf;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start2, end2);
    newBuf.__proto__ = Buffer$2.prototype;
  } else {
    var sliceLen = end2 - start2;
    newBuf = new Buffer$2(sliceLen, void 0);
    for (var i2 = 0; i2 < sliceLen; ++i2) {
      newBuf[i2] = this[i2 + start2];
    }
  }
  return newBuf;
}, "slice");
function checkOffset2(offset2, ext, length2) {
  if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
  if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
}
__name(checkOffset2, "checkOffset");
Buffer$2.prototype.readUIntLE = /* @__PURE__ */ __name(function readUIntLE2(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset2(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i2] * mul;
  }
  return val;
}, "readUIntLE");
Buffer$2.prototype.readUIntBE = /* @__PURE__ */ __name(function readUIntBE2(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset2(offset2, byteLength5, this.length);
  }
  var val = this[offset2 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset2 + --byteLength5] * mul;
  }
  return val;
}, "readUIntBE");
Buffer$2.prototype.readUInt8 = /* @__PURE__ */ __name(function readUInt83(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 1, this.length);
  return this[offset2];
}, "readUInt8");
Buffer$2.prototype.readUInt16LE = /* @__PURE__ */ __name(function readUInt16LE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 2, this.length);
  return this[offset2] | this[offset2 + 1] << 8;
}, "readUInt16LE");
Buffer$2.prototype.readUInt16BE = /* @__PURE__ */ __name(function readUInt16BE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 2, this.length);
  return this[offset2] << 8 | this[offset2 + 1];
}, "readUInt16BE");
Buffer$2.prototype.readUInt32LE = /* @__PURE__ */ __name(function readUInt32LE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
}, "readUInt32LE");
Buffer$2.prototype.readUInt32BE = /* @__PURE__ */ __name(function readUInt32BE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
}, "readUInt32BE");
Buffer$2.prototype.readIntLE = /* @__PURE__ */ __name(function readIntLE2(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset2(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i2] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
}, "readIntLE");
Buffer$2.prototype.readIntBE = /* @__PURE__ */ __name(function readIntBE2(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset2(offset2, byteLength5, this.length);
  var i2 = byteLength5;
  var mul = 1;
  var val = this[offset2 + --i2];
  while (i2 > 0 && (mul *= 256)) {
    val += this[offset2 + --i2] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
}, "readIntBE");
Buffer$2.prototype.readInt8 = /* @__PURE__ */ __name(function readInt82(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 1, this.length);
  if (!(this[offset2] & 128)) return this[offset2];
  return (255 - this[offset2] + 1) * -1;
}, "readInt8");
Buffer$2.prototype.readInt16LE = /* @__PURE__ */ __name(function readInt16LE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 2, this.length);
  var val = this[offset2] | this[offset2 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
}, "readInt16LE");
Buffer$2.prototype.readInt16BE = /* @__PURE__ */ __name(function readInt16BE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 2, this.length);
  var val = this[offset2 + 1] | this[offset2] << 8;
  return val & 32768 ? val | 4294901760 : val;
}, "readInt16BE");
Buffer$2.prototype.readInt32LE = /* @__PURE__ */ __name(function readInt32LE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
}, "readInt32LE");
Buffer$2.prototype.readInt32BE = /* @__PURE__ */ __name(function readInt32BE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
}, "readInt32BE");
Buffer$2.prototype.readFloatLE = /* @__PURE__ */ __name(function readFloatLE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return read2(this, offset2, true, 23, 4);
}, "readFloatLE");
Buffer$2.prototype.readFloatBE = /* @__PURE__ */ __name(function readFloatBE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return read2(this, offset2, false, 23, 4);
}, "readFloatBE");
Buffer$2.prototype.readDoubleLE = /* @__PURE__ */ __name(function readDoubleLE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 8, this.length);
  return read2(this, offset2, true, 52, 8);
}, "readDoubleLE");
Buffer$2.prototype.readDoubleBE = /* @__PURE__ */ __name(function readDoubleBE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 8, this.length);
  return read2(this, offset2, false, 52, 8);
}, "readDoubleBE");
function checkInt2(buf, value2, offset2, ext, max2, min2) {
  if (!internalIsBuffer2(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max2 || value2 < min2) throw new RangeError('"value" argument is out of bounds');
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
}
__name(checkInt2, "checkInt");
Buffer$2.prototype.writeUIntLE = /* @__PURE__ */ __name(function writeUIntLE2(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt2(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i2 = 0;
  this[offset2] = value2 & 255;
  while (++i2 < byteLength5 && (mul *= 256)) {
    this[offset2 + i2] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
}, "writeUIntLE");
Buffer$2.prototype.writeUIntBE = /* @__PURE__ */ __name(function writeUIntBE2(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt2(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var i2 = byteLength5 - 1;
  var mul = 1;
  this[offset2 + i2] = value2 & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    this[offset2 + i2] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
}, "writeUIntBE");
Buffer$2.prototype.writeUInt8 = /* @__PURE__ */ __name(function writeUInt82(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 1, 255, 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset2] = value2 & 255;
  return offset2 + 1;
}, "writeUInt8");
function objectWriteUInt162(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i2 = 0, j = Math.min(buf.length - offset2, 2); i2 < j; ++i2) {
    buf[offset2 + i2] = (value2 & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
  }
}
__name(objectWriteUInt162, "objectWriteUInt16");
Buffer$2.prototype.writeUInt16LE = /* @__PURE__ */ __name(function writeUInt16LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt162(this, value2, offset2, true);
  }
  return offset2 + 2;
}, "writeUInt16LE");
Buffer$2.prototype.writeUInt16BE = /* @__PURE__ */ __name(function writeUInt16BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt162(this, value2, offset2, false);
  }
  return offset2 + 2;
}, "writeUInt16BE");
function objectWriteUInt322(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i2 = 0, j = Math.min(buf.length - offset2, 4); i2 < j; ++i2) {
    buf[offset2 + i2] = value2 >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
  }
}
__name(objectWriteUInt322, "objectWriteUInt32");
Buffer$2.prototype.writeUInt32LE = /* @__PURE__ */ __name(function writeUInt32LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2 + 3] = value2 >>> 24;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset2, true);
  }
  return offset2 + 4;
}, "writeUInt32LE");
Buffer$2.prototype.writeUInt32BE = /* @__PURE__ */ __name(function writeUInt32BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset2, false);
  }
  return offset2 + 4;
}, "writeUInt32BE");
Buffer$2.prototype.writeIntLE = /* @__PURE__ */ __name(function writeIntLE2(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt2(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i2 = 0;
  var mul = 1;
  var sub = 0;
  this[offset2] = value2 & 255;
  while (++i2 < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i2] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
}, "writeIntLE");
Buffer$2.prototype.writeIntBE = /* @__PURE__ */ __name(function writeIntBE2(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt2(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i2 = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset2 + i2] = value2 & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i2] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
}, "writeIntBE");
Buffer$2.prototype.writeInt8 = /* @__PURE__ */ __name(function writeInt82(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 1, 127, -128);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset2] = value2 & 255;
  return offset2 + 1;
}, "writeInt8");
Buffer$2.prototype.writeInt16LE = /* @__PURE__ */ __name(function writeInt16LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt162(this, value2, offset2, true);
  }
  return offset2 + 2;
}, "writeInt16LE");
Buffer$2.prototype.writeInt16BE = /* @__PURE__ */ __name(function writeInt16BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt162(this, value2, offset2, false);
  }
  return offset2 + 2;
}, "writeInt16BE");
Buffer$2.prototype.writeInt32LE = /* @__PURE__ */ __name(function writeInt32LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 4, 2147483647, -2147483648);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt322(this, value2, offset2, true);
  }
  return offset2 + 4;
}, "writeInt32LE");
Buffer$2.prototype.writeInt32BE = /* @__PURE__ */ __name(function writeInt32BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset2, false);
  }
  return offset2 + 4;
}, "writeInt32BE");
function checkIEEE7542(buf, value2, offset2, ext, max2, min2) {
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset2 < 0) throw new RangeError("Index out of range");
}
__name(checkIEEE7542, "checkIEEE754");
function writeFloat2(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value2, offset2, 4);
  }
  write3(buf, value2, offset2, littleEndian, 23, 4);
  return offset2 + 4;
}
__name(writeFloat2, "writeFloat");
Buffer$2.prototype.writeFloatLE = /* @__PURE__ */ __name(function writeFloatLE2(value2, offset2, noAssert) {
  return writeFloat2(this, value2, offset2, true, noAssert);
}, "writeFloatLE");
Buffer$2.prototype.writeFloatBE = /* @__PURE__ */ __name(function writeFloatBE2(value2, offset2, noAssert) {
  return writeFloat2(this, value2, offset2, false, noAssert);
}, "writeFloatBE");
function writeDouble2(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value2, offset2, 8);
  }
  write3(buf, value2, offset2, littleEndian, 52, 8);
  return offset2 + 8;
}
__name(writeDouble2, "writeDouble");
Buffer$2.prototype.writeDoubleLE = /* @__PURE__ */ __name(function writeDoubleLE2(value2, offset2, noAssert) {
  return writeDouble2(this, value2, offset2, true, noAssert);
}, "writeDoubleLE");
Buffer$2.prototype.writeDoubleBE = /* @__PURE__ */ __name(function writeDoubleBE2(value2, offset2, noAssert) {
  return writeDouble2(this, value2, offset2, false, noAssert);
}, "writeDoubleBE");
Buffer$2.prototype.copy = /* @__PURE__ */ __name(function copy2(target, targetStart, start2, end2) {
  if (!start2) start2 = 0;
  if (!end2 && end2 !== 0) end2 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end2 > 0 && end2 < start2) end2 = start2;
  if (end2 === start2) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start2 < 0 || start2 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end2 > this.length) end2 = this.length;
  if (target.length - targetStart < end2 - start2) {
    end2 = target.length - targetStart + start2;
  }
  var len = end2 - start2;
  var i2;
  if (this === target && start2 < targetStart && targetStart < end2) {
    for (i2 = len - 1; i2 >= 0; --i2) {
      target[i2 + targetStart] = this[i2 + start2];
    }
  } else if (len < 1e3 || !Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (i2 = 0; i2 < len; ++i2) {
      target[i2 + targetStart] = this[i2 + start2];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start2, start2 + len),
      targetStart
    );
  }
  return len;
}, "copy");
Buffer$2.prototype.fill = /* @__PURE__ */ __name(function fill2(val, start2, end2, encoding) {
  if (typeof val === "string") {
    if (typeof start2 === "string") {
      encoding = start2;
      start2 = 0;
      end2 = this.length;
    } else if (typeof end2 === "string") {
      encoding = end2;
      end2 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer$2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start2 < 0 || this.length < start2 || this.length < end2) {
    throw new RangeError("Out of range index");
  }
  if (end2 <= start2) {
    return this;
  }
  start2 = start2 >>> 0;
  end2 = end2 === void 0 ? this.length : end2 >>> 0;
  if (!val) val = 0;
  var i2;
  if (typeof val === "number") {
    for (i2 = start2; i2 < end2; ++i2) {
      this[i2] = val;
    }
  } else {
    var bytes = internalIsBuffer2(val) ? val : utf8ToBytes2(new Buffer$2(val, encoding).toString());
    var len = bytes.length;
    for (i2 = 0; i2 < end2 - start2; ++i2) {
      this[i2 + start2] = bytes[i2 % len];
    }
  }
  return this;
}, "fill");
var INVALID_BASE64_RE2 = /[^+\/0-9A-Za-z-_]/g;
function base64clean2(str) {
  str = stringtrim2(str).replace(INVALID_BASE64_RE2, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
__name(base64clean2, "base64clean");
function stringtrim2(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
__name(stringtrim2, "stringtrim");
function toHex$1(n5) {
  if (n5 < 16) return "0" + n5.toString(16);
  return n5.toString(16);
}
__name(toHex$1, "toHex$1");
function utf8ToBytes2(string, units) {
  units = units || Infinity;
  var codePoint;
  var length2 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i2 = 0; i2 < length2; ++i2) {
    codePoint = string.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length2) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
__name(utf8ToBytes2, "utf8ToBytes");
function asciiToBytes2(str) {
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    byteArray.push(str.charCodeAt(i2) & 255);
  }
  return byteArray;
}
__name(asciiToBytes2, "asciiToBytes");
function utf16leToBytes2(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    if ((units -= 2) < 0) break;
    c2 = str.charCodeAt(i2);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
__name(utf16leToBytes2, "utf16leToBytes");
function base64ToBytes2(str) {
  return toByteArray2(base64clean2(str));
}
__name(base64ToBytes2, "base64ToBytes");
function blitBuffer2(src, dst, offset2, length2) {
  for (var i2 = 0; i2 < length2; ++i2) {
    if (i2 + offset2 >= dst.length || i2 >= src.length) break;
    dst[i2 + offset2] = src[i2];
  }
  return i2;
}
__name(blitBuffer2, "blitBuffer");
function isnan2(val) {
  return val !== val;
}
__name(isnan2, "isnan");
function isBuffer$12(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer2(obj) || isSlowBuffer2(obj));
}
__name(isBuffer$12, "isBuffer$1");
function isFastBuffer2(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
__name(isFastBuffer2, "isFastBuffer");
function isSlowBuffer2(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer2(obj.slice(0, 0));
}
__name(isSlowBuffer2, "isSlowBuffer");
var _polyfillNode_buffer2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Buffer: Buffer$2,
  INSPECT_MAX_BYTES: INSPECT_MAX_BYTES2,
  SlowBuffer: SlowBuffer2,
  isBuffer: isBuffer$12,
  kMaxLength: _kMaxLength2
});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs2(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
__name(getDefaultExportFromCjs2, "getDefaultExportFromCjs");
function getAugmentedNamespace2(n5) {
  if (n5.__esModule) return n5;
  var f4 = n5.default;
  if (typeof f4 == "function") {
    var a4 = /* @__PURE__ */ __name(function a5() {
      if (this instanceof a5) {
        return Reflect.construct(f4, arguments, this.constructor);
      }
      return f4.apply(this, arguments);
    }, "a");
    a4.prototype = f4.prototype;
  } else a4 = {};
  Object.defineProperty(a4, "__esModule", { value: true });
  Object.keys(n5).forEach(function(k3) {
    var d3 = Object.getOwnPropertyDescriptor(n5, k3);
    Object.defineProperty(a4, k3, d3.get ? d3 : {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return n5[k3];
      }, "get")
    });
  });
  return a4;
}
__name(getAugmentedNamespace2, "getAugmentedNamespace");
var readableBrowser = { exports: {} };
var _registry = {};
function defaultSetTimout2() {
  throw new Error("setTimeout has not been defined");
}
__name(defaultSetTimout2, "defaultSetTimout");
function defaultClearTimeout2() {
  throw new Error("clearTimeout has not been defined");
}
__name(defaultClearTimeout2, "defaultClearTimeout");
var cachedSetTimeout2 = defaultSetTimout2;
var cachedClearTimeout2 = defaultClearTimeout2;
if (typeof global$12.setTimeout === "function") {
  cachedSetTimeout2 = setTimeout;
}
if (typeof global$12.clearTimeout === "function") {
  cachedClearTimeout2 = clearTimeout;
}
function runTimeout2(fun) {
  if (cachedSetTimeout2 === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
    cachedSetTimeout2 = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout2(fun, 0);
  } catch (e4) {
    try {
      return cachedSetTimeout2.call(null, fun, 0);
    } catch (e5) {
      return cachedSetTimeout2.call(this, fun, 0);
    }
  }
}
__name(runTimeout2, "runTimeout");
function runClearTimeout2(marker) {
  if (cachedClearTimeout2 === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
    cachedClearTimeout2 = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout2(marker);
  } catch (e4) {
    try {
      return cachedClearTimeout2.call(null, marker);
    } catch (e5) {
      return cachedClearTimeout2.call(this, marker);
    }
  }
}
__name(runClearTimeout2, "runClearTimeout");
var queue2 = [];
var draining2 = false;
var currentQueue2;
var queueIndex2 = -1;
function cleanUpNextTick2() {
  if (!draining2 || !currentQueue2) {
    return;
  }
  draining2 = false;
  if (currentQueue2.length) {
    queue2 = currentQueue2.concat(queue2);
  } else {
    queueIndex2 = -1;
  }
  if (queue2.length) {
    drainQueue2();
  }
}
__name(cleanUpNextTick2, "cleanUpNextTick");
function drainQueue2() {
  if (draining2) {
    return;
  }
  var timeout = runTimeout2(cleanUpNextTick2);
  draining2 = true;
  var len = queue2.length;
  while (len) {
    currentQueue2 = queue2;
    queue2 = [];
    while (++queueIndex2 < len) {
      if (currentQueue2) {
        currentQueue2[queueIndex2].run();
      }
    }
    queueIndex2 = -1;
    len = queue2.length;
  }
  currentQueue2 = null;
  draining2 = false;
  runClearTimeout2(timeout);
}
__name(drainQueue2, "drainQueue");
function nextTick3(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue2.push(new Item2(fun, args));
  if (queue2.length === 1 && !draining2) {
    runTimeout2(drainQueue2);
  }
}
__name(nextTick3, "nextTick");
function Item2(fun, array) {
  this.fun = fun;
  this.array = array;
}
__name(Item2, "Item");
Item2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title3 = "browser";
var platform3 = "browser";
var browser$12 = true;
var env3 = {};
var argv3 = [];
var version3 = "";
var versions3 = {};
var release3 = {};
var config$1 = {};
function noop$2() {
}
__name(noop$2, "noop$2");
var on3 = noop$2;
var addListener4 = noop$2;
var once$2 = noop$2;
var off3 = noop$2;
var removeListener4 = noop$2;
var removeAllListeners4 = noop$2;
var emit4 = noop$2;
function binding$12(name) {
  throw new Error("process.binding is not supported");
}
__name(binding$12, "binding$1");
function cwd3() {
  return "/";
}
__name(cwd3, "cwd");
function chdir3(dir3) {
  throw new Error("process.chdir is not supported");
}
__name(chdir3, "chdir");
function umask3() {
  return 0;
}
__name(umask3, "umask");
var performance4 = global$12.performance || {};
var performanceNow2 = performance4.now || performance4.mozNow || performance4.msNow || performance4.oNow || performance4.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime5(previousTimestamp) {
  var clocktime = performanceNow2.call(performance4) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
__name(hrtime5, "hrtime");
var startTime2 = /* @__PURE__ */ new Date();
function uptime3() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime2;
  return dif / 1e3;
}
__name(uptime3, "uptime");
var browser$1$1 = {
  nextTick: nextTick3,
  title: title3,
  browser: browser$12,
  env: env3,
  argv: argv3,
  version: version3,
  versions: versions3,
  on: on3,
  addListener: addListener4,
  once: once$2,
  off: off3,
  removeListener: removeListener4,
  removeAllListeners: removeAllListeners4,
  emit: emit4,
  binding: binding$12,
  cwd: cwd3,
  chdir: chdir3,
  umask: umask3,
  hrtime: hrtime5,
  platform: platform3,
  release: release3,
  config: config$1,
  uptime: uptime3
};
var domain3;
function EventHandlers2() {
}
__name(EventHandlers2, "EventHandlers");
EventHandlers2.prototype = /* @__PURE__ */ Object.create(null);
function EventEmitter3() {
  EventEmitter3.init.call(this);
}
__name(EventEmitter3, "EventEmitter");
EventEmitter3.EventEmitter = EventEmitter3;
EventEmitter3.usingDomains = false;
EventEmitter3.prototype.domain = void 0;
EventEmitter3.prototype._events = void 0;
EventEmitter3.prototype._maxListeners = void 0;
EventEmitter3.defaultMaxListeners = 10;
EventEmitter3.init = function() {
  this.domain = null;
  if (EventEmitter3.usingDomains) {
    if (domain3.active && !(this instanceof domain3.Domain)) {
      this.domain = domain3.active;
    }
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers2();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter3.prototype.setMaxListeners = /* @__PURE__ */ __name(function setMaxListeners3(n5) {
  if (typeof n5 !== "number" || n5 < 0 || isNaN(n5))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n5;
  return this;
}, "setMaxListeners");
function $getMaxListeners2(that) {
  if (that._maxListeners === void 0)
    return EventEmitter3.defaultMaxListeners;
  return that._maxListeners;
}
__name($getMaxListeners2, "$getMaxListeners");
EventEmitter3.prototype.getMaxListeners = /* @__PURE__ */ __name(function getMaxListeners3() {
  return $getMaxListeners2(this);
}, "getMaxListeners");
function emitNone2(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners4 = arrayClone2(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners4[i2].call(self2);
  }
}
__name(emitNone2, "emitNone");
function emitOne2(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners4 = arrayClone2(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners4[i2].call(self2, arg1);
  }
}
__name(emitOne2, "emitOne");
function emitTwo2(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners4 = arrayClone2(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners4[i2].call(self2, arg1, arg2);
  }
}
__name(emitTwo2, "emitTwo");
function emitThree2(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners4 = arrayClone2(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners4[i2].call(self2, arg1, arg2, arg3);
  }
}
__name(emitThree2, "emitThree");
function emitMany2(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners4 = arrayClone2(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners4[i2].apply(self2, args);
  }
}
__name(emitMany2, "emitMany");
EventEmitter3.prototype.emit = /* @__PURE__ */ __name(function emit5(type2) {
  var er, handler, len, args, i2, events2, domain4;
  var doError = type2 === "error";
  events2 = this._events;
  if (events2)
    doError = doError && events2.error == null;
  else if (!doError)
    return false;
  domain4 = this.domain;
  if (doError) {
    er = arguments[1];
    if (domain4) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain4;
      er.domainThrown = false;
      domain4.emit("error", er);
    } else if (er instanceof Error) {
      throw er;
    } else {
      var err2 = new Error('Uncaught, unspecified "error" event. (' + er + ")");
      err2.context = er;
      throw err2;
    }
    return false;
  }
  handler = events2[type2];
  if (!handler)
    return false;
  var isFn = typeof handler === "function";
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone2(handler, isFn, this);
      break;
    case 2:
      emitOne2(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo2(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree2(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i2 = 1; i2 < len; i2++)
        args[i2 - 1] = arguments[i2];
      emitMany2(handler, isFn, this, args);
  }
  return true;
}, "emit");
function _addListener2(target, type2, listener, prepend) {
  var m3;
  var events2;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = target._events;
  if (!events2) {
    events2 = target._events = new EventHandlers2();
    target._eventsCount = 0;
  } else {
    if (events2.newListener) {
      target.emit(
        "newListener",
        type2,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type2];
  }
  if (!existing) {
    existing = events2[type2] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m3 = $getMaxListeners2(target);
      if (m3 && m3 > 0 && existing.length > m3) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type2;
        w.count = existing.length;
        emitWarning3(w);
      }
    }
  }
  return target;
}
__name(_addListener2, "_addListener");
function emitWarning3(e4) {
  typeof console.warn === "function" ? console.warn(e4) : console.log(e4);
}
__name(emitWarning3, "emitWarning");
EventEmitter3.prototype.addListener = /* @__PURE__ */ __name(function addListener5(type2, listener) {
  return _addListener2(this, type2, listener, false);
}, "addListener");
EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
EventEmitter3.prototype.prependListener = /* @__PURE__ */ __name(function prependListener4(type2, listener) {
  return _addListener2(this, type2, listener, true);
}, "prependListener");
function _onceWrap2(target, type2, listener) {
  var fired = false;
  function g() {
    target.removeListener(type2, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  __name(g, "g");
  g.listener = listener;
  return g;
}
__name(_onceWrap2, "_onceWrap");
EventEmitter3.prototype.once = /* @__PURE__ */ __name(function once4(type2, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.on(type2, _onceWrap2(this, type2, listener));
  return this;
}, "once");
EventEmitter3.prototype.prependOnceListener = /* @__PURE__ */ __name(function prependOnceListener3(type2, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type2, _onceWrap2(this, type2, listener));
  return this;
}, "prependOnceListener");
EventEmitter3.prototype.removeListener = /* @__PURE__ */ __name(function removeListener5(type2, listener) {
  var list, events2, position, i2, originalListener;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = this._events;
  if (!events2)
    return this;
  list = events2[type2];
  if (!list)
    return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers2();
    else {
      delete events2[type2];
      if (events2.removeListener)
        this.emit("removeListener", type2, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length; i2-- > 0; ) {
      if (list[i2] === listener || list[i2].listener && list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (list.length === 1) {
      list[0] = void 0;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers2();
        return this;
      } else {
        delete events2[type2];
      }
    } else {
      spliceOne2(list, position);
    }
    if (events2.removeListener)
      this.emit("removeListener", type2, originalListener || listener);
  }
  return this;
}, "removeListener");
EventEmitter3.prototype.off = function(type2, listener) {
  return this.removeListener(type2, listener);
};
EventEmitter3.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners5(type2) {
  var listeners4, events2;
  events2 = this._events;
  if (!events2)
    return this;
  if (!events2.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers2();
      this._eventsCount = 0;
    } else if (events2[type2]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers2();
      else
        delete events2[type2];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    for (var i2 = 0, key; i2 < keys2.length; ++i2) {
      key = keys2[i2];
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = new EventHandlers2();
    this._eventsCount = 0;
    return this;
  }
  listeners4 = events2[type2];
  if (typeof listeners4 === "function") {
    this.removeListener(type2, listeners4);
  } else if (listeners4) {
    do {
      this.removeListener(type2, listeners4[listeners4.length - 1]);
    } while (listeners4[0]);
  }
  return this;
}, "removeAllListeners");
EventEmitter3.prototype.listeners = /* @__PURE__ */ __name(function listeners3(type2) {
  var evlistener;
  var ret;
  var events2 = this._events;
  if (!events2)
    ret = [];
  else {
    evlistener = events2[type2];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === "function")
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners2(evlistener);
  }
  return ret;
}, "listeners");
EventEmitter3.listenerCount = function(emitter, type2) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type2);
  } else {
    return listenerCount3.call(emitter, type2);
  }
};
EventEmitter3.prototype.listenerCount = listenerCount3;
function listenerCount3(type2) {
  var events2 = this._events;
  if (events2) {
    var evlistener = events2[type2];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
__name(listenerCount3, "listenerCount");
EventEmitter3.prototype.eventNames = /* @__PURE__ */ __name(function eventNames3() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
}, "eventNames");
function spliceOne2(list, index2) {
  for (var i2 = index2, k3 = i2 + 1, n5 = list.length; k3 < n5; i2 += 1, k3 += 1)
    list[i2] = list[k3];
  list.pop();
}
__name(spliceOne2, "spliceOne");
function arrayClone2(arr, i2) {
  var copy5 = new Array(i2);
  while (i2--)
    copy5[i2] = arr[i2];
  return copy5;
}
__name(arrayClone2, "arrayClone");
function unwrapListeners2(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
__name(unwrapListeners2, "unwrapListeners");
var _polyfillNode_events = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EventEmitter: EventEmitter3,
  default: EventEmitter3
});
var require$$1$1 = /* @__PURE__ */ getAugmentedNamespace2(_polyfillNode_events);
var streamBrowser = require$$1$1.EventEmitter;
var require$$02 = /* @__PURE__ */ getAugmentedNamespace2(_polyfillNode_buffer2);
var inherits$2;
if (typeof Object.create === "function") {
  inherits$2 = /* @__PURE__ */ __name(function inherits4(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  }, "inherits");
} else {
  inherits$2 = /* @__PURE__ */ __name(function inherits4(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = /* @__PURE__ */ __name(function() {
    }, "TempCtor");
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }, "inherits");
}
var getOwnPropertyDescriptors3 = Object.getOwnPropertyDescriptors || /* @__PURE__ */ __name(function getOwnPropertyDescriptors4(obj) {
  var keys2 = Object.keys(obj);
  var descriptors = {};
  for (var i2 = 0; i2 < keys2.length; i2++) {
    descriptors[keys2[i2]] = Object.getOwnPropertyDescriptor(obj, keys2[i2]);
  }
  return descriptors;
}, "getOwnPropertyDescriptors");
var formatRegExp2 = /%[sdj%]/g;
function format2(f4) {
  if (!isString2(f4)) {
    var objects = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      objects.push(inspect$12(arguments[i2]));
    }
    return objects.join(" ");
  }
  var i2 = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f4).replace(formatRegExp2, function(x2) {
    if (x2 === "%%") return "%";
    if (i2 >= len) return x2;
    switch (x2) {
      case "%s":
        return String(args[i2++]);
      case "%d":
        return Number(args[i2++]);
      case "%j":
        try {
          return JSON.stringify(args[i2++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i2]; i2 < len; x = args[++i2]) {
    if (isNull2(x) || !isObject2(x)) {
      str += " " + x;
    } else {
      str += " " + inspect$12(x);
    }
  }
  return str;
}
__name(format2, "format");
function deprecate$1(fn, msg2) {
  if (isUndefined2(global$12.process)) {
    return function() {
      return deprecate$1(fn, msg2).apply(this, arguments);
    };
  }
  if (browser$1$1.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1$1.throwDeprecation) {
        throw new Error(msg2);
      } else if (browser$1$1.traceDeprecation) {
        console.trace(msg2);
      } else {
        console.error(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  __name(deprecated, "deprecated");
  return deprecated;
}
__name(deprecate$1, "deprecate$1");
var debugs2 = {};
var debugEnviron2;
function debuglog2(set5) {
  if (isUndefined2(debugEnviron2))
    debugEnviron2 = browser$1$1.env.NODE_DEBUG || "";
  set5 = set5.toUpperCase();
  if (!debugs2[set5]) {
    if (new RegExp("\\b" + set5 + "\\b", "i").test(debugEnviron2)) {
      var pid2 = 0;
      debugs2[set5] = function() {
        var msg2 = format2.apply(null, arguments);
        console.error("%s %d: %s", set5, pid2, msg2);
      };
    } else {
      debugs2[set5] = function() {
      };
    }
  }
  return debugs2[set5];
}
__name(debuglog2, "debuglog");
function inspect$12(obj, opts2) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor2
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean2(opts2)) {
    ctx.showHidden = opts2;
  } else if (opts2) {
    _extend2(ctx, opts2);
  }
  if (isUndefined2(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined2(ctx.depth)) ctx.depth = 2;
  if (isUndefined2(ctx.colors)) ctx.colors = false;
  if (isUndefined2(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor2;
  return formatValue2(ctx, obj, ctx.depth);
}
__name(inspect$12, "inspect$1");
inspect$12.colors = {
  "bold": [1, 22],
  "italic": [3, 23],
  "underline": [4, 24],
  "inverse": [7, 27],
  "white": [37, 39],
  "grey": [90, 39],
  "black": [30, 39],
  "blue": [34, 39],
  "cyan": [36, 39],
  "green": [32, 39],
  "magenta": [35, 39],
  "red": [31, 39],
  "yellow": [33, 39]
};
inspect$12.styles = {
  "special": "cyan",
  "number": "yellow",
  "boolean": "yellow",
  "undefined": "grey",
  "null": "bold",
  "string": "green",
  "date": "magenta",
  // "name": intentionally not styling
  "regexp": "red"
};
function stylizeWithColor2(str, styleType) {
  var style = inspect$12.styles[styleType];
  if (style) {
    return "\x1B[" + inspect$12.colors[style][0] + "m" + str + "\x1B[" + inspect$12.colors[style][1] + "m";
  } else {
    return str;
  }
}
__name(stylizeWithColor2, "stylizeWithColor");
function stylizeNoColor2(str, styleType) {
  return str;
}
__name(stylizeNoColor2, "stylizeNoColor");
function arrayToHash2(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
__name(arrayToHash2, "arrayToHash");
function formatValue2(ctx, value2, recurseTimes) {
  if (ctx.customInspect && value2 && isFunction2(value2.inspect) && // Filter out the util module, it's inspect function is special
  value2.inspect !== inspect$12 && // Also filter out any prototype objects using the circular check.
  !(value2.constructor && value2.constructor.prototype === value2)) {
    var ret = value2.inspect(recurseTimes, ctx);
    if (!isString2(ret)) {
      ret = formatValue2(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive2(ctx, value2);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value2);
  var visibleKeys = arrayToHash2(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value2);
  }
  if (isError2(value2) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError2(value2);
  }
  if (keys2.length === 0) {
    if (isFunction2(value2)) {
      var name = value2.name ? ": " + value2.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp2(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    }
    if (isDate2(value2)) {
      return ctx.stylize(Date.prototype.toString.call(value2), "date");
    }
    if (isError2(value2)) {
      return formatError2(value2);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray2(value2)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction2(value2)) {
    var n5 = value2.name ? ": " + value2.name : "";
    base = " [Function" + n5 + "]";
  }
  if (isRegExp2(value2)) {
    base = " " + RegExp.prototype.toString.call(value2);
  }
  if (isDate2(value2)) {
    base = " " + Date.prototype.toUTCString.call(value2);
  }
  if (isError2(value2)) {
    base = " " + formatError2(value2);
  }
  if (keys2.length === 0 && (!array || value2.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp2(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value2);
  var output;
  if (array) {
    output = formatArray2(ctx, value2, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty2(ctx, value2, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString2(output, base, braces);
}
__name(formatValue2, "formatValue");
function formatPrimitive2(ctx, value2) {
  if (isUndefined2(value2))
    return ctx.stylize("undefined", "undefined");
  if (isString2(value2)) {
    var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber2(value2))
    return ctx.stylize("" + value2, "number");
  if (isBoolean2(value2))
    return ctx.stylize("" + value2, "boolean");
  if (isNull2(value2))
    return ctx.stylize("null", "null");
}
__name(formatPrimitive2, "formatPrimitive");
function formatError2(value2) {
  return "[" + Error.prototype.toString.call(value2) + "]";
}
__name(formatError2, "formatError");
function formatArray2(ctx, value2, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i2 = 0, l4 = value2.length; i2 < l4; ++i2) {
    if (hasOwnProperty2(value2, String(i2))) {
      output.push(formatProperty2(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        String(i2),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty2(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
__name(formatArray2, "formatArray");
function formatProperty2(ctx, value2, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value2, key) || { value: value2[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty2(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull2(recurseTimes)) {
        str = formatValue2(ctx, desc.value, null);
      } else {
        str = formatValue2(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line2) {
            return "  " + line2;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line2) {
            return "   " + line2;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined2(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
__name(formatProperty2, "formatProperty");
function reduceToSingleString2(output, base, braces) {
  var length2 = output.reduce(function(prev, cur) {
    if (cur.indexOf("\n") >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length2 > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
__name(reduceToSingleString2, "reduceToSingleString");
function isArray2(ar) {
  return Array.isArray(ar);
}
__name(isArray2, "isArray");
function isBoolean2(arg) {
  return typeof arg === "boolean";
}
__name(isBoolean2, "isBoolean");
function isNull2(arg) {
  return arg === null;
}
__name(isNull2, "isNull");
function isNullOrUndefined2(arg) {
  return arg == null;
}
__name(isNullOrUndefined2, "isNullOrUndefined");
function isNumber2(arg) {
  return typeof arg === "number";
}
__name(isNumber2, "isNumber");
function isString2(arg) {
  return typeof arg === "string";
}
__name(isString2, "isString");
function isSymbol2(arg) {
  return typeof arg === "symbol";
}
__name(isSymbol2, "isSymbol");
function isUndefined2(arg) {
  return arg === void 0;
}
__name(isUndefined2, "isUndefined");
function isRegExp2(re) {
  return isObject2(re) && objectToString2(re) === "[object RegExp]";
}
__name(isRegExp2, "isRegExp");
function isObject2(arg) {
  return typeof arg === "object" && arg !== null;
}
__name(isObject2, "isObject");
function isDate2(d3) {
  return isObject2(d3) && objectToString2(d3) === "[object Date]";
}
__name(isDate2, "isDate");
function isError2(e4) {
  return isObject2(e4) && (objectToString2(e4) === "[object Error]" || e4 instanceof Error);
}
__name(isError2, "isError");
function isFunction2(arg) {
  return typeof arg === "function";
}
__name(isFunction2, "isFunction");
function isPrimitive2(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
__name(isPrimitive2, "isPrimitive");
function isBuffer2(maybeBuf) {
  return Buffer$2.isBuffer(maybeBuf);
}
__name(isBuffer2, "isBuffer");
function objectToString2(o4) {
  return Object.prototype.toString.call(o4);
}
__name(objectToString2, "objectToString");
function pad$1(n5) {
  return n5 < 10 ? "0" + n5.toString(10) : n5.toString(10);
}
__name(pad$1, "pad$1");
var months2 = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp2() {
  var d3 = /* @__PURE__ */ new Date();
  var time3 = [
    pad$1(d3.getHours()),
    pad$1(d3.getMinutes()),
    pad$1(d3.getSeconds())
  ].join(":");
  return [d3.getDate(), months2[d3.getMonth()], time3].join(" ");
}
__name(timestamp2, "timestamp");
function log4() {
  console.log("%s - %s", timestamp2(), format2.apply(null, arguments));
}
__name(log4, "log");
function _extend2(origin, add2) {
  if (!add2 || !isObject2(add2)) return origin;
  var keys2 = Object.keys(add2);
  var i2 = keys2.length;
  while (i2--) {
    origin[keys2[i2]] = add2[keys2[i2]];
  }
  return origin;
}
__name(_extend2, "_extend");
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
__name(hasOwnProperty2, "hasOwnProperty");
var kCustomPromisifiedSymbol2 = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
function promisify2(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol2 && original[kCustomPromisifiedSymbol2]) {
    var fn = original[kCustomPromisifiedSymbol2];
    if (typeof fn !== "function") {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol2, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }
  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function(resolve3, reject) {
      promiseResolve = resolve3;
      promiseReject = reject;
    });
    var args = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      args.push(arguments[i2]);
    }
    args.push(function(err2, value2) {
      if (err2) {
        promiseReject(err2);
      } else {
        promiseResolve(value2);
      }
    });
    try {
      original.apply(this, args);
    } catch (err2) {
      promiseReject(err2);
    }
    return promise;
  }
  __name(fn, "fn");
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol2) Object.defineProperty(fn, kCustomPromisifiedSymbol2, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors3(original)
  );
}
__name(promisify2, "promisify");
promisify2.custom = kCustomPromisifiedSymbol2;
function callbackifyOnRejected2(reason, cb) {
  if (!reason) {
    var newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
__name(callbackifyOnRejected2, "callbackifyOnRejected");
function callbackify2(original) {
  if (typeof original !== "function") {
    throw new TypeError('The "original" argument must be of type Function');
  }
  function callbackified() {
    var args = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      args.push(arguments[i2]);
    }
    var maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new TypeError("The last argument must be of type Function");
    }
    var self2 = this;
    var cb = /* @__PURE__ */ __name(function() {
      return maybeCb.apply(self2, arguments);
    }, "cb");
    original.apply(this, args).then(
      function(ret) {
        browser$1$1.nextTick(cb.bind(null, null, ret));
      },
      function(rej) {
        browser$1$1.nextTick(callbackifyOnRejected2.bind(null, rej, cb));
      }
    );
  }
  __name(callbackified, "callbackified");
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors3(original));
  return callbackified;
}
__name(callbackify2, "callbackify");
var _polyfillNode_util2 = {
  inherits: inherits$2,
  _extend: _extend2,
  log: log4,
  isBuffer: isBuffer2,
  isPrimitive: isPrimitive2,
  isFunction: isFunction2,
  isError: isError2,
  isDate: isDate2,
  isObject: isObject2,
  isRegExp: isRegExp2,
  isUndefined: isUndefined2,
  isSymbol: isSymbol2,
  isString: isString2,
  isNumber: isNumber2,
  isNullOrUndefined: isNullOrUndefined2,
  isNull: isNull2,
  isBoolean: isBoolean2,
  isArray: isArray2,
  inspect: inspect$12,
  deprecate: deprecate$1,
  format: format2,
  debuglog: debuglog2,
  promisify: promisify2,
  callbackify: callbackify2
};
var _polyfillNode_util$12 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _extend: _extend2,
  callbackify: callbackify2,
  debuglog: debuglog2,
  default: _polyfillNode_util2,
  deprecate: deprecate$1,
  format: format2,
  inherits: inherits$2,
  inspect: inspect$12,
  isArray: isArray2,
  isBoolean: isBoolean2,
  isBuffer: isBuffer2,
  isDate: isDate2,
  isError: isError2,
  isFunction: isFunction2,
  isNull: isNull2,
  isNullOrUndefined: isNullOrUndefined2,
  isNumber: isNumber2,
  isObject: isObject2,
  isPrimitive: isPrimitive2,
  isRegExp: isRegExp2,
  isString: isString2,
  isSymbol: isSymbol2,
  isUndefined: isUndefined2,
  log: log4,
  promisify: promisify2
});
var require$$32 = /* @__PURE__ */ getAugmentedNamespace2(_polyfillNode_util$12);
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  __name(ownKeys, "ownKeys");
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  __name(_objectSpread, "_objectSpread");
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  __name(_defineProperty, "_defineProperty");
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  __name(_classCallCheck, "_classCallCheck");
  function _defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  __name(_defineProperties, "_defineProperties");
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    return Constructor;
  }
  __name(_createClass, "_createClass");
  var _require2 = require$$02, Buffer5 = _require2.Buffer;
  var _require22 = require$$32, inspect6 = _require22.inspect;
  var custom = inspect6 && inspect6.custom || "inspect";
  function copyBuffer(src, target, offset2) {
    Buffer5.prototype.copy.call(src, target, offset2);
  }
  __name(copyBuffer, "copyBuffer");
  buffer_list = /* @__PURE__ */ function() {
    function BufferList3() {
      _classCallCheck(this, BufferList3);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    __name(BufferList3, "BufferList");
    _createClass(BufferList3, [{
      key: "push",
      value: /* @__PURE__ */ __name(function push(v3) {
        var entry = {
          data: v3,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }, "push")
    }, {
      key: "unshift",
      value: /* @__PURE__ */ __name(function unshift(v3) {
        var entry = {
          data: v3,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }, "unshift")
    }, {
      key: "shift",
      value: /* @__PURE__ */ __name(function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }, "shift")
    }, {
      key: "clear",
      value: /* @__PURE__ */ __name(function clear3() {
        this.head = this.tail = null;
        this.length = 0;
      }, "clear")
    }, {
      key: "join",
      value: /* @__PURE__ */ __name(function join(s4) {
        if (this.length === 0) return "";
        var p3 = this.head;
        var ret = "" + p3.data;
        while (p3 = p3.next) {
          ret += s4 + p3.data;
        }
        return ret;
      }, "join")
    }, {
      key: "concat",
      value: /* @__PURE__ */ __name(function concat5(n5) {
        if (this.length === 0) return Buffer5.alloc(0);
        var ret = Buffer5.allocUnsafe(n5 >>> 0);
        var p3 = this.head;
        var i2 = 0;
        while (p3) {
          copyBuffer(p3.data, ret, i2);
          i2 += p3.data.length;
          p3 = p3.next;
        }
        return ret;
      }, "concat")
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: /* @__PURE__ */ __name(function consume(n5, hasStrings) {
        var ret;
        if (n5 < this.head.data.length) {
          ret = this.head.data.slice(0, n5);
          this.head.data = this.head.data.slice(n5);
        } else if (n5 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n5) : this._getBuffer(n5);
        }
        return ret;
      }, "consume")
    }, {
      key: "first",
      value: /* @__PURE__ */ __name(function first() {
        return this.head.data;
      }, "first")
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: /* @__PURE__ */ __name(function _getString(n5) {
        var p3 = this.head;
        var c2 = 1;
        var ret = p3.data;
        n5 -= ret.length;
        while (p3 = p3.next) {
          var str = p3.data;
          var nb = n5 > str.length ? str.length : n5;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n5);
          n5 -= nb;
          if (n5 === 0) {
            if (nb === str.length) {
              ++c2;
              if (p3.next) this.head = p3.next;
              else this.head = this.tail = null;
            } else {
              this.head = p3;
              p3.data = str.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }, "_getString")
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: /* @__PURE__ */ __name(function _getBuffer(n5) {
        var ret = Buffer5.allocUnsafe(n5);
        var p3 = this.head;
        var c2 = 1;
        p3.data.copy(ret);
        n5 -= p3.data.length;
        while (p3 = p3.next) {
          var buf = p3.data;
          var nb = n5 > buf.length ? buf.length : n5;
          buf.copy(ret, ret.length - n5, 0, nb);
          n5 -= nb;
          if (n5 === 0) {
            if (nb === buf.length) {
              ++c2;
              if (p3.next) this.head = p3.next;
              else this.head = this.tail = null;
            } else {
              this.head = p3;
              p3.data = buf.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }, "_getBuffer")
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: /* @__PURE__ */ __name(function value2(_, options) {
        return inspect6(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }, "value")
    }]);
    return BufferList3;
  }();
  return buffer_list;
}
__name(requireBuffer_list, "requireBuffer_list");
function destroy(err2, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err2);
    } else if (err2) {
      if (!this._writableState) {
        browser$1$1.nextTick(emitErrorNT, this, err2);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        browser$1$1.nextTick(emitErrorNT, this, err2);
      }
    }
    return this;
  }
  if (this._readableState) {
    this._readableState.destroyed = true;
  }
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err2 || null, function(err3) {
    if (!cb && err3) {
      if (!_this._writableState) {
        browser$1$1.nextTick(emitErrorAndCloseNT, _this, err3);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        browser$1$1.nextTick(emitErrorAndCloseNT, _this, err3);
      } else {
        browser$1$1.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      browser$1$1.nextTick(emitCloseNT, _this);
      cb(err3);
    } else {
      browser$1$1.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
__name(destroy, "destroy");
function emitErrorAndCloseNT(self2, err2) {
  emitErrorNT(self2, err2);
  emitCloseNT(self2);
}
__name(emitErrorAndCloseNT, "emitErrorAndCloseNT");
function emitCloseNT(self2) {
  if (self2._writableState && !self2._writableState.emitClose) return;
  if (self2._readableState && !self2._readableState.emitClose) return;
  self2.emit("close");
}
__name(emitCloseNT, "emitCloseNT");
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
__name(undestroy, "undestroy");
function emitErrorNT(self2, err2) {
  self2.emit("error", err2);
}
__name(emitErrorNT, "emitErrorNT");
function errorOrDestroy$2(stream2, err2) {
  var rState = stream2._readableState;
  var wState = stream2._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream2.destroy(err2);
  else stream2.emit("error", err2);
}
__name(errorOrDestroy$2, "errorOrDestroy$2");
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy: errorOrDestroy$2
};
var errorsBrowser = {};
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
__name(_inheritsLoose, "_inheritsLoose");
var codes = {};
function createErrorType(code, message, Base2) {
  if (!Base2) {
    Base2 = Error;
  }
  function getMessage3(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  __name(getMessage3, "getMessage");
  var NodeError = /* @__PURE__ */ function(_Base) {
    _inheritsLoose(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      return _Base.call(this, getMessage3(arg1, arg2, arg3)) || this;
    }
    __name(NodeError2, "NodeError");
    return NodeError2;
  }(Base2);
  NodeError.prototype.name = Base2.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
}
__name(createErrorType, "createErrorType");
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function(i2) {
      return String(i2);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
__name(oneOf, "oneOf");
function startsWith(str, search, pos) {
  return str.substr(0, search.length) === search;
}
__name(startsWith, "startsWith");
function endsWith(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
__name(endsWith, "endsWith");
function includes3(str, search, start2) {
  if (typeof start2 !== "number") {
    start2 = 0;
  }
  if (start2 + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start2) !== -1;
  }
}
__name(includes3, "includes");
createErrorType("ERR_INVALID_OPT_VALUE", function(name, value2) {
  return 'The value "' + value2 + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
  var determiner;
  if (typeof expected === "string" && startsWith(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg2;
  if (endsWith(name, " argument")) {
    msg2 = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  } else {
    var type2 = includes3(name, ".") ? "property" : "argument";
    msg2 = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  }
  msg2 += ". Received type ".concat(typeof actual);
  return msg2;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
  return "The " + name + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name) {
  return "Cannot call " + name + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
  return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
__name(highWaterMarkFrom, "highWaterMarkFrom");
function getHighWaterMark$2(state2, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }
  return state2.objectMode ? 16 : 16 * 1024;
}
__name(getHighWaterMark$2, "getHighWaterMark$2");
var state = {
  getHighWaterMark: getHighWaterMark$2
};
var inherits3;
if (typeof Object.create === "function") {
  inherits3 = /* @__PURE__ */ __name(function inherits4(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  }, "inherits");
} else {
  inherits3 = /* @__PURE__ */ __name(function inherits4(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = /* @__PURE__ */ __name(function() {
    }, "TempCtor");
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }, "inherits");
}
var inherits$12 = inherits3;
var _polyfillNode_inherits = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: inherits$12
});
var require$$12 = /* @__PURE__ */ getAugmentedNamespace2(_polyfillNode_inherits);
var isBufferEncoding2 = Buffer$2.isEncoding || function(encoding) {
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function assertEncoding2(encoding) {
  if (encoding && !isBufferEncoding2(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
__name(assertEncoding2, "assertEncoding");
function StringDecoder$1(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding2(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar2;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar2;
      break;
    default:
      this.write = passThroughWrite2;
      return;
  }
  this.charBuffer = new Buffer$2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
__name(StringDecoder$1, "StringDecoder$1");
StringDecoder$1.prototype.write = function(buffer) {
  var charStr = "";
  while (this.charLength) {
    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;
    if (this.charReceived < this.charLength) {
      return "";
    }
    buffer = buffer.slice(available, buffer.length);
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 55296 && charCode <= 56319) {
      this.charLength += this.surrogateSize;
      charStr = "";
      continue;
    }
    this.charReceived = this.charLength = 0;
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }
  this.detectIncompleteChar(buffer);
  var end2 = buffer.length;
  if (this.charLength) {
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end2);
    end2 -= this.charReceived;
  }
  charStr += buffer.toString(this.encoding, 0, end2);
  var end2 = charStr.length - 1;
  var charCode = charStr.charCodeAt(end2);
  if (charCode >= 55296 && charCode <= 56319) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end2);
  }
  return charStr;
};
StringDecoder$1.prototype.detectIncompleteChar = function(buffer) {
  var i2 = buffer.length >= 3 ? 3 : buffer.length;
  for (; i2 > 0; i2--) {
    var c2 = buffer[buffer.length - i2];
    if (i2 == 1 && c2 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (i2 <= 2 && c2 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (i2 <= 3 && c2 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i2;
};
StringDecoder$1.prototype.end = function(buffer) {
  var res = "";
  if (buffer && buffer.length)
    res = this.write(buffer);
  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }
  return res;
};
function passThroughWrite2(buffer) {
  return buffer.toString(this.encoding);
}
__name(passThroughWrite2, "passThroughWrite");
function utf16DetectIncompleteChar2(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
__name(utf16DetectIncompleteChar2, "utf16DetectIncompleteChar");
function base64DetectIncompleteChar2(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
__name(base64DetectIncompleteChar2, "base64DetectIncompleteChar");
var _polyfillNode_string_decoder = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  StringDecoder: StringDecoder$1
});
var require$$10 = /* @__PURE__ */ getAugmentedNamespace2(_polyfillNode_string_decoder);
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(callback) {
  var called = false;
  return function() {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
__name(once$1, "once$1");
function noop$1() {
}
__name(noop$1, "noop$1");
function isRequest$1(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
__name(isRequest$1, "isRequest$1");
function eos$1(stream2, opts2, callback) {
  if (typeof opts2 === "function") return eos$1(stream2, null, opts2);
  if (!opts2) opts2 = {};
  callback = once$1(callback || noop$1);
  var readable = opts2.readable || opts2.readable !== false && stream2.readable;
  var writable = opts2.writable || opts2.writable !== false && stream2.writable;
  var onlegacyfinish = /* @__PURE__ */ __name(function onlegacyfinish2() {
    if (!stream2.writable) onfinish();
  }, "onlegacyfinish");
  var writableEnded = stream2._writableState && stream2._writableState.finished;
  var onfinish = /* @__PURE__ */ __name(function onfinish2() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream2);
  }, "onfinish");
  var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
  var onend3 = /* @__PURE__ */ __name(function onend4() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream2);
  }, "onend");
  var onerror = /* @__PURE__ */ __name(function onerror2(err2) {
    callback.call(stream2, err2);
  }, "onerror");
  var onclose = /* @__PURE__ */ __name(function onclose2() {
    var err2;
    if (readable && !readableEnded) {
      if (!stream2._readableState || !stream2._readableState.ended) err2 = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err2);
    }
    if (writable && !writableEnded) {
      if (!stream2._writableState || !stream2._writableState.ended) err2 = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err2);
    }
  }, "onclose");
  var onrequest = /* @__PURE__ */ __name(function onrequest2() {
    stream2.req.on("finish", onfinish);
  }, "onrequest");
  if (isRequest$1(stream2)) {
    stream2.on("complete", onfinish);
    stream2.on("abort", onclose);
    if (stream2.req) onrequest();
    else stream2.on("request", onrequest);
  } else if (writable && !stream2._writableState) {
    stream2.on("end", onlegacyfinish);
    stream2.on("close", onlegacyfinish);
  }
  stream2.on("end", onend3);
  stream2.on("finish", onfinish);
  if (opts2.error !== false) stream2.on("error", onerror);
  stream2.on("close", onclose);
  return function() {
    stream2.removeListener("complete", onfinish);
    stream2.removeListener("abort", onclose);
    stream2.removeListener("request", onrequest);
    if (stream2.req) stream2.req.removeListener("finish", onfinish);
    stream2.removeListener("end", onlegacyfinish);
    stream2.removeListener("close", onlegacyfinish);
    stream2.removeListener("finish", onfinish);
    stream2.removeListener("end", onend3);
    stream2.removeListener("error", onerror);
    stream2.removeListener("close", onclose);
  };
}
__name(eos$1, "eos$1");
var endOfStream = eos$1;
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  __name(_defineProperty, "_defineProperty");
  var finished = endOfStream;
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value2, done3) {
    return {
      value: value2,
      done: done3
    };
  }
  __name(createIterResult, "createIterResult");
  function readAndResolve(iter) {
    var resolve3 = iter[kLastResolve];
    if (resolve3 !== null) {
      var data2 = iter[kStream].read();
      if (data2 !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve3(createIterResult(data2, false));
      }
    }
  }
  __name(readAndResolve, "readAndResolve");
  function onReadable(iter) {
    browser$1$1.nextTick(readAndResolve, iter);
  }
  __name(onReadable, "onReadable");
  function wrapForNext(lastPromise, iter) {
    return function(resolve3, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve3(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve3, reject);
      }, reject);
    };
  }
  __name(wrapForNext, "wrapForNext");
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: /* @__PURE__ */ __name(function next() {
      var _this = this;
      var error3 = this[kError];
      if (error3 !== null) {
        return Promise.reject(error3);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve3, reject) {
          browser$1$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve3(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data2 = this[kStream].read();
        if (data2 !== null) {
          return Promise.resolve(createIterResult(data2, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }, "next")
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", /* @__PURE__ */ __name(function _return() {
    var _this2 = this;
    return new Promise(function(resolve3, reject) {
      _this2[kStream].destroy(null, function(err2) {
        if (err2) {
          reject(err2);
          return;
        }
        resolve3(createIterResult(void 0, true));
      });
    });
  }, "_return")), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator2 = /* @__PURE__ */ __name(function createReadableStreamAsyncIterator3(stream2) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream2,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: /* @__PURE__ */ __name(function value2(resolve3, reject) {
        var data2 = iterator[kStream].read();
        if (data2) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve3(createIterResult(data2, false));
        } else {
          iterator[kLastResolve] = resolve3;
          iterator[kLastReject] = reject;
        }
      }, "value"),
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream2, function(err2) {
      if (err2 && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err2);
        }
        iterator[kError] = err2;
        return;
      }
      var resolve3 = iterator[kLastResolve];
      if (resolve3 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve3(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream2.on("readable", onReadable.bind(null, iterator));
    return iterator;
  }, "createReadableStreamAsyncIterator");
  async_iterator = createReadableStreamAsyncIterator2;
  return async_iterator;
}
__name(requireAsync_iterator, "requireAsync_iterator");
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser) return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = /* @__PURE__ */ __name(function() {
    throw new Error("Readable.from is not available in the browser");
  }, "fromBrowser");
  return fromBrowser;
}
__name(requireFromBrowser, "requireFromBrowser");
var Registry$4 = _registry;
Registry$4.Readable = Readable2;
Readable2.ReadableState = ReadableState2;
require$$1$1.EventEmitter;
var EElistenerCount = /* @__PURE__ */ __name(function EElistenerCount2(emitter, type2) {
  return emitter.listeners(type2).length;
}, "EElistenerCount");
var Stream$1 = streamBrowser;
var Buffer$1 = require$$02.Buffer;
var OurUint8Array$1 = commonjsGlobal.Uint8Array || function() {
};
function _uint8ArrayToBuffer$1(chunk) {
  return Buffer$1.from(chunk);
}
__name(_uint8ArrayToBuffer$1, "_uint8ArrayToBuffer$1");
function _isUint8Array$1(obj) {
  return Buffer$1.isBuffer(obj) || obj instanceof OurUint8Array$1;
}
__name(_isUint8Array$1, "_isUint8Array$1");
var debugUtil = require$$32;
var debug4;
if (debugUtil && debugUtil.debuglog) {
  debug4 = debugUtil.debuglog("stream");
} else {
  debug4 = /* @__PURE__ */ __name(function debug5() {
  }, "debug");
}
var BufferList2 = requireBuffer_list();
var destroyImpl$1 = destroy_1;
var _require$1 = state;
var getHighWaterMark$1 = _require$1.getHighWaterMark;
var _require$codes$3 = errorsBrowser.codes;
var ERR_INVALID_ARG_TYPE$1 = _require$codes$3.ERR_INVALID_ARG_TYPE;
var ERR_STREAM_PUSH_AFTER_EOF = _require$codes$3.ERR_STREAM_PUSH_AFTER_EOF;
var ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$3.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
var StringDecoder2;
var createReadableStreamAsyncIterator;
var from2;
require$$12(Readable2, Stream$1);
var errorOrDestroy$1 = destroyImpl$1.errorOrDestroy;
var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
function prependListener5(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
  else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
  else emitter._events[event] = [fn, emitter._events[event]];
}
__name(prependListener5, "prependListener");
function ReadableState2(options, stream2, isDuplex) {
  options = options || {};
  if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Registry$4.Duplex;
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
  this.highWaterMark = getHighWaterMark$1(this, options, "readableHighWaterMark", isDuplex);
  this.buffer = new BufferList2();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;
  this.emitClose = options.emitClose !== false;
  this.autoDestroy = !!options.autoDestroy;
  this.destroyed = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder2) StringDecoder2 = require$$10.StringDecoder;
    this.decoder = new StringDecoder2(options.encoding);
    this.encoding = options.encoding;
  }
}
__name(ReadableState2, "ReadableState");
function Readable2(options) {
  if (!(this instanceof Readable2)) return new Readable2(options);
  var isDuplex = this instanceof Registry$4.Duplex;
  this._readableState = new ReadableState2(options, this, isDuplex);
  this.readable = true;
  if (options) {
    if (typeof options.read === "function") this._read = options.read;
    if (typeof options.destroy === "function") this._destroy = options.destroy;
  }
  Stream$1.call(this);
}
__name(Readable2, "Readable");
Object.defineProperty(Readable2.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: /* @__PURE__ */ __name(function get() {
    if (this._readableState === void 0) {
      return false;
    }
    return this._readableState.destroyed;
  }, "get"),
  set: /* @__PURE__ */ __name(function set(value2) {
    if (!this._readableState) {
      return;
    }
    this._readableState.destroyed = value2;
  }, "set")
});
Readable2.prototype.destroy = destroyImpl$1.destroy;
Readable2.prototype._undestroy = destroyImpl$1.undestroy;
Readable2.prototype._destroy = function(err2, cb) {
  cb(err2);
};
Readable2.prototype.push = function(chunk, encoding) {
  var state2 = this._readableState;
  var skipChunkCheck;
  if (!state2.objectMode) {
    if (typeof chunk === "string") {
      encoding = encoding || state2.defaultEncoding;
      if (encoding !== state2.encoding) {
        chunk = Buffer$1.from(chunk, encoding);
        encoding = "";
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
};
Readable2.prototype.unshift = function(chunk) {
  return readableAddChunk2(this, chunk, null, true, false);
};
function readableAddChunk2(stream2, chunk, encoding, addToFront, skipChunkCheck) {
  debug4("readableAddChunk", chunk);
  var state2 = stream2._readableState;
  if (chunk === null) {
    state2.reading = false;
    onEofChunk2(stream2, state2);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid2(state2, chunk);
    if (er) {
      errorOrDestroy$1(stream2, er);
    } else if (state2.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer$1.prototype) {
        chunk = _uint8ArrayToBuffer$1(chunk);
      }
      if (addToFront) {
        if (state2.endEmitted) errorOrDestroy$1(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
        else addChunk(stream2, state2, chunk, true);
      } else if (state2.ended) {
        errorOrDestroy$1(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state2.destroyed) {
        return false;
      } else {
        state2.reading = false;
        if (state2.decoder && !encoding) {
          chunk = state2.decoder.write(chunk);
          if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
          else maybeReadMore2(stream2, state2);
        } else {
          addChunk(stream2, state2, chunk, false);
        }
      }
    } else if (!addToFront) {
      state2.reading = false;
      maybeReadMore2(stream2, state2);
    }
  }
  return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
}
__name(readableAddChunk2, "readableAddChunk");
function addChunk(stream2, state2, chunk, addToFront) {
  if (state2.flowing && state2.length === 0 && !state2.sync) {
    state2.awaitDrain = 0;
    stream2.emit("data", chunk);
  } else {
    state2.length += state2.objectMode ? 1 : chunk.length;
    if (addToFront) state2.buffer.unshift(chunk);
    else state2.buffer.push(chunk);
    if (state2.needReadable) emitReadable2(stream2);
  }
  maybeReadMore2(stream2, state2);
}
__name(addChunk, "addChunk");
function chunkInvalid2(state2, chunk) {
  var er;
  if (!_isUint8Array$1(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
    er = new ERR_INVALID_ARG_TYPE$1("chunk", ["string", "Buffer", "Uint8Array"], chunk);
  }
  return er;
}
__name(chunkInvalid2, "chunkInvalid");
Readable2.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
Readable2.prototype.setEncoding = function(enc) {
  if (!StringDecoder2) StringDecoder2 = require$$10.StringDecoder;
  var decoder2 = new StringDecoder2(enc);
  this._readableState.decoder = decoder2;
  this._readableState.encoding = this._readableState.decoder.encoding;
  var p3 = this._readableState.buffer.head;
  var content = "";
  while (p3 !== null) {
    content += decoder2.write(p3.data);
    p3 = p3.next;
  }
  this._readableState.buffer.clear();
  if (content !== "") this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};
var MAX_HWM2 = 1073741824;
function computeNewHighWaterMark2(n5) {
  if (n5 >= MAX_HWM2) {
    n5 = MAX_HWM2;
  } else {
    n5--;
    n5 |= n5 >>> 1;
    n5 |= n5 >>> 2;
    n5 |= n5 >>> 4;
    n5 |= n5 >>> 8;
    n5 |= n5 >>> 16;
    n5++;
  }
  return n5;
}
__name(computeNewHighWaterMark2, "computeNewHighWaterMark");
function howMuchToRead2(n5, state2) {
  if (n5 <= 0 || state2.length === 0 && state2.ended) return 0;
  if (state2.objectMode) return 1;
  if (n5 !== n5) {
    if (state2.flowing && state2.length) return state2.buffer.head.data.length;
    else return state2.length;
  }
  if (n5 > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark2(n5);
  if (n5 <= state2.length) return n5;
  if (!state2.ended) {
    state2.needReadable = true;
    return 0;
  }
  return state2.length;
}
__name(howMuchToRead2, "howMuchToRead");
Readable2.prototype.read = function(n5) {
  debug4("read", n5);
  n5 = parseInt(n5, 10);
  var state2 = this._readableState;
  var nOrig = n5;
  if (n5 !== 0) state2.emittedReadable = false;
  if (n5 === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
    debug4("read: emitReadable", state2.length, state2.ended);
    if (state2.length === 0 && state2.ended) endReadable2(this);
    else emitReadable2(this);
    return null;
  }
  n5 = howMuchToRead2(n5, state2);
  if (n5 === 0 && state2.ended) {
    if (state2.length === 0) endReadable2(this);
    return null;
  }
  var doRead = state2.needReadable;
  debug4("need readable", doRead);
  if (state2.length === 0 || state2.length - n5 < state2.highWaterMark) {
    doRead = true;
    debug4("length less than watermark", doRead);
  }
  if (state2.ended || state2.reading) {
    doRead = false;
    debug4("reading or ended", doRead);
  } else if (doRead) {
    debug4("do read");
    state2.reading = true;
    state2.sync = true;
    if (state2.length === 0) state2.needReadable = true;
    this._read(state2.highWaterMark);
    state2.sync = false;
    if (!state2.reading) n5 = howMuchToRead2(nOrig, state2);
  }
  var ret;
  if (n5 > 0) ret = fromList2(n5, state2);
  else ret = null;
  if (ret === null) {
    state2.needReadable = state2.length <= state2.highWaterMark;
    n5 = 0;
  } else {
    state2.length -= n5;
    state2.awaitDrain = 0;
  }
  if (state2.length === 0) {
    if (!state2.ended) state2.needReadable = true;
    if (nOrig !== n5 && state2.ended) endReadable2(this);
  }
  if (ret !== null) this.emit("data", ret);
  return ret;
};
function onEofChunk2(stream2, state2) {
  debug4("onEofChunk");
  if (state2.ended) return;
  if (state2.decoder) {
    var chunk = state2.decoder.end();
    if (chunk && chunk.length) {
      state2.buffer.push(chunk);
      state2.length += state2.objectMode ? 1 : chunk.length;
    }
  }
  state2.ended = true;
  if (state2.sync) {
    emitReadable2(stream2);
  } else {
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      state2.emittedReadable = true;
      emitReadable_2(stream2);
    }
  }
}
__name(onEofChunk2, "onEofChunk");
function emitReadable2(stream2) {
  var state2 = stream2._readableState;
  debug4("emitReadable", state2.needReadable, state2.emittedReadable);
  state2.needReadable = false;
  if (!state2.emittedReadable) {
    debug4("emitReadable", state2.flowing);
    state2.emittedReadable = true;
    browser$1$1.nextTick(emitReadable_2, stream2);
  }
}
__name(emitReadable2, "emitReadable");
function emitReadable_2(stream2) {
  var state2 = stream2._readableState;
  debug4("emitReadable_", state2.destroyed, state2.length, state2.ended);
  if (!state2.destroyed && (state2.length || state2.ended)) {
    stream2.emit("readable");
    state2.emittedReadable = false;
  }
  state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
  flow2(stream2);
}
__name(emitReadable_2, "emitReadable_");
function maybeReadMore2(stream2, state2) {
  if (!state2.readingMore) {
    state2.readingMore = true;
    browser$1$1.nextTick(maybeReadMore_2, stream2, state2);
  }
}
__name(maybeReadMore2, "maybeReadMore");
function maybeReadMore_2(stream2, state2) {
  while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
    var len = state2.length;
    debug4("maybeReadMore read 0");
    stream2.read(0);
    if (len === state2.length)
      break;
  }
  state2.readingMore = false;
}
__name(maybeReadMore_2, "maybeReadMore_");
Readable2.prototype._read = function(n5) {
  errorOrDestroy$1(this, new ERR_METHOD_NOT_IMPLEMENTED$2("_read()"));
};
Readable2.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state2 = this._readableState;
  switch (state2.pipesCount) {
    case 0:
      state2.pipes = dest;
      break;
    case 1:
      state2.pipes = [state2.pipes, dest];
      break;
    default:
      state2.pipes.push(dest);
      break;
  }
  state2.pipesCount += 1;
  debug4("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== browser$1$1.stdout && dest !== browser$1$1.stderr;
  var endFn = doEnd ? onend3 : unpipe;
  if (state2.endEmitted) browser$1$1.nextTick(endFn);
  else src.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug4("onunpipe");
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  __name(onunpipe, "onunpipe");
  function onend3() {
    debug4("onend");
    dest.end();
  }
  __name(onend3, "onend");
  var ondrain = pipeOnDrain2(src);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug4("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend3);
    src.removeListener("end", unpipe);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  __name(cleanup, "cleanup");
  src.on("data", ondata);
  function ondata(chunk) {
    debug4("ondata");
    var ret = dest.write(chunk);
    debug4("dest.write", ret);
    if (ret === false) {
      if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf4(state2.pipes, dest) !== -1) && !cleanedUp) {
        debug4("false write response, pause", state2.awaitDrain);
        state2.awaitDrain++;
      }
      src.pause();
    }
  }
  __name(ondata, "ondata");
  function onerror(er) {
    debug4("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (EElistenerCount(dest, "error") === 0) errorOrDestroy$1(dest, er);
  }
  __name(onerror, "onerror");
  prependListener5(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  __name(onclose, "onclose");
  dest.once("close", onclose);
  function onfinish() {
    debug4("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  __name(onfinish, "onfinish");
  dest.once("finish", onfinish);
  function unpipe() {
    debug4("unpipe");
    src.unpipe(dest);
  }
  __name(unpipe, "unpipe");
  dest.emit("pipe", src);
  if (!state2.flowing) {
    debug4("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain2(src) {
  return /* @__PURE__ */ __name(function pipeOnDrainFunctionResult() {
    var state2 = src._readableState;
    debug4("pipeOnDrain", state2.awaitDrain);
    if (state2.awaitDrain) state2.awaitDrain--;
    if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
      state2.flowing = true;
      flow2(src);
    }
  }, "pipeOnDrainFunctionResult");
}
__name(pipeOnDrain2, "pipeOnDrain");
Readable2.prototype.unpipe = function(dest) {
  var state2 = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };
  if (state2.pipesCount === 0) return this;
  if (state2.pipesCount === 1) {
    if (dest && dest !== state2.pipes) return this;
    if (!dest) dest = state2.pipes;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    if (dest) dest.emit("unpipe", this, unpipeInfo);
    return this;
  }
  if (!dest) {
    var dests = state2.pipes;
    var len = state2.pipesCount;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    for (var i2 = 0; i2 < len; i2++) {
      dests[i2].emit("unpipe", this, {
        hasUnpiped: false
      });
    }
    return this;
  }
  var index2 = indexOf4(state2.pipes, dest);
  if (index2 === -1) return this;
  state2.pipes.splice(index2, 1);
  state2.pipesCount -= 1;
  if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
  dest.emit("unpipe", this, unpipeInfo);
  return this;
};
Readable2.prototype.on = function(ev, fn) {
  var res = Stream$1.prototype.on.call(this, ev, fn);
  var state2 = this._readableState;
  if (ev === "data") {
    state2.readableListening = this.listenerCount("readable") > 0;
    if (state2.flowing !== false) this.resume();
  } else if (ev === "readable") {
    if (!state2.endEmitted && !state2.readableListening) {
      state2.readableListening = state2.needReadable = true;
      state2.flowing = false;
      state2.emittedReadable = false;
      debug4("on readable", state2.length, state2.reading);
      if (state2.length) {
        emitReadable2(this);
      } else if (!state2.reading) {
        browser$1$1.nextTick(nReadingNextTick2, this);
      }
    }
  }
  return res;
};
Readable2.prototype.addListener = Readable2.prototype.on;
Readable2.prototype.removeListener = function(ev, fn) {
  var res = Stream$1.prototype.removeListener.call(this, ev, fn);
  if (ev === "readable") {
    browser$1$1.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable2.prototype.removeAllListeners = function(ev) {
  var res = Stream$1.prototype.removeAllListeners.apply(this, arguments);
  if (ev === "readable" || ev === void 0) {
    browser$1$1.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self2) {
  var state2 = self2._readableState;
  state2.readableListening = self2.listenerCount("readable") > 0;
  if (state2.resumeScheduled && !state2.paused) {
    state2.flowing = true;
  } else if (self2.listenerCount("data") > 0) {
    self2.resume();
  }
}
__name(updateReadableListening, "updateReadableListening");
function nReadingNextTick2(self2) {
  debug4("readable nexttick read 0");
  self2.read(0);
}
__name(nReadingNextTick2, "nReadingNextTick");
Readable2.prototype.resume = function() {
  var state2 = this._readableState;
  if (!state2.flowing) {
    debug4("resume");
    state2.flowing = !state2.readableListening;
    resume2(this, state2);
  }
  state2.paused = false;
  return this;
};
function resume2(stream2, state2) {
  if (!state2.resumeScheduled) {
    state2.resumeScheduled = true;
    browser$1$1.nextTick(resume_2, stream2, state2);
  }
}
__name(resume2, "resume");
function resume_2(stream2, state2) {
  debug4("resume", state2.reading);
  if (!state2.reading) {
    stream2.read(0);
  }
  state2.resumeScheduled = false;
  stream2.emit("resume");
  flow2(stream2);
  if (state2.flowing && !state2.reading) stream2.read(0);
}
__name(resume_2, "resume_");
Readable2.prototype.pause = function() {
  debug4("call pause flowing=%j", this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug4("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  this._readableState.paused = true;
  return this;
};
function flow2(stream2) {
  var state2 = stream2._readableState;
  debug4("flow", state2.flowing);
  while (state2.flowing && stream2.read() !== null) {
  }
}
__name(flow2, "flow");
Readable2.prototype.wrap = function(stream2) {
  var _this = this;
  var state2 = this._readableState;
  var paused = false;
  stream2.on("end", function() {
    debug4("wrapped end");
    if (state2.decoder && !state2.ended) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream2.on("data", function(chunk) {
    debug4("wrapped data");
    if (state2.decoder) chunk = state2.decoder.write(chunk);
    if (state2.objectMode && (chunk === null || chunk === void 0)) return;
    else if (!state2.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i2 in stream2) {
    if (this[i2] === void 0 && typeof stream2[i2] === "function") {
      this[i2] = (/* @__PURE__ */ __name(function methodWrap(method) {
        return /* @__PURE__ */ __name(function methodWrapReturnFunction() {
          return stream2[method].apply(stream2, arguments);
        }, "methodWrapReturnFunction");
      }, "methodWrap"))(i2);
    }
  }
  for (var n5 = 0; n5 < kProxyEvents.length; n5++) {
    stream2.on(kProxyEvents[n5], this.emit.bind(this, kProxyEvents[n5]));
  }
  this._read = function(n6) {
    debug4("wrapped _read", n6);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return this;
};
if (typeof Symbol === "function") {
  Readable2.prototype[Symbol.asyncIterator] = function() {
    if (createReadableStreamAsyncIterator === void 0) {
      createReadableStreamAsyncIterator = requireAsync_iterator();
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: /* @__PURE__ */ __name(function get2() {
    return this._readableState.highWaterMark;
  }, "get")
});
Object.defineProperty(Readable2.prototype, "readableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: /* @__PURE__ */ __name(function get3() {
    return this._readableState && this._readableState.buffer;
  }, "get")
});
Object.defineProperty(Readable2.prototype, "readableFlowing", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: /* @__PURE__ */ __name(function get4() {
    return this._readableState.flowing;
  }, "get"),
  set: /* @__PURE__ */ __name(function set2(state2) {
    if (this._readableState) {
      this._readableState.flowing = state2;
    }
  }, "set")
});
Readable2._fromList = fromList2;
Object.defineProperty(Readable2.prototype, "readableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: /* @__PURE__ */ __name(function get5() {
    return this._readableState.length;
  }, "get")
});
function fromList2(n5, state2) {
  if (state2.length === 0) return null;
  var ret;
  if (state2.objectMode) ret = state2.buffer.shift();
  else if (!n5 || n5 >= state2.length) {
    if (state2.decoder) ret = state2.buffer.join("");
    else if (state2.buffer.length === 1) ret = state2.buffer.first();
    else ret = state2.buffer.concat(state2.length);
    state2.buffer.clear();
  } else {
    ret = state2.buffer.consume(n5, state2.decoder);
  }
  return ret;
}
__name(fromList2, "fromList");
function endReadable2(stream2) {
  var state2 = stream2._readableState;
  debug4("endReadable", state2.endEmitted);
  if (!state2.endEmitted) {
    state2.ended = true;
    browser$1$1.nextTick(endReadableNT2, state2, stream2);
  }
}
__name(endReadable2, "endReadable");
function endReadableNT2(state2, stream2) {
  debug4("endReadableNT", state2.endEmitted, state2.length);
  if (!state2.endEmitted && state2.length === 0) {
    state2.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
    if (state2.autoDestroy) {
      var wState = stream2._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream2.destroy();
      }
    }
  }
}
__name(endReadableNT2, "endReadableNT");
if (typeof Symbol === "function") {
  Readable2.from = function(iterable, opts2) {
    if (from2 === void 0) {
      from2 = requireFromBrowser();
    }
    return from2(Readable2, iterable, opts2);
  };
}
function indexOf4(xs, x) {
  for (var i2 = 0, l4 = xs.length; i2 < l4; i2++) {
    if (xs[i2] === x) return i2;
  }
  return -1;
}
__name(indexOf4, "indexOf");
var browser2 = deprecate2;
function deprecate2(fn, msg2) {
  if (config3("noDeprecation")) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config3("throwDeprecation")) {
        throw new Error(msg2);
      } else if (config3("traceDeprecation")) {
        console.trace(msg2);
      } else {
        console.warn(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  __name(deprecated, "deprecated");
  return deprecated;
}
__name(deprecate2, "deprecate");
function config3(name) {
  try {
    if (!commonjsGlobal.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = commonjsGlobal.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === "true";
}
__name(config3, "config");
var Registry$3 = _registry;
Registry$3.Writable = Writable3;
function CorkedRequest2(state2) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function() {
    onCorkedFinish(_this, state2);
  };
}
__name(CorkedRequest2, "CorkedRequest");
Writable3.WritableState = WritableState2;
var internalUtil = {
  deprecate: browser2
};
var Stream2 = streamBrowser;
var Buffer3 = require$$02.Buffer;
var OurUint8Array = commonjsGlobal.Uint8Array || function() {
};
function _uint8ArrayToBuffer(chunk) {
  return Buffer3.from(chunk);
}
__name(_uint8ArrayToBuffer, "_uint8ArrayToBuffer");
function _isUint8Array(obj) {
  return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
}
__name(_isUint8Array, "_isUint8Array");
var destroyImpl = destroy_1;
var _require = state;
var getHighWaterMark = _require.getHighWaterMark;
var _require$codes$2 = errorsBrowser.codes;
var ERR_INVALID_ARG_TYPE = _require$codes$2.ERR_INVALID_ARG_TYPE;
var ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_MULTIPLE_CALLBACK$1 = _require$codes$2.ERR_MULTIPLE_CALLBACK;
var ERR_STREAM_CANNOT_PIPE = _require$codes$2.ERR_STREAM_CANNOT_PIPE;
var ERR_STREAM_DESTROYED$1 = _require$codes$2.ERR_STREAM_DESTROYED;
var ERR_STREAM_NULL_VALUES = _require$codes$2.ERR_STREAM_NULL_VALUES;
var ERR_STREAM_WRITE_AFTER_END = _require$codes$2.ERR_STREAM_WRITE_AFTER_END;
var ERR_UNKNOWN_ENCODING = _require$codes$2.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require$$12(Writable3, Stream2);
function nop2() {
}
__name(nop2, "nop");
function WritableState2(options, stream2, isDuplex) {
  options = options || {};
  if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Registry$3.Duplex;
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
  this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
  this.finalCalled = false;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  this.destroyed = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite2(stream2, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.emitClose = options.emitClose !== false;
  this.autoDestroy = !!options.autoDestroy;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest2(this);
}
__name(WritableState2, "WritableState");
WritableState2.prototype.getBuffer = /* @__PURE__ */ __name(function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
}, "getBuffer");
(function() {
  try {
    Object.defineProperty(WritableState2.prototype, "buffer", {
      get: internalUtil.deprecate(/* @__PURE__ */ __name(function writableStateBufferGetter() {
        return this.getBuffer();
      }, "writableStateBufferGetter"), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
    });
  } catch (_) {
  }
})();
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable3, Symbol.hasInstance, {
    value: /* @__PURE__ */ __name(function value2(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable3) return false;
      return object && object._writableState instanceof WritableState2;
    }, "value")
  });
} else {
  realHasInstance = /* @__PURE__ */ __name(function realHasInstance2(object) {
    return object instanceof this;
  }, "realHasInstance");
}
function Writable3(options) {
  var isDuplex = this instanceof Registry$3.Duplex;
  if (!isDuplex && !realHasInstance.call(Writable3, this)) return new Writable3(options);
  this._writableState = new WritableState2(options, this, isDuplex);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function") this._write = options.write;
    if (typeof options.writev === "function") this._writev = options.writev;
    if (typeof options.destroy === "function") this._destroy = options.destroy;
    if (typeof options.final === "function") this._final = options.final;
  }
  Stream2.call(this);
}
__name(Writable3, "Writable");
Writable3.prototype.pipe = function() {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd2(stream2, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  errorOrDestroy(stream2, er);
  browser$1$1.nextTick(cb, er);
}
__name(writeAfterEnd2, "writeAfterEnd");
function validChunk2(stream2, state2, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== "string" && !state2.objectMode) {
    er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
  }
  if (er) {
    errorOrDestroy(stream2, er);
    browser$1$1.nextTick(cb, er);
    return false;
  }
  return true;
}
__name(validChunk2, "validChunk");
Writable3.prototype.write = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  var ret = false;
  var isBuf = !state2.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer3.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = "buffer";
  else if (!encoding) encoding = state2.defaultEncoding;
  if (typeof cb !== "function") cb = nop2;
  if (state2.ending) writeAfterEnd2(this, cb);
  else if (isBuf || validChunk2(this, state2, chunk, cb)) {
    state2.pendingcb++;
    ret = writeOrBuffer2(this, state2, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable3.prototype.cork = function() {
  this._writableState.corked++;
};
Writable3.prototype.uncork = function() {
  var state2 = this._writableState;
  if (state2.corked) {
    state2.corked--;
    if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer2(this, state2);
  }
};
Writable3.prototype.setDefaultEncoding = /* @__PURE__ */ __name(function setDefaultEncoding2(encoding) {
  if (typeof encoding === "string") encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
}, "setDefaultEncoding");
Object.defineProperty(Writable3.prototype, "writableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: /* @__PURE__ */ __name(function get6() {
    return this._writableState && this._writableState.getBuffer();
  }, "get")
});
function decodeChunk2(state2, chunk, encoding) {
  if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer3.from(chunk, encoding);
  }
  return chunk;
}
__name(decodeChunk2, "decodeChunk");
Object.defineProperty(Writable3.prototype, "writableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: /* @__PURE__ */ __name(function get7() {
    return this._writableState.highWaterMark;
  }, "get")
});
function writeOrBuffer2(stream2, state2, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk2(state2, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = "buffer";
      chunk = newChunk;
    }
  }
  var len = state2.objectMode ? 1 : chunk.length;
  state2.length += len;
  var ret = state2.length < state2.highWaterMark;
  if (!ret) state2.needDrain = true;
  if (state2.writing || state2.corked) {
    var last2 = state2.lastBufferedRequest;
    state2.lastBufferedRequest = {
      chunk,
      encoding,
      isBuf,
      callback: cb,
      next: null
    };
    if (last2) {
      last2.next = state2.lastBufferedRequest;
    } else {
      state2.bufferedRequest = state2.lastBufferedRequest;
    }
    state2.bufferedRequestCount += 1;
  } else {
    doWrite2(stream2, state2, false, len, chunk, encoding, cb);
  }
  return ret;
}
__name(writeOrBuffer2, "writeOrBuffer");
function doWrite2(stream2, state2, writev2, len, chunk, encoding, cb) {
  state2.writelen = len;
  state2.writecb = cb;
  state2.writing = true;
  state2.sync = true;
  if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED$1("write"));
  else if (writev2) stream2._writev(chunk, state2.onwrite);
  else stream2._write(chunk, encoding, state2.onwrite);
  state2.sync = false;
}
__name(doWrite2, "doWrite");
function onwriteError2(stream2, state2, sync, er, cb) {
  --state2.pendingcb;
  if (sync) {
    browser$1$1.nextTick(cb, er);
    browser$1$1.nextTick(finishMaybe2, stream2, state2);
    stream2._writableState.errorEmitted = true;
    errorOrDestroy(stream2, er);
  } else {
    cb(er);
    stream2._writableState.errorEmitted = true;
    errorOrDestroy(stream2, er);
    finishMaybe2(stream2, state2);
  }
}
__name(onwriteError2, "onwriteError");
function onwriteStateUpdate2(state2) {
  state2.writing = false;
  state2.writecb = null;
  state2.length -= state2.writelen;
  state2.writelen = 0;
}
__name(onwriteStateUpdate2, "onwriteStateUpdate");
function onwrite2(stream2, er) {
  var state2 = stream2._writableState;
  var sync = state2.sync;
  var cb = state2.writecb;
  if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK$1();
  onwriteStateUpdate2(state2);
  if (er) onwriteError2(stream2, state2, sync, er, cb);
  else {
    var finished = needFinish2(state2) || stream2.destroyed;
    if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
      clearBuffer2(stream2, state2);
    }
    if (sync) {
      browser$1$1.nextTick(afterWrite2, stream2, state2, finished, cb);
    } else {
      afterWrite2(stream2, state2, finished, cb);
    }
  }
}
__name(onwrite2, "onwrite");
function afterWrite2(stream2, state2, finished, cb) {
  if (!finished) onwriteDrain2(stream2, state2);
  state2.pendingcb--;
  cb();
  finishMaybe2(stream2, state2);
}
__name(afterWrite2, "afterWrite");
function onwriteDrain2(stream2, state2) {
  if (state2.length === 0 && state2.needDrain) {
    state2.needDrain = false;
    stream2.emit("drain");
  }
}
__name(onwriteDrain2, "onwriteDrain");
function clearBuffer2(stream2, state2) {
  state2.bufferProcessing = true;
  var entry = state2.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l4 = state2.bufferedRequestCount;
    var buffer = new Array(l4);
    var holder = state2.corkedRequestsFree;
    holder.entry = entry;
    var count3 = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count3] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count3 += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite2(stream2, state2, true, state2.length, buffer, "", holder.finish);
    state2.pendingcb++;
    state2.lastBufferedRequest = null;
    if (holder.next) {
      state2.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state2.corkedRequestsFree = new CorkedRequest2(state2);
    }
    state2.bufferedRequestCount = 0;
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state2.objectMode ? 1 : chunk.length;
      doWrite2(stream2, state2, false, len, chunk, encoding, cb);
      entry = entry.next;
      state2.bufferedRequestCount--;
      if (state2.writing) {
        break;
      }
    }
    if (entry === null) state2.lastBufferedRequest = null;
  }
  state2.bufferedRequest = entry;
  state2.bufferProcessing = false;
}
__name(clearBuffer2, "clearBuffer");
Writable3.prototype._write = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED$1("_write()"));
};
Writable3.prototype._writev = null;
Writable3.prototype.end = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
  if (state2.corked) {
    state2.corked = 1;
    this.uncork();
  }
  if (!state2.ending) endWritable2(this, state2, cb);
  return this;
};
Object.defineProperty(Writable3.prototype, "writableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: /* @__PURE__ */ __name(function get8() {
    return this._writableState.length;
  }, "get")
});
function needFinish2(state2) {
  return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
}
__name(needFinish2, "needFinish");
function callFinal(stream2, state2) {
  stream2._final(function(err2) {
    state2.pendingcb--;
    if (err2) {
      errorOrDestroy(stream2, err2);
    }
    state2.prefinished = true;
    stream2.emit("prefinish");
    finishMaybe2(stream2, state2);
  });
}
__name(callFinal, "callFinal");
function prefinish$1(stream2, state2) {
  if (!state2.prefinished && !state2.finalCalled) {
    if (typeof stream2._final === "function" && !state2.destroyed) {
      state2.pendingcb++;
      state2.finalCalled = true;
      browser$1$1.nextTick(callFinal, stream2, state2);
    } else {
      state2.prefinished = true;
      stream2.emit("prefinish");
    }
  }
}
__name(prefinish$1, "prefinish$1");
function finishMaybe2(stream2, state2) {
  var need = needFinish2(state2);
  if (need) {
    prefinish$1(stream2, state2);
    if (state2.pendingcb === 0) {
      state2.finished = true;
      stream2.emit("finish");
      if (state2.autoDestroy) {
        var rState = stream2._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream2.destroy();
        }
      }
    }
  }
  return need;
}
__name(finishMaybe2, "finishMaybe");
function endWritable2(stream2, state2, cb) {
  state2.ending = true;
  finishMaybe2(stream2, state2);
  if (cb) {
    if (state2.finished) browser$1$1.nextTick(cb);
    else stream2.once("finish", cb);
  }
  state2.ended = true;
  stream2.writable = false;
}
__name(endWritable2, "endWritable");
function onCorkedFinish(corkReq, state2, err2) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state2.pendingcb--;
    cb(err2);
    entry = entry.next;
  }
  state2.corkedRequestsFree.next = corkReq;
}
__name(onCorkedFinish, "onCorkedFinish");
Object.defineProperty(Writable3.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: /* @__PURE__ */ __name(function get9() {
    if (this._writableState === void 0) {
      return false;
    }
    return this._writableState.destroyed;
  }, "get"),
  set: /* @__PURE__ */ __name(function set3(value2) {
    if (!this._writableState) {
      return;
    }
    this._writableState.destroyed = value2;
  }, "set")
});
Writable3.prototype.destroy = destroyImpl.destroy;
Writable3.prototype._undestroy = destroyImpl.undestroy;
Writable3.prototype._destroy = function(err2, cb) {
  cb(err2);
};
var objectKeys$1 = Object.keys || function(obj) {
  var keys2 = [];
  for (var key in obj) {
    keys2.push(key);
  }
  return keys2;
};
var Registry$2 = _registry;
Registry$2.Duplex = Duplex2;
require$$12(Duplex2, Registry$2.Readable);
{
  keys2 = objectKeys$1(Registry$2.Writable.prototype);
  for (v3 = 0; v3 < keys2.length; v3++) {
    method = keys2[v3];
    if (!Duplex2.prototype[method]) Duplex2.prototype[method] = Registry$2.Writable.prototype[method];
  }
}
var keys2;
var method;
var v3;
function Duplex2(options) {
  if (!(this instanceof Duplex2)) return new Duplex2(options);
  Registry$2.Readable.call(this, options);
  Registry$2.Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once("end", onend2);
    }
  }
}
__name(Duplex2, "Duplex");
Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: /* @__PURE__ */ __name(function get10() {
    return this._writableState.highWaterMark;
  }, "get")
});
Object.defineProperty(Duplex2.prototype, "writableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: /* @__PURE__ */ __name(function get11() {
    return this._writableState && this._writableState.getBuffer();
  }, "get")
});
Object.defineProperty(Duplex2.prototype, "writableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: /* @__PURE__ */ __name(function get12() {
    return this._writableState.length;
  }, "get")
});
function onend2() {
  if (this._writableState.ended) return;
  browser$1$1.nextTick(onEndNT2, this);
}
__name(onend2, "onend");
function onEndNT2(self2) {
  self2.end();
}
__name(onEndNT2, "onEndNT");
Object.defineProperty(Duplex2.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: /* @__PURE__ */ __name(function get13() {
    if (this._readableState === void 0 || this._writableState === void 0) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  }, "get"),
  set: /* @__PURE__ */ __name(function set4(value2) {
    if (this._readableState === void 0 || this._writableState === void 0) {
      return;
    }
    this._readableState.destroyed = value2;
    this._writableState.destroyed = value2;
  }, "set")
});
var Registry$1 = _registry;
Registry$1.Transform = Transform$1;
var _require$codes$1 = errorsBrowser.codes;
var ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK;
var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING;
var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
require$$12(Transform$1, Registry$1.Duplex);
function afterTransform2(er, data2) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 != null)
    this.push(data2);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
__name(afterTransform2, "afterTransform");
function Transform$1(options) {
  if (!(this instanceof Transform$1)) return new Transform$1(options);
  Registry$1.Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform2.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function") this._transform = options.transform;
    if (typeof options.flush === "function") this._flush = options.flush;
  }
  this.on("prefinish", prefinish2);
}
__name(Transform$1, "Transform$1");
function prefinish2() {
  var _this = this;
  if (typeof this._flush === "function" && !this._readableState.destroyed) {
    this._flush(function(er, data2) {
      done2(_this, er, data2);
    });
  } else {
    done2(this, null, null);
  }
}
__name(prefinish2, "prefinish");
Transform$1.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Registry$1.Duplex.prototype.push.call(this, chunk, encoding);
};
Transform$1.prototype._transform = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$1.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};
Transform$1.prototype._read = function(n5) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
Transform$1.prototype._destroy = function(err2, cb) {
  Registry$1.Duplex.prototype._destroy.call(this, err2, function(err22) {
    cb(err22);
  });
};
function done2(stream2, er, data2) {
  if (er) return stream2.emit("error", er);
  if (data2 != null)
    stream2.push(data2);
  if (stream2._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream2._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream2.push(null);
}
__name(done2, "done");
var Registry = _registry;
Registry.PassThrough = PassThrough2;
require$$12(PassThrough2, Registry.Transform);
function PassThrough2(options) {
  if (!(this instanceof PassThrough2)) return new PassThrough2(options);
  Transform.call(this, options);
}
__name(PassThrough2, "PassThrough");
PassThrough2.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
var eos;
function once5(callback) {
  var called = false;
  return function() {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
__name(once5, "once");
var _require$codes = errorsBrowser.codes;
var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop2(err2) {
  if (err2) throw err2;
}
__name(noop2, "noop");
function isRequest(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
__name(isRequest, "isRequest");
function destroyer(stream2, reading, writing, callback) {
  callback = once5(callback);
  var closed = false;
  stream2.on("close", function() {
    closed = true;
  });
  if (eos === void 0) eos = endOfStream;
  eos(stream2, {
    readable: reading,
    writable: writing
  }, function(err2) {
    if (err2) return callback(err2);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err2) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;
    if (isRequest(stream2)) return stream2.abort();
    if (typeof stream2.destroy === "function") return stream2.destroy();
    callback(err2 || new ERR_STREAM_DESTROYED("pipe"));
  };
}
__name(destroyer, "destroyer");
function call(fn) {
  fn();
}
__name(call, "call");
function pipe(from4, to) {
  return from4.pipe(to);
}
__name(pipe, "pipe");
function popCallback(streams) {
  if (!streams.length) return noop2;
  if (typeof streams[streams.length - 1] !== "function") return noop2;
  return streams.pop();
}
__name(popCallback, "popCallback");
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  var error3;
  var destroys = streams.map(function(stream2, i2) {
    var reading = i2 < streams.length - 1;
    var writing = i2 > 0;
    return destroyer(stream2, reading, writing, function(err2) {
      if (!error3) error3 = err2;
      if (err2) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error3);
    });
  });
  return streams.reduce(pipe);
}
__name(pipeline, "pipeline");
var pipeline_1 = pipeline;
(function(module, exports) {
  const Registry2 = _registry;
  exports = module.exports = Registry2.Readable;
  exports.Stream = Registry2.Readable;
  exports.Readable = Registry2.Readable;
  exports.Writable = Registry2.Writable;
  exports.Duplex = Registry2.Duplex;
  exports.Transform = Registry2.Transform;
  exports.PassThrough = Registry2.PassThrough;
  exports.finished = endOfStream;
  exports.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports;
var stream = /* @__PURE__ */ getDefaultExportFromCjs2(readableBrowserExports);
var lib2 = {};
var binding3 = {};
function compare6(a4, b3) {
  if (a4 === b3) {
    return 0;
  }
  var x = a4.length;
  var y3 = b3.length;
  for (var i2 = 0, len = Math.min(x, y3); i2 < len; ++i2) {
    if (a4[i2] !== b3[i2]) {
      x = a4[i2];
      y3 = b3[i2];
      break;
    }
  }
  if (x < y3) {
    return -1;
  }
  if (y3 < x) {
    return 1;
  }
  return 0;
}
__name(compare6, "compare");
var hasOwn2 = Object.prototype.hasOwnProperty;
var objectKeys2 = Object.keys || function(obj) {
  var keys2 = [];
  for (var key in obj) {
    if (hasOwn2.call(obj, key)) keys2.push(key);
  }
  return keys2;
};
var pSlice2 = Array.prototype.slice;
var _functionsHaveNames2;
function functionsHaveNames2() {
  if (typeof _functionsHaveNames2 !== "undefined") {
    return _functionsHaveNames2;
  }
  return _functionsHaveNames2 = function() {
    return (/* @__PURE__ */ __name(function foo() {
    }, "foo")).name === "foo";
  }();
}
__name(functionsHaveNames2, "functionsHaveNames");
function pToString2(obj) {
  return Object.prototype.toString.call(obj);
}
__name(pToString2, "pToString");
function isView2(arrbuf) {
  if (isBuffer$12(arrbuf)) {
    return false;
  }
  if (typeof global$12.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
__name(isView2, "isView");
function assert4(value2, message) {
  if (!value2) fail2(value2, true, message, "==", ok2);
}
__name(assert4, "assert");
var regex2 = /\s*function\s+([^\(\s]*)\s*/;
function getName2(func) {
  if (!isFunction2(func)) {
    return;
  }
  if (functionsHaveNames2()) {
    return func.name;
  }
  var str = func.toString();
  var match2 = str.match(regex2);
  return match2 && match2[1];
}
__name(getName2, "getName");
assert4.AssertionError = AssertionError2;
function AssertionError2(options) {
  this.name = "AssertionError";
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage2(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail2;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err2 = new Error();
    if (err2.stack) {
      var out = err2.stack;
      var fn_name = getName2(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
__name(AssertionError2, "AssertionError");
inherits$2(AssertionError2, Error);
function truncate2(s4, n5) {
  if (typeof s4 === "string") {
    return s4.length < n5 ? s4 : s4.slice(0, n5);
  } else {
    return s4;
  }
}
__name(truncate2, "truncate");
function inspect4(something) {
  if (functionsHaveNames2() || !isFunction2(something)) {
    return inspect$12(something);
  }
  var rawname = getName2(something);
  var name = rawname ? ": " + rawname : "";
  return "[Function" + name + "]";
}
__name(inspect4, "inspect");
function getMessage2(self2) {
  return truncate2(inspect4(self2.actual), 128) + " " + self2.operator + " " + truncate2(inspect4(self2.expected), 128);
}
__name(getMessage2, "getMessage");
function fail2(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError2({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
__name(fail2, "fail");
assert4.fail = fail2;
function ok2(value2, message) {
  if (!value2) fail2(value2, true, message, "==", ok2);
}
__name(ok2, "ok");
assert4.ok = ok2;
assert4.equal = equal2;
function equal2(actual, expected, message) {
  if (actual != expected) fail2(actual, expected, message, "==", equal2);
}
__name(equal2, "equal");
assert4.notEqual = notEqual2;
function notEqual2(actual, expected, message) {
  if (actual == expected) {
    fail2(actual, expected, message, "!=", notEqual2);
  }
}
__name(notEqual2, "notEqual");
assert4.deepEqual = deepEqual2;
function deepEqual2(actual, expected, message) {
  if (!_deepEqual2(actual, expected, false)) {
    fail2(actual, expected, message, "deepEqual", deepEqual2);
  }
}
__name(deepEqual2, "deepEqual");
assert4.deepStrictEqual = deepStrictEqual2;
function deepStrictEqual2(actual, expected, message) {
  if (!_deepEqual2(actual, expected, true)) {
    fail2(actual, expected, message, "deepStrictEqual", deepStrictEqual2);
  }
}
__name(deepStrictEqual2, "deepStrictEqual");
function _deepEqual2(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer$12(actual) && isBuffer$12(expected)) {
    return compare6(actual, expected) === 0;
  } else if (isDate2(actual) && isDate2(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp2(actual) && isRegExp2(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView2(actual) && isView2(expected) && pToString2(actual) === pToString2(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare6(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (isBuffer$12(actual) !== isBuffer$12(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv2(actual, expected, strict, memos);
  }
}
__name(_deepEqual2, "_deepEqual");
function isArguments2(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
__name(isArguments2, "isArguments");
function objEquiv2(a4, b3, strict, actualVisitedObjects) {
  if (a4 === null || a4 === void 0 || b3 === null || b3 === void 0)
    return false;
  if (isPrimitive2(a4) || isPrimitive2(b3))
    return a4 === b3;
  if (strict && Object.getPrototypeOf(a4) !== Object.getPrototypeOf(b3))
    return false;
  var aIsArgs = isArguments2(a4);
  var bIsArgs = isArguments2(b3);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a4 = pSlice2.call(a4);
    b3 = pSlice2.call(b3);
    return _deepEqual2(a4, b3, strict);
  }
  var ka = objectKeys2(a4);
  var kb = objectKeys2(b3);
  var key, i2;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i2 = ka.length - 1; i2 >= 0; i2--) {
    if (ka[i2] !== kb[i2])
      return false;
  }
  for (i2 = ka.length - 1; i2 >= 0; i2--) {
    key = ka[i2];
    if (!_deepEqual2(a4[key], b3[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
__name(objEquiv2, "objEquiv");
assert4.notDeepEqual = notDeepEqual2;
function notDeepEqual2(actual, expected, message) {
  if (_deepEqual2(actual, expected, false)) {
    fail2(actual, expected, message, "notDeepEqual", notDeepEqual2);
  }
}
__name(notDeepEqual2, "notDeepEqual");
assert4.notDeepStrictEqual = notDeepStrictEqual2;
function notDeepStrictEqual2(actual, expected, message) {
  if (_deepEqual2(actual, expected, true)) {
    fail2(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual2);
  }
}
__name(notDeepStrictEqual2, "notDeepStrictEqual");
assert4.strictEqual = strictEqual2;
function strictEqual2(actual, expected, message) {
  if (actual !== expected) {
    fail2(actual, expected, message, "===", strictEqual2);
  }
}
__name(strictEqual2, "strictEqual");
assert4.notStrictEqual = notStrictEqual2;
function notStrictEqual2(actual, expected, message) {
  if (actual === expected) {
    fail2(actual, expected, message, "!==", notStrictEqual2);
  }
}
__name(notStrictEqual2, "notStrictEqual");
function expectedException2(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e4) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
__name(expectedException2, "expectedException");
function _tryBlock2(block) {
  var error3;
  try {
    block();
  } catch (e4) {
    error3 = e4;
  }
  return error3;
}
__name(_tryBlock2, "_tryBlock");
function _throws2(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock2(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail2(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError2(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException2(actual, expected) || isUnexpectedException) {
    fail2(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException2(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
__name(_throws2, "_throws");
assert4.throws = throws2;
function throws2(block, error3, message) {
  _throws2(true, block, error3, message);
}
__name(throws2, "throws");
assert4.doesNotThrow = doesNotThrow2;
function doesNotThrow2(block, error3, message) {
  _throws2(false, block, error3, message);
}
__name(doesNotThrow2, "doesNotThrow");
assert4.ifError = ifError2;
function ifError2(err2) {
  if (err2) throw err2;
}
__name(ifError2, "ifError");
var _polyfillNode_assert2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AssertionError: AssertionError2,
  assert: ok2,
  deepEqual: deepEqual2,
  deepStrictEqual: deepStrictEqual2,
  default: assert4,
  doesNotThrow: doesNotThrow2,
  equal: equal2,
  fail: fail2,
  ifError: ifError2,
  notDeepEqual: notDeepEqual2,
  notDeepStrictEqual: notDeepStrictEqual2,
  notEqual: notEqual2,
  notStrictEqual: notStrictEqual2,
  ok: ok2,
  strictEqual: strictEqual2,
  throws: throws2
});
var require$$42 = /* @__PURE__ */ getAugmentedNamespace2(_polyfillNode_assert2);
(function(exports) {
  var assert5 = require$$42;
  var Zstream = import_zstream.default;
  var zlib_deflate = import_deflate.default;
  var zlib_inflate = import_inflate.default;
  var constants4 = import_constants3.default;
  for (var key in constants4) {
    exports[key] = constants4[key];
  }
  exports.NONE = 0;
  exports.DEFLATE = 1;
  exports.INFLATE = 2;
  exports.GZIP = 3;
  exports.GUNZIP = 4;
  exports.DEFLATERAW = 5;
  exports.INFLATERAW = 6;
  exports.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib(mode) {
    if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  __name(Zlib, "Zlib");
  Zlib.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert5(this.init_done, "close before init");
    assert5(this.mode <= exports.UNZIP);
    if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports.NONE;
    this.dictionary = null;
  };
  Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert5.equal(arguments.length, 8);
    assert5(this.init_done, "write before init");
    assert5(this.mode !== exports.NONE, "already finalized");
    assert5.equal(false, this.write_in_progress, "write already in progress");
    assert5.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert5.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer$2.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    browser$1$1.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports.INFLATE;
              break;
            }
          // fallthrough
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports.GUNZIP;
            } else {
              this.mode = exports.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      // fallthrough
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports.Z_DATA_ERROR) {
            this.err = exports.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib.prototype._checkError = function() {
    switch (this.err) {
      case exports.Z_OK:
      case exports.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports.Z_STREAM_END:
        break;
      case exports.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    assert5(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert5(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert5(level >= -1 && level <= 9, "invalid compression level");
    assert5(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert5(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
  };
  Zlib.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports.Z_NO_FLUSH;
    this.err = exports.Z_OK;
    if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
      case exports.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib.prototype._reset = function() {
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
      case exports.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports.INFLATE:
      case exports.INFLATERAW:
      case exports.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports.Zlib = Zlib;
})(binding3);
(function(exports) {
  var Buffer5 = require$$02.Buffer;
  var Transform3 = readableBrowserExports.Transform;
  var binding$13 = binding3;
  var util = require$$32;
  var assert5 = require$$42.ok;
  var kMaxLength4 = require$$02.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength4.toString(16) + " bytes";
  binding$13.Z_MIN_WINDOWBITS = 8;
  binding$13.Z_MAX_WINDOWBITS = 15;
  binding$13.Z_DEFAULT_WINDOWBITS = 15;
  binding$13.Z_MIN_CHUNK = 64;
  binding$13.Z_MAX_CHUNK = Infinity;
  binding$13.Z_DEFAULT_CHUNK = 16 * 1024;
  binding$13.Z_MIN_MEMLEVEL = 1;
  binding$13.Z_MAX_MEMLEVEL = 9;
  binding$13.Z_DEFAULT_MEMLEVEL = 8;
  binding$13.Z_MIN_LEVEL = -1;
  binding$13.Z_MAX_LEVEL = 9;
  binding$13.Z_DEFAULT_LEVEL = binding$13.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding$13);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports, bkey, {
        enumerable: true,
        value: binding$13[bkey],
        writable: false
      });
    }
  }
  var codes2 = {
    Z_OK: binding$13.Z_OK,
    Z_STREAM_END: binding$13.Z_STREAM_END,
    Z_NEED_DICT: binding$13.Z_NEED_DICT,
    Z_ERRNO: binding$13.Z_ERRNO,
    Z_STREAM_ERROR: binding$13.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding$13.Z_DATA_ERROR,
    Z_MEM_ERROR: binding$13.Z_MEM_ERROR,
    Z_BUF_ERROR: binding$13.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding$13.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes2);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes2[codes2[ckey]] = ckey;
  }
  Object.defineProperty(exports, "codes", {
    enumerable: true,
    value: Object.freeze(codes2),
    writable: false
  });
  exports.Deflate = Deflate;
  exports.Inflate = Inflate;
  exports.Gzip = Gzip;
  exports.Gunzip = Gunzip;
  exports.DeflateRaw = DeflateRaw;
  exports.InflateRaw = InflateRaw;
  exports.Unzip = Unzip;
  exports.createDeflate = function(o4) {
    return new Deflate(o4);
  };
  exports.createInflate = function(o4) {
    return new Inflate(o4);
  };
  exports.createDeflateRaw = function(o4) {
    return new DeflateRaw(o4);
  };
  exports.createInflateRaw = function(o4) {
    return new InflateRaw(o4);
  };
  exports.createGzip = function(o4) {
    return new Gzip(o4);
  };
  exports.createGunzip = function(o4) {
    return new Gunzip(o4);
  };
  exports.createUnzip = function(o4) {
    return new Unzip(o4);
  };
  exports.deflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Deflate(opts2), buffer, callback);
  };
  exports.deflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Deflate(opts2), buffer);
  };
  exports.gzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gzip(opts2), buffer, callback);
  };
  exports.gzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gzip(opts2), buffer);
  };
  exports.deflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new DeflateRaw(opts2), buffer, callback);
  };
  exports.deflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new DeflateRaw(opts2), buffer);
  };
  exports.unzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Unzip(opts2), buffer, callback);
  };
  exports.unzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Unzip(opts2), buffer);
  };
  exports.inflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Inflate(opts2), buffer, callback);
  };
  exports.inflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Inflate(opts2), buffer);
  };
  exports.gunzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gunzip(opts2), buffer, callback);
  };
  exports.gunzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gunzip(opts2), buffer);
  };
  exports.inflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new InflateRaw(opts2), buffer, callback);
  };
  exports.inflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new InflateRaw(opts2), buffer);
  };
  function zlibBuffer(engine2, buffer, callback) {
    var buffers = [];
    var nread = 0;
    engine2.on("error", onError);
    engine2.on("end", onEnd);
    engine2.end(buffer);
    flow3();
    function flow3() {
      var chunk;
      while (null !== (chunk = engine2.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine2.once("readable", flow3);
    }
    __name(flow3, "flow");
    function onError(err2) {
      engine2.removeListener("end", onEnd);
      engine2.removeListener("readable", flow3);
      callback(err2);
    }
    __name(onError, "onError");
    function onEnd() {
      var buf;
      var err2 = null;
      if (nread >= kMaxLength4) {
        err2 = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer5.concat(buffers, nread);
      }
      buffers = [];
      engine2.close();
      callback(err2, buf);
    }
    __name(onEnd, "onEnd");
  }
  __name(zlibBuffer, "zlibBuffer");
  function zlibBufferSync(engine2, buffer) {
    if (typeof buffer === "string") buffer = Buffer5.from(buffer);
    if (!Buffer5.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
    var flushFlag = engine2._finishFlushFlag;
    return engine2._processChunk(buffer, flushFlag);
  }
  __name(zlibBufferSync, "zlibBufferSync");
  function Deflate(opts2) {
    if (!(this instanceof Deflate)) return new Deflate(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATE);
  }
  __name(Deflate, "Deflate");
  function Inflate(opts2) {
    if (!(this instanceof Inflate)) return new Inflate(opts2);
    Zlib.call(this, opts2, binding$13.INFLATE);
  }
  __name(Inflate, "Inflate");
  function Gzip(opts2) {
    if (!(this instanceof Gzip)) return new Gzip(opts2);
    Zlib.call(this, opts2, binding$13.GZIP);
  }
  __name(Gzip, "Gzip");
  function Gunzip(opts2) {
    if (!(this instanceof Gunzip)) return new Gunzip(opts2);
    Zlib.call(this, opts2, binding$13.GUNZIP);
  }
  __name(Gunzip, "Gunzip");
  function DeflateRaw(opts2) {
    if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATERAW);
  }
  __name(DeflateRaw, "DeflateRaw");
  function InflateRaw(opts2) {
    if (!(this instanceof InflateRaw)) return new InflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.INFLATERAW);
  }
  __name(InflateRaw, "InflateRaw");
  function Unzip(opts2) {
    if (!(this instanceof Unzip)) return new Unzip(opts2);
    Zlib.call(this, opts2, binding$13.UNZIP);
  }
  __name(Unzip, "Unzip");
  function isValidFlushFlag(flag) {
    return flag === binding$13.Z_NO_FLUSH || flag === binding$13.Z_PARTIAL_FLUSH || flag === binding$13.Z_SYNC_FLUSH || flag === binding$13.Z_FULL_FLUSH || flag === binding$13.Z_FINISH || flag === binding$13.Z_BLOCK;
  }
  __name(isValidFlushFlag, "isValidFlushFlag");
  function Zlib(opts2, mode) {
    var _this = this;
    this._opts = opts2 = opts2 || {};
    this._chunkSize = opts2.chunkSize || exports.Z_DEFAULT_CHUNK;
    Transform3.call(this, opts2);
    if (opts2.flush && !isValidFlushFlag(opts2.flush)) {
      throw new Error("Invalid flush flag: " + opts2.flush);
    }
    if (opts2.finishFlush && !isValidFlushFlag(opts2.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts2.finishFlush);
    }
    this._flushFlag = opts2.flush || binding$13.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts2.finishFlush !== "undefined" ? opts2.finishFlush : binding$13.Z_FINISH;
    if (opts2.chunkSize) {
      if (opts2.chunkSize < exports.Z_MIN_CHUNK || opts2.chunkSize > exports.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts2.chunkSize);
      }
    }
    if (opts2.windowBits) {
      if (opts2.windowBits < exports.Z_MIN_WINDOWBITS || opts2.windowBits > exports.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts2.windowBits);
      }
    }
    if (opts2.level) {
      if (opts2.level < exports.Z_MIN_LEVEL || opts2.level > exports.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts2.level);
      }
    }
    if (opts2.memLevel) {
      if (opts2.memLevel < exports.Z_MIN_MEMLEVEL || opts2.memLevel > exports.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts2.memLevel);
      }
    }
    if (opts2.strategy) {
      if (opts2.strategy != exports.Z_FILTERED && opts2.strategy != exports.Z_HUFFMAN_ONLY && opts2.strategy != exports.Z_RLE && opts2.strategy != exports.Z_FIXED && opts2.strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts2.strategy);
      }
    }
    if (opts2.dictionary) {
      if (!Buffer5.isBuffer(opts2.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding$13.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno2) {
      _close(self2);
      self2._hadError = true;
      var error3 = new Error(message);
      error3.errno = errno2;
      error3.code = exports.codes[errno2];
      self2.emit("error", error3);
    };
    var level = exports.Z_DEFAULT_COMPRESSION;
    if (typeof opts2.level === "number") level = opts2.level;
    var strategy = exports.Z_DEFAULT_STRATEGY;
    if (typeof opts2.strategy === "number") strategy = opts2.strategy;
    this._handle.init(opts2.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts2.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts2.dictionary);
    this._buffer = Buffer5.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: /* @__PURE__ */ __name(function() {
        return !_this._handle;
      }, "get"),
      configurable: true,
      enumerable: true
    });
  }
  __name(Zlib, "Zlib");
  util.inherits(Zlib, Transform3);
  Zlib.prototype.params = function(level, strategy, callback) {
    if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding$13.Z_SYNC_FLUSH, function() {
        assert5(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback) callback();
        }
      });
    } else {
      browser$1$1.nextTick(callback);
    }
  };
  Zlib.prototype.reset = function() {
    assert5(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib.prototype._flush = function(callback) {
    this._transform(Buffer5.alloc(0), "", callback);
  };
  Zlib.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding$13.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback) browser$1$1.nextTick(callback);
    } else if (ws.ending) {
      if (callback) this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer5.alloc(0), "", callback);
    }
  };
  Zlib.prototype.close = function(callback) {
    _close(this, callback);
    browser$1$1.nextTick(emitCloseNT2, this);
  };
  function _close(engine2, callback) {
    if (callback) browser$1$1.nextTick(callback);
    if (!engine2._handle) return;
    engine2._handle.close();
    engine2._handle = null;
  }
  __name(_close, "_close");
  function emitCloseNT2(self2) {
    self2.emit("close");
  }
  __name(emitCloseNT2, "emitCloseNT");
  Zlib.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last2 = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer5.isBuffer(chunk)) return cb(new Error("invalid input"));
    if (!this._handle) return cb(new Error("zlib binding closed"));
    if (last2) flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding$13.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error3;
      this.on("error", function(er) {
        error3 = er;
      });
      assert5(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error3;
      }
      if (nread >= kMaxLength4) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer5.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert5(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError) return;
      var have = availOutBefore - availOutAfter;
      assert5(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer5.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async) return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async) return false;
      cb();
    }
    __name(callback, "callback");
  };
  util.inherits(Deflate, Zlib);
  util.inherits(Inflate, Zlib);
  util.inherits(Gzip, Zlib);
  util.inherits(Gunzip, Zlib);
  util.inherits(DeflateRaw, Zlib);
  util.inherits(InflateRaw, Zlib);
  util.inherits(Unzip, Zlib);
})(lib2);
var zlib2 = /* @__PURE__ */ getDefaultExportFromCjs2(lib2);
var PDFReference = class extends stream.Writable {
  static {
    __name(this, "PDFReference");
  }
  constructor(document2, id, data2) {
    super({
      decodeStrings: false
    });
    this.finalize = this.finalize.bind(this);
    this.document = document2;
    this.id = id;
    if (data2 == null) {
      data2 = {};
    }
    this.data = data2;
    this.gen = 0;
    this.deflate = null;
    this.compress = this.document.compress && !this.data.Filter;
    this.uncompressedLength = 0;
    this.chunks = [];
  }
  initDeflate() {
    this.data.Filter = "FlateDecode";
    this.deflate = zlib2.createDeflate();
    this.deflate.on("data", (chunk) => {
      this.chunks.push(chunk);
      return this.data.Length += chunk.length;
    });
    return this.deflate.on("end", this.finalize);
  }
  _write(chunk, encoding, callback) {
    if (!(chunk instanceof Uint8Array)) {
      chunk = Buffer$2.from(chunk + "\n", "binary");
    }
    this.uncompressedLength += chunk.length;
    if (this.data.Length == null) {
      this.data.Length = 0;
    }
    if (this.compress) {
      if (!this.deflate) {
        this.initDeflate();
      }
      this.deflate.write(chunk);
    } else {
      this.chunks.push(chunk);
      this.data.Length += chunk.length;
    }
    return callback();
  }
  end() {
    super.end(...arguments);
    if (this.deflate) {
      return this.deflate.end();
    }
    return this.finalize();
  }
  finalize() {
    this.offset = this.document._offset;
    this.document._write(`${this.id} ${this.gen} obj`);
    this.document._write(PDFObject.convert(this.data));
    if (this.chunks.length) {
      this.document._write("stream");
      for (let chunk of Array.from(this.chunks)) {
        this.document._write(chunk);
      }
      this.chunks.length = 0;
      this.document._write("\nendstream");
    }
    this.document._write("endobj");
    return this.document._refEnd(this);
  }
  toString() {
    return `${this.id} ${this.gen} R`;
  }
};
var PDFTree = class {
  static {
    __name(this, "PDFTree");
  }
  constructor(options) {
    if (options === void 0) {
      options = {};
    }
    this._items = {};
    this.limits = typeof options.limits === "boolean" ? options.limits : true;
  }
  add(key, val) {
    return this._items[key] = val;
  }
  get(key) {
    return this._items[key];
  }
  toString() {
    const sortedKeys = Object.keys(this._items).sort((a4, b3) => this._compareKeys(a4, b3));
    const out = ["<<"];
    if (this.limits && sortedKeys.length > 1) {
      const first = sortedKeys[0], last2 = sortedKeys[sortedKeys.length - 1];
      out.push(`  /Limits ${PDFObject.convert([this._dataForKey(first), this._dataForKey(last2)])}`);
    }
    out.push(`  /${this._keysName()} [`);
    for (let key of sortedKeys) {
      out.push(`    ${PDFObject.convert(this._dataForKey(key))} ${PDFObject.convert(this._items[key])}`);
    }
    out.push("]");
    out.push(">>");
    return out.join("\n");
  }
  _compareKeys() {
    throw new Error("Must be implemented by subclasses");
  }
  _keysName() {
    throw new Error("Must be implemented by subclasses");
  }
  _dataForKey() {
    throw new Error("Must be implemented by subclasses");
  }
};
var PDFNameTree = class extends PDFTree {
  static {
    __name(this, "PDFNameTree");
  }
  _compareKeys(a4, b3) {
    return a4.localeCompare(b3);
  }
  _keysName() {
    return "Names";
  }
  _dataForKey(k3) {
    return new String(k3);
  }
};
var pad2 = /* @__PURE__ */ __name((str, length2) => (Array(length2 + 1).join("0") + str).slice(-length2), "pad");
var escapableRe = /[\n\r\t\b\f()\\]/g;
var escapable = {
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\b": "\\b",
  "\f": "\\f",
  "\\": "\\\\",
  "(": "\\(",
  ")": "\\)"
};
var swapBytes = /* @__PURE__ */ __name(function(buff) {
  const l4 = buff.length;
  if (l4 & 1) {
    throw new Error("Buffer length must be even");
  } else {
    for (let i2 = 0, end2 = l4 - 1; i2 < end2; i2 += 2) {
      const a4 = buff[i2];
      buff[i2] = buff[i2 + 1];
      buff[i2 + 1] = a4;
    }
  }
  return buff;
}, "swapBytes");
var PDFObject = class _PDFObject {
  static {
    __name(this, "PDFObject");
  }
  static convert(object) {
    if (typeof object === "string") {
      return `/${object}`;
    }
    if (object instanceof String) {
      let string = object;
      let isUnicode = false;
      for (let i2 = 0, end2 = string.length; i2 < end2; i2++) {
        if (string.charCodeAt(i2) > 127) {
          isUnicode = true;
          break;
        }
      }
      if (isUnicode) {
        string = swapBytes(Buffer$2.from(`\uFEFF${string}`, "utf16le")).toString("binary");
      }
      string = string.replace(escapableRe, (c2) => escapable[c2]);
      return `(${string})`;
    }
    if (Buffer$2.isBuffer(object)) {
      return `<${object.toString("hex")}>`;
    }
    if (object instanceof PDFReference || object instanceof PDFNameTree) {
      return object.toString();
    }
    if (object instanceof Date) {
      return `(D:${pad2(object.getUTCFullYear(), 4)}` + pad2(object.getUTCMonth() + 1, 2) + pad2(object.getUTCDate(), 2) + pad2(object.getUTCHours(), 2) + pad2(object.getUTCMinutes(), 2) + pad2(object.getUTCSeconds(), 2) + "Z)";
    }
    if (Array.isArray(object)) {
      const items = Array.from(object).map((e4) => _PDFObject.convert(e4)).join(" ");
      return `[${items}]`;
    }
    if ({}.toString.call(object) === "[object Object]") {
      const out = ["<<"];
      for (let key in object) {
        const val = object[key];
        out.push(`/${key} ${_PDFObject.convert(val)}`);
      }
      out.push(">>");
      return out.join("\n");
    }
    if (typeof object === "number") {
      return _PDFObject.number(object);
    }
    return `${object}`;
  }
  static number(n5) {
    if (n5 > -1e21 && n5 < 1e21) {
      return Math.round(n5 * 1e6) / 1e6;
    }
    throw new Error(`unsupported number: ${n5}`);
  }
};
var DEFAULT_MARGINS = {
  top: 72,
  left: 72,
  bottom: 72,
  right: 72
};
var SIZES = {
  "4A0": [4767.87, 6740.79],
  "2A0": [3370.39, 4767.87],
  A0: [2383.94, 3370.39],
  A1: [1683.78, 2383.94],
  A2: [1190.55, 1683.78],
  A3: [841.89, 1190.55],
  A4: [595.28, 841.89],
  A5: [419.53, 595.28],
  A6: [297.64, 419.53],
  A7: [209.76, 297.64],
  A8: [147.4, 209.76],
  A9: [104.88, 147.4],
  A10: [73.7, 104.88],
  B0: [2834.65, 4008.19],
  B1: [2004.09, 2834.65],
  B2: [1417.32, 2004.09],
  B3: [1000.63, 1417.32],
  B4: [708.66, 1000.63],
  B5: [498.9, 708.66],
  B6: [354.33, 498.9],
  B7: [249.45, 354.33],
  B8: [175.75, 249.45],
  B9: [124.72, 175.75],
  B10: [87.87, 124.72],
  C0: [2599.37, 3676.54],
  C1: [1836.85, 2599.37],
  C2: [1298.27, 1836.85],
  C3: [918.43, 1298.27],
  C4: [649.13, 918.43],
  C5: [459.21, 649.13],
  C6: [323.15, 459.21],
  C7: [229.61, 323.15],
  C8: [161.57, 229.61],
  C9: [113.39, 161.57],
  C10: [79.37, 113.39],
  RA0: [2437.8, 3458.27],
  RA1: [1729.13, 2437.8],
  RA2: [1218.9, 1729.13],
  RA3: [864.57, 1218.9],
  RA4: [609.45, 864.57],
  SRA0: [2551.18, 3628.35],
  SRA1: [1814.17, 2551.18],
  SRA2: [1275.59, 1814.17],
  SRA3: [907.09, 1275.59],
  SRA4: [637.8, 907.09],
  EXECUTIVE: [521.86, 756],
  FOLIO: [612, 936],
  LEGAL: [612, 1008],
  LETTER: [612, 792],
  TABLOID: [792, 1224]
};
var PDFPage = class {
  static {
    __name(this, "PDFPage");
  }
  constructor(document2, options) {
    if (options === void 0) {
      options = {};
    }
    this.document = document2;
    this._options = options;
    this.size = options.size || "letter";
    this.layout = options.layout || "portrait";
    this.userUnit = options.userUnit || 1;
    if (typeof options.margin === "number") {
      this.margins = {
        top: options.margin,
        left: options.margin,
        bottom: options.margin,
        right: options.margin
      };
    } else {
      this.margins = options.margins || DEFAULT_MARGINS;
    }
    const dimensions = Array.isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()];
    this.width = dimensions[this.layout === "portrait" ? 0 : 1];
    this.height = dimensions[this.layout === "portrait" ? 1 : 0];
    this.content = this.document.ref();
    if (options.font) document2.font(options.font, options.fontFamily);
    if (options.fontSize) document2.fontSize(options.fontSize);
    this.resources = this.document.ref({
      ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"]
    });
    this.dictionary = this.document.ref({
      Type: "Page",
      Parent: this.document._root.data.Pages,
      MediaBox: [0, 0, this.width, this.height],
      Contents: this.content,
      Resources: this.resources,
      UserUnit: this.userUnit
    });
    this.markings = [];
  }
  // Lazily create these objects
  get fonts() {
    const data2 = this.resources.data;
    return data2.Font != null ? data2.Font : data2.Font = {};
  }
  get xobjects() {
    const data2 = this.resources.data;
    return data2.XObject != null ? data2.XObject : data2.XObject = {};
  }
  get ext_gstates() {
    const data2 = this.resources.data;
    return data2.ExtGState != null ? data2.ExtGState : data2.ExtGState = {};
  }
  get patterns() {
    const data2 = this.resources.data;
    return data2.Pattern != null ? data2.Pattern : data2.Pattern = {};
  }
  get colorSpaces() {
    const data2 = this.resources.data;
    return data2.ColorSpace || (data2.ColorSpace = {});
  }
  get annotations() {
    const data2 = this.dictionary.data;
    return data2.Annots != null ? data2.Annots : data2.Annots = [];
  }
  get structParentTreeKey() {
    const data2 = this.dictionary.data;
    return data2.StructParents != null ? data2.StructParents : data2.StructParents = this.document.createStructParentTreeNextKey();
  }
  maxY() {
    return this.height - this.margins.bottom;
  }
  write(chunk) {
    return this.content.write(chunk);
  }
  // Set tab order if document is tagged for accessibility.
  _setTabOrder() {
    if (!this.dictionary.Tabs && this.document.hasMarkInfoDictionary()) {
      this.dictionary.data.Tabs = "S";
    }
  }
  end() {
    this._setTabOrder();
    this.dictionary.end();
    this.resources.data.ColorSpace = this.resources.data.ColorSpace || {};
    for (let color of Object.values(this.document.spotColors)) {
      this.resources.data.ColorSpace[color.id] = color;
    }
    this.resources.end();
    return this.content.end();
  }
};
var wordArrayToBuffer = /* @__PURE__ */ __name((wordArray) => {
  const byteArray = [];
  for (let i2 = 0; i2 < wordArray.sigBytes; i2++) {
    byteArray.push(wordArray.words[Math.floor(i2 / 4)] >> 8 * (3 - i2 % 4) & 255);
  }
  return Buffer$2.from(byteArray);
}, "wordArrayToBuffer");
var PDFSecurity = class {
  static {
    __name(this, "PDFSecurity");
  }
  static generateFileID(info3) {
    if (info3 === void 0) {
      info3 = {};
    }
    let infoStr = `${info3.CreationDate.getTime()}
`;
    for (let key in info3) {
      if (!info3.hasOwnProperty(key)) continue;
      infoStr += `${key}: ${info3[key].valueOf()}
`;
    }
    return wordArrayToBuffer((0, import_md5.default)(infoStr));
  }
};
var {
  number: number$2
} = PDFObject;
var PDFGradient$1 = class PDFGradient {
  static {
    __name(this, "PDFGradient");
  }
  constructor(doc) {
    this.doc = doc;
    this.stops = [];
    this.embedded = false;
    this.transform = [1, 0, 0, 1, 0, 0];
  }
  stop(pos, color, opacity) {
    if (opacity == null) {
      opacity = 1;
    }
    color = this.doc._normalizeColor(color);
    if (this.stops.length === 0) {
      if (color.length === 3) {
        this._colorSpace = "DeviceRGB";
      } else if (color.length === 4) {
        this._colorSpace = "DeviceCMYK";
      } else if (color.length === 1) {
        this._colorSpace = "DeviceGray";
      } else {
        throw new Error("Unknown color space");
      }
    } else if (this._colorSpace === "DeviceRGB" && color.length !== 3 || this._colorSpace === "DeviceCMYK" && color.length !== 4 || this._colorSpace === "DeviceGray" && color.length !== 1) {
      throw new Error("All gradient stops must use the same color space");
    }
    opacity = Math.max(0, Math.min(1, opacity));
    this.stops.push([pos, color, opacity]);
    return this;
  }
  setTransform(m11, m12, m21, m22, dx, dy) {
    this.transform = [m11, m12, m21, m22, dx, dy];
    return this;
  }
  embed(m3) {
    let fn;
    const stopsLength = this.stops.length;
    if (stopsLength === 0) {
      return;
    }
    this.embedded = true;
    this.matrix = m3;
    const last2 = this.stops[stopsLength - 1];
    if (last2[0] < 1) {
      this.stops.push([1, last2[1], last2[2]]);
    }
    const bounds = [];
    const encode = [];
    const stops = [];
    for (let i2 = 0; i2 < stopsLength - 1; i2++) {
      encode.push(0, 1);
      if (i2 + 2 !== stopsLength) {
        bounds.push(this.stops[i2 + 1][0]);
      }
      fn = this.doc.ref({
        FunctionType: 2,
        Domain: [0, 1],
        C0: this.stops[i2 + 0][1],
        C1: this.stops[i2 + 1][1],
        N: 1
      });
      stops.push(fn);
      fn.end();
    }
    if (stopsLength === 1) {
      fn = stops[0];
    } else {
      fn = this.doc.ref({
        FunctionType: 3,
        // stitching function
        Domain: [0, 1],
        Functions: stops,
        Bounds: bounds,
        Encode: encode
      });
      fn.end();
    }
    this.id = `Sh${++this.doc._gradCount}`;
    const shader = this.shader(fn);
    shader.end();
    const pattern3 = this.doc.ref({
      Type: "Pattern",
      PatternType: 2,
      Shading: shader,
      Matrix: this.matrix.map(number$2)
    });
    pattern3.end();
    if (this.stops.some((stop) => stop[2] < 1)) {
      let grad = this.opacityGradient();
      grad._colorSpace = "DeviceGray";
      for (let stop of this.stops) {
        grad.stop(stop[0], [stop[2]]);
      }
      grad = grad.embed(this.matrix);
      const pageBBox = [0, 0, this.doc.page.width, this.doc.page.height];
      const form = this.doc.ref({
        Type: "XObject",
        Subtype: "Form",
        FormType: 1,
        BBox: pageBBox,
        Group: {
          Type: "Group",
          S: "Transparency",
          CS: "DeviceGray"
        },
        Resources: {
          ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
          Pattern: {
            Sh1: grad
          }
        }
      });
      form.write("/Pattern cs /Sh1 scn");
      form.end(`${pageBBox.join(" ")} re f`);
      const gstate = this.doc.ref({
        Type: "ExtGState",
        SMask: {
          Type: "Mask",
          S: "Luminosity",
          G: form
        }
      });
      gstate.end();
      const opacityPattern = this.doc.ref({
        Type: "Pattern",
        PatternType: 1,
        PaintType: 1,
        TilingType: 2,
        BBox: pageBBox,
        XStep: pageBBox[2],
        YStep: pageBBox[3],
        Resources: {
          ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
          Pattern: {
            Sh1: pattern3
          },
          ExtGState: {
            Gs1: gstate
          }
        }
      });
      opacityPattern.write("/Gs1 gs /Pattern cs /Sh1 scn");
      opacityPattern.end(`${pageBBox.join(" ")} re f`);
      this.doc.page.patterns[this.id] = opacityPattern;
    } else {
      this.doc.page.patterns[this.id] = pattern3;
    }
    return pattern3;
  }
  apply(stroke) {
    const [m0, m1, m22, m3, m4, m5] = this.doc._ctm;
    const [m11, m12, m21, m222, dx, dy] = this.transform;
    const m6 = [m0 * m11 + m22 * m12, m1 * m11 + m3 * m12, m0 * m21 + m22 * m222, m1 * m21 + m3 * m222, m0 * dx + m22 * dy + m4, m1 * dx + m3 * dy + m5];
    if (!this.embedded || m6.join(" ") !== this.matrix.join(" ")) {
      this.embed(m6);
    }
    this.doc._setColorSpace("Pattern", stroke);
    const op = stroke ? "SCN" : "scn";
    return this.doc.addContent(`/${this.id} ${op}`);
  }
};
var PDFLinearGradient$1 = class PDFLinearGradient extends PDFGradient$1 {
  static {
    __name(this, "PDFLinearGradient");
  }
  constructor(doc, x1, y1, x2, y22) {
    super(doc);
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y22;
  }
  shader(fn) {
    return this.doc.ref({
      ShadingType: 2,
      ColorSpace: this._colorSpace,
      Coords: [this.x1, this.y1, this.x2, this.y2],
      Function: fn,
      Extend: [true, true]
    });
  }
  opacityGradient() {
    return new PDFLinearGradient(this.doc, this.x1, this.y1, this.x2, this.y2);
  }
};
var PDFRadialGradient$1 = class PDFRadialGradient extends PDFGradient$1 {
  static {
    __name(this, "PDFRadialGradient");
  }
  constructor(doc, x1, y1, r1, x2, y22, r22) {
    super(doc);
    this.doc = doc;
    this.x1 = x1;
    this.y1 = y1;
    this.r1 = r1;
    this.x2 = x2;
    this.y2 = y22;
    this.r2 = r22;
  }
  shader(fn) {
    return this.doc.ref({
      ShadingType: 3,
      ColorSpace: this._colorSpace,
      Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],
      Function: fn,
      Extend: [true, true]
    });
  }
  opacityGradient() {
    return new PDFRadialGradient(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);
  }
};
var Gradient = {
  PDFGradient: PDFGradient$1,
  PDFLinearGradient: PDFLinearGradient$1,
  PDFRadialGradient: PDFRadialGradient$1
};
var underlyingColorSpaces = ["DeviceCMYK", "DeviceRGB"];
var PDFTilingPattern$1 = class PDFTilingPattern {
  static {
    __name(this, "PDFTilingPattern");
  }
  constructor(doc, bBox, xStep, yStep, stream2) {
    this.doc = doc;
    this.bBox = bBox;
    this.xStep = xStep;
    this.yStep = yStep;
    this.stream = stream2;
  }
  createPattern() {
    const resources = this.doc.ref();
    resources.end();
    const [m0, m1, m22, m3, m4, m5] = this.doc._ctm;
    const [m11, m12, m21, m222, dx, dy] = [1, 0, 0, 1, 0, 0];
    const m6 = [m0 * m11 + m22 * m12, m1 * m11 + m3 * m12, m0 * m21 + m22 * m222, m1 * m21 + m3 * m222, m0 * dx + m22 * dy + m4, m1 * dx + m3 * dy + m5];
    const pattern3 = this.doc.ref({
      Type: "Pattern",
      PatternType: 1,
      // tiling
      PaintType: 2,
      // 1-colored, 2-uncolored
      TilingType: 2,
      // 2-no distortion
      BBox: this.bBox,
      XStep: this.xStep,
      YStep: this.yStep,
      Matrix: m6.map((v3) => +v3.toFixed(5)),
      Resources: resources
    });
    pattern3.end(this.stream);
    return pattern3;
  }
  embedPatternColorSpaces() {
    underlyingColorSpaces.forEach((csName) => {
      const csId = this.getPatternColorSpaceId(csName);
      if (this.doc.page.colorSpaces[csId]) return;
      const cs = this.doc.ref(["Pattern", csName]);
      cs.end();
      this.doc.page.colorSpaces[csId] = cs;
    });
  }
  getPatternColorSpaceId(underlyingColorspace) {
    return `CsP${underlyingColorspace}`;
  }
  embed() {
    if (!this.id) {
      this.doc._patternCount = this.doc._patternCount + 1;
      this.id = "P" + this.doc._patternCount;
      this.pattern = this.createPattern();
    }
    if (!this.doc.page.patterns[this.id]) {
      this.doc.page.patterns[this.id] = this.pattern;
    }
  }
  apply(stroke, patternColor) {
    this.embedPatternColorSpaces();
    this.embed();
    const normalizedColor = this.doc._normalizeColor(patternColor);
    if (!normalizedColor) throw Error(`invalid pattern color. (value: ${patternColor})`);
    const csId = this.getPatternColorSpaceId(this.doc._getColorSpace(normalizedColor));
    this.doc._setColorSpace(csId, stroke);
    const op = stroke ? "SCN" : "scn";
    return this.doc.addContent(`${normalizedColor.join(" ")} /${this.id} ${op}`);
  }
};
var pattern = {
  PDFTilingPattern: PDFTilingPattern$1
};
var SpotColor = class {
  static {
    __name(this, "SpotColor");
  }
  constructor(doc, name, C, M, Y, K) {
    this.id = "CS" + Object.keys(doc.spotColors).length;
    this.name = name;
    this.values = [C, M, Y, K];
    this.ref = doc.ref(["Separation", this.name, "DeviceCMYK", {
      Range: [0, 1, 0, 1, 0, 1, 0, 1],
      C0: [0, 0, 0, 0],
      C1: this.values.map((value2) => value2 / 100),
      FunctionType: 2,
      Domain: [0, 1],
      N: 1
    }]);
    this.ref.end();
  }
  toString() {
    return `${this.ref.id} 0 R`;
  }
};
var {
  PDFGradient: PDFGradient2,
  PDFLinearGradient: PDFLinearGradient2,
  PDFRadialGradient: PDFRadialGradient2
} = Gradient;
var {
  PDFTilingPattern: PDFTilingPattern2
} = pattern;
var ColorMixin = {
  initColor() {
    this.spotColors = {};
    this._opacityRegistry = {};
    this._opacityCount = 0;
    this._patternCount = 0;
    return this._gradCount = 0;
  },
  _normalizeColor(color) {
    if (typeof color === "string") {
      if (color.charAt(0) === "#") {
        if (color.length === 4) {
          color = color.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, "#$1$1$2$2$3$3");
        }
        const hex = parseInt(color.slice(1), 16);
        color = [hex >> 16, hex >> 8 & 255, hex & 255];
      } else if (namedColors[color]) {
        color = namedColors[color];
      } else if (this.spotColors[color]) {
        return this.spotColors[color];
      }
    }
    if (Array.isArray(color)) {
      if (color.length === 3) {
        color = color.map((part) => part / 255);
      } else if (color.length === 4) {
        color = color.map((part) => part / 100);
      }
      return color;
    }
    return null;
  },
  _setColor(color, stroke) {
    if (color instanceof PDFGradient2) {
      color.apply(stroke);
      return true;
    } else if (Array.isArray(color) && color[0] instanceof PDFTilingPattern2) {
      color[0].apply(stroke, color[1]);
      return true;
    }
    return this._setColorCore(color, stroke);
  },
  _setColorCore(color, stroke) {
    color = this._normalizeColor(color);
    if (!color) {
      return false;
    }
    const op = stroke ? "SCN" : "scn";
    const space = this._getColorSpace(color);
    this._setColorSpace(space, stroke);
    if (color instanceof SpotColor) {
      this.page.colorSpaces[color.id] = color.ref;
      this.addContent(`1 ${op}`);
    } else {
      this.addContent(`${color.join(" ")} ${op}`);
    }
    return true;
  },
  _setColorSpace(space, stroke) {
    const op = stroke ? "CS" : "cs";
    return this.addContent(`/${space} ${op}`);
  },
  _getColorSpace(color) {
    if (color instanceof SpotColor) {
      return color.id;
    }
    return color.length === 4 ? "DeviceCMYK" : "DeviceRGB";
  },
  fillColor(color, opacity) {
    const set5 = this._setColor(color, false);
    if (set5) {
      this.fillOpacity(opacity);
    }
    this._fillColor = [color, opacity];
    return this;
  },
  strokeColor(color, opacity) {
    const set5 = this._setColor(color, true);
    if (set5) {
      this.strokeOpacity(opacity);
    }
    return this;
  },
  opacity(opacity) {
    this._doOpacity(opacity, opacity);
    return this;
  },
  fillOpacity(opacity) {
    this._doOpacity(opacity, null);
    return this;
  },
  strokeOpacity(opacity) {
    this._doOpacity(null, opacity);
    return this;
  },
  _doOpacity(fillOpacity, strokeOpacity) {
    let dictionary, name;
    if (fillOpacity == null && strokeOpacity == null) {
      return;
    }
    if (fillOpacity != null) {
      fillOpacity = Math.max(0, Math.min(1, fillOpacity));
    }
    if (strokeOpacity != null) {
      strokeOpacity = Math.max(0, Math.min(1, strokeOpacity));
    }
    const key = `${fillOpacity}_${strokeOpacity}`;
    if (this._opacityRegistry[key]) {
      [dictionary, name] = this._opacityRegistry[key];
    } else {
      dictionary = {
        Type: "ExtGState"
      };
      if (fillOpacity != null) {
        dictionary.ca = fillOpacity;
      }
      if (strokeOpacity != null) {
        dictionary.CA = strokeOpacity;
      }
      dictionary = this.ref(dictionary);
      dictionary.end();
      const id = ++this._opacityCount;
      name = `Gs${id}`;
      this._opacityRegistry[key] = [dictionary, name];
    }
    this.page.ext_gstates[name] = dictionary;
    return this.addContent(`/${name} gs`);
  },
  linearGradient(x1, y1, x2, y22) {
    return new PDFLinearGradient2(this, x1, y1, x2, y22);
  },
  radialGradient(x1, y1, r1, x2, y22, r22) {
    return new PDFRadialGradient2(this, x1, y1, r1, x2, y22, r22);
  },
  pattern(bbox, xStep, yStep, stream2) {
    return new PDFTilingPattern2(this, bbox, xStep, yStep, stream2);
  },
  addSpotColor(name, C, M, Y, K) {
    const color = new SpotColor(this, name, C, M, Y, K);
    this.spotColors[name] = color;
    return this;
  }
};
var namedColors = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
var cx;
var cy;
var px;
var py;
var sx;
var sy;
cx = cy = px = py = sx = sy = 0;
var argsCountPerCommand = {
  M: 2,
  m: 2,
  Z: 0,
  z: 0,
  L: 2,
  l: 2,
  H: 1,
  h: 1,
  V: 1,
  v: 1,
  C: 6,
  c: 6,
  S: 4,
  s: 4,
  Q: 4,
  q: 4,
  T: 2,
  t: 2,
  A: 7,
  a: 7
};
var isCommand = /* @__PURE__ */ __name((c2) => {
  return c2 in argsCountPerCommand;
}, "isCommand");
var isWsp = /* @__PURE__ */ __name((c2) => {
  const codePoint = c2.codePointAt(0);
  return codePoint === 32 || codePoint === 9 || codePoint === 13 || codePoint === 10;
}, "isWsp");
var isDigit = /* @__PURE__ */ __name((c2) => {
  const codePoint = c2.codePointAt(0);
  if (codePoint == null) {
    return false;
  }
  return 48 <= codePoint && codePoint <= 57;
}, "isDigit");
var readNumber = /* @__PURE__ */ __name((string, cursor) => {
  let i2 = cursor;
  let value2 = "";
  let state2 = (
    /** @type {ReadNumberState} */
    "none"
  );
  for (; i2 < string.length; i2 += 1) {
    const c2 = string[i2];
    if (c2 === "+" || c2 === "-") {
      if (state2 === "none") {
        state2 = "sign";
        value2 += c2;
        continue;
      }
      if (state2 === "e") {
        state2 = "exponent_sign";
        value2 += c2;
        continue;
      }
    }
    if (isDigit(c2)) {
      if (state2 === "none" || state2 === "sign" || state2 === "whole") {
        state2 = "whole";
        value2 += c2;
        continue;
      }
      if (state2 === "decimal_point" || state2 === "decimal") {
        state2 = "decimal";
        value2 += c2;
        continue;
      }
      if (state2 === "e" || state2 === "exponent_sign" || state2 === "exponent") {
        state2 = "exponent";
        value2 += c2;
        continue;
      }
    }
    if (c2 === ".") {
      if (state2 === "none" || state2 === "sign" || state2 === "whole") {
        state2 = "decimal_point";
        value2 += c2;
        continue;
      }
    }
    if (c2 === "E" || c2 === "e") {
      if (state2 === "whole" || state2 === "decimal_point" || state2 === "decimal") {
        state2 = "e";
        value2 += c2;
        continue;
      }
    }
    break;
  }
  const number3 = Number.parseFloat(value2);
  if (Number.isNaN(number3)) {
    return [cursor, null];
  }
  return [i2 - 1, number3];
}, "readNumber");
var parsePathData = /* @__PURE__ */ __name((string) => {
  const pathData = [];
  let command = null;
  let args = (
    /** @type {number[]} */
    []
  );
  let argsCount = 0;
  let canHaveComma = false;
  let hadComma = false;
  for (let i2 = 0; i2 < string.length; i2 += 1) {
    const c2 = string.charAt(i2);
    if (isWsp(c2)) {
      continue;
    }
    if (canHaveComma && c2 === ",") {
      if (hadComma) {
        break;
      }
      hadComma = true;
      continue;
    }
    if (isCommand(c2)) {
      if (hadComma) {
        return pathData;
      }
      if (command == null) {
        if (c2 !== "M" && c2 !== "m") {
          return pathData;
        }
      } else {
        if (args.length !== 0) {
          return pathData;
        }
      }
      command = c2;
      args = [];
      argsCount = argsCountPerCommand[command];
      canHaveComma = false;
      if (argsCount === 0) {
        pathData.push({
          command,
          args
        });
      }
      continue;
    }
    if (command == null) {
      return pathData;
    }
    let newCursor = i2;
    let number3 = null;
    if (command === "A" || command === "a") {
      const position = args.length;
      if (position === 0 || position === 1) {
        if (c2 !== "+" && c2 !== "-") {
          [newCursor, number3] = readNumber(string, i2);
        }
      }
      if (position === 2 || position === 5 || position === 6) {
        [newCursor, number3] = readNumber(string, i2);
      }
      if (position === 3 || position === 4) {
        if (c2 === "0") {
          number3 = 0;
        }
        if (c2 === "1") {
          number3 = 1;
        }
      }
    } else {
      [newCursor, number3] = readNumber(string, i2);
    }
    if (number3 == null) {
      return pathData;
    }
    args.push(number3);
    canHaveComma = true;
    hadComma = false;
    i2 = newCursor;
    if (args.length === argsCount) {
      pathData.push({
        command,
        args
      });
      if (command === "M") {
        command = "L";
      }
      if (command === "m") {
        command = "l";
      }
      args = [];
    }
  }
  return pathData;
}, "parsePathData");
var apply = /* @__PURE__ */ __name(function(commands, doc) {
  cx = cy = px = py = sx = sy = 0;
  for (let i2 = 0; i2 < commands.length; i2++) {
    const {
      command,
      args
    } = commands[i2];
    if (typeof runners[command] === "function") {
      runners[command](doc, args);
    }
  }
}, "apply");
var runners = {
  M(doc, a4) {
    cx = a4[0];
    cy = a4[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return doc.moveTo(cx, cy);
  },
  m(doc, a4) {
    cx += a4[0];
    cy += a4[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return doc.moveTo(cx, cy);
  },
  C(doc, a4) {
    cx = a4[4];
    cy = a4[5];
    px = a4[2];
    py = a4[3];
    return doc.bezierCurveTo(...a4);
  },
  c(doc, a4) {
    doc.bezierCurveTo(a4[0] + cx, a4[1] + cy, a4[2] + cx, a4[3] + cy, a4[4] + cx, a4[5] + cy);
    px = cx + a4[2];
    py = cy + a4[3];
    cx += a4[4];
    return cy += a4[5];
  },
  S(doc, a4) {
    if (px === null) {
      px = cx;
      py = cy;
    }
    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a4[0], a4[1], a4[2], a4[3]);
    px = a4[0];
    py = a4[1];
    cx = a4[2];
    return cy = a4[3];
  },
  s(doc, a4) {
    if (px === null) {
      px = cx;
      py = cy;
    }
    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a4[0], cy + a4[1], cx + a4[2], cy + a4[3]);
    px = cx + a4[0];
    py = cy + a4[1];
    cx += a4[2];
    return cy += a4[3];
  },
  Q(doc, a4) {
    px = a4[0];
    py = a4[1];
    cx = a4[2];
    cy = a4[3];
    return doc.quadraticCurveTo(a4[0], a4[1], cx, cy);
  },
  q(doc, a4) {
    doc.quadraticCurveTo(a4[0] + cx, a4[1] + cy, a4[2] + cx, a4[3] + cy);
    px = cx + a4[0];
    py = cy + a4[1];
    cx += a4[2];
    return cy += a4[3];
  },
  T(doc, a4) {
    if (px === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    doc.quadraticCurveTo(px, py, a4[0], a4[1]);
    px = cx - (px - cx);
    py = cy - (py - cy);
    cx = a4[0];
    return cy = a4[1];
  },
  t(doc, a4) {
    if (px === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    doc.quadraticCurveTo(px, py, cx + a4[0], cy + a4[1]);
    cx += a4[0];
    return cy += a4[1];
  },
  A(doc, a4) {
    solveArc(doc, cx, cy, a4);
    cx = a4[5];
    return cy = a4[6];
  },
  a(doc, a4) {
    a4[5] += cx;
    a4[6] += cy;
    solveArc(doc, cx, cy, a4);
    cx = a4[5];
    return cy = a4[6];
  },
  L(doc, a4) {
    cx = a4[0];
    cy = a4[1];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  l(doc, a4) {
    cx += a4[0];
    cy += a4[1];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  H(doc, a4) {
    cx = a4[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  h(doc, a4) {
    cx += a4[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  V(doc, a4) {
    cy = a4[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  v(doc, a4) {
    cy += a4[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  Z(doc) {
    doc.closePath();
    cx = sx;
    return cy = sy;
  },
  z(doc) {
    doc.closePath();
    cx = sx;
    return cy = sy;
  }
};
var solveArc = /* @__PURE__ */ __name(function(doc, x, y3, coords) {
  const [rx, ry, rot, large, sweep, ex, ey] = coords;
  const segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y3);
  for (let seg of segs) {
    const bez = segmentToBezier(...seg);
    doc.bezierCurveTo(...bez);
  }
}, "solveArc");
var arcToSegments = /* @__PURE__ */ __name(function(x, y3, rx, ry, large, sweep, rotateX, ox, oy) {
  const th = rotateX * (Math.PI / 180);
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y3) * 0.5;
  py = cos_th * (oy - y3) * 0.5 - sin_th * (ox - x) * 0.5;
  let pl = px * px / (rx * rx) + py * py / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x0 = a00 * ox + a01 * oy;
  const y0 = a10 * ox + a11 * oy;
  const x1 = a00 * x + a01 * y3;
  const y1 = a10 * x + a11 * y3;
  const d3 = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
  let sfactor_sq = 1 / d3 - 0.25;
  if (sfactor_sq < 0) {
    sfactor_sq = 0;
  }
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep === large) {
    sfactor = -sfactor;
  }
  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
  const th0 = Math.atan2(y0 - yc, x0 - xc);
  const th1 = Math.atan2(y1 - yc, x1 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += 2 * Math.PI;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= 2 * Math.PI;
  }
  const segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 1e-3)));
  const result = [];
  for (let i2 = 0; i2 < segments; i2++) {
    const th2 = th0 + i2 * th_arc / segments;
    const th3 = th0 + (i2 + 1) * th_arc / segments;
    result[i2] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return result;
}, "arcToSegments");
var segmentToBezier = /* @__PURE__ */ __name(function(cx2, cy2, th0, th1, rx, ry, sin_th, cos_th) {
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const th_half = 0.5 * (th1 - th0);
  const t4 = 8 / 3 * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);
  const x1 = cx2 + Math.cos(th0) - t4 * Math.sin(th0);
  const y1 = cy2 + Math.sin(th0) + t4 * Math.cos(th0);
  const x3 = cx2 + Math.cos(th1);
  const y3 = cy2 + Math.sin(th1);
  const x2 = x3 + t4 * Math.sin(th1);
  const y22 = y3 - t4 * Math.cos(th1);
  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y22, a10 * x2 + a11 * y22, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
}, "segmentToBezier");
var SVGPath = class {
  static {
    __name(this, "SVGPath");
  }
  static apply(doc, path) {
    const commands = parsePathData(path);
    apply(commands, doc);
  }
};
var {
  number: number$1
} = PDFObject;
var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
var VectorMixin = {
  initVector() {
    this._ctm = [1, 0, 0, 1, 0, 0];
    return this._ctmStack = [];
  },
  save() {
    this._ctmStack.push(this._ctm.slice());
    return this.addContent("q");
  },
  restore() {
    this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];
    return this.addContent("Q");
  },
  closePath() {
    return this.addContent("h");
  },
  lineWidth(w) {
    return this.addContent(`${number$1(w)} w`);
  },
  _CAP_STYLES: {
    BUTT: 0,
    ROUND: 1,
    SQUARE: 2
  },
  lineCap(c2) {
    if (typeof c2 === "string") {
      c2 = this._CAP_STYLES[c2.toUpperCase()];
    }
    return this.addContent(`${c2} J`);
  },
  _JOIN_STYLES: {
    MITER: 0,
    ROUND: 1,
    BEVEL: 2
  },
  lineJoin(j) {
    if (typeof j === "string") {
      j = this._JOIN_STYLES[j.toUpperCase()];
    }
    return this.addContent(`${j} j`);
  },
  miterLimit(m3) {
    return this.addContent(`${number$1(m3)} M`);
  },
  dash(length2, options) {
    if (options === void 0) {
      options = {};
    }
    const originalLength = length2;
    if (!Array.isArray(length2)) {
      length2 = [length2, options.space || length2];
    }
    const valid = length2.every((x) => Number.isFinite(x) && x > 0);
    if (!valid) {
      throw new Error(`dash(${JSON.stringify(originalLength)}, ${JSON.stringify(options)}) invalid, lengths must be numeric and greater than zero`);
    }
    length2 = length2.map(number$1).join(" ");
    return this.addContent(`[${length2}] ${number$1(options.phase || 0)} d`);
  },
  undash() {
    return this.addContent("[] 0 d");
  },
  moveTo(x, y3) {
    return this.addContent(`${number$1(x)} ${number$1(y3)} m`);
  },
  lineTo(x, y3) {
    return this.addContent(`${number$1(x)} ${number$1(y3)} l`);
  },
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y3) {
    return this.addContent(`${number$1(cp1x)} ${number$1(cp1y)} ${number$1(cp2x)} ${number$1(cp2y)} ${number$1(x)} ${number$1(y3)} c`);
  },
  quadraticCurveTo(cpx, cpy, x, y3) {
    return this.addContent(`${number$1(cpx)} ${number$1(cpy)} ${number$1(x)} ${number$1(y3)} v`);
  },
  rect(x, y3, w, h) {
    return this.addContent(`${number$1(x)} ${number$1(y3)} ${number$1(w)} ${number$1(h)} re`);
  },
  roundedRect(x, y3, w, h, r5) {
    if (r5 == null) {
      r5 = 0;
    }
    r5 = Math.min(r5, 0.5 * w, 0.5 * h);
    const c2 = r5 * (1 - KAPPA);
    this.moveTo(x + r5, y3);
    this.lineTo(x + w - r5, y3);
    this.bezierCurveTo(x + w - c2, y3, x + w, y3 + c2, x + w, y3 + r5);
    this.lineTo(x + w, y3 + h - r5);
    this.bezierCurveTo(x + w, y3 + h - c2, x + w - c2, y3 + h, x + w - r5, y3 + h);
    this.lineTo(x + r5, y3 + h);
    this.bezierCurveTo(x + c2, y3 + h, x, y3 + h - c2, x, y3 + h - r5);
    this.lineTo(x, y3 + r5);
    this.bezierCurveTo(x, y3 + c2, x + c2, y3, x + r5, y3);
    return this.closePath();
  },
  ellipse(x, y3, r1, r22) {
    if (r22 == null) {
      r22 = r1;
    }
    x -= r1;
    y3 -= r22;
    const ox = r1 * KAPPA;
    const oy = r22 * KAPPA;
    const xe = x + r1 * 2;
    const ye = y3 + r22 * 2;
    const xm = x + r1;
    const ym = y3 + r22;
    this.moveTo(x, ym);
    this.bezierCurveTo(x, ym - oy, xm - ox, y3, xm, y3);
    this.bezierCurveTo(xm + ox, y3, xe, ym - oy, xe, ym);
    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
    return this.closePath();
  },
  circle(x, y3, radius) {
    return this.ellipse(x, y3, radius);
  },
  arc(x, y3, radius, startAngle, endAngle, anticlockwise) {
    if (anticlockwise == null) {
      anticlockwise = false;
    }
    const TWO_PI = 2 * Math.PI;
    const HALF_PI = 0.5 * Math.PI;
    let deltaAng = endAngle - startAngle;
    if (Math.abs(deltaAng) > TWO_PI) {
      deltaAng = TWO_PI;
    } else if (deltaAng !== 0 && anticlockwise !== deltaAng < 0) {
      const dir3 = anticlockwise ? -1 : 1;
      deltaAng = dir3 * TWO_PI + deltaAng;
    }
    const numSegs = Math.ceil(Math.abs(deltaAng) / HALF_PI);
    const segAng = deltaAng / numSegs;
    const handleLen = segAng / HALF_PI * KAPPA * radius;
    let curAng = startAngle;
    let deltaCx = -Math.sin(curAng) * handleLen;
    let deltaCy = Math.cos(curAng) * handleLen;
    let ax = x + Math.cos(curAng) * radius;
    let ay = y3 + Math.sin(curAng) * radius;
    this.moveTo(ax, ay);
    for (let segIdx = 0; segIdx < numSegs; segIdx++) {
      const cp1x = ax + deltaCx;
      const cp1y = ay + deltaCy;
      curAng += segAng;
      ax = x + Math.cos(curAng) * radius;
      ay = y3 + Math.sin(curAng) * radius;
      deltaCx = -Math.sin(curAng) * handleLen;
      deltaCy = Math.cos(curAng) * handleLen;
      const cp2x = ax - deltaCx;
      const cp2y = ay - deltaCy;
      this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ax, ay);
    }
    return this;
  },
  polygon() {
    for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
      points[_key] = arguments[_key];
    }
    this.moveTo(...points.shift() || []);
    for (let point of points) {
      this.lineTo(...point || []);
    }
    return this.closePath();
  },
  path(path) {
    SVGPath.apply(this, path);
    return this;
  },
  _windingRule(rule) {
    if (/even-?odd/.test(rule)) {
      return "*";
    }
    return "";
  },
  fill(color, rule) {
    if (/(even-?odd)|(non-?zero)/.test(color)) {
      rule = color;
      color = null;
    }
    if (color) {
      this.fillColor(color);
    }
    return this.addContent(`f${this._windingRule(rule)}`);
  },
  stroke(color) {
    if (color) {
      this.strokeColor(color);
    }
    return this.addContent("S");
  },
  fillAndStroke(fillColor, strokeColor, rule) {
    if (strokeColor == null) {
      strokeColor = fillColor;
    }
    const isFillRule = /(even-?odd)|(non-?zero)/;
    if (isFillRule.test(fillColor)) {
      rule = fillColor;
      fillColor = null;
    }
    if (isFillRule.test(strokeColor)) {
      rule = strokeColor;
      strokeColor = fillColor;
    }
    if (fillColor) {
      this.fillColor(fillColor);
      this.strokeColor(strokeColor);
    }
    return this.addContent(`B${this._windingRule(rule)}`);
  },
  clip(rule) {
    return this.addContent(`W${this._windingRule(rule)} n`);
  },
  transform(m11, m12, m21, m22, dx, dy) {
    if (m11 === 1 && m12 === 0 && m21 === 0 && m22 === 1 && dx === 0 && dy === 0) {
      return this;
    }
    const m3 = this._ctm;
    const [m0, m1, m23, m32, m4, m5] = m3;
    m3[0] = m0 * m11 + m23 * m12;
    m3[1] = m1 * m11 + m32 * m12;
    m3[2] = m0 * m21 + m23 * m22;
    m3[3] = m1 * m21 + m32 * m22;
    m3[4] = m0 * dx + m23 * dy + m4;
    m3[5] = m1 * dx + m32 * dy + m5;
    const values = [m11, m12, m21, m22, dx, dy].map((v3) => number$1(v3)).join(" ");
    return this.addContent(`${values} cm`);
  },
  translate(x, y3) {
    return this.transform(1, 0, 0, 1, x, y3);
  },
  rotate(angle, options) {
    if (options === void 0) {
      options = {};
    }
    let y3;
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    let x = y3 = 0;
    if (options.origin != null) {
      [x, y3] = options.origin;
      const x1 = x * cos - y3 * sin;
      const y1 = x * sin + y3 * cos;
      x -= x1;
      y3 -= y1;
    }
    return this.transform(cos, sin, -sin, cos, x, y3);
  },
  scale(xFactor, yFactor, options) {
    if (options === void 0) {
      options = {};
    }
    let y3;
    if (yFactor == null) {
      yFactor = xFactor;
    }
    if (typeof yFactor === "object") {
      options = yFactor;
      yFactor = xFactor;
    }
    let x = y3 = 0;
    if (options.origin != null) {
      [x, y3] = options.origin;
      x -= xFactor * x;
      y3 -= yFactor * y3;
    }
    return this.transform(xFactor, 0, 0, yFactor, x, y3);
  }
};
var fs = {};
var range = /* @__PURE__ */ __name((left, right, inclusive) => {
  let range2 = [];
  let end2 = right + 1;
  for (let i2 = left; i2 < end2; i2++) {
    range2.push(i2);
  }
  return range2;
}, "range");
var WIN_ANSI_MAP = {
  402: 131,
  8211: 150,
  8212: 151,
  8216: 145,
  8217: 146,
  8218: 130,
  8220: 147,
  8221: 148,
  8222: 132,
  8224: 134,
  8225: 135,
  8226: 149,
  8230: 133,
  8364: 128,
  8240: 137,
  8249: 139,
  8250: 155,
  710: 136,
  8482: 153,
  338: 140,
  339: 156,
  732: 152,
  352: 138,
  353: 154,
  376: 159,
  381: 142,
  382: 158
};
var characters = `.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef

space         exclam         quotedbl       numbersign
dollar        percent        ampersand      quotesingle
parenleft     parenright     asterisk       plus
comma         hyphen         period         slash
zero          one            two            three
four          five           six            seven
eight         nine           colon          semicolon
less          equal          greater        question

at            A              B              C
D             E              F              G
H             I              J              K
L             M              N              O
P             Q              R              S
T             U              V              W
X             Y              Z              bracketleft
backslash     bracketright   asciicircum    underscore

grave         a              b              c
d             e              f              g
h             i              j              k
l             m              n              o
p             q              r              s
t             u              v              w
x             y              z              braceleft
bar           braceright     asciitilde     .notdef

Euro          .notdef        quotesinglbase florin
quotedblbase  ellipsis       dagger         daggerdbl
circumflex    perthousand    Scaron         guilsinglleft
OE            .notdef        Zcaron         .notdef
.notdef       quoteleft      quoteright     quotedblleft
quotedblright bullet         endash         emdash
tilde         trademark      scaron         guilsinglright
oe            .notdef        zcaron         ydieresis

space         exclamdown     cent           sterling
currency      yen            brokenbar      section
dieresis      copyright      ordfeminine    guillemotleft
logicalnot    softhyphen     registered     macron
degree        plusminus      twosuperior    threesuperior
acute         mu             paragraph      periodcentered
cedilla       onesuperior    ordmasculine   guillemotright
onequarter    onehalf        threequarters  questiondown

Agrave        Aacute         Acircumflex    Atilde
Adieresis     Aring          AE             Ccedilla
Egrave        Eacute         Ecircumflex    Edieresis
Igrave        Iacute         Icircumflex    Idieresis
Eth           Ntilde         Ograve         Oacute
Ocircumflex   Otilde         Odieresis      multiply
Oslash        Ugrave         Uacute         Ucircumflex
Udieresis     Yacute         Thorn          germandbls

agrave        aacute         acircumflex    atilde
adieresis     aring          ae             ccedilla
egrave        eacute         ecircumflex    edieresis
igrave        iacute         icircumflex    idieresis
eth           ntilde         ograve         oacute
ocircumflex   otilde         odieresis      divide
oslash        ugrave         uacute         ucircumflex
udieresis     yacute         thorn          ydieresis`.split(/\s+/);
function parse(contents) {
  const obj = {
    attributes: {},
    glyphWidths: {},
    kernPairs: {}
  };
  let section = "";
  for (let line2 of contents.split("\n")) {
    var match2;
    var a4;
    if (match2 = line2.match(/^Start(\w+)/)) {
      section = match2[1];
      continue;
    } else if (match2 = line2.match(/^End(\w+)/)) {
      section = "";
      continue;
    }
    switch (section) {
      case "FontMetrics":
        match2 = line2.match(/(^\w+)\s+(.*)/);
        var key = match2[1];
        var value2 = match2[2];
        if (a4 = obj.attributes[key]) {
          if (!Array.isArray(a4)) {
            a4 = obj.attributes[key] = [a4];
          }
          a4.push(value2);
        } else {
          obj.attributes[key] = value2;
        }
        break;
      case "CharMetrics":
        if (!/^CH?\s/.test(line2)) {
          continue;
        }
        var name = line2.match(/\bN\s+(\.?\w+)\s*;/)[1];
        obj.glyphWidths[name] = +line2.match(/\bWX\s+(\d+)\s*;/)[1];
        break;
      case "KernPairs":
        match2 = line2.match(/^KPX\s+(\.?\w+)\s+(\.?\w+)\s+(-?\d+)/);
        if (match2) {
          obj.kernPairs[match2[1] + match2[2]] = parseInt(match2[3]);
        }
        break;
    }
  }
  return obj;
}
__name(parse, "parse");
var AFMFont = class _AFMFont {
  static {
    __name(this, "AFMFont");
  }
  static open(filename) {
    {
      throw new Error("AFMFont.open not available on browser build");
    }
  }
  static fromJson(json) {
    return new _AFMFont(json);
  }
  constructor(contents) {
    if (typeof contents === "string") {
      this.contents = contents;
      this.parse();
    } else {
      this.attributes = contents.attributes;
      this.glyphWidths = contents.glyphWidths;
      this.kernPairs = contents.kernPairs;
    }
    this.charWidths = range(0, 255).map((i2) => this.glyphWidths[characters[i2]]);
    this.bbox = Array.from(this.attributes.FontBBox.split(/\s+/)).map((e4) => +e4);
    this.ascender = +(this.attributes.Ascender || 0);
    this.descender = +(this.attributes.Descender || 0);
    this.xHeight = +(this.attributes.XHeight || 0);
    this.capHeight = +(this.attributes.CapHeight || 0);
    this.lineGap = this.bbox[3] - this.bbox[1] - (this.ascender - this.descender);
  }
  parse() {
    const parsed = parse(this.contents);
    this.attributes = parsed.attributes;
    this.glyphWidths = parsed.glyphWidths;
    this.kernPairs = parsed.kernPairs;
  }
  encodeText(text) {
    const res = [];
    for (let i2 = 0, end2 = text.length, asc = 0 <= end2; asc ? i2 < end2 : i2 > end2; asc ? i2++ : i2--) {
      let char = text.charCodeAt(i2);
      char = WIN_ANSI_MAP[char] || char;
      res.push(char.toString(16));
    }
    return res;
  }
  glyphsForString(string) {
    const glyphs = [];
    for (let i2 = 0, end2 = string.length, asc = 0 <= end2; asc ? i2 < end2 : i2 > end2; asc ? i2++ : i2--) {
      const charCode = string.charCodeAt(i2);
      glyphs.push(this.characterToGlyph(charCode));
    }
    return glyphs;
  }
  characterToGlyph(character) {
    return characters[WIN_ANSI_MAP[character] || character] || ".notdef";
  }
  widthOfGlyph(glyph) {
    return this.glyphWidths[glyph] || 0;
  }
  getKernPair(left, right) {
    return this.kernPairs[left + right] || 0;
  }
  advancesForGlyphs(glyphs) {
    const advances = [];
    for (let index2 = 0; index2 < glyphs.length; index2++) {
      const left = glyphs[index2];
      const right = glyphs[index2 + 1];
      advances.push(this.widthOfGlyph(left) + this.getKernPair(left, right));
    }
    return advances;
  }
};
var attributes = [
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:43:52 1997",
      "UniqueID 43052",
      "VMusage 37169 48194"
    ],
    FontName: "Helvetica-Bold",
    FullName: "Helvetica Bold",
    FamilyName: "Helvetica",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-170 -228 1003 962 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "532",
    Ascender: "718",
    Descender: "-207",
    StdHW: "118",
    StdVW: "140"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:45:12 1997",
      "UniqueID 43053",
      "VMusage 14482 68586"
    ],
    FontName: "Helvetica-BoldOblique",
    FullName: "Helvetica Bold Oblique",
    FamilyName: "Helvetica",
    Weight: "Bold",
    ItalicAngle: "-12",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-174 -228 1114 962",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "532",
    Ascender: "718",
    Descender: "-207",
    StdHW: "118",
    StdVW: "140"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:44:31 1997",
      "UniqueID 43055",
      "VMusage 14960 69346"
    ],
    FontName: "Helvetica-Oblique",
    FullName: "Helvetica Oblique",
    FamilyName: "Helvetica",
    Weight: "Medium",
    ItalicAngle: "-12",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-170 -225 1116 931 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "523",
    Ascender: "718",
    Descender: "-207",
    StdHW: "76",
    StdVW: "88"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:38:23 1997",
      "UniqueID 43054",
      "VMusage 37069 48094"
    ],
    FontName: "Helvetica",
    FullName: "Helvetica",
    FamilyName: "Helvetica",
    Weight: "Medium",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-166 -225 1000 931 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "523",
    Ascender: "718",
    Descender: "-207",
    StdHW: "76",
    StdVW: "88"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:52:56 1997",
      "UniqueID 43065",
      "VMusage 41636 52661"
    ],
    FontName: "Times-Bold",
    FullName: "Times Bold",
    FamilyName: "Times",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-168 -218 1000 935 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "676",
    XHeight: "461",
    Ascender: "683",
    Descender: "-217",
    StdHW: "44",
    StdVW: "139"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 13:04:06 1997",
      "UniqueID 43066",
      "VMusage 45874 56899"
    ],
    FontName: "Times-BoldItalic",
    FullName: "Times Bold Italic",
    FamilyName: "Times",
    Weight: "Bold",
    ItalicAngle: "-15",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-200 -218 996 921",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "669",
    XHeight: "462",
    Ascender: "683",
    Descender: "-217",
    StdHW: "42",
    StdVW: "121"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:56:55 1997",
      "UniqueID 43067",
      "VMusage 47727 58752"
    ],
    FontName: "Times-Italic",
    FullName: "Times Italic",
    FamilyName: "Times",
    Weight: "Medium",
    ItalicAngle: "-15.5",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-169 -217 1010 883 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "653",
    XHeight: "441",
    Ascender: "683",
    Descender: "-217",
    StdHW: "32",
    StdVW: "76"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:49:17 1997",
      "UniqueID 43068",
      "VMusage 43909 54934"
    ],
    FontName: "Times-Roman",
    FullName: "Times Roman",
    FamilyName: "Times",
    Weight: "Roman",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-168 -218 1000 898 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "662",
    XHeight: "450",
    Ascender: "683",
    Descender: "-217",
    StdHW: "28",
    StdVW: "84"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Mon Jun 23 16:28:00 1997",
      "UniqueID 43048",
      "VMusage 41139 52164"
    ],
    FontName: "Courier-Bold",
    FullName: "Courier Bold",
    FamilyName: "Courier",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-113 -250 749 801 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "439",
    Ascender: "629",
    Descender: "-157",
    StdHW: "84",
    StdVW: "106"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Mon Jun 23 16:28:46 1997",
      "UniqueID 43049",
      "VMusage 17529 79244"
    ],
    FontName: "Courier-BoldOblique",
    FullName: "Courier Bold Oblique",
    FamilyName: "Courier",
    Weight: "Bold",
    ItalicAngle: "-12",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-57 -250 869 801",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "439",
    Ascender: "629",
    Descender: "-157",
    StdHW: "84",
    StdVW: "106"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 17:37:52 1997",
      "UniqueID 43051",
      "VMusage 16248 75829"
    ],
    FontName: "Courier-Oblique",
    FullName: "Courier Oblique",
    FamilyName: "Courier",
    Weight: "Medium",
    ItalicAngle: "-12",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-27 -250 849 805 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "426",
    Ascender: "629",
    Descender: "-157",
    StdHW: "51",
    StdVW: "51"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 17:27:09 1997",
      "UniqueID 43050",
      "VMusage 39754 50779"
    ],
    FontName: "Courier",
    FullName: "Courier",
    FamilyName: "Courier",
    Weight: "Medium",
    ItalicAngle: "0",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-23 -250 715 805 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "426",
    Ascender: "629",
    Descender: "-157",
    StdHW: "51",
    StdVW: "51"
  }
];
var glyphWidths = {
  space: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  exclam: [
    333,
    333,
    278,
    278,
    333,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  quotedbl: [
    474,
    474,
    355,
    355,
    555,
    555,
    420,
    408,
    600,
    600,
    600,
    600
  ],
  numbersign: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  dollar: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  percent: [
    889,
    889,
    889,
    889,
    1e3,
    833,
    833,
    833,
    600,
    600,
    600,
    600
  ],
  ampersand: [
    722,
    722,
    667,
    667,
    833,
    778,
    778,
    778,
    600,
    600,
    600,
    600
  ],
  quoteright: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  parenleft: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  parenright: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  asterisk: [
    389,
    389,
    389,
    389,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  plus: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  comma: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  hyphen: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  period: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  slash: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  zero: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  one: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  two: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  three: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  four: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  five: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  six: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  seven: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  eight: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  nine: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  colon: [
    333,
    333,
    278,
    278,
    333,
    333,
    333,
    278,
    600,
    600,
    600,
    600
  ],
  semicolon: [
    333,
    333,
    278,
    278,
    333,
    333,
    333,
    278,
    600,
    600,
    600,
    600
  ],
  less: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  equal: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  greater: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  question: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  at: [
    975,
    975,
    1015,
    1015,
    930,
    832,
    920,
    921,
    600,
    600,
    600,
    600
  ],
  A: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  B: [
    722,
    722,
    667,
    667,
    667,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  C: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  D: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  E: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  F: [
    611,
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  G: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  H: [
    722,
    722,
    722,
    722,
    778,
    778,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  I: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  J: [
    556,
    556,
    500,
    500,
    500,
    500,
    444,
    389,
    600,
    600,
    600,
    600
  ],
  K: [
    722,
    722,
    667,
    667,
    778,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  L: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  M: [
    833,
    833,
    833,
    833,
    944,
    889,
    833,
    889,
    600,
    600,
    600,
    600
  ],
  N: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  O: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  P: [
    667,
    667,
    667,
    667,
    611,
    611,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  Q: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  R: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  S: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  T: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  U: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  V: [
    667,
    667,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  W: [
    944,
    944,
    944,
    944,
    1e3,
    889,
    833,
    944,
    600,
    600,
    600,
    600
  ],
  X: [
    667,
    667,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Y: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  Z: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  bracketleft: [
    333,
    333,
    278,
    278,
    333,
    333,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  backslash: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  bracketright: [
    333,
    333,
    278,
    278,
    333,
    333,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  asciicircum: [
    584,
    584,
    469,
    469,
    581,
    570,
    422,
    469,
    600,
    600,
    600,
    600
  ],
  underscore: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  quoteleft: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  a: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  b: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  c: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  d: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  e: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  f: [
    333,
    333,
    278,
    278,
    333,
    333,
    278,
    333,
    600,
    600,
    600,
    600
  ],
  g: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  h: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  i: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  j: [
    278,
    278,
    222,
    222,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  k: [
    556,
    556,
    500,
    500,
    556,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  l: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  m: [
    889,
    889,
    833,
    833,
    833,
    778,
    722,
    778,
    600,
    600,
    600,
    600
  ],
  n: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  o: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  p: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  q: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  r: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  s: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  t: [
    333,
    333,
    278,
    278,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  u: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  v: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  w: [
    778,
    778,
    722,
    722,
    722,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  x: [
    556,
    556,
    500,
    500,
    500,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  y: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  z: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  braceleft: [
    389,
    389,
    334,
    334,
    394,
    348,
    400,
    480,
    600,
    600,
    600,
    600
  ],
  bar: [
    280,
    280,
    260,
    260,
    220,
    220,
    275,
    200,
    600,
    600,
    600,
    600
  ],
  braceright: [
    389,
    389,
    334,
    334,
    394,
    348,
    400,
    480,
    600,
    600,
    600,
    600
  ],
  asciitilde: [
    584,
    584,
    584,
    584,
    520,
    570,
    541,
    541,
    600,
    600,
    600,
    600
  ],
  exclamdown: [
    333,
    333,
    333,
    333,
    333,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  cent: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  sterling: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  fraction: [
    167,
    167,
    167,
    167,
    167,
    167,
    167,
    167,
    600,
    600,
    600,
    600
  ],
  yen: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  florin: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  section: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  currency: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  quotesingle: [
    238,
    238,
    191,
    191,
    278,
    278,
    214,
    180,
    600,
    600,
    600,
    600
  ],
  quotedblleft: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  guillemotleft: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  guilsinglleft: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  guilsinglright: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  fi: [
    611,
    611,
    500,
    500,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  fl: [
    611,
    611,
    500,
    500,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  endash: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  dagger: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  daggerdbl: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  periodcentered: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  paragraph: [
    556,
    556,
    537,
    537,
    540,
    500,
    523,
    453,
    600,
    600,
    600,
    600
  ],
  bullet: [
    350,
    350,
    350,
    350,
    350,
    350,
    350,
    350,
    600,
    600,
    600,
    600
  ],
  quotesinglbase: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  quotedblbase: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  quotedblright: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  guillemotright: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ellipsis: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    889,
    1e3,
    600,
    600,
    600,
    600
  ],
  perthousand: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    600,
    600,
    600,
    600
  ],
  questiondown: [
    611,
    611,
    611,
    611,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  grave: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  acute: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  circumflex: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  tilde: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  macron: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  breve: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  dotaccent: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  dieresis: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ring: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  cedilla: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  hungarumlaut: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ogonek: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  caron: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  emdash: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    889,
    1e3,
    600,
    600,
    600,
    600
  ],
  AE: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    944,
    889,
    889,
    600,
    600,
    600,
    600
  ],
  ordfeminine: [
    370,
    370,
    370,
    370,
    300,
    266,
    276,
    276,
    600,
    600,
    600,
    600
  ],
  Lslash: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Oslash: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  OE: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    944,
    944,
    889,
    600,
    600,
    600,
    600
  ],
  ordmasculine: [
    365,
    365,
    365,
    365,
    330,
    300,
    310,
    310,
    600,
    600,
    600,
    600
  ],
  ae: [
    889,
    889,
    889,
    889,
    722,
    722,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  dotlessi: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  lslash: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  oslash: [
    611,
    611,
    611,
    611,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  oe: [
    944,
    944,
    944,
    944,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  germandbls: [
    611,
    611,
    611,
    611,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Idieresis: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  eacute: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  abreve: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  uhungarumlaut: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ecaron: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Ydieresis: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  divide: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  Yacute: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  Acircumflex: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  aacute: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Ucircumflex: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  yacute: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  scommaaccent: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  ecircumflex: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Uring: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Udieresis: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  aogonek: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Uacute: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  uogonek: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Edieresis: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  Dcroat: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  commaaccent: [
    250,
    250,
    250,
    250,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  copyright: [
    737,
    737,
    737,
    737,
    747,
    747,
    760,
    760,
    600,
    600,
    600,
    600
  ],
  Emacron: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  ccaron: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  aring: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Ncommaaccent: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  lacute: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  agrave: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Tcommaaccent: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Cacute: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  atilde: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Edotaccent: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  scaron: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  scedilla: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  iacute: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  lozenge: [
    494,
    494,
    471,
    471,
    494,
    494,
    471,
    471,
    600,
    600,
    600,
    600
  ],
  Rcaron: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Gcommaaccent: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  ucircumflex: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  acircumflex: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Amacron: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  rcaron: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  ccedilla: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Zdotaccent: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Thorn: [
    667,
    667,
    667,
    667,
    611,
    611,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  Omacron: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Racute: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Sacute: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  dcaron: [
    743,
    743,
    643,
    643,
    672,
    608,
    544,
    588,
    600,
    600,
    600,
    600
  ],
  Umacron: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  uring: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  threesuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  Ograve: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Agrave: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Abreve: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  multiply: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  uacute: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Tcaron: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  partialdiff: [
    494,
    494,
    476,
    476,
    494,
    494,
    476,
    476,
    600,
    600,
    600,
    600
  ],
  ydieresis: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  Nacute: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  icircumflex: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Ecircumflex: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  adieresis: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  edieresis: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  cacute: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  nacute: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  umacron: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Ncaron: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  Iacute: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  plusminus: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  brokenbar: [
    280,
    280,
    260,
    260,
    220,
    220,
    275,
    200,
    600,
    600,
    600,
    600
  ],
  registered: [
    737,
    737,
    737,
    737,
    747,
    747,
    760,
    760,
    600,
    600,
    600,
    600
  ],
  Gbreve: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Idotaccent: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  summation: [
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600
  ],
  Egrave: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  racute: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  omacron: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Zacute: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Zcaron: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  greaterequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  Eth: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Ccedilla: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  lcommaaccent: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  tcaron: [
    389,
    389,
    317,
    317,
    416,
    366,
    300,
    326,
    600,
    600,
    600,
    600
  ],
  eogonek: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Uogonek: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Aacute: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Adieresis: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  egrave: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  zacute: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  iogonek: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Oacute: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  oacute: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  amacron: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  sacute: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  idieresis: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Ocircumflex: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Ugrave: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Delta: [
    612,
    612,
    612,
    612,
    612,
    612,
    612,
    612,
    600,
    600,
    600,
    600
  ],
  thorn: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  twosuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  Odieresis: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  mu: [
    611,
    611,
    556,
    556,
    556,
    576,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  igrave: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  ohungarumlaut: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Eogonek: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  dcroat: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  threequarters: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  Scedilla: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  lcaron: [
    400,
    400,
    299,
    299,
    394,
    382,
    300,
    344,
    600,
    600,
    600,
    600
  ],
  Kcommaaccent: [
    722,
    722,
    667,
    667,
    778,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  Lacute: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  trademark: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    980,
    980,
    600,
    600,
    600,
    600
  ],
  edotaccent: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Igrave: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  Imacron: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  Lcaron: [
    611,
    611,
    556,
    556,
    667,
    611,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  onehalf: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  lessequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  ocircumflex: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ntilde: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Uhungarumlaut: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Eacute: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  emacron: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  gbreve: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  onequarter: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  Scaron: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  Scommaaccent: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  Ohungarumlaut: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  degree: [
    400,
    400,
    400,
    400,
    400,
    400,
    400,
    400,
    600,
    600,
    600,
    600
  ],
  ograve: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Ccaron: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  ugrave: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  radical: [
    549,
    549,
    453,
    453,
    549,
    549,
    453,
    453,
    600,
    600,
    600,
    600
  ],
  Dcaron: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  rcommaaccent: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  Ntilde: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  otilde: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Rcommaaccent: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Lcommaaccent: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Atilde: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Aogonek: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Aring: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Otilde: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  zdotaccent: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  Ecaron: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  Iogonek: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  kcommaaccent: [
    556,
    556,
    500,
    500,
    556,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  minus: [
    584,
    584,
    584,
    584,
    570,
    606,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  Icircumflex: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ncaron: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  tcommaaccent: [
    333,
    333,
    278,
    278,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  logicalnot: [
    584,
    584,
    584,
    584,
    570,
    606,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  odieresis: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  udieresis: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  notequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  gcommaaccent: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  eth: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  zcaron: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  ncommaaccent: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  onesuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  imacron: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Euro: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ]
};
var kernPairs = {
  AC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  ATcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  ATcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Au: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Audieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Augrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Av: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Ay: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Ayacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AacuteC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AacuteT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AacuteW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AacuteY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AacuteYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AacuteYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aacuteu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacutev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aacutew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Aacutey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aacuteyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aacuteydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AbreveC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AbreveT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AbreveW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AbreveY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AbreveYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AbreveYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Abreveu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abrevev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Abrevew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Abrevey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Abreveyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Abreveydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AcircumflexC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AcircumflexT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AcircumflexW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AcircumflexY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AcircumflexYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AcircumflexYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Acircumflexu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Acircumflexw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Acircumflexy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Acircumflexyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Acircumflexydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AdieresisC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AdieresisT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AdieresisW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AdieresisY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AdieresisYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AdieresisYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Adieresisu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Adieresisw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Adieresisy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Adieresisyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Adieresisydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AgraveC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AgraveT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AgraveW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AgraveY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AgraveYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AgraveYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Agraveu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agravev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Agravew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Agravey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Agraveyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Agraveydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AmacronC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AmacronT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AmacronW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AmacronY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AmacronYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AmacronYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Amacronu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Amacronw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Amacrony: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Amacronyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Amacronydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AogonekC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AogonekT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AogonekW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AogonekY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AogonekYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AogonekYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aogoneku: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aogonekw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -52
  ],
  Aogoneky: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  Aogonekyacute: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  Aogonekydieresis: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  AringC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AringT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AringW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AringY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AringYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AringYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aringu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aringw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Aringy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aringyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aringydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AtildeC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AtildeT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AtildeW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AtildeY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AtildeYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AtildeYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Atildeu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Atildew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Atildey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Atildeyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Atildeydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  BA: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAacute: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAbreve: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAcircumflex: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAdieresis: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAgrave: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAmacron: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAogonek: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAring: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAtilde: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BU: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUacute: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUcircumflex: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUdieresis: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUgrave: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUhungarumlaut: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUmacron: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUogonek: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUring: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  DA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  DcaronA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DcaronW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DcaronY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcaronYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcaronYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcaroncomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dcaronperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  DcroatA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DcroatW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DcroatY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcroatYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcroatYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcroatcomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dcroatperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  FA: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAacute: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAbreve: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAcircumflex: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAdieresis: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAgrave: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAmacron: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAogonek: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAring: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAtilde: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  Fa: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faacute: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fabreve: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Facircumflex: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fadieresis: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fagrave: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Famacron: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faogonek: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faring: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fatilde: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fcomma: [
    -100,
    -100,
    -150,
    -150,
    -92,
    -129,
    -135,
    -80
  ],
  Fperiod: [
    -100,
    -100,
    -150,
    -150,
    -110,
    -129,
    -135,
    -80
  ],
  JA: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAbreve: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAogonek: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAring: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  Jcomma: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    -25
  ],
  Jperiod: [
    -20,
    -20,
    -30,
    -30,
    -20,
    -10,
    -25
  ],
  Ju: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juacute: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jucircumflex: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Judieresis: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jugrave: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jumacron: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juogonek: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juring: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  KO: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOacute: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOcircumflex: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOdieresis: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOgrave: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOhungarumlaut: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOmacron: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOslash: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOtilde: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  Ke: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Keacute: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kecaron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kecircumflex: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kedieresis: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kedotaccent: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kegrave: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kemacron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Keogonek: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Ko: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Koacute: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kocircumflex: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kodieresis: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kograve: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kohungarumlaut: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Komacron: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Koslash: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kotilde: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Ku: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuacute: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kudieresis: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kugrave: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kumacron: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuogonek: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuring: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Ky: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kyacute: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kydieresis: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  KcommaaccentO: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOacute: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOcircumflex: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOdieresis: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOgrave: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOhungarumlaut: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOmacron: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOslash: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOtilde: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  Kcommaaccente: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccenteacute: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentecaron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentecircumflex: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentedieresis: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentedotaccent: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentegrave: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentemacron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccenteogonek: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccento: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentoacute: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentocircumflex: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentodieresis: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentograve: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentohungarumlaut: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentomacron: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentoslash: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentotilde: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentu: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuacute: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentudieresis: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentugrave: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentumacron: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuogonek: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccenturing: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccenty: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kcommaaccentyacute: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kcommaaccentydieresis: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  LT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Ly: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LacuteT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LacuteW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LacuteY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LacuteYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LacuteYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lacutequotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lacutequoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lacutey: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lacuteyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lacuteydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LcommaaccentT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LcommaaccentW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LcommaaccentY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LcommaaccentYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LcommaaccentYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lcommaaccentquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lcommaaccentquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lcommaaccenty: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lcommaaccentyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lcommaaccentydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LslashT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LslashW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LslashY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LslashYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LslashYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lslashquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lslashquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lslashy: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lslashyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lslashydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  OA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ocomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Operiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OacuteA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OacuteX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Oacutecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Oacuteperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OcircumflexX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ocircumflexcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ocircumflexperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OdieresisX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Odieresiscomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Odieresisperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OgraveA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OgraveX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ogravecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ograveperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OhungarumlautX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ohungarumlautcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ohungarumlautperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OmacronA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OmacronX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Omacroncomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Omacronperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OslashA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OslashW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OslashX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OslashY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OslashYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OslashYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Oslashcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Oslashperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OtildeA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OtildeX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Otildecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Otildeperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  PA: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAacute: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAbreve: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAcircumflex: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAdieresis: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAgrave: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAmacron: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAogonek: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAring: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAtilde: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  Pa: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paacute: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pabreve: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pacircumflex: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Padieresis: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pagrave: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pamacron: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paogonek: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paring: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Patilde: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pcomma: [
    -120,
    -120,
    -180,
    -180,
    -92,
    -129,
    -135,
    -111
  ],
  Pe: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Peacute: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pecaron: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pecircumflex: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pedieresis: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pedotaccent: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pegrave: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pemacron: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Peogonek: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Po: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Poacute: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pocircumflex: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Podieresis: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pograve: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pohungarumlaut: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pomacron: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Poslash: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Potilde: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pperiod: [
    -120,
    -120,
    -180,
    -180,
    -110,
    -129,
    -135,
    -111
  ],
  QU: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUacute: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUcircumflex: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUdieresis: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUgrave: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUhungarumlaut: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUmacron: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUogonek: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUring: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  Qcomma: [
    20,
    20
  ],
  Qperiod: [
    20,
    20,
    0,
    0,
    -20
  ],
  RO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RacuteW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RacuteY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RcaronW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RcaronY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RcommaaccentW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RcommaaccentY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  TA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Ta: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Taacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Taogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Taring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Te: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Teacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -70
  ],
  Tedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Temacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Teogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Thyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  To: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Toacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Todieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Toslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Totilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Trcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Turing: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Ty: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  TcaronA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Tcarona: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronaacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tcaronacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tcaronadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronaogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronaring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaroncolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcaroncomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Tcarone: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaroneacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -30
  ],
  Tcaronedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tcaronedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Tcaronemacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Tcaroneogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronhyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  Tcarono: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronoacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronodieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronoslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronotilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tcaronr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronrcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tcaronu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuring: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Tcarony: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcaronyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcaronydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  TcommaaccentA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Tcommaaccenta: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentaacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tcommaaccentacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tcommaaccentadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentaogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentaring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentcolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcommaaccentcomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Tcommaaccente: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccenteacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -30
  ],
  Tcommaaccentedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tcommaaccentedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Tcommaaccentemacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Tcommaaccenteogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccenthyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  Tcommaaccento: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentoacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentodieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentoslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentotilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tcommaaccentr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentrcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tcommaaccentu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccenturing: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Tcommaaccenty: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcommaaccentyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcommaaccentydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  UA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ucomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UacuteA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uacutecomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uacuteperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UcircumflexA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ucircumflexcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Ucircumflexperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UdieresisA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Udieresiscomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Udieresisperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UgraveA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ugravecomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Ugraveperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UhungarumlautA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uhungarumlautcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uhungarumlautperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UmacronA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Umacroncomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Umacronperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UogonekA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uogonekcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uogonekperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UringA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uringcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uringperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  VA: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAacute: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAbreve: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAcircumflex: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAdieresis: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAgrave: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAmacron: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAogonek: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAring: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAtilde: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VG: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VGbreve: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VGcommaaccent: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VO: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOacute: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOdieresis: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOgrave: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOhungarumlaut: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOmacron: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOslash: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOtilde: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  Va: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vaacute: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vabreve: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vacircumflex: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vadieresis: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vagrave: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vamacron: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vaogonek: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Varing: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vatilde: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vcolon: [
    -40,
    -40,
    -40,
    -40,
    -92,
    -74,
    -65,
    -74
  ],
  Vcomma: [
    -120,
    -120,
    -125,
    -125,
    -129,
    -129,
    -129,
    -129
  ],
  Ve: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Veacute: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vecaron: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -71
  ],
  Vecircumflex: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -71
  ],
  Vedieresis: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Vedotaccent: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vegrave: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Vemacron: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Veogonek: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vhyphen: [
    -80,
    -80,
    -80,
    -80,
    -74,
    -70,
    -55,
    -100
  ],
  Vo: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Voacute: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vocircumflex: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vodieresis: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vograve: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vohungarumlaut: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vomacron: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Voslash: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Votilde: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vperiod: [
    -120,
    -120,
    -125,
    -125,
    -145,
    -129,
    -129,
    -129
  ],
  Vsemicolon: [
    -40,
    -40,
    -40,
    -40,
    -92,
    -74,
    -74,
    -74
  ],
  Vu: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuacute: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vucircumflex: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vudieresis: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vugrave: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuhungarumlaut: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vumacron: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuogonek: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuring: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  WA: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAacute: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAbreve: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAcircumflex: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAdieresis: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAgrave: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAmacron: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAogonek: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAring: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAtilde: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WO: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOacute: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOgrave: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOmacron: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOslash: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOtilde: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  Wa: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waacute: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wabreve: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wacircumflex: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wadieresis: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wagrave: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wamacron: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waogonek: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waring: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Watilde: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wcolon: [
    -10,
    -10,
    0,
    0,
    -55,
    -55,
    -65,
    -37
  ],
  Wcomma: [
    -80,
    -80,
    -80,
    -80,
    -92,
    -74,
    -92,
    -92
  ],
  We: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Weacute: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wecaron: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wecircumflex: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wedieresis: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Wedotaccent: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wegrave: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Wemacron: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Weogonek: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Whyphen: [
    -40,
    -40,
    -40,
    -40,
    -37,
    -50,
    -37,
    -65
  ],
  Wo: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Woacute: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wocircumflex: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wodieresis: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wograve: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wohungarumlaut: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Womacron: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Woslash: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wotilde: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wperiod: [
    -80,
    -80,
    -80,
    -80,
    -92,
    -74,
    -92,
    -92
  ],
  Wsemicolon: [
    -10,
    -10,
    0,
    0,
    -55,
    -55,
    -65,
    -37
  ],
  Wu: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuacute: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wucircumflex: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wudieresis: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wugrave: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuhungarumlaut: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wumacron: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuogonek: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuring: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wy: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  Wyacute: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  Wydieresis: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  YA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Ya: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Yacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yaring: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yatilde: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ycolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ycomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Ye: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yeacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Yedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Yeogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yo: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yomacron: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Ysemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  YacuteA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Yacutea: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacutearing: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteatilde: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yacutecolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yacutecomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Yacutee: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteeacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Yacuteedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteeogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteo: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteomacron: [
    -100,
    -100,
    -70,
    -70,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Yacutesemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yacuteu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  YdieresisA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Ydieresisa: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisaring: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisatilde: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresiscolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ydieresiscomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Ydieresise: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresiseacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Ydieresisedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresisedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresisemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresiseogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresiso: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisomacron: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Ydieresissemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ydieresisu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  ag: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  av: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  ay: [
    -20,
    -20,
    -30,
    -30
  ],
  ayacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aacutew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aacutey: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  abrevew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  abrevey: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  acircumflexw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  acircumflexy: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  adieresisw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  adieresisy: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  agravew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  agravey: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  amacrong: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacrongbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacrongcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacronv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  amacronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  amacrony: [
    -20,
    -20,
    -30,
    -30
  ],
  amacronyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  amacronydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aogonekw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aogoneky: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aringg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aringw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aringy: [
    -20,
    -20,
    -30,
    -30
  ],
  aringyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aringydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  atildew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  atildey: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  bl: [
    -10,
    -10,
    -20,
    -20
  ],
  blacute: [
    -10,
    -10,
    -20,
    -20
  ],
  blcommaaccent: [
    -10,
    -10,
    -20,
    -20
  ],
  blslash: [
    -10,
    -10,
    -20,
    -20
  ],
  bu: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buacute: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bucircumflex: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  budieresis: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bugrave: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bumacron: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buogonek: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buring: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bv: [
    -20,
    -20,
    -20,
    -20,
    -15,
    0,
    0,
    -15
  ],
  by: [
    -20,
    -20,
    -20,
    -20
  ],
  byacute: [
    -20,
    -20,
    -20,
    -20
  ],
  bydieresis: [
    -20,
    -20,
    -20,
    -20
  ],
  ch: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ck: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ckcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cl: [
    -20,
    -20
  ],
  clacute: [
    -20,
    -20
  ],
  clcommaaccent: [
    -20,
    -20
  ],
  clslash: [
    -20,
    -20
  ],
  cy: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteh: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  cacutek: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cacutekcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cacutel: [
    -20,
    -20
  ],
  cacutelacute: [
    -20,
    -20
  ],
  cacutelcommaaccent: [
    -20,
    -20
  ],
  cacutelslash: [
    -20,
    -20
  ],
  cacutey: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronh: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ccaronk: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccaronkcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccaronl: [
    -20,
    -20
  ],
  ccaronlacute: [
    -20,
    -20
  ],
  ccaronlcommaaccent: [
    -20,
    -20
  ],
  ccaronlslash: [
    -20,
    -20
  ],
  ccarony: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillah: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ccedillak: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccedillakcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccedillal: [
    -20,
    -20
  ],
  ccedillalacute: [
    -20,
    -20
  ],
  ccedillalcommaaccent: [
    -20,
    -20
  ],
  ccedillalslash: [
    -20,
    -20
  ],
  ccedillay: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillayacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillaydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  colonspace: [
    -40,
    -40,
    -50,
    -50
  ],
  commaquotedblright: [
    -120,
    -120,
    -100,
    -100,
    -45,
    -95,
    -140,
    -70
  ],
  commaquoteright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  commaspace: [
    -40,
    -40
  ],
  dd: [
    -10,
    -10
  ],
  ddcroat: [
    -10,
    -10
  ],
  dv: [
    -15,
    -15
  ],
  dw: [
    -15,
    -15,
    0,
    0,
    -15
  ],
  dy: [
    -15,
    -15
  ],
  dyacute: [
    -15,
    -15
  ],
  dydieresis: [
    -15,
    -15
  ],
  dcroatd: [
    -10,
    -10
  ],
  dcroatdcroat: [
    -10,
    -10
  ],
  dcroatv: [
    -15,
    -15
  ],
  dcroatw: [
    -15,
    -15,
    0,
    0,
    -15
  ],
  dcroaty: [
    -15,
    -15
  ],
  dcroatyacute: [
    -15,
    -15
  ],
  dcroatydieresis: [
    -15,
    -15
  ],
  ecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacutecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eacuteperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  eacutev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  eacutew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  eacutex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  eacutey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacuteyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacuteydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaroncomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  ecaronperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ecaronv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ecaronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ecaronx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ecarony: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaronyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaronydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  ecircumflexperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ecircumflexv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ecircumflexw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ecircumflexx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ecircumflexy: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresiscomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  edieresisperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  edieresisv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  edieresisw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  edieresisx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  edieresisy: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresisyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresisydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  edotaccentperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  edotaccentv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  edotaccentw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  edotaccentx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  edotaccenty: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egravecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  egraveperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  egravev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  egravew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  egravex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  egravey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egraveyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egraveydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacroncomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  emacronperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  emacronv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  emacronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  emacronx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  emacrony: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacronyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacronydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eogonekperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  eogonekv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  eogonekw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  eogonekx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  eogoneky: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  fcomma: [
    -10,
    -10,
    -30,
    -30,
    -15,
    -10,
    -10
  ],
  fe: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  feacute: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fecaron: [
    -10,
    -10,
    -30,
    -30
  ],
  fecircumflex: [
    -10,
    -10,
    -30,
    -30
  ],
  fedieresis: [
    -10,
    -10,
    -30,
    -30
  ],
  fedotaccent: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fegrave: [
    -10,
    -10,
    -30,
    -30
  ],
  femacron: [
    -10,
    -10,
    -30,
    -30
  ],
  feogonek: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fo: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  foacute: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  focircumflex: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fodieresis: [
    -20,
    -20,
    -30,
    -30,
    -25
  ],
  fograve: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fohungarumlaut: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fomacron: [
    -20,
    -20,
    -30,
    -30,
    -25
  ],
  foslash: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fotilde: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fperiod: [
    -10,
    -10,
    -30,
    -30,
    -15,
    -10,
    -15
  ],
  fquotedblright: [
    30,
    30,
    60,
    60,
    50
  ],
  fquoteright: [
    30,
    30,
    50,
    50,
    55,
    55,
    92,
    55
  ],
  ge: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  geacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  geogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  ggbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  ggcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevee: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveeacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveeogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccente: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccenteacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccenteogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  hy: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  hyacute: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  hydieresis: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  ko: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  koacute: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kocircumflex: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kodieresis: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kograve: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kohungarumlaut: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  komacron: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  koslash: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kotilde: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccento: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentoacute: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentocircumflex: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentodieresis: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentograve: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentohungarumlaut: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentomacron: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentoslash: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentotilde: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  lw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ly: [
    -15,
    -15
  ],
  lyacute: [
    -15,
    -15
  ],
  lydieresis: [
    -15,
    -15
  ],
  lacutew: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lacutey: [
    -15,
    -15
  ],
  lacuteyacute: [
    -15,
    -15
  ],
  lacuteydieresis: [
    -15,
    -15
  ],
  lcommaaccentw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lcommaaccenty: [
    -15,
    -15
  ],
  lcommaaccentyacute: [
    -15,
    -15
  ],
  lcommaaccentydieresis: [
    -15,
    -15
  ],
  lslashw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lslashy: [
    -15,
    -15
  ],
  lslashyacute: [
    -15,
    -15
  ],
  lslashydieresis: [
    -15,
    -15
  ],
  mu: [
    -20,
    -20,
    -10,
    -10
  ],
  muacute: [
    -20,
    -20,
    -10,
    -10
  ],
  mucircumflex: [
    -20,
    -20,
    -10,
    -10
  ],
  mudieresis: [
    -20,
    -20,
    -10,
    -10
  ],
  mugrave: [
    -20,
    -20,
    -10,
    -10
  ],
  muhungarumlaut: [
    -20,
    -20,
    -10,
    -10
  ],
  mumacron: [
    -20,
    -20,
    -10,
    -10
  ],
  muogonek: [
    -20,
    -20,
    -10,
    -10
  ],
  muring: [
    -20,
    -20,
    -10,
    -10
  ],
  my: [
    -30,
    -30,
    -15,
    -15
  ],
  myacute: [
    -30,
    -30,
    -15,
    -15
  ],
  mydieresis: [
    -30,
    -30,
    -15,
    -15
  ],
  nu: [
    -10,
    -10,
    -10,
    -10
  ],
  nuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  nucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  nudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  nugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  nuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  numacron: [
    -10,
    -10,
    -10,
    -10
  ],
  nuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  nuring: [
    -10,
    -10,
    -10,
    -10
  ],
  nv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ny: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteu: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuring: [
    -10,
    -10,
    -10,
    -10
  ],
  nacutev: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  nacutey: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronu: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuring: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ncarony: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentu: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccenturing: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ncommaaccenty: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeu: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuring: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildev: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ntildey: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ov: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ow: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ox: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  oy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacutev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  oacutew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  oacutex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  oacutey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacuteyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacuteydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ocircumflexw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ocircumflexx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ocircumflexy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  odieresisw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  odieresisx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  odieresisy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ogravev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ogravew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ogravex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ogravey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ograveyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ograveydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ohungarumlautw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ohungarumlautx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ohungarumlauty: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  omacronw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  omacronx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  omacrony: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oslashv: [
    -20,
    -20,
    -70,
    -70,
    -10,
    -15,
    -10,
    -15
  ],
  oslashw: [
    -15,
    -15,
    -70,
    -70,
    -10,
    -25,
    0,
    -25
  ],
  oslashx: [
    -30,
    -30,
    -85,
    -85,
    0,
    -10
  ],
  oslashy: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  oslashyacute: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  oslashydieresis: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  otildev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  otildew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  otildex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  otildey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  otildeyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  otildeydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  py: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  pyacute: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  pydieresis: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  periodquotedblright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  periodquoteright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  periodspace: [
    -40,
    -40,
    -60,
    -60
  ],
  quotedblrightspace: [
    -80,
    -80,
    -40,
    -40
  ],
  quoteleftquoteleft: [
    -46,
    -46,
    -57,
    -57,
    -63,
    -74,
    -111,
    -74
  ],
  quoterightd: [
    -80,
    -80,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightdcroat: [
    -80,
    -80,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightl: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlacute: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlcommaaccent: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlslash: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightquoteright: [
    -46,
    -46,
    -57,
    -57,
    -63,
    -74,
    -111,
    -74
  ],
  quoterightr: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightracute: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightrcaron: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightrcommaaccent: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterights: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightsacute: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscaron: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscedilla: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscommaaccent: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightspace: [
    -80,
    -80,
    -70,
    -70,
    -74,
    -74,
    -111,
    -74
  ],
  quoterightv: [
    -20,
    -20,
    0,
    0,
    -20,
    -15,
    -10,
    -50
  ],
  rc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rd: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rdcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rgbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rgcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rhyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  ro: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  roacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  romacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  roslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rs: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rt: [
    20,
    20,
    40,
    40
  ],
  rtcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rv: [
    10,
    10,
    30,
    30,
    -10
  ],
  ry: [
    10,
    10,
    30,
    30
  ],
  ryacute: [
    10,
    10,
    30,
    30
  ],
  rydieresis: [
    10,
    10,
    30,
    30
  ],
  racutec: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutecacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutecomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  racuted: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  racutedcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  racuteg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutegbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutegcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutehyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  racuteo: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  racuteq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutes: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutesacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutet: [
    20,
    20,
    40,
    40
  ],
  racutetcommaaccent: [
    20,
    20,
    40,
    40
  ],
  racutev: [
    10,
    10,
    30,
    30,
    -10
  ],
  racutey: [
    10,
    10,
    30,
    30
  ],
  racuteyacute: [
    10,
    10,
    30,
    30
  ],
  racuteydieresis: [
    10,
    10,
    30,
    30
  ],
  rcaronc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroncacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroncomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rcarond: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcarondcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcarong: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcarongbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcarongcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcaronhyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  rcarono: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rcaronq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcarons: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaront: [
    20,
    20,
    40,
    40
  ],
  rcarontcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rcaronv: [
    10,
    10,
    30,
    30,
    -10
  ],
  rcarony: [
    10,
    10,
    30,
    30
  ],
  rcaronyacute: [
    10,
    10,
    30,
    30
  ],
  rcaronydieresis: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentcacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentcomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rcommaaccentd: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcommaaccentdcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcommaaccentg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccentgbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccentgcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccenthyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  rcommaaccento: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rcommaaccentq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccents: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentt: [
    20,
    20,
    40,
    40
  ],
  rcommaaccenttcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rcommaaccentv: [
    10,
    10,
    30,
    30,
    -10
  ],
  rcommaaccenty: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentyacute: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentydieresis: [
    10,
    10,
    30,
    30
  ],
  sw: [
    -15,
    -15,
    -30,
    -30
  ],
  sacutew: [
    -15,
    -15,
    -30,
    -30
  ],
  scaronw: [
    -15,
    -15,
    -30,
    -30
  ],
  scedillaw: [
    -15,
    -15,
    -30,
    -30
  ],
  scommaaccentw: [
    -15,
    -15,
    -30,
    -30
  ],
  semicolonspace: [
    -40,
    -40,
    -50,
    -50
  ],
  spaceT: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceTcaron: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceTcommaaccent: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceV: [
    -80,
    -80,
    -50,
    -50,
    -45,
    -70,
    -35,
    -50
  ],
  spaceW: [
    -80,
    -80,
    -40,
    -40,
    -30,
    -70,
    -40,
    -30
  ],
  spaceY: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spaceYacute: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spaceYdieresis: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spacequotedblleft: [
    -80,
    -80,
    -30,
    -30
  ],
  spacequoteleft: [
    -60,
    -60,
    -60,
    -60
  ],
  va: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vaacute: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vabreve: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vacircumflex: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vadieresis: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vagrave: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vamacron: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vaogonek: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  varing: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vatilde: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vcomma: [
    -80,
    -80,
    -80,
    -80,
    -55,
    -37,
    -74,
    -65
  ],
  vo: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  voacute: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vocircumflex: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vodieresis: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vograve: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vohungarumlaut: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vomacron: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  voslash: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  votilde: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vperiod: [
    -80,
    -80,
    -80,
    -80,
    -70,
    -37,
    -74,
    -65
  ],
  wcomma: [
    -40,
    -40,
    -60,
    -60,
    -55,
    -37,
    -74,
    -65
  ],
  wo: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  woacute: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wocircumflex: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wodieresis: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wograve: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wohungarumlaut: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  womacron: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  woslash: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wotilde: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wperiod: [
    -40,
    -40,
    -60,
    -60,
    -70,
    -37,
    -74,
    -65
  ],
  xe: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xeacute: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xecaron: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xecircumflex: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xedieresis: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xedotaccent: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xegrave: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xemacron: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xeogonek: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  ya: [
    -30,
    -30,
    -20,
    -20
  ],
  yaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  yabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  yacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  yadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  yagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  yamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  yaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  yaring: [
    -30,
    -30,
    -20,
    -20
  ],
  yatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  ycomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  ye: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yeacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yeogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yo: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  yacutea: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  yacutearing: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  yacutecomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  yacutee: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteeacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteeogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteo: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  ydieresisa: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaring: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresiscomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  ydieresise: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiseacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiseogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiso: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  ze: [
    10,
    10,
    -15,
    -15
  ],
  zeacute: [
    10,
    10,
    -15,
    -15
  ],
  zecaron: [
    10,
    10,
    -15,
    -15
  ],
  zecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zegrave: [
    10,
    10,
    -15,
    -15
  ],
  zemacron: [
    10,
    10,
    -15,
    -15
  ],
  zeogonek: [
    10,
    10,
    -15,
    -15
  ],
  zacutee: [
    10,
    10,
    -15,
    -15
  ],
  zacuteeacute: [
    10,
    10,
    -15,
    -15
  ],
  zacuteecaron: [
    10,
    10,
    -15,
    -15
  ],
  zacuteecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zacuteedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zacuteedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zacuteegrave: [
    10,
    10,
    -15,
    -15
  ],
  zacuteemacron: [
    10,
    10,
    -15,
    -15
  ],
  zacuteeogonek: [
    10,
    10,
    -15,
    -15
  ],
  zcarone: [
    10,
    10,
    -15,
    -15
  ],
  zcaroneacute: [
    10,
    10,
    -15,
    -15
  ],
  zcaronecaron: [
    10,
    10,
    -15,
    -15
  ],
  zcaronecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zcaronedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zcaronedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zcaronegrave: [
    10,
    10,
    -15,
    -15
  ],
  zcaronemacron: [
    10,
    10,
    -15,
    -15
  ],
  zcaroneogonek: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccente: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccenteacute: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentecaron: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentegrave: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentemacron: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccenteogonek: [
    10,
    10,
    -15,
    -15
  ],
  Bcomma: [
    0,
    0,
    -20,
    -20
  ],
  Bperiod: [
    0,
    0,
    -20,
    -20
  ],
  Ccomma: [
    0,
    0,
    -30,
    -30
  ],
  Cperiod: [
    0,
    0,
    -30,
    -30
  ],
  Cacutecomma: [
    0,
    0,
    -30,
    -30
  ],
  Cacuteperiod: [
    0,
    0,
    -30,
    -30
  ],
  Ccaroncomma: [
    0,
    0,
    -30,
    -30
  ],
  Ccaronperiod: [
    0,
    0,
    -30,
    -30
  ],
  Ccedillacomma: [
    0,
    0,
    -30,
    -30
  ],
  Ccedillaperiod: [
    0,
    0,
    -30,
    -30
  ],
  Fe: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Feacute: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fecaron: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fecircumflex: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fedieresis: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fedotaccent: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fegrave: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Femacron: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Feogonek: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fo: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Foacute: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Focircumflex: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fodieresis: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fograve: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fohungarumlaut: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fomacron: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Foslash: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fotilde: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fr: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Fracute: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Frcaron: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Frcommaaccent: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Ja: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaacute: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jabreve: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jacircumflex: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jadieresis: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jagrave: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jamacron: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaogonek: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaring: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jatilde: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  LcaronT: [
    0,
    0,
    -110,
    -110
  ],
  LcaronTcaron: [
    0,
    0,
    -110,
    -110
  ],
  LcaronTcommaaccent: [
    0,
    0,
    -110,
    -110
  ],
  LcaronV: [
    0,
    0,
    -110,
    -110
  ],
  LcaronW: [
    0,
    0,
    -70,
    -70
  ],
  LcaronY: [
    0,
    0,
    -140,
    -140
  ],
  LcaronYacute: [
    0,
    0,
    -140,
    -140
  ],
  LcaronYdieresis: [
    0,
    0,
    -140,
    -140
  ],
  Lcaronquotedblright: [
    0,
    0,
    -140,
    -140
  ],
  Lcaronquoteright: [
    0,
    0,
    -160,
    -160,
    0,
    0,
    0,
    -92
  ],
  Lcarony: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Lcaronyacute: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Lcaronydieresis: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Scomma: [
    0,
    0,
    -20,
    -20
  ],
  Speriod: [
    0,
    0,
    -20,
    -20
  ],
  Sacutecomma: [
    0,
    0,
    -20,
    -20
  ],
  Sacuteperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scaroncomma: [
    0,
    0,
    -20,
    -20
  ],
  Scaronperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scedillacomma: [
    0,
    0,
    -20,
    -20
  ],
  Scedillaperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scommaaccentcomma: [
    0,
    0,
    -20,
    -20
  ],
  Scommaaccentperiod: [
    0,
    0,
    -20,
    -20
  ],
  Trcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronrcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentrcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Yhyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Yi: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacutehyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Yacutei: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacuteiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacuteiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresishyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Ydieresisi: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresisiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresisiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  bb: [
    0,
    0,
    -10,
    -10,
    -10,
    -10
  ],
  bcomma: [
    0,
    0,
    -40,
    -40
  ],
  bperiod: [
    0,
    0,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  ccomma: [
    0,
    0,
    -15,
    -15
  ],
  cacutecomma: [
    0,
    0,
    -15,
    -15
  ],
  ccaroncomma: [
    0,
    0,
    -15,
    -15
  ],
  ccedillacomma: [
    0,
    0,
    -15,
    -15
  ],
  fa: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faacute: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fabreve: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  facircumflex: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fadieresis: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fagrave: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  famacron: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faogonek: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faring: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fatilde: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fdotlessi: [
    0,
    0,
    -28,
    -28,
    -35,
    -30,
    -60,
    -50
  ],
  gr: [
    0,
    0,
    -10,
    -10
  ],
  gracute: [
    0,
    0,
    -10,
    -10
  ],
  grcaron: [
    0,
    0,
    -10,
    -10
  ],
  grcommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  gbrever: [
    0,
    0,
    -10,
    -10
  ],
  gbreveracute: [
    0,
    0,
    -10,
    -10
  ],
  gbrevercaron: [
    0,
    0,
    -10,
    -10
  ],
  gbrevercommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentr: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentracute: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentrcaron: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentrcommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  ke: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  keacute: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kecaron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kecircumflex: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kedieresis: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kedotaccent: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kegrave: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kemacron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  keogonek: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccente: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccenteacute: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentecaron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentecircumflex: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentedieresis: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentedotaccent: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentegrave: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentemacron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccenteogonek: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  ocomma: [
    0,
    0,
    -40,
    -40
  ],
  operiod: [
    0,
    0,
    -40,
    -40
  ],
  oacutecomma: [
    0,
    0,
    -40,
    -40
  ],
  oacuteperiod: [
    0,
    0,
    -40,
    -40
  ],
  ocircumflexcomma: [
    0,
    0,
    -40,
    -40
  ],
  ocircumflexperiod: [
    0,
    0,
    -40,
    -40
  ],
  odieresiscomma: [
    0,
    0,
    -40,
    -40
  ],
  odieresisperiod: [
    0,
    0,
    -40,
    -40
  ],
  ogravecomma: [
    0,
    0,
    -40,
    -40
  ],
  ograveperiod: [
    0,
    0,
    -40,
    -40
  ],
  ohungarumlautcomma: [
    0,
    0,
    -40,
    -40
  ],
  ohungarumlautperiod: [
    0,
    0,
    -40,
    -40
  ],
  omacroncomma: [
    0,
    0,
    -40,
    -40
  ],
  omacronperiod: [
    0,
    0,
    -40,
    -40
  ],
  oslasha: [
    0,
    0,
    -55,
    -55
  ],
  oslashaacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashabreve: [
    0,
    0,
    -55,
    -55
  ],
  oslashacircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashadieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashagrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashamacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashaogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslasharing: [
    0,
    0,
    -55,
    -55
  ],
  oslashatilde: [
    0,
    0,
    -55,
    -55
  ],
  oslashb: [
    0,
    0,
    -55,
    -55
  ],
  oslashc: [
    0,
    0,
    -55,
    -55
  ],
  oslashcacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashccaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashccedilla: [
    0,
    0,
    -55,
    -55
  ],
  oslashcomma: [
    0,
    0,
    -95,
    -95
  ],
  oslashd: [
    0,
    0,
    -55,
    -55
  ],
  oslashdcroat: [
    0,
    0,
    -55,
    -55
  ],
  oslashe: [
    0,
    0,
    -55,
    -55
  ],
  oslasheacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashecaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashecircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashedieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashedotaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashegrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashemacron: [
    0,
    0,
    -55,
    -55
  ],
  oslasheogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashf: [
    0,
    0,
    -55,
    -55
  ],
  oslashg: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashgbreve: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashgcommaaccent: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashh: [
    0,
    0,
    -55,
    -55
  ],
  oslashi: [
    0,
    0,
    -55,
    -55
  ],
  oslashiacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashicircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashidieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashigrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashimacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashiogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashj: [
    0,
    0,
    -55,
    -55
  ],
  oslashk: [
    0,
    0,
    -55,
    -55
  ],
  oslashkcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashl: [
    0,
    0,
    -55,
    -55
  ],
  oslashlacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashlcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashlslash: [
    0,
    0,
    -55,
    -55
  ],
  oslashm: [
    0,
    0,
    -55,
    -55
  ],
  oslashn: [
    0,
    0,
    -55,
    -55
  ],
  oslashnacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashncaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashncommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashntilde: [
    0,
    0,
    -55,
    -55
  ],
  oslasho: [
    0,
    0,
    -55,
    -55
  ],
  oslashoacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashocircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashodieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashograve: [
    0,
    0,
    -55,
    -55
  ],
  oslashohungarumlaut: [
    0,
    0,
    -55,
    -55
  ],
  oslashomacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashoslash: [
    0,
    0,
    -55,
    -55
  ],
  oslashotilde: [
    0,
    0,
    -55,
    -55
  ],
  oslashp: [
    0,
    0,
    -55,
    -55
  ],
  oslashperiod: [
    0,
    0,
    -95,
    -95
  ],
  oslashq: [
    0,
    0,
    -55,
    -55
  ],
  oslashr: [
    0,
    0,
    -55,
    -55
  ],
  oslashracute: [
    0,
    0,
    -55,
    -55
  ],
  oslashrcaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashrcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashs: [
    0,
    0,
    -55,
    -55
  ],
  oslashsacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashscaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashscedilla: [
    0,
    0,
    -55,
    -55
  ],
  oslashscommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslasht: [
    0,
    0,
    -55,
    -55
  ],
  oslashtcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashu: [
    0,
    0,
    -55,
    -55
  ],
  oslashuacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashucircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashudieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashugrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashuhungarumlaut: [
    0,
    0,
    -55,
    -55
  ],
  oslashumacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashuogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashuring: [
    0,
    0,
    -55,
    -55
  ],
  oslashz: [
    0,
    0,
    -55,
    -55
  ],
  oslashzacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashzcaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashzdotaccent: [
    0,
    0,
    -55,
    -55
  ],
  otildecomma: [
    0,
    0,
    -40,
    -40
  ],
  otildeperiod: [
    0,
    0,
    -40,
    -40
  ],
  pcomma: [
    0,
    0,
    -35,
    -35
  ],
  pperiod: [
    0,
    0,
    -35,
    -35
  ],
  ra: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  radieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ragrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ramacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ratilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcolon: [
    0,
    0,
    30,
    30
  ],
  ri: [
    0,
    0,
    15,
    15
  ],
  riacute: [
    0,
    0,
    15,
    15
  ],
  ricircumflex: [
    0,
    0,
    15,
    15
  ],
  ridieresis: [
    0,
    0,
    15,
    15
  ],
  rigrave: [
    0,
    0,
    15,
    15
  ],
  rimacron: [
    0,
    0,
    15,
    15
  ],
  riogonek: [
    0,
    0,
    15,
    15
  ],
  rk: [
    0,
    0,
    15,
    15
  ],
  rkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rl: [
    0,
    0,
    15,
    15
  ],
  rlacute: [
    0,
    0,
    15,
    15
  ],
  rlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rlslash: [
    0,
    0,
    15,
    15
  ],
  rm: [
    0,
    0,
    25,
    25
  ],
  rn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rsemicolon: [
    0,
    0,
    30,
    30
  ],
  ru: [
    0,
    0,
    15,
    15
  ],
  ruacute: [
    0,
    0,
    15,
    15
  ],
  rucircumflex: [
    0,
    0,
    15,
    15
  ],
  rudieresis: [
    0,
    0,
    15,
    15
  ],
  rugrave: [
    0,
    0,
    15,
    15
  ],
  ruhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rumacron: [
    0,
    0,
    15,
    15
  ],
  ruogonek: [
    0,
    0,
    15,
    15
  ],
  ruring: [
    0,
    0,
    15,
    15
  ],
  racutea: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racutearing: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racutecolon: [
    0,
    0,
    30,
    30
  ],
  racutei: [
    0,
    0,
    15,
    15
  ],
  racuteiacute: [
    0,
    0,
    15,
    15
  ],
  racuteicircumflex: [
    0,
    0,
    15,
    15
  ],
  racuteidieresis: [
    0,
    0,
    15,
    15
  ],
  racuteigrave: [
    0,
    0,
    15,
    15
  ],
  racuteimacron: [
    0,
    0,
    15,
    15
  ],
  racuteiogonek: [
    0,
    0,
    15,
    15
  ],
  racutek: [
    0,
    0,
    15,
    15
  ],
  racutekcommaaccent: [
    0,
    0,
    15,
    15
  ],
  racutel: [
    0,
    0,
    15,
    15
  ],
  racutelacute: [
    0,
    0,
    15,
    15
  ],
  racutelcommaaccent: [
    0,
    0,
    15,
    15
  ],
  racutelslash: [
    0,
    0,
    15,
    15
  ],
  racutem: [
    0,
    0,
    25,
    25
  ],
  racuten: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutenacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutencaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutencommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutentilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutep: [
    0,
    0,
    30,
    30,
    -10
  ],
  racutesemicolon: [
    0,
    0,
    30,
    30
  ],
  racuteu: [
    0,
    0,
    15,
    15
  ],
  racuteuacute: [
    0,
    0,
    15,
    15
  ],
  racuteucircumflex: [
    0,
    0,
    15,
    15
  ],
  racuteudieresis: [
    0,
    0,
    15,
    15
  ],
  racuteugrave: [
    0,
    0,
    15,
    15
  ],
  racuteuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  racuteumacron: [
    0,
    0,
    15,
    15
  ],
  racuteuogonek: [
    0,
    0,
    15,
    15
  ],
  racuteuring: [
    0,
    0,
    15,
    15
  ],
  rcarona: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaroncolon: [
    0,
    0,
    30,
    30
  ],
  rcaroni: [
    0,
    0,
    15,
    15
  ],
  rcaroniacute: [
    0,
    0,
    15,
    15
  ],
  rcaronicircumflex: [
    0,
    0,
    15,
    15
  ],
  rcaronidieresis: [
    0,
    0,
    15,
    15
  ],
  rcaronigrave: [
    0,
    0,
    15,
    15
  ],
  rcaronimacron: [
    0,
    0,
    15,
    15
  ],
  rcaroniogonek: [
    0,
    0,
    15,
    15
  ],
  rcaronk: [
    0,
    0,
    15,
    15
  ],
  rcaronkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcaronl: [
    0,
    0,
    15,
    15
  ],
  rcaronlacute: [
    0,
    0,
    15,
    15
  ],
  rcaronlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcaronlslash: [
    0,
    0,
    15,
    15
  ],
  rcaronm: [
    0,
    0,
    25,
    25
  ],
  rcaronn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rcaronsemicolon: [
    0,
    0,
    30,
    30
  ],
  rcaronu: [
    0,
    0,
    15,
    15
  ],
  rcaronuacute: [
    0,
    0,
    15,
    15
  ],
  rcaronucircumflex: [
    0,
    0,
    15,
    15
  ],
  rcaronudieresis: [
    0,
    0,
    15,
    15
  ],
  rcaronugrave: [
    0,
    0,
    15,
    15
  ],
  rcaronuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rcaronumacron: [
    0,
    0,
    15,
    15
  ],
  rcaronuogonek: [
    0,
    0,
    15,
    15
  ],
  rcaronuring: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenta: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentcolon: [
    0,
    0,
    30,
    30
  ],
  rcommaaccenti: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentiacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenticircumflex: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentidieresis: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentigrave: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentimacron: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentiogonek: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentk: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentl: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlslash: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentm: [
    0,
    0,
    25,
    25
  ],
  rcommaaccentn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rcommaaccentsemicolon: [
    0,
    0,
    30,
    30
  ],
  rcommaaccentu: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentucircumflex: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentudieresis: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentugrave: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentumacron: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuogonek: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenturing: [
    0,
    0,
    15,
    15
  ],
  scomma: [
    0,
    0,
    -15,
    -15
  ],
  speriod: [
    0,
    0,
    -15,
    -15
  ],
  sacutecomma: [
    0,
    0,
    -15,
    -15
  ],
  sacuteperiod: [
    0,
    0,
    -15,
    -15
  ],
  scaroncomma: [
    0,
    0,
    -15,
    -15
  ],
  scaronperiod: [
    0,
    0,
    -15,
    -15
  ],
  scedillacomma: [
    0,
    0,
    -15,
    -15
  ],
  scedillaperiod: [
    0,
    0,
    -15,
    -15
  ],
  scommaaccentcomma: [
    0,
    0,
    -15,
    -15
  ],
  scommaaccentperiod: [
    0,
    0,
    -15,
    -15
  ],
  ve: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  veacute: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vecaron: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vecircumflex: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vedieresis: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vedotaccent: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vegrave: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vemacron: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  veogonek: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  wa: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waacute: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wabreve: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wacircumflex: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wadieresis: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wagrave: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wamacron: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waogonek: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waring: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  watilde: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  we: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  weacute: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wecaron: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wecircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wedieresis: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wedotaccent: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wegrave: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wemacron: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  weogonek: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  zo: [
    0,
    0,
    -15,
    -15
  ],
  zoacute: [
    0,
    0,
    -15,
    -15
  ],
  zocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zograve: [
    0,
    0,
    -15,
    -15
  ],
  zohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zomacron: [
    0,
    0,
    -15,
    -15
  ],
  zoslash: [
    0,
    0,
    -15,
    -15
  ],
  zotilde: [
    0,
    0,
    -15,
    -15
  ],
  zacuteo: [
    0,
    0,
    -15,
    -15
  ],
  zacuteoacute: [
    0,
    0,
    -15,
    -15
  ],
  zacuteocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zacuteodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zacuteograve: [
    0,
    0,
    -15,
    -15
  ],
  zacuteohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zacuteomacron: [
    0,
    0,
    -15,
    -15
  ],
  zacuteoslash: [
    0,
    0,
    -15,
    -15
  ],
  zacuteotilde: [
    0,
    0,
    -15,
    -15
  ],
  zcarono: [
    0,
    0,
    -15,
    -15
  ],
  zcaronoacute: [
    0,
    0,
    -15,
    -15
  ],
  zcaronocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zcaronodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zcaronograve: [
    0,
    0,
    -15,
    -15
  ],
  zcaronohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zcaronomacron: [
    0,
    0,
    -15,
    -15
  ],
  zcaronoslash: [
    0,
    0,
    -15,
    -15
  ],
  zcaronotilde: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccento: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentoacute: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentograve: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentomacron: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentoslash: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentotilde: [
    0,
    0,
    -15,
    -15
  ],
  Ap: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aacutep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aacutequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Abrevep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Abrevequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Acircumflexp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Acircumflexquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Adieresisp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Adieresisquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Agravep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Agravequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Amacronp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Amacronquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aogonekp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aogonekquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aringp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aringquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Atildep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Atildequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Je: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jeacute: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jecaron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jecircumflex: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jedieresis: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jedotaccent: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jegrave: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jemacron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jeogonek: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jo: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Joacute: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jocircumflex: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jodieresis: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jograve: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Johungarumlaut: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jomacron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Joslash: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jotilde: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  NA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  Ti: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroni: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroniacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroniogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccenti: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccentiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccentiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Vi: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Viacute: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Vicircumflex: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vidieresis: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vigrave: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vimacron: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Viogonek: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Wi: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  Wiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  Wiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  fi: [
    0,
    0,
    0,
    0,
    -25,
    0,
    -20,
    -20
  ],
  gperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  gbreveperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  gcommaaccentperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  iv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  iacutev: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  icircumflexv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  idieresisv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  igravev: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  imacronv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  iogonekv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  ky: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kyacute: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kydieresis: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccenty: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccentyacute: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccentydieresis: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  quotedblleftA: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAacute: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAbreve: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAcircumflex: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAdieresis: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAgrave: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAmacron: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAogonek: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAring: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAtilde: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftA: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAacute: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAbreve: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAcircumflex: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAdieresis: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAgrave: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAmacron: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAogonek: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAring: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAtilde: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  re: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  reacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  recaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  recircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  redieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  redotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  regrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  remacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  reogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutee: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteeacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteeogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcarone: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroneacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroneogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccente: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccenteacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccenteogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  spaceA: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAacute: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAbreve: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAcircumflex: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAdieresis: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAgrave: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAmacron: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAogonek: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAring: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAtilde: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  Fi: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fiacute: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Ficircumflex: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fidieresis: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Figrave: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fimacron: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fiogonek: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  eb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  eacuteb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ecaronb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ecircumflexb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  edieresisb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  edotaccentb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  egraveb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  emacronb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  eogonekb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ff: [
    0,
    0,
    0,
    0,
    0,
    -18,
    -18,
    -25
  ],
  quoterightt: [
    0,
    0,
    0,
    0,
    0,
    -37,
    -30,
    -18
  ],
  quoterighttcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    -37,
    -30,
    -18
  ],
  Yicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  eg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacuteg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacutegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacutegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egraveg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egravegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egravegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  fiogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    -20
  ],
  gcomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevecomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentcomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  og: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacuteg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacutegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacutegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ograveg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogravegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogravegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildeg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  fiacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -20
  ],
  ga: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  garing: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbrevea: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbrevearing: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccenta: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaring: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ]
};
var data = {
  attributes,
  glyphWidths,
  kernPairs
};
var initFont = /* @__PURE__ */ __name((font) => {
  return [font.FontName, {
    attributes: font,
    glyphWidths: {},
    kernPairs: {}
  }];
}, "initFont");
var expandData = /* @__PURE__ */ __name((data2) => {
  const {
    attributes: attributes2,
    glyphWidths: glyphWidths2,
    kernPairs: kernPairs2
  } = data2;
  const fonts = attributes2.map(initFont);
  Object.keys(glyphWidths2).forEach((key) => {
    glyphWidths2[key].forEach((value2, index2) => {
      if (value2) fonts[index2][1].glyphWidths[key] = value2;
    });
  });
  Object.keys(kernPairs2).forEach((key) => {
    kernPairs2[key].forEach((value2, index2) => {
      if (value2) fonts[index2][1].kernPairs[key] = value2;
    });
  });
  return Object.fromEntries(fonts);
}, "expandData");
var STANDARD_FONTS = expandData(data);
var createStandardFont = /* @__PURE__ */ __name((PDFFont2) => class StandardFont extends PDFFont2 {
  static {
    __name(this, "StandardFont");
  }
  constructor(document2, name, id) {
    super();
    this.document = document2;
    this.name = name;
    this.id = id;
    this.font = AFMFont.fromJson(STANDARD_FONTS[this.name]);
    this.ascender = this.font.ascender;
    this.descender = this.font.descender;
    this.bbox = this.font.bbox;
    this.lineGap = this.font.lineGap;
  }
  embed() {
    this.dictionary.data = {
      Type: "Font",
      BaseFont: this.name,
      Subtype: "Type1",
      Encoding: "WinAnsiEncoding"
    };
    return this.dictionary.end();
  }
  encode(text) {
    const encoded = this.font.encodeText(text);
    const glyphs = this.font.glyphsForString(`${text}`);
    const advances = this.font.advancesForGlyphs(glyphs);
    const positions = [];
    for (let i2 = 0; i2 < glyphs.length; i2++) {
      const glyph = glyphs[i2];
      positions.push({
        xAdvance: advances[i2],
        yAdvance: 0,
        xOffset: 0,
        yOffset: 0,
        advanceWidth: this.font.widthOfGlyph(glyph)
      });
    }
    return [encoded, positions];
  }
  encodeGlyphs(glyphs) {
    const res = [];
    for (let glyph of Array.from(glyphs)) {
      res.push(`00${glyph.id.toString(16)}`.slice(-2));
    }
    return res;
  }
  widthOfString(string, size) {
    const glyphs = this.font.glyphsForString(`${string}`);
    const advances = this.font.advancesForGlyphs(glyphs);
    let width = 0;
    for (let advance of Array.from(advances)) {
      width += advance;
    }
    const scale2 = size / 1e3;
    return width * scale2;
  }
  static isStandardFont(name) {
    return name in STANDARD_FONTS;
  }
}, "createStandardFont");
var toHex2 = /* @__PURE__ */ __name(function() {
  for (var _len = arguments.length, codePoints = new Array(_len), _key = 0; _key < _len; _key++) {
    codePoints[_key] = arguments[_key];
  }
  const codes2 = Array.from(codePoints).map((code) => `0000${code.toString(16)}`.slice(-4));
  return codes2.join("");
}, "toHex");
var createEmbeddedFont = /* @__PURE__ */ __name((PDFFont2) => class EmbeddedFont extends PDFFont2 {
  static {
    __name(this, "EmbeddedFont");
  }
  constructor(document2, font, id) {
    super();
    this.document = document2;
    this.font = font;
    this.id = id;
    this.subset = this.font.createSubset();
    this.unicode = [[0]];
    this.widths = [this.font.getGlyph(0).advanceWidth];
    this.name = this.font.postscriptName;
    this.scale = 1e3 / this.font.unitsPerEm;
    this.ascender = this.font.ascent * this.scale;
    this.descender = this.font.descent * this.scale;
    this.xHeight = this.font.xHeight * this.scale;
    this.capHeight = this.font.capHeight * this.scale;
    this.lineGap = this.font.lineGap * this.scale;
    this.bbox = this.font.bbox;
    this.layoutCache = /* @__PURE__ */ Object.create(null);
  }
  layoutRun(text, features2) {
    const run = this.font.layout(text, features2, void 0, void 0, "ltr");
    for (let i2 = 0; i2 < run.positions.length; i2++) {
      const position = run.positions[i2];
      for (let key in position) {
        position[key] *= this.scale;
      }
      position.advanceWidth = run.glyphs[i2].advanceWidth * this.scale;
    }
    return run;
  }
  layoutCached(text) {
    let cached;
    if (cached = this.layoutCache[text]) {
      return cached;
    }
    const run = this.layoutRun(text);
    this.layoutCache[text] = run;
    return run;
  }
  layout(text, features2, onlyWidth) {
    if (onlyWidth == null) {
      onlyWidth = false;
    }
    if (features2) {
      return this.layoutRun(text, features2);
    }
    const glyphs = onlyWidth ? null : [];
    const positions = onlyWidth ? null : [];
    let advanceWidth2 = 0;
    let last2 = 0;
    let index2 = 0;
    while (index2 <= text.length) {
      let needle;
      if (index2 === text.length && last2 < index2 || (needle = text.charAt(index2), [" ", "	"].includes(needle))) {
        const run = this.layoutCached(text.slice(last2, ++index2));
        if (!onlyWidth) {
          glyphs.push(...Array.from(run.glyphs || []));
          positions.push(...Array.from(run.positions || []));
        }
        advanceWidth2 += run.advanceWidth;
        last2 = index2;
      } else {
        index2++;
      }
    }
    return {
      glyphs,
      positions,
      advanceWidth: advanceWidth2
    };
  }
  encode(text, features2) {
    const {
      glyphs,
      positions
    } = this.layout(text, features2);
    const res = [];
    for (let i2 = 0; i2 < glyphs.length; i2++) {
      const glyph = glyphs[i2];
      const gid = this.subset.includeGlyph(glyph.id);
      res.push(`0000${gid.toString(16)}`.slice(-4));
      if (this.widths[gid] == null) {
        this.widths[gid] = glyph.advanceWidth * this.scale;
      }
      if (this.unicode[gid] == null) {
        this.unicode[gid] = glyph.codePoints;
      }
    }
    return [res, positions];
  }
  encodeGlyphs(glyphs) {
    const res = [];
    for (let i2 = 0; i2 < glyphs.length; i2++) {
      const glyph = glyphs[i2];
      const gid = this.subset.includeGlyph(glyph.id);
      res.push(`0000${gid.toString(16)}`.slice(-4));
      if (this.widths[gid] == null) {
        this.widths[gid] = glyph.advanceWidth * this.scale;
      }
      if (this.unicode[gid] == null) {
        this.unicode[gid] = glyph.codePoints;
      }
    }
    return res;
  }
  widthOfString(string, size, features2) {
    const width = this.layout(string, features2, true).advanceWidth;
    const scale2 = size / 1e3;
    return width * scale2;
  }
  embed() {
    const isCFF = this.subset.cff != null;
    const fontFile = this.document.ref();
    if (isCFF) {
      fontFile.data.Subtype = "CIDFontType0C";
    }
    fontFile.end(this.subset.encode());
    const familyClass = ((this.font["OS/2"] != null ? this.font["OS/2"].sFamilyClass : void 0) || 0) >> 8;
    let flags = 0;
    if (this.font.post.isFixedPitch) {
      flags |= 1 << 0;
    }
    if (1 <= familyClass && familyClass <= 7) {
      flags |= 1 << 1;
    }
    flags |= 1 << 2;
    if (familyClass === 10) {
      flags |= 1 << 3;
    }
    if (this.font.head.macStyle.italic) {
      flags |= 1 << 6;
    }
    const tag = [0, 1, 2, 3, 4, 5].map(() => String.fromCharCode(Math.random() * 26 + 65)).join("");
    const name = tag + "+" + this.font.postscriptName;
    const {
      bbox
    } = this.font;
    const descriptor = this.document.ref({
      Type: "FontDescriptor",
      FontName: name,
      Flags: flags,
      FontBBox: [bbox.minX * this.scale, bbox.minY * this.scale, bbox.maxX * this.scale, bbox.maxY * this.scale],
      ItalicAngle: this.font.italicAngle,
      Ascent: this.ascender,
      Descent: this.descender,
      CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,
      XHeight: (this.font.xHeight || 0) * this.scale,
      StemV: 0
    });
    if (isCFF) {
      descriptor.data.FontFile3 = fontFile;
    } else {
      descriptor.data.FontFile2 = fontFile;
    }
    descriptor.end();
    const descendantFontData = {
      Type: "Font",
      Subtype: "CIDFontType0",
      BaseFont: name,
      CIDSystemInfo: {
        Registry: new String("Adobe"),
        Ordering: new String("Identity"),
        Supplement: 0
      },
      FontDescriptor: descriptor,
      W: [0, this.widths]
    };
    if (!isCFF) {
      descendantFontData.Subtype = "CIDFontType2";
      descendantFontData.CIDToGIDMap = "Identity";
    }
    const descendantFont = this.document.ref(descendantFontData);
    descendantFont.end();
    this.dictionary.data = {
      Type: "Font",
      Subtype: "Type0",
      BaseFont: name,
      Encoding: "Identity-H",
      DescendantFonts: [descendantFont],
      ToUnicode: this.toUnicodeCmap()
    };
    return this.dictionary.end();
  }
  // Maps the glyph ids encoded in the PDF back to unicode strings
  // Because of ligature substitutions and the like, there may be one or more
  // unicode characters represented by each glyph.
  toUnicodeCmap() {
    const cmap = this.document.ref();
    let entries = [];
    let unicodeMap = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange";
    for (let [index2, codePoints] of this.unicode.entries()) {
      const encoded = [];
      if (entries.length >= 100) {
        unicodeMap += "\n" + entries.length + " beginbfchar\n" + entries.join("\n") + "\nendbfchar";
        entries = [];
      }
      for (let value2 of codePoints) {
        if (value2 > 65535) {
          value2 -= 65536;
          encoded.push(toHex2(value2 >>> 10 & 1023 | 55296));
          value2 = 56320 | value2 & 1023;
        }
        encoded.push(toHex2(value2));
      }
      entries.push("<" + toHex2(index2) + "><" + encoded.join(" ") + ">");
    }
    if (entries.length) {
      unicodeMap += "\n" + entries.length + " beginbfchar\n" + entries.join("\n") + "\nendbfchar\n";
    }
    unicodeMap += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
    cmap.end(unicodeMap);
    return cmap;
  }
}, "createEmbeddedFont");
var PDFFont = class {
  static {
    __name(this, "PDFFont");
  }
  static open(document2, src, family, id) {
    let font;
    if (typeof src === "string") {
      if (StandardFont.isStandardFont(src)) {
        return new StandardFont(document2, src, id);
      }
      {
        throw new Error(`Can't open ${src} in browser build`);
      }
    } else if (src instanceof Uint8Array) {
      font = $d636bc798e7178db$export$185802fd694ee1f5(src, family);
    } else if (src instanceof ArrayBuffer) {
      font = $d636bc798e7178db$export$185802fd694ee1f5(new Uint8Array(src), family);
    } else if (typeof src === "object") {
      font = src;
    }
    if (font == null) {
      throw new Error("Not a supported font format or standard PDF font.");
    }
    return new EmbeddedFont(document2, font, id);
  }
  encode() {
    throw new Error("Must be implemented by subclasses");
  }
  widthOfString() {
    throw new Error("Must be implemented by subclasses");
  }
  ref() {
    return this.dictionary != null ? this.dictionary : this.dictionary = this.document.ref();
  }
  finalize() {
    if (this.embedded || this.dictionary == null) {
      return;
    }
    this.embed();
    return this.embedded = true;
  }
  embed() {
    throw new Error("Must be implemented by subclasses");
  }
  lineHeight(size, includeGap) {
    if (includeGap == null) {
      includeGap = false;
    }
    const gap = includeGap ? this.lineGap : 0;
    return (this.ascender + gap - this.descender) / 1e3 * size;
  }
};
var StandardFont = createStandardFont(PDFFont);
var EmbeddedFont = createEmbeddedFont(PDFFont);
var FontsMixin = {
  initFonts() {
    this._fontFamilies = {};
    this._fontCount = 0;
    this._fontSize = 12;
    this._font = null;
    this._registeredFonts = {};
    return this.font("Helvetica");
  },
  font(src, family, size) {
    let cacheKey;
    let font;
    if (typeof family === "number") {
      size = family;
      family = null;
    }
    if (typeof src === "string" && this._registeredFonts[src]) {
      cacheKey = src;
      ({
        src,
        family
      } = this._registeredFonts[src]);
    } else {
      cacheKey = family || src;
      if (typeof cacheKey !== "string") {
        cacheKey = null;
      }
    }
    if (size != null) {
      this.fontSize(size);
    }
    if (font = this._fontFamilies[cacheKey]) {
      this._font = font;
      return this;
    }
    const id = `F${++this._fontCount}`;
    this._font = PDFFont.open(this, src, family, id);
    if (font = this._fontFamilies[this._font.name]) {
      this._font = font;
      return this;
    }
    if (cacheKey) {
      this._fontFamilies[cacheKey] = this._font;
    }
    if (this._font.name) {
      this._fontFamilies[this._font.name] = this._font;
    }
    return this;
  },
  fontSize(_fontSize) {
    this._fontSize = _fontSize;
    return this;
  },
  currentLineHeight(includeGap) {
    if (includeGap == null) {
      includeGap = false;
    }
    return this._font.lineHeight(this._fontSize, includeGap);
  },
  registerFont(name, src, family) {
    this._registeredFonts[name] = {
      src,
      family
    };
    return this;
  }
};
function PDFNumber(n5) {
  return Math.fround(n5);
}
__name(PDFNumber, "PDFNumber");
var SOFT_HYPHEN = "\xAD";
var HYPHEN = "-";
var LineWrapper = class extends EventEmitter3 {
  static {
    __name(this, "LineWrapper");
  }
  constructor(document2, options) {
    super();
    this.document = document2;
    this.horizontalScaling = options.horizontalScaling || 100;
    this.indent = (options.indent || 0) * this.horizontalScaling / 100;
    this.characterSpacing = (options.characterSpacing || 0) * this.horizontalScaling / 100;
    this.wordSpacing = (options.wordSpacing === 0) * this.horizontalScaling / 100;
    this.columns = options.columns || 1;
    this.columnGap = (options.columnGap != null ? options.columnGap : 18) * this.horizontalScaling / 100;
    this.lineWidth = (options.width * this.horizontalScaling / 100 - this.columnGap * (this.columns - 1)) / this.columns;
    this.spaceLeft = this.lineWidth;
    this.startX = this.document.x;
    this.startY = this.document.y;
    this.column = 1;
    this.ellipsis = options.ellipsis;
    this.continuedX = 0;
    this.features = options.features;
    if (options.height != null) {
      this.height = options.height;
      this.maxY = PDFNumber(this.startY + options.height);
    } else {
      this.maxY = PDFNumber(this.document.page.maxY());
    }
    this.on("firstLine", (options2) => {
      const indent = this.continuedX || this.indent;
      this.document.x += indent;
      this.lineWidth -= indent;
      if (options2.indentAllLines) {
        return;
      }
      return this.once("line", () => {
        this.document.x -= indent;
        this.lineWidth += indent;
        if (options2.continued && !this.continuedX) {
          this.continuedX = this.indent;
        }
        if (!options2.continued) {
          return this.continuedX = 0;
        }
      });
    });
    this.on("lastLine", (options2) => {
      const {
        align
      } = options2;
      if (align === "justify") {
        options2.align = "left";
      }
      this.lastLine = true;
      return this.once("line", () => {
        this.document.y += options2.paragraphGap || 0;
        options2.align = align;
        return this.lastLine = false;
      });
    });
  }
  wordWidth(word) {
    return this.document.widthOfString(word, this) + this.characterSpacing + this.wordSpacing;
  }
  canFit(word, w) {
    if (word[word.length - 1] != SOFT_HYPHEN) {
      return w <= this.spaceLeft;
    }
    return w + this.wordWidth(HYPHEN) <= this.spaceLeft;
  }
  eachWord(text, fn) {
    let bk;
    const breaker = new $557adaaeb0c7885f$exports(text);
    let last2 = null;
    const wordWidths = /* @__PURE__ */ Object.create(null);
    while (bk = breaker.nextBreak()) {
      var shouldContinue;
      let word = text.slice((last2 != null ? last2.position : void 0) || 0, bk.position);
      let w = wordWidths[word] != null ? wordWidths[word] : wordWidths[word] = this.wordWidth(word);
      if (w > this.lineWidth + this.continuedX) {
        let lbk = last2;
        const fbk = {};
        while (word.length) {
          var l4, mightGrow;
          if (w > this.spaceLeft) {
            l4 = Math.ceil(this.spaceLeft / (w / word.length));
            w = this.wordWidth(word.slice(0, l4));
            mightGrow = w <= this.spaceLeft && l4 < word.length;
          } else {
            l4 = word.length;
          }
          let mustShrink = w > this.spaceLeft && l4 > 0;
          while (mustShrink || mightGrow) {
            if (mustShrink) {
              w = this.wordWidth(word.slice(0, --l4));
              mustShrink = w > this.spaceLeft && l4 > 0;
            } else {
              w = this.wordWidth(word.slice(0, ++l4));
              mustShrink = w > this.spaceLeft && l4 > 0;
              mightGrow = w <= this.spaceLeft && l4 < word.length;
            }
          }
          if (l4 === 0 && this.spaceLeft === this.lineWidth) {
            l4 = 1;
          }
          fbk.required = bk.required || l4 < word.length;
          shouldContinue = fn(word.slice(0, l4), w, fbk, lbk);
          lbk = {
            required: false
          };
          word = word.slice(l4);
          w = this.wordWidth(word);
          if (shouldContinue === false) {
            break;
          }
        }
      } else {
        shouldContinue = fn(word, w, bk, last2);
      }
      if (shouldContinue === false) {
        break;
      }
      last2 = bk;
    }
  }
  wrap(text, options) {
    this.horizontalScaling = options.horizontalScaling || 100;
    if (options.indent != null) {
      this.indent = options.indent * this.horizontalScaling / 100;
    }
    if (options.characterSpacing != null) {
      this.characterSpacing = options.characterSpacing * this.horizontalScaling / 100;
    }
    if (options.wordSpacing != null) {
      this.wordSpacing = options.wordSpacing * this.horizontalScaling / 100;
    }
    if (options.ellipsis != null) {
      this.ellipsis = options.ellipsis;
    }
    const nextY = this.document.y + this.document.currentLineHeight(true);
    if (this.document.y > this.maxY || nextY > this.maxY) {
      this.nextSection();
    }
    let buffer = "";
    let textWidth = 0;
    let wc = 0;
    let lc = 0;
    let {
      y: y3
    } = this.document;
    const emitLine = /* @__PURE__ */ __name(() => {
      options.textWidth = textWidth + this.wordSpacing * (wc - 1);
      options.wordCount = wc;
      options.lineWidth = this.lineWidth;
      ({
        y: y3
      } = this.document);
      this.emit("line", buffer, options, this);
      return lc++;
    }, "emitLine");
    this.emit("sectionStart", options, this);
    this.eachWord(text, (word, w, bk, last2) => {
      if (last2 == null || last2.required) {
        this.emit("firstLine", options, this);
        this.spaceLeft = this.lineWidth;
      }
      if (this.canFit(word, w)) {
        buffer += word;
        textWidth += w;
        wc++;
      }
      if (bk.required || !this.canFit(word, w)) {
        const lh = this.document.currentLineHeight(true);
        if (this.height != null && this.ellipsis && PDFNumber(this.document.y + lh * 2) > this.maxY && this.column >= this.columns) {
          if (this.ellipsis === true) {
            this.ellipsis = "\u2026";
          }
          buffer = buffer.replace(/\s+$/, "");
          textWidth = this.wordWidth(buffer + this.ellipsis);
          while (buffer && textWidth > this.lineWidth) {
            buffer = buffer.slice(0, -1).replace(/\s+$/, "");
            textWidth = this.wordWidth(buffer + this.ellipsis);
          }
          if (textWidth <= this.lineWidth) {
            buffer = buffer + this.ellipsis;
          }
          textWidth = this.wordWidth(buffer);
        }
        if (bk.required) {
          if (w > this.spaceLeft) {
            emitLine();
            buffer = word;
            textWidth = w;
            wc = 1;
          }
          this.emit("lastLine", options, this);
        }
        if (buffer[buffer.length - 1] == SOFT_HYPHEN) {
          buffer = buffer.slice(0, -1) + HYPHEN;
          this.spaceLeft -= this.wordWidth(HYPHEN);
        }
        emitLine();
        if (PDFNumber(this.document.y + lh) > this.maxY) {
          const shouldContinue = this.nextSection();
          if (!shouldContinue) {
            wc = 0;
            buffer = "";
            return false;
          }
        }
        if (bk.required) {
          this.spaceLeft = this.lineWidth;
          buffer = "";
          textWidth = 0;
          return wc = 0;
        } else {
          this.spaceLeft = this.lineWidth - w;
          buffer = word;
          textWidth = w;
          return wc = 1;
        }
      } else {
        return this.spaceLeft -= w;
      }
    });
    if (wc > 0) {
      this.emit("lastLine", options, this);
      emitLine();
    }
    this.emit("sectionEnd", options, this);
    if (options.continued === true) {
      if (lc > 1) {
        this.continuedX = 0;
      }
      this.continuedX += options.textWidth || 0;
      return this.document.y = y3;
    } else {
      return this.document.x = this.startX;
    }
  }
  nextSection(options) {
    this.emit("sectionEnd", options, this);
    if (++this.column > this.columns) {
      if (this.height != null) {
        return false;
      }
      this.document.continueOnNewPage();
      this.column = 1;
      this.startY = this.document.page.margins.top;
      this.maxY = this.document.page.maxY();
      this.document.x = this.startX;
      if (this.document._fillColor) {
        this.document.fillColor(...this.document._fillColor);
      }
      this.emit("pageBreak", options, this);
    } else {
      this.document.x += this.lineWidth + this.columnGap;
      this.document.y = this.startY;
      this.emit("columnBreak", options, this);
    }
    this.emit("sectionStart", options, this);
    return true;
  }
};
var {
  number
} = PDFObject;
var TextMixin = {
  initText() {
    this._line = this._line.bind(this);
    this.x = 0;
    this.y = 0;
    return this._lineGap = 0;
  },
  lineGap(_lineGap) {
    this._lineGap = _lineGap;
    return this;
  },
  moveDown(lines) {
    if (lines == null) {
      lines = 1;
    }
    this.y += this.currentLineHeight(true) * lines + this._lineGap;
    return this;
  },
  moveUp(lines) {
    if (lines == null) {
      lines = 1;
    }
    this.y -= this.currentLineHeight(true) * lines + this._lineGap;
    return this;
  },
  _text(text, x, y3, options, lineCallback) {
    options = this._initOptions(x, y3, options);
    text = text == null ? "" : `${text}`;
    if (options.wordSpacing) {
      text = text.replace(/\s{2,}/g, " ");
    }
    const addStructure = /* @__PURE__ */ __name(() => {
      if (options.structParent) {
        options.structParent.add(this.struct(options.structType || "P", [this.markStructureContent(options.structType || "P")]));
      }
    }, "addStructure");
    if (options.rotation !== 0) {
      this.save();
      this.rotate(-options.rotation, {
        origin: [this.x, this.y]
      });
    }
    if (options.width) {
      let wrapper = this._wrapper;
      if (!wrapper) {
        wrapper = new LineWrapper(this, options);
        wrapper.on("line", lineCallback);
        wrapper.on("firstLine", addStructure);
      }
      this._wrapper = options.continued ? wrapper : null;
      this._textOptions = options.continued ? options : null;
      wrapper.wrap(text, options);
    } else {
      for (let line2 of text.split("\n")) {
        addStructure();
        lineCallback(line2, options);
      }
    }
    if (options.rotation !== 0) this.restore();
    return this;
  },
  text(text, x, y3, options) {
    return this._text(text, x, y3, options, this._line);
  },
  widthOfString(string, options) {
    if (options === void 0) {
      options = {};
    }
    const horizontalScaling = options.horizontalScaling || 100;
    return (this._font.widthOfString(string, this._fontSize, options.features) + (options.characterSpacing || 0) * (string.length - 1)) * horizontalScaling / 100;
  },
  /**
   * Compute the bounding box of a string
   * based on what will actually be rendered by `doc.text()`
   *
   * @param string - The string
   * @param x - X position of text (defaults to this.x)
   * @param y - Y position of text (defaults to this.y)
   * @param options - Any text options (The same you would apply to `doc.text()`)
   * @returns {{x: number, y: number, width: number, height: number}}
   */
  boundsOfString(string, x, y3, options) {
  },
  heightOfString(text, options) {
    const {
      x,
      y: y3
    } = this;
    options = this._initOptions(options);
    options.height = Infinity;
    const lineGap2 = options.lineGap || this._lineGap || 0;
    this._text(text, this.x, this.y, options, () => {
      return this.y += this.currentLineHeight(true) + lineGap2;
    });
    const height2 = this.y - y3;
    this.x = x;
    this.y = y3;
    return height2;
  },
  list(list, x, y3, options, wrapper) {
    options = this._initOptions(x, y3, options);
    const listType = options.listType || "bullet";
    const unit = Math.round(this._font.ascender / 1e3 * this._fontSize);
    const midLine = unit / 2;
    const r5 = options.bulletRadius || unit / 3;
    const indent = options.textIndent || (listType === "bullet" ? r5 * 5 : unit * 2);
    const itemIndent = options.bulletIndent || (listType === "bullet" ? r5 * 8 : unit * 2);
    let level = 1;
    const items = [];
    const levels = [];
    const numbers = [];
    var flatten3 = /* @__PURE__ */ __name(function(list2) {
      let n5 = 1;
      for (let i2 = 0; i2 < list2.length; i2++) {
        const item = list2[i2];
        if (Array.isArray(item)) {
          level++;
          flatten3(item);
          level--;
        } else {
          items.push(item);
          levels.push(level);
          if (listType !== "bullet") {
            numbers.push(n5++);
          }
        }
      }
    }, "flatten");
    flatten3(list);
    const label = /* @__PURE__ */ __name(function(n5) {
      switch (listType) {
        case "numbered":
          return `${n5}.`;
        case "lettered":
          var letter = String.fromCharCode((n5 - 1) % 26 + 65);
          var times = Math.floor((n5 - 1) / 26 + 1);
          var text = Array(times + 1).join(letter);
          return `${text}.`;
      }
    }, "label");
    const drawListItem = /* @__PURE__ */ __name(function(listItem, i2) {
      wrapper = new LineWrapper(this, options);
      wrapper.on("line", this._line);
      level = 1;
      wrapper.once("firstLine", () => {
        let item, itemType, labelType, bodyType;
        if (options.structParent) {
          if (options.structTypes) {
            [itemType, labelType, bodyType] = options.structTypes;
          } else {
            [itemType, labelType, bodyType] = ["LI", "Lbl", "LBody"];
          }
        }
        if (itemType) {
          item = this.struct(itemType);
          options.structParent.add(item);
        } else if (options.structParent) {
          item = options.structParent;
        }
        let l4;
        if ((l4 = levels[i2++]) !== level) {
          const diff = itemIndent * (l4 - level);
          this.x += diff;
          wrapper.lineWidth -= diff;
          level = l4;
        }
        if (item && (labelType || bodyType)) {
          item.add(this.struct(labelType || bodyType, [this.markStructureContent(labelType || bodyType)]));
        }
        switch (listType) {
          case "bullet":
            this.circle(this.x - indent + r5, this.y + midLine, r5);
            this.fill();
            break;
          case "numbered":
          case "lettered":
            var text = label(numbers[i2 - 1]);
            this._fragment(text, this.x - indent, this.y, options);
            break;
        }
        if (item && labelType && bodyType) {
          item.add(this.struct(bodyType, [this.markStructureContent(bodyType)]));
        }
        if (item && item !== options.structParent) {
          item.end();
        }
      });
      wrapper.on("sectionStart", () => {
        const pos = indent + itemIndent * (level - 1);
        this.x += pos;
        return wrapper.lineWidth -= pos;
      });
      wrapper.on("sectionEnd", () => {
        const pos = indent + itemIndent * (level - 1);
        this.x -= pos;
        return wrapper.lineWidth += pos;
      });
      wrapper.wrap(listItem, options);
    }, "drawListItem");
    for (let i2 = 0; i2 < items.length; i2++) {
      drawListItem.call(this, items[i2], i2);
    }
    return this;
  },
  _initOptions(x, y3, options) {
    var _options$rotation;
    if (x === void 0) {
      x = {};
    }
    if (options === void 0) {
      options = {};
    }
    if (typeof x === "object") {
      options = x;
      x = null;
    }
    const result = Object.assign({}, options);
    if (this._textOptions) {
      for (let key in this._textOptions) {
        const val = this._textOptions[key];
        if (key !== "continued") {
          if (result[key] === void 0) {
            result[key] = val;
          }
        }
      }
    }
    if (x != null) {
      this.x = x;
    }
    if (y3 != null) {
      this.y = y3;
    }
    if (result.lineBreak !== false) {
      if (result.width == null) {
        result.width = this.page.width - this.x - this.page.margins.right;
      }
      result.width = Math.max(result.width, 0);
    }
    if (!result.columns) {
      result.columns = 0;
    }
    if (result.columnGap == null) {
      result.columnGap = 18;
    }
    result.rotation = Number((_options$rotation = options.rotation) !== null && _options$rotation !== void 0 ? _options$rotation : 0) % 360;
    if (result.rotation < 0) result.rotation += 360;
    return result;
  },
  _line(text, options, wrapper) {
    if (options === void 0) {
      options = {};
    }
    this._fragment(text, this.x, this.y, options);
    const lineGap2 = options.lineGap || this._lineGap || 0;
    if (!wrapper) {
      return this.x += this.widthOfString(text, options);
    } else {
      return this.y += this.currentLineHeight(true) + lineGap2;
    }
  },
  _fragment(text, x, y3, options) {
    let dy, encoded, i2, positions, textWidth, words;
    text = `${text}`.replace(/\n/g, "");
    if (text.length === 0) {
      return;
    }
    const align = options.align || "left";
    let wordSpacing = options.wordSpacing || 0;
    const characterSpacing = options.characterSpacing || 0;
    const horizontalScaling = options.horizontalScaling || 100;
    if (options.width) {
      switch (align) {
        case "right":
          textWidth = this.widthOfString(text.replace(/\s+$/, ""), options);
          x += options.lineWidth - textWidth;
          break;
        case "center":
          x += options.lineWidth / 2 - options.textWidth / 2;
          break;
        case "justify":
          words = text.trim().split(/\s+/);
          textWidth = this.widthOfString(text.replace(/\s+/g, ""), options);
          var spaceWidth = this.widthOfString(" ") + characterSpacing;
          wordSpacing = Math.max(0, (options.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);
          break;
      }
    }
    if (typeof options.baseline === "number") {
      dy = -options.baseline;
    } else {
      switch (options.baseline) {
        case "svg-middle":
          dy = 0.5 * this._font.xHeight;
          break;
        case "middle":
        case "svg-central":
          dy = 0.5 * (this._font.descender + this._font.ascender);
          break;
        case "bottom":
        case "ideographic":
          dy = this._font.descender;
          break;
        case "alphabetic":
          dy = 0;
          break;
        case "mathematical":
          dy = 0.5 * this._font.ascender;
          break;
        case "hanging":
          dy = 0.8 * this._font.ascender;
          break;
        case "top":
          dy = this._font.ascender;
          break;
        default:
          dy = this._font.ascender;
      }
      dy = dy / 1e3 * this._fontSize;
    }
    const renderedWidth = options.textWidth + wordSpacing * (options.wordCount - 1) + characterSpacing * (text.length - 1);
    if (options.link != null) {
      this.link(x, y3, renderedWidth, this.currentLineHeight(), options.link);
    }
    if (options.goTo != null) {
      this.goTo(x, y3, renderedWidth, this.currentLineHeight(), options.goTo);
    }
    if (options.destination != null) {
      this.addNamedDestination(options.destination, "XYZ", x, y3, null);
    }
    if (options.underline) {
      this.save();
      if (!options.stroke) {
        this.strokeColor(...this._fillColor || []);
      }
      const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);
      this.lineWidth(lineWidth);
      let lineY = y3 + this.currentLineHeight() - lineWidth;
      this.moveTo(x, lineY);
      this.lineTo(x + renderedWidth, lineY);
      this.stroke();
      this.restore();
    }
    if (options.strike) {
      this.save();
      if (!options.stroke) {
        this.strokeColor(...this._fillColor || []);
      }
      const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);
      this.lineWidth(lineWidth);
      let lineY = y3 + this.currentLineHeight() / 2;
      this.moveTo(x, lineY);
      this.lineTo(x + renderedWidth, lineY);
      this.stroke();
      this.restore();
    }
    this.save();
    if (options.oblique) {
      let skew;
      if (typeof options.oblique === "number") {
        skew = -Math.tan(options.oblique * Math.PI / 180);
      } else {
        skew = -0.25;
      }
      this.transform(1, 0, 0, 1, x, y3);
      this.transform(1, 0, skew, 1, -skew * dy, 0);
      this.transform(1, 0, 0, 1, -x, -y3);
    }
    this.transform(1, 0, 0, -1, 0, this.page.height);
    y3 = this.page.height - y3 - dy;
    if (this.page.fonts[this._font.id] == null) {
      this.page.fonts[this._font.id] = this._font.ref();
    }
    this.addContent("BT");
    this.addContent(`1 0 0 1 ${number(x)} ${number(y3)} Tm`);
    this.addContent(`/${this._font.id} ${number(this._fontSize)} Tf`);
    const mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;
    if (mode) {
      this.addContent(`${mode} Tr`);
    }
    if (characterSpacing) {
      this.addContent(`${number(characterSpacing)} Tc`);
    }
    if (horizontalScaling !== 100) {
      this.addContent(`${horizontalScaling} Tz`);
    }
    if (wordSpacing) {
      words = text.trim().split(/\s+/);
      wordSpacing += this.widthOfString(" ") + characterSpacing;
      wordSpacing *= 1e3 / this._fontSize;
      encoded = [];
      positions = [];
      for (let word of words) {
        const [encodedWord, positionsWord] = this._font.encode(word, options.features);
        encoded = encoded.concat(encodedWord);
        positions = positions.concat(positionsWord);
        const space = {};
        const object = positions[positions.length - 1];
        for (let key in object) {
          const val = object[key];
          space[key] = val;
        }
        space.xAdvance += wordSpacing;
        positions[positions.length - 1] = space;
      }
    } else {
      [encoded, positions] = this._font.encode(text, options.features);
    }
    const scale2 = this._fontSize / 1e3;
    const commands = [];
    let last2 = 0;
    let hadOffset = false;
    const addSegment = /* @__PURE__ */ __name((cur) => {
      if (last2 < cur) {
        const hex = encoded.slice(last2, cur).join("");
        const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;
        commands.push(`<${hex}> ${number(-advance)}`);
      }
      return last2 = cur;
    }, "addSegment");
    const flush = /* @__PURE__ */ __name((i3) => {
      addSegment(i3);
      if (commands.length > 0) {
        this.addContent(`[${commands.join(" ")}] TJ`);
        return commands.length = 0;
      }
    }, "flush");
    for (i2 = 0; i2 < positions.length; i2++) {
      const pos = positions[i2];
      if (pos.xOffset || pos.yOffset) {
        flush(i2);
        this.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale2)} ${number(y3 + pos.yOffset * scale2)} Tm`);
        flush(i2 + 1);
        hadOffset = true;
      } else {
        if (hadOffset) {
          this.addContent(`1 0 0 1 ${number(x)} ${number(y3)} Tm`);
          hadOffset = false;
        }
        if (pos.xAdvance - pos.advanceWidth !== 0) {
          addSegment(i2 + 1);
        }
      }
      x += pos.xAdvance * scale2;
    }
    flush(i2);
    this.addContent("ET");
    return this.restore();
  }
};
var COLOR_SPACE_MAP = {
  1: "DeviceGray",
  3: "DeviceRGB",
  4: "DeviceCMYK"
};
var JPEG2 = class {
  static {
    __name(this, "JPEG");
  }
  constructor(data2, label) {
    this.data = data2;
    this.label = label;
    this.orientation = 1;
    if (this.data.readUInt16BE(0) !== 65496) {
      throw "SOI not found in JPEG";
    }
    const markers = src_default.decode(this.data);
    for (let i2 = 0; i2 < markers.length; i2 += 1) {
      const marker = markers[i2];
      if (marker.name === "EXIF" && marker.entries.orientation) {
        this.orientation = marker.entries.orientation;
      }
      if (marker.name === "SOF") {
        this.bits ||= marker.precision;
        this.width ||= marker.width;
        this.height ||= marker.height;
        this.colorSpace ||= COLOR_SPACE_MAP[marker.numberOfComponents];
      }
    }
    this.obj = null;
  }
  embed(document2) {
    if (this.obj) {
      return;
    }
    this.obj = document2.ref({
      Type: "XObject",
      Subtype: "Image",
      BitsPerComponent: this.bits,
      Width: this.width,
      Height: this.height,
      ColorSpace: this.colorSpace,
      Filter: "DCTDecode"
    });
    if (this.colorSpace === "DeviceCMYK") {
      this.obj.data["Decode"] = [1, 0, 1, 0, 1, 0, 1, 0];
    }
    this.obj.end(this.data);
    return this.data = null;
  }
};
var PNGImage = class {
  static {
    __name(this, "PNGImage");
  }
  constructor(data2, label) {
    this.label = label;
    this.image = new PNG(data2);
    this.width = this.image.width;
    this.height = this.image.height;
    this.imgData = this.image.imgData;
    this.obj = null;
  }
  embed(document2) {
    let dataDecoded = false;
    this.document = document2;
    if (this.obj) {
      return;
    }
    const hasAlphaChannel = this.image.hasAlphaChannel;
    const isInterlaced = this.image.interlaceMethod === 1;
    this.obj = this.document.ref({
      Type: "XObject",
      Subtype: "Image",
      BitsPerComponent: hasAlphaChannel ? 8 : this.image.bits,
      Width: this.width,
      Height: this.height,
      Filter: "FlateDecode"
    });
    if (!hasAlphaChannel) {
      const params = this.document.ref({
        Predictor: isInterlaced ? 1 : 15,
        Colors: this.image.colors,
        BitsPerComponent: this.image.bits,
        Columns: this.width
      });
      this.obj.data.DecodeParms = params;
      params.end();
    }
    if (this.image.palette.length === 0) {
      this.obj.data.ColorSpace = this.image.colorSpace;
    } else {
      const palette = this.document.ref();
      palette.end(Buffer$2.from(this.image.palette));
      this.obj.data.ColorSpace = ["Indexed", "DeviceRGB", this.image.palette.length / 3 - 1, palette];
    }
    if (this.image.transparency.grayscale != null) {
      const val = this.image.transparency.grayscale;
      this.obj.data.Mask = [val, val];
    } else if (this.image.transparency.rgb) {
      const {
        rgb
      } = this.image.transparency;
      const mask = [];
      for (let x of rgb) {
        mask.push(x, x);
      }
      this.obj.data.Mask = mask;
    } else if (this.image.transparency.indexed) {
      dataDecoded = true;
      return this.loadIndexedAlphaChannel();
    } else if (hasAlphaChannel) {
      dataDecoded = true;
      return this.splitAlphaChannel();
    }
    if (isInterlaced && !dataDecoded) {
      return this.decodeData();
    }
    this.finalize();
  }
  finalize() {
    if (this.alphaChannel) {
      const sMask = this.document.ref({
        Type: "XObject",
        Subtype: "Image",
        Height: this.height,
        Width: this.width,
        BitsPerComponent: 8,
        Filter: "FlateDecode",
        ColorSpace: "DeviceGray",
        Decode: [0, 1]
      });
      sMask.end(this.alphaChannel);
      this.obj.data.SMask = sMask;
    }
    this.obj.end(this.imgData);
    this.image = null;
    return this.imgData = null;
  }
  splitAlphaChannel() {
    return this.image.decodePixels((pixels) => {
      let a4;
      let p3;
      const colorCount = this.image.colors;
      const pixelCount = this.width * this.height;
      const imgData = Buffer$2.alloc(pixelCount * colorCount);
      const alphaChannel = Buffer$2.alloc(pixelCount);
      let i2 = p3 = a4 = 0;
      const len = pixels.length;
      const skipByteCount = this.image.bits === 16 ? 1 : 0;
      while (i2 < len) {
        for (let colorIndex = 0; colorIndex < colorCount; colorIndex++) {
          imgData[p3++] = pixels[i2++];
          i2 += skipByteCount;
        }
        alphaChannel[a4++] = pixels[i2++];
        i2 += skipByteCount;
      }
      this.imgData = zlib2.deflateSync(imgData);
      this.alphaChannel = zlib2.deflateSync(alphaChannel);
      return this.finalize();
    });
  }
  loadIndexedAlphaChannel() {
    const transparency = this.image.transparency.indexed;
    return this.image.decodePixels((pixels) => {
      const alphaChannel = Buffer$2.alloc(this.width * this.height);
      let i2 = 0;
      for (let j = 0, end2 = pixels.length; j < end2; j++) {
        alphaChannel[i2++] = transparency[pixels[j]];
      }
      this.alphaChannel = zlib2.deflateSync(alphaChannel);
      return this.finalize();
    });
  }
  decodeData() {
    this.image.decodePixels((pixels) => {
      this.imgData = zlib2.deflateSync(pixels);
      this.finalize();
    });
  }
};
var PDFImage = class {
  static {
    __name(this, "PDFImage");
  }
  static open(src, label) {
    let data2;
    if (Buffer$2.isBuffer(src)) {
      data2 = src;
    } else if (src instanceof ArrayBuffer) {
      data2 = Buffer$2.from(new Uint8Array(src));
    } else {
      let match2;
      if (match2 = /^data:.+?;base64,(.*)$/.exec(src)) {
        data2 = Buffer$2.from(match2[1], "base64");
      } else {
        data2 = fs.readFileSync(src);
        if (!data2) {
          return;
        }
      }
    }
    if (data2[0] === 255 && data2[1] === 216) {
      return new JPEG2(data2, label);
    } else if (data2[0] === 137 && data2.toString("ascii", 1, 4) === "PNG") {
      return new PNGImage(data2, label);
    } else {
      throw new Error("Unknown image format.");
    }
  }
};
var ImagesMixin = {
  initImages() {
    this._imageRegistry = {};
    return this._imageCount = 0;
  },
  image(src, x, y3, options) {
    if (options === void 0) {
      options = {};
    }
    let bh, bp, bw, image, ip, left, left1, rotateAngle, originX, originY;
    if (typeof x === "object") {
      options = x;
      x = null;
    }
    const ignoreOrientation = options.ignoreOrientation || options.ignoreOrientation !== false && this.options.ignoreOrientation;
    x = (left = x != null ? x : options.x) != null ? left : this.x;
    y3 = (left1 = y3 != null ? y3 : options.y) != null ? left1 : this.y;
    if (typeof src === "string") {
      image = this._imageRegistry[src];
    }
    if (!image) {
      if (src.width && src.height) {
        image = src;
      } else {
        image = this.openImage(src);
      }
    }
    if (!image.obj) {
      image.embed(this);
    }
    if (this.page.xobjects[image.label] == null) {
      this.page.xobjects[image.label] = image.obj;
    }
    let {
      width,
      height: height2
    } = image;
    if (!ignoreOrientation && image.orientation > 4) {
      [width, height2] = [height2, width];
    }
    let w = options.width || width;
    let h = options.height || height2;
    if (options.width && !options.height) {
      const wp = w / width;
      w = width * wp;
      h = height2 * wp;
    } else if (options.height && !options.width) {
      const hp = h / height2;
      w = width * hp;
      h = height2 * hp;
    } else if (options.scale) {
      w = width * options.scale;
      h = height2 * options.scale;
    } else if (options.fit) {
      [bw, bh] = options.fit;
      bp = bw / bh;
      ip = width / height2;
      if (ip > bp) {
        w = bw;
        h = bw / ip;
      } else {
        h = bh;
        w = bh * ip;
      }
    } else if (options.cover) {
      [bw, bh] = options.cover;
      bp = bw / bh;
      ip = width / height2;
      if (ip > bp) {
        h = bh;
        w = bh * ip;
      } else {
        w = bw;
        h = bw / ip;
      }
    }
    if (options.fit || options.cover) {
      if (options.align === "center") {
        x = x + bw / 2 - w / 2;
      } else if (options.align === "right") {
        x = x + bw - w;
      }
      if (options.valign === "center") {
        y3 = y3 + bh / 2 - h / 2;
      } else if (options.valign === "bottom") {
        y3 = y3 + bh - h;
      }
    }
    if (!ignoreOrientation) {
      switch (image.orientation) {
        // No orientation (need to flip image, though, because of the default transform matrix on the document)
        default:
        case 1:
          h = -h;
          y3 -= h;
          rotateAngle = 0;
          break;
        // Flip Horizontal
        case 2:
          w = -w;
          h = -h;
          x -= w;
          y3 -= h;
          rotateAngle = 0;
          break;
        // Rotate 180 degrees
        case 3:
          originX = x;
          originY = y3;
          h = -h;
          x -= w;
          rotateAngle = 180;
          break;
        // Flip vertical
        case 4:
          break;
        // Flip horizontally and rotate 270 degrees CW
        case 5:
          originX = x;
          originY = y3;
          [w, h] = [h, w];
          y3 -= h;
          rotateAngle = 90;
          break;
        // Rotate 90 degrees CW
        case 6:
          originX = x;
          originY = y3;
          [w, h] = [h, w];
          h = -h;
          rotateAngle = 90;
          break;
        // Flip horizontally and rotate 90 degrees CW
        case 7:
          originX = x;
          originY = y3;
          [w, h] = [h, w];
          h = -h;
          w = -w;
          x -= w;
          rotateAngle = 90;
          break;
        // Rotate 270 degrees CW
        case 8:
          originX = x;
          originY = y3;
          [w, h] = [h, w];
          h = -h;
          x -= w;
          y3 -= h;
          rotateAngle = -90;
          break;
      }
    } else {
      h = -h;
      y3 -= h;
      rotateAngle = 0;
    }
    if (options.link != null) {
      this.link(x, y3, w, h, options.link);
    }
    if (options.goTo != null) {
      this.goTo(x, y3, w, h, options.goTo);
    }
    if (options.destination != null) {
      this.addNamedDestination(options.destination, "XYZ", x, y3, null);
    }
    if (this.y === y3) {
      this.y += h;
    }
    this.save();
    if (rotateAngle) {
      this.rotate(rotateAngle, {
        origin: [originX, originY]
      });
    }
    this.transform(w, 0, 0, h, x, y3);
    this.addContent(`/${image.label} Do`);
    this.restore();
    return this;
  },
  openImage(src) {
    let image;
    if (typeof src === "string") {
      image = this._imageRegistry[src];
    }
    if (!image) {
      image = PDFImage.open(src, `I${++this._imageCount}`);
      if (typeof src === "string") {
        this._imageRegistry[src] = image;
      }
    }
    return image;
  }
};
var AnnotationsMixin = {
  annotate(x, y3, w, h, options) {
    options.Type = "Annot";
    options.Rect = this._convertRect(x, y3, w, h);
    options.Border = [0, 0, 0];
    if (options.Subtype === "Link" && typeof options.F === "undefined") {
      options.F = 1 << 2;
    }
    if (options.Subtype !== "Link") {
      if (options.C == null) {
        options.C = this._normalizeColor(options.color || [0, 0, 0]);
      }
    }
    delete options.color;
    if (typeof options.Dest === "string") {
      options.Dest = new String(options.Dest);
    }
    for (let key in options) {
      const val = options[key];
      options[key[0].toUpperCase() + key.slice(1)] = val;
    }
    const ref2 = this.ref(options);
    this.page.annotations.push(ref2);
    ref2.end();
    return this;
  },
  note(x, y3, w, h, contents, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Text";
    options.Contents = new String(contents);
    if (options.Name == null) {
      options.Name = "Comment";
    }
    if (options.color == null) {
      options.color = [243, 223, 92];
    }
    return this.annotate(x, y3, w, h, options);
  },
  goTo(x, y3, w, h, name, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Link";
    options.A = this.ref({
      S: "GoTo",
      D: new String(name)
    });
    options.A.end();
    return this.annotate(x, y3, w, h, options);
  },
  link(x, y3, w, h, url, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Link";
    if (typeof url === "number") {
      const pages = this._root.data.Pages.data;
      if (url >= 0 && url < pages.Kids.length) {
        options.A = this.ref({
          S: "GoTo",
          D: [pages.Kids[url], "XYZ", null, null, null]
        });
        options.A.end();
      } else {
        throw new Error(`The document has no page ${url}`);
      }
    } else {
      options.A = this.ref({
        S: "URI",
        URI: new String(url)
      });
      options.A.end();
    }
    return this.annotate(x, y3, w, h, options);
  },
  _markup(x, y3, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    const [x1, y1, x2, y22] = this._convertRect(x, y3, w, h);
    options.QuadPoints = [x1, y22, x2, y22, x1, y1, x2, y1];
    options.Contents = new String();
    return this.annotate(x, y3, w, h, options);
  },
  highlight(x, y3, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Highlight";
    if (options.color == null) {
      options.color = [241, 238, 148];
    }
    return this._markup(x, y3, w, h, options);
  },
  underline(x, y3, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Underline";
    return this._markup(x, y3, w, h, options);
  },
  strike(x, y3, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "StrikeOut";
    return this._markup(x, y3, w, h, options);
  },
  lineAnnotation(x1, y1, x2, y22, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Line";
    options.Contents = new String();
    options.L = [x1, this.page.height - y1, x2, this.page.height - y22];
    return this.annotate(x1, y1, x2, y22, options);
  },
  rectAnnotation(x, y3, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Square";
    options.Contents = new String();
    return this.annotate(x, y3, w, h, options);
  },
  ellipseAnnotation(x, y3, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Circle";
    options.Contents = new String();
    return this.annotate(x, y3, w, h, options);
  },
  textAnnotation(x, y3, w, h, text, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "FreeText";
    options.Contents = new String(text);
    options.DA = new String();
    return this.annotate(x, y3, w, h, options);
  },
  fileAnnotation(x, y3, w, h, file, options) {
    if (file === void 0) {
      file = {};
    }
    if (options === void 0) {
      options = {};
    }
    const filespec = this.file(file.src, Object.assign({
      hidden: true
    }, file));
    options.Subtype = "FileAttachment";
    options.FS = filespec;
    if (options.Contents) {
      options.Contents = new String(options.Contents);
    } else if (filespec.data.Desc) {
      options.Contents = filespec.data.Desc;
    }
    return this.annotate(x, y3, w, h, options);
  },
  _convertRect(x1, y1, w, h) {
    let y22 = y1;
    y1 += h;
    let x2 = x1 + w;
    const [m0, m1, m22, m3, m4, m5] = this._ctm;
    x1 = m0 * x1 + m22 * y1 + m4;
    y1 = m1 * x1 + m3 * y1 + m5;
    x2 = m0 * x2 + m22 * y22 + m4;
    y22 = m1 * x2 + m3 * y22 + m5;
    return [x1, y1, x2, y22];
  }
};
var DEFAULT_OPTIONS = {
  top: 0,
  left: 0,
  zoom: 0,
  fit: false,
  pageNumber: null,
  expanded: false
};
var PDFOutline = class _PDFOutline {
  static {
    __name(this, "PDFOutline");
  }
  constructor(document2, parent, title4, dest, options) {
    if (options === void 0) {
      options = DEFAULT_OPTIONS;
    }
    this.document = document2;
    this.options = options;
    this.outlineData = {};
    if (dest !== null) {
      const destWidth = dest.data.MediaBox[2];
      const destHeight = dest.data.MediaBox[3];
      const top = destHeight - (options.top || 0);
      const left = destWidth - (options.left || 0);
      const zoom = options.zoom || 0;
      this.outlineData["Dest"] = options.fit ? [dest, "Fit"] : [dest, "XYZ", left, top, zoom];
    }
    if (parent !== null) {
      this.outlineData["Parent"] = parent;
    }
    if (title4 !== null) {
      this.outlineData["Title"] = new String(title4);
    }
    this.dictionary = this.document.ref(this.outlineData);
    this.children = [];
  }
  addItem(title4, options) {
    if (options === void 0) {
      options = DEFAULT_OPTIONS;
    }
    const pages = this.document._root.data.Pages.data.Kids;
    const dest = options.pageNumber !== null ? pages[options.pageNumber] : this.document.page.dictionary;
    const result = new _PDFOutline(this.document, this.dictionary, title4, dest, options);
    this.children.push(result);
    return result;
  }
  endOutline() {
    if (this.children.length > 0) {
      if (this.options.expanded) {
        this.outlineData.Count = this.children.length;
      }
      const first = this.children[0], last2 = this.children[this.children.length - 1];
      this.outlineData.First = first.dictionary;
      this.outlineData.Last = last2.dictionary;
      for (let i2 = 0, len = this.children.length; i2 < len; i2++) {
        const child = this.children[i2];
        if (i2 > 0) {
          child.outlineData.Prev = this.children[i2 - 1].dictionary;
        }
        if (i2 < this.children.length - 1) {
          child.outlineData.Next = this.children[i2 + 1].dictionary;
        }
        child.endOutline();
      }
    }
    return this.dictionary.end();
  }
};
var OutlineMixin = {
  initOutline() {
    return this.outline = new PDFOutline(this, null, null, null);
  },
  endOutline() {
    this.outline.endOutline();
    if (this.outline.children.length > 0) {
      this._root.data.Outlines = this.outline.dictionary;
      return this._root.data.PageMode = this._root.data.PageMode || "UseOutlines";
    }
  }
};
var PDFStructureContent = class {
  static {
    __name(this, "PDFStructureContent");
  }
  constructor(pageRef, mcid) {
    this.refs = [{
      pageRef,
      mcid
    }];
  }
  push(structContent) {
    structContent.refs.forEach((ref2) => this.refs.push(ref2));
  }
};
var PDFStructureElement = class _PDFStructureElement {
  static {
    __name(this, "PDFStructureElement");
  }
  constructor(document2, type2, options, children) {
    if (options === void 0) {
      options = {};
    }
    if (children === void 0) {
      children = null;
    }
    this.document = document2;
    this._attached = false;
    this._ended = false;
    this._flushed = false;
    this.dictionary = document2.ref({
      // Type: "StructElem",
      S: type2
    });
    const data2 = this.dictionary.data;
    if (Array.isArray(options) || this._isValidChild(options)) {
      children = options;
      options = {};
    }
    if (typeof options.title !== "undefined") {
      data2.T = new String(options.title);
    }
    if (typeof options.lang !== "undefined") {
      data2.Lang = new String(options.lang);
    }
    if (typeof options.alt !== "undefined") {
      data2.Alt = new String(options.alt);
    }
    if (typeof options.expanded !== "undefined") {
      data2.E = new String(options.expanded);
    }
    if (typeof options.actual !== "undefined") {
      data2.ActualText = new String(options.actual);
    }
    this._children = [];
    if (children) {
      if (!Array.isArray(children)) {
        children = [children];
      }
      children.forEach((child) => this.add(child));
      this.end();
    }
  }
  add(child) {
    if (this._ended) {
      throw new Error(`Cannot add child to already-ended structure element`);
    }
    if (!this._isValidChild(child)) {
      throw new Error(`Invalid structure element child`);
    }
    if (child instanceof _PDFStructureElement) {
      child.setParent(this.dictionary);
      if (this._attached) {
        child.setAttached();
      }
    }
    if (child instanceof PDFStructureContent) {
      this._addContentToParentTree(child);
    }
    if (typeof child === "function" && this._attached) {
      child = this._contentForClosure(child);
    }
    this._children.push(child);
    return this;
  }
  _addContentToParentTree(content) {
    content.refs.forEach((_ref) => {
      let {
        pageRef,
        mcid
      } = _ref;
      const pageStructParents = this.document.getStructParentTree().get(pageRef.data.StructParents);
      pageStructParents[mcid] = this.dictionary;
    });
  }
  setParent(parentRef) {
    if (this.dictionary.data.P) {
      throw new Error(`Structure element added to more than one parent`);
    }
    this.dictionary.data.P = parentRef;
    this._flush();
  }
  setAttached() {
    if (this._attached) {
      return;
    }
    this._children.forEach((child, index2) => {
      if (child instanceof _PDFStructureElement) {
        child.setAttached();
      }
      if (typeof child === "function") {
        this._children[index2] = this._contentForClosure(child);
      }
    });
    this._attached = true;
    this._flush();
  }
  end() {
    if (this._ended) {
      return;
    }
    this._children.filter((child) => child instanceof _PDFStructureElement).forEach((child) => child.end());
    this._ended = true;
    this._flush();
  }
  _isValidChild(child) {
    return child instanceof _PDFStructureElement || child instanceof PDFStructureContent || typeof child === "function";
  }
  _contentForClosure(closure) {
    const content = this.document.markStructureContent(this.dictionary.data.S);
    closure();
    this.document.endMarkedContent();
    this._addContentToParentTree(content);
    return content;
  }
  _isFlushable() {
    if (!this.dictionary.data.P || !this._ended) {
      return false;
    }
    return this._children.every((child) => {
      if (typeof child === "function") {
        return false;
      }
      if (child instanceof _PDFStructureElement) {
        return child._isFlushable();
      }
      return true;
    });
  }
  _flush() {
    if (this._flushed || !this._isFlushable()) {
      return;
    }
    this.dictionary.data.K = [];
    this._children.forEach((child) => this._flushChild(child));
    this.dictionary.end();
    this._children = [];
    this.dictionary.data.K = null;
    this._flushed = true;
  }
  _flushChild(child) {
    if (child instanceof _PDFStructureElement) {
      this.dictionary.data.K.push(child.dictionary);
    }
    if (child instanceof PDFStructureContent) {
      child.refs.forEach((_ref2) => {
        let {
          pageRef,
          mcid
        } = _ref2;
        if (!this.dictionary.data.Pg) {
          this.dictionary.data.Pg = pageRef;
        }
        if (this.dictionary.data.Pg === pageRef) {
          this.dictionary.data.K.push(mcid);
        } else {
          this.dictionary.data.K.push({
            Type: "MCR",
            Pg: pageRef,
            MCID: mcid
          });
        }
      });
    }
  }
};
var PDFNumberTree = class extends PDFTree {
  static {
    __name(this, "PDFNumberTree");
  }
  _compareKeys(a4, b3) {
    return parseInt(a4) - parseInt(b3);
  }
  _keysName() {
    return "Nums";
  }
  _dataForKey(k3) {
    return parseInt(k3);
  }
};
var MarkingsMixin = {
  initMarkings(options) {
    this.structChildren = [];
    if (options.tagged) {
      this.getMarkInfoDictionary().data.Marked = true;
      this.getStructTreeRoot();
    }
  },
  markContent(tag, options) {
    if (options === void 0) {
      options = null;
    }
    if (tag === "Artifact" || options && options.mcid) {
      let toClose = 0;
      this.page.markings.forEach((marking) => {
        if (toClose || marking.structContent || marking.tag === "Artifact") {
          toClose++;
        }
      });
      while (toClose--) {
        this.endMarkedContent();
      }
    }
    if (!options) {
      this.page.markings.push({
        tag
      });
      this.addContent(`/${tag} BMC`);
      return this;
    }
    this.page.markings.push({
      tag,
      options
    });
    const dictionary = {};
    if (typeof options.mcid !== "undefined") {
      dictionary.MCID = options.mcid;
    }
    if (tag === "Artifact") {
      if (typeof options.type === "string") {
        dictionary.Type = options.type;
      }
      if (Array.isArray(options.bbox)) {
        dictionary.BBox = [options.bbox[0], this.page.height - options.bbox[3], options.bbox[2], this.page.height - options.bbox[1]];
      }
      if (Array.isArray(options.attached) && options.attached.every((val) => typeof val === "string")) {
        dictionary.Attached = options.attached;
      }
    }
    if (tag === "Span") {
      if (options.lang) {
        dictionary.Lang = new String(options.lang);
      }
      if (options.alt) {
        dictionary.Alt = new String(options.alt);
      }
      if (options.expanded) {
        dictionary.E = new String(options.expanded);
      }
      if (options.actual) {
        dictionary.ActualText = new String(options.actual);
      }
    }
    this.addContent(`/${tag} ${PDFObject.convert(dictionary)} BDC`);
    return this;
  },
  markStructureContent(tag, options) {
    if (options === void 0) {
      options = {};
    }
    const pageStructParents = this.getStructParentTree().get(this.page.structParentTreeKey);
    const mcid = pageStructParents.length;
    pageStructParents.push(null);
    this.markContent(tag, {
      ...options,
      mcid
    });
    const structContent = new PDFStructureContent(this.page.dictionary, mcid);
    this.page.markings.slice(-1)[0].structContent = structContent;
    return structContent;
  },
  endMarkedContent() {
    this.page.markings.pop();
    this.addContent("EMC");
    return this;
  },
  struct(type2, options, children) {
    if (options === void 0) {
      options = {};
    }
    if (children === void 0) {
      children = null;
    }
    return new PDFStructureElement(this, type2, options, children);
  },
  addStructure(structElem) {
    const structTreeRoot = this.getStructTreeRoot();
    structElem.setParent(structTreeRoot);
    structElem.setAttached();
    this.structChildren.push(structElem);
    if (!structTreeRoot.data.K) {
      structTreeRoot.data.K = [];
    }
    structTreeRoot.data.K.push(structElem.dictionary);
    return this;
  },
  initPageMarkings(pageMarkings) {
    pageMarkings.forEach((marking) => {
      if (marking.structContent) {
        const structContent = marking.structContent;
        const newStructContent = this.markStructureContent(marking.tag, marking.options);
        structContent.push(newStructContent);
        this.page.markings.slice(-1)[0].structContent = structContent;
      } else {
        this.markContent(marking.tag, marking.options);
      }
    });
  },
  endPageMarkings(page) {
    const pageMarkings = page.markings;
    pageMarkings.forEach(() => page.write("EMC"));
    page.markings = [];
    return pageMarkings;
  },
  getMarkInfoDictionary() {
    if (!this._root.data.MarkInfo) {
      this._root.data.MarkInfo = this.ref({});
    }
    return this._root.data.MarkInfo;
  },
  hasMarkInfoDictionary() {
    return !!this._root.data.MarkInfo;
  },
  getStructTreeRoot() {
    if (!this._root.data.StructTreeRoot) {
      this._root.data.StructTreeRoot = this.ref({
        Type: "StructTreeRoot",
        ParentTree: new PDFNumberTree(),
        ParentTreeNextKey: 0
      });
    }
    return this._root.data.StructTreeRoot;
  },
  getStructParentTree() {
    return this.getStructTreeRoot().data.ParentTree;
  },
  createStructParentTreeNextKey() {
    this.getMarkInfoDictionary();
    const structTreeRoot = this.getStructTreeRoot();
    const key = structTreeRoot.data.ParentTreeNextKey++;
    structTreeRoot.data.ParentTree.add(key, []);
    return key;
  },
  endMarkings() {
    const structTreeRoot = this._root.data.StructTreeRoot;
    if (structTreeRoot) {
      structTreeRoot.end();
      this.structChildren.forEach((structElem) => structElem.end());
    }
    if (this._root.data.MarkInfo) {
      this._root.data.MarkInfo.end();
    }
  }
};
var FIELD_FLAGS = {
  readOnly: 1,
  required: 2,
  noExport: 4,
  multiline: 4096,
  password: 8192,
  toggleToOffButton: 16384,
  radioButton: 32768,
  pushButton: 65536,
  combo: 131072,
  edit: 262144,
  sort: 524288,
  multiSelect: 2097152,
  noSpell: 4194304
};
var FIELD_JUSTIFY = {
  left: 0,
  center: 1,
  right: 2
};
var VALUE_MAP = {
  value: "V",
  defaultValue: "DV"
};
var FORMAT_SPECIAL = {
  zip: "0",
  zipPlus4: "1",
  zip4: "1",
  phone: "2",
  ssn: "3"
};
var FORMAT_DEFAULT = {
  number: {
    nDec: 0,
    sepComma: false,
    negStyle: "MinusBlack",
    currency: "",
    currencyPrepend: true
  },
  percent: {
    nDec: 0,
    sepComma: false
  }
};
var AcroFormMixin = {
  /**
   * Must call if adding AcroForms to a document. Must also call font() before
   * this method to set the default font.
   */
  initForm() {
    if (!this._font) {
      throw new Error("Must set a font before calling initForm method");
    }
    this._acroform = {
      fonts: {},
      defaultFont: this._font.name
    };
    this._acroform.fonts[this._font.id] = this._font.ref();
    let data2 = {
      Fields: [],
      NeedAppearances: true,
      DA: new String(`/${this._font.id} 0 Tf 0 g`),
      DR: {
        Font: {}
      }
    };
    data2.DR.Font[this._font.id] = this._font.ref();
    const AcroForm = this.ref(data2);
    this._root.data.AcroForm = AcroForm;
    return this;
  },
  /**
   * Called automatically by document.js
   */
  endAcroForm() {
    if (this._root.data.AcroForm) {
      if (!Object.keys(this._acroform.fonts).length && !this._acroform.defaultFont) {
        throw new Error("No fonts specified for PDF form");
      }
      let fontDict = this._root.data.AcroForm.data.DR.Font;
      Object.keys(this._acroform.fonts).forEach((name) => {
        fontDict[name] = this._acroform.fonts[name];
      });
      this._root.data.AcroForm.data.Fields.forEach((fieldRef) => {
        this._endChild(fieldRef);
      });
      this._root.data.AcroForm.end();
    }
    return this;
  },
  _endChild(ref2) {
    if (Array.isArray(ref2.data.Kids)) {
      ref2.data.Kids.forEach((childRef) => {
        this._endChild(childRef);
      });
      ref2.end();
    }
    return this;
  },
  /**
   * Creates and adds a form field to the document. Form fields are intermediate
   * nodes in a PDF form that are used to specify form name heirarchy and form
   * value defaults.
   * @param {string} name - field name (T attribute in field dictionary)
   * @param {object} options  - other attributes to include in field dictionary
   */
  formField(name, options) {
    if (options === void 0) {
      options = {};
    }
    let fieldDict = this._fieldDict(name, null, options);
    let fieldRef = this.ref(fieldDict);
    this._addToParent(fieldRef);
    return fieldRef;
  },
  /**
   * Creates and adds a Form Annotation to the document. Form annotations are
   * called Widget annotations internally within a PDF file.
   * @param {string} name - form field name (T attribute of widget annotation
   * dictionary)
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @param {object} options
   */
  formAnnotation(name, type2, x, y3, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    let fieldDict = this._fieldDict(name, type2, options);
    fieldDict.Subtype = "Widget";
    if (fieldDict.F === void 0) {
      fieldDict.F = 4;
    }
    this.annotate(x, y3, w, h, fieldDict);
    let annotRef = this.page.annotations[this.page.annotations.length - 1];
    return this._addToParent(annotRef);
  },
  formText(name, x, y3, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "text", x, y3, w, h, options);
  },
  formPushButton(name, x, y3, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "pushButton", x, y3, w, h, options);
  },
  formCombo(name, x, y3, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "combo", x, y3, w, h, options);
  },
  formList(name, x, y3, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "list", x, y3, w, h, options);
  },
  formRadioButton(name, x, y3, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "radioButton", x, y3, w, h, options);
  },
  formCheckbox(name, x, y3, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "checkbox", x, y3, w, h, options);
  },
  _addToParent(fieldRef) {
    let parent = fieldRef.data.Parent;
    if (parent) {
      if (!parent.data.Kids) {
        parent.data.Kids = [];
      }
      parent.data.Kids.push(fieldRef);
    } else {
      this._root.data.AcroForm.data.Fields.push(fieldRef);
    }
    return this;
  },
  _fieldDict(name, type2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!this._acroform) {
      throw new Error("Call document.initForm() method before adding form elements to document");
    }
    let opts2 = Object.assign({}, options);
    if (type2 !== null) {
      opts2 = this._resolveType(type2, options);
    }
    opts2 = this._resolveFlags(opts2);
    opts2 = this._resolveJustify(opts2);
    opts2 = this._resolveFont(opts2);
    opts2 = this._resolveStrings(opts2);
    opts2 = this._resolveColors(opts2);
    opts2 = this._resolveFormat(opts2);
    opts2.T = new String(name);
    if (opts2.parent) {
      opts2.Parent = opts2.parent;
      delete opts2.parent;
    }
    return opts2;
  },
  _resolveType(type2, opts2) {
    if (type2 === "text") {
      opts2.FT = "Tx";
    } else if (type2 === "pushButton") {
      opts2.FT = "Btn";
      opts2.pushButton = true;
    } else if (type2 === "radioButton") {
      opts2.FT = "Btn";
      opts2.radioButton = true;
    } else if (type2 === "checkbox") {
      opts2.FT = "Btn";
    } else if (type2 === "combo") {
      opts2.FT = "Ch";
      opts2.combo = true;
    } else if (type2 === "list") {
      opts2.FT = "Ch";
    } else {
      throw new Error(`Invalid form annotation type '${type2}'`);
    }
    return opts2;
  },
  _resolveFormat(opts2) {
    const f4 = opts2.format;
    if (f4 && f4.type) {
      let fnKeystroke;
      let fnFormat;
      let params = "";
      if (FORMAT_SPECIAL[f4.type] !== void 0) {
        fnKeystroke = `AFSpecial_Keystroke`;
        fnFormat = `AFSpecial_Format`;
        params = FORMAT_SPECIAL[f4.type];
      } else {
        let format3 = f4.type.charAt(0).toUpperCase() + f4.type.slice(1);
        fnKeystroke = `AF${format3}_Keystroke`;
        fnFormat = `AF${format3}_Format`;
        if (f4.type === "date") {
          fnKeystroke += "Ex";
          params = String(f4.param);
        } else if (f4.type === "time") {
          params = String(f4.param);
        } else if (f4.type === "number") {
          let p3 = Object.assign({}, FORMAT_DEFAULT.number, f4);
          params = String([String(p3.nDec), p3.sepComma ? "0" : "1", '"' + p3.negStyle + '"', "null", '"' + p3.currency + '"', String(p3.currencyPrepend)].join(","));
        } else if (f4.type === "percent") {
          let p3 = Object.assign({}, FORMAT_DEFAULT.percent, f4);
          params = String([String(p3.nDec), p3.sepComma ? "0" : "1"].join(","));
        }
      }
      opts2.AA = opts2.AA ? opts2.AA : {};
      opts2.AA.K = {
        S: "JavaScript",
        JS: new String(`${fnKeystroke}(${params});`)
      };
      opts2.AA.F = {
        S: "JavaScript",
        JS: new String(`${fnFormat}(${params});`)
      };
    }
    delete opts2.format;
    return opts2;
  },
  _resolveColors(opts2) {
    let color = this._normalizeColor(opts2.backgroundColor);
    if (color) {
      if (!opts2.MK) {
        opts2.MK = {};
      }
      opts2.MK.BG = color;
    }
    color = this._normalizeColor(opts2.borderColor);
    if (color) {
      if (!opts2.MK) {
        opts2.MK = {};
      }
      opts2.MK.BC = color;
    }
    delete opts2.backgroundColor;
    delete opts2.borderColor;
    return opts2;
  },
  _resolveFlags(options) {
    let result = 0;
    Object.keys(options).forEach((key) => {
      if (FIELD_FLAGS[key]) {
        if (options[key]) {
          result |= FIELD_FLAGS[key];
        }
        delete options[key];
      }
    });
    if (result !== 0) {
      options.Ff = options.Ff ? options.Ff : 0;
      options.Ff |= result;
    }
    return options;
  },
  _resolveJustify(options) {
    let result = 0;
    if (options.align !== void 0) {
      if (typeof FIELD_JUSTIFY[options.align] === "number") {
        result = FIELD_JUSTIFY[options.align];
      }
      delete options.align;
    }
    if (result !== 0) {
      options.Q = result;
    }
    return options;
  },
  _resolveFont(options) {
    if (this._acroform.fonts[this._font.id] == null) {
      this._acroform.fonts[this._font.id] = this._font.ref();
    }
    if (this._acroform.defaultFont !== this._font.name) {
      options.DR = {
        Font: {}
      };
      const fontSize = options.fontSize || 0;
      options.DR.Font[this._font.id] = this._font.ref();
      options.DA = new String(`/${this._font.id} ${fontSize} Tf 0 g`);
    }
    return options;
  },
  _resolveStrings(options) {
    let select = [];
    function appendChoices(a4) {
      if (Array.isArray(a4)) {
        for (let idx = 0; idx < a4.length; idx++) {
          if (typeof a4[idx] === "string") {
            select.push(new String(a4[idx]));
          } else {
            select.push(a4[idx]);
          }
        }
      }
    }
    __name(appendChoices, "appendChoices");
    appendChoices(options.Opt);
    if (options.select) {
      appendChoices(options.select);
      delete options.select;
    }
    if (select.length) {
      options.Opt = select;
    }
    Object.keys(VALUE_MAP).forEach((key) => {
      if (options[key] !== void 0) {
        options[VALUE_MAP[key]] = options[key];
        delete options[key];
      }
    });
    ["V", "DV"].forEach((key) => {
      if (typeof options[key] === "string") {
        options[key] = new String(options[key]);
      }
    });
    if (options.MK && options.MK.CA) {
      options.MK.CA = new String(options.MK.CA);
    }
    if (options.label) {
      options.MK = options.MK ? options.MK : {};
      options.MK.CA = new String(options.label);
      delete options.label;
    }
    return options;
  }
};
var AttachmentsMixin = {
  /**
   * Embed contents of `src` in PDF
   * @param {Buffer | ArrayBuffer | string} src input Buffer, ArrayBuffer, base64 encoded string or path to file
   * @param {object} options
   *  * options.name: filename to be shown in PDF, will use `src` if none set
   *  * options.type: filetype to be shown in PDF
   *  * options.description: description to be shown in PDF
   *  * options.hidden: if true, do not add attachment to EmbeddedFiles dictionary. Useful for file attachment annotations
   *  * options.creationDate: override creation date
   *  * options.modifiedDate: override modified date
   *  * options.relationship: Relationship between the PDF document and its attached file. Can be 'Alternative', 'Data', 'Source', 'Supplement' or 'Unspecified'.
   * @returns filespec reference
   */
  file(src, options) {
    if (options === void 0) {
      options = {};
    }
    options.name = options.name || src;
    options.relationship = options.relationship || "Unspecified";
    const refBody = {
      Type: "EmbeddedFile",
      Params: {}
    };
    let data2;
    if (!src) {
      throw new Error("No src specified");
    }
    if (Buffer$2.isBuffer(src)) {
      data2 = src;
    } else if (src instanceof ArrayBuffer) {
      data2 = Buffer$2.from(new Uint8Array(src));
    } else {
      let match2;
      if (match2 = /^data:(.*?);base64,(.*)$/.exec(src)) {
        if (match2[1]) {
          refBody.Subtype = match2[1].replace("/", "#2F");
        }
        data2 = Buffer$2.from(match2[2], "base64");
      } else {
        data2 = fs.readFileSync(src);
        if (!data2) {
          throw new Error(`Could not read contents of file at filepath ${src}`);
        }
        const {
          birthtime,
          ctime
        } = fs.statSync(src);
        refBody.Params.CreationDate = birthtime;
        refBody.Params.ModDate = ctime;
      }
    }
    if (options.creationDate instanceof Date) {
      refBody.Params.CreationDate = options.creationDate;
    }
    if (options.modifiedDate instanceof Date) {
      refBody.Params.ModDate = options.modifiedDate;
    }
    if (options.type) {
      refBody.Subtype = options.type.replace("/", "#2F");
    }
    const checksum = import_crypto_js.default.MD5(import_crypto_js.default.lib.WordArray.create(new Uint8Array(data2)));
    refBody.Params.CheckSum = new String(checksum);
    refBody.Params.Size = data2.byteLength;
    let ref2;
    if (!this._fileRegistry) this._fileRegistry = {};
    let file = this._fileRegistry[options.name];
    if (file && isEqual(refBody, file)) {
      ref2 = file.ref;
    } else {
      ref2 = this.ref(refBody);
      ref2.end(data2);
      this._fileRegistry[options.name] = {
        ...refBody,
        ref: ref2
      };
    }
    const fileSpecBody = {
      Type: "Filespec",
      AFRelationship: options.relationship,
      F: new String(options.name),
      EF: {
        F: ref2
      },
      UF: new String(options.name)
    };
    if (options.description) {
      fileSpecBody.Desc = new String(options.description);
    }
    const filespec = this.ref(fileSpecBody);
    filespec.end();
    if (!options.hidden) {
      this.addNamedEmbeddedFile(options.name, filespec);
    }
    if (this._root.data.AF) {
      this._root.data.AF.push(filespec);
    } else {
      this._root.data.AF = [filespec];
    }
    return filespec;
  }
};
function isEqual(a4, b3) {
  return a4.Subtype === b3.Subtype && a4.Params.CheckSum.toString() === b3.Params.CheckSum.toString() && a4.Params.Size === b3.Params.Size && a4.Params.CreationDate.getTime() === b3.Params.CreationDate.getTime() && (a4.Params.ModDate === void 0 && b3.Params.ModDate === void 0 || a4.Params.ModDate.getTime() === b3.Params.ModDate.getTime());
}
__name(isEqual, "isEqual");
var __dirname = "/home/runner/work/react-pdf/react-pdf/packages/pdfkit/src/mixins";
var PDFA = {
  initPDFA(pSubset) {
    if (pSubset.charAt(pSubset.length - 3) === "-") {
      this.subset_conformance = pSubset.charAt(pSubset.length - 1).toUpperCase();
      this.subset = parseInt(pSubset.charAt(pSubset.length - 2));
    } else {
      this.subset_conformance = "B";
      this.subset = parseInt(pSubset.charAt(pSubset.length - 1));
    }
  },
  endSubset() {
    this._addPdfaMetadata();
    this._addColorOutputIntent();
  },
  _addColorOutputIntent() {
    const iccProfile = fs.readFileSync(`${__dirname}/data/sRGB_IEC61966_2_1.icc`);
    const colorProfileRef = this.ref({
      Length: iccProfile.length,
      N: 3
    });
    colorProfileRef.write(iccProfile);
    colorProfileRef.end();
    const intentRef = this.ref({
      Type: "OutputIntent",
      S: "GTS_PDFA1",
      Info: new String("sRGB IEC61966-2.1"),
      OutputConditionIdentifier: new String("sRGB IEC61966-2.1"),
      DestOutputProfile: colorProfileRef
    });
    intentRef.end();
    this._root.data.OutputIntents = [intentRef];
  },
  _getPdfaid() {
    return `
        <rdf:Description xmlns:pdfaid="http://www.aiim.org/pdfa/ns/id/" rdf:about="">
            <pdfaid:part>${this.subset}</pdfaid:part>
            <pdfaid:conformance>${this.subset_conformance}</pdfaid:conformance>
        </rdf:Description>
        `;
  },
  _addPdfaMetadata() {
    this.appendXML(this._getPdfaid());
  }
};
var PDFUA = {
  initPDFUA() {
    this.subset = 1;
  },
  endSubset() {
    this._addPdfuaMetadata();
  },
  _addPdfuaMetadata() {
    this.appendXML(this._getPdfuaid());
  },
  _getPdfuaid() {
    return `
        <rdf:Description xmlns:pdfuaid="http://www.aiim.org/pdfua/ns/id/" rdf:about="">
            <pdfuaid:part>${this.subset}</pdfuaid:part>
        </rdf:Description>
        `;
  }
};
var SubsetMixin = {
  _importSubset(subset) {
    Object.assign(this, subset);
  },
  initSubset(options) {
    switch (options.subset) {
      case "PDF/A-1":
      case "PDF/A-1a":
      case "PDF/A-1b":
      case "PDF/A-2":
      case "PDF/A-2a":
      case "PDF/A-2b":
      case "PDF/A-3":
      case "PDF/A-3a":
      case "PDF/A-3b":
        this._importSubset(PDFA);
        this.initPDFA(options.subset);
        break;
      case "PDF/UA":
        this._importSubset(PDFUA);
        this.initPDFUA();
        break;
    }
  }
};
var PDFMetadata = class {
  static {
    __name(this, "PDFMetadata");
  }
  constructor() {
    this._metadata = `
        <?xpacket begin="\uFEFF" id="W5M0MpCehiHzreSzNTczkc9d"?>
            <x:xmpmeta xmlns:x="adobe:ns:meta/">
                <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
        `;
  }
  _closeTags() {
    this._metadata = this._metadata.concat(`
                </rdf:RDF>
            </x:xmpmeta>
        <?xpacket end="w"?>
        `);
  }
  append(xml, newline) {
    if (newline === void 0) {
      newline = true;
    }
    this._metadata = this._metadata.concat(xml);
    if (newline) this._metadata = this._metadata.concat("\n");
  }
  getXML() {
    return this._metadata;
  }
  getLength() {
    return this._metadata.length;
  }
  end() {
    this._closeTags();
    this._metadata = this._metadata.trim();
  }
};
var MetadataMixin = {
  initMetadata() {
    this.metadata = new PDFMetadata();
  },
  appendXML(xml, newline) {
    if (newline === void 0) {
      newline = true;
    }
    this.metadata.append(xml, newline);
  },
  _addInfo() {
    this.appendXML(`
        <rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/">
            <xmp:CreateDate>${this.info.CreationDate.toISOString().split(".")[0] + "Z"}</xmp:CreateDate>
            <xmp:CreatorTool>${this.info.Creator}</xmp:CreatorTool>
        </rdf:Description>
        `);
    if (this.info.Title || this.info.Author || this.info.Subject) {
      this.appendXML(`
            <rdf:Description rdf:about="" xmlns:dc="http://purl.org/dc/elements/1.1/">
            `);
      if (this.info.Title) {
        this.appendXML(`
                <dc:title>
                    <rdf:Alt>
                        <rdf:li xml:lang="x-default">${this.info.Title}</rdf:li>
                    </rdf:Alt>
                </dc:title>
                `);
      }
      if (this.info.Author) {
        this.appendXML(`
                <dc:creator>
                    <rdf:Seq>
                        <rdf:li>${this.info.Author}</rdf:li>
                    </rdf:Seq>
                </dc:creator>
                `);
      }
      if (this.info.Subject) {
        this.appendXML(`
                <dc:description>
                    <rdf:Alt>
                        <rdf:li xml:lang="x-default">${this.info.Subject}</rdf:li>
                    </rdf:Alt>
                </dc:description>
                `);
      }
      this.appendXML(`
            </rdf:Description>
            `);
    }
    this.appendXML(`
        <rdf:Description rdf:about="" xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
            <pdf:Producer>${this.info.Creator}</pdf:Producer>`, false);
    if (this.info.Keywords) {
      this.appendXML(`
            <pdf:Keywords>${this.info.Keywords}</pdf:Keywords>`, false);
    }
    this.appendXML(`
        </rdf:Description>
        `);
  },
  endMetadata() {
    this._addInfo();
    this.metadata.end();
    if (this.version != 1.3) {
      this.metadataRef = this.ref({
        length: this.metadata.getLength(),
        Type: "Metadata",
        Subtype: "XML"
      });
      this.metadataRef.compress = false;
      this.metadataRef.write(Buffer$2.from(this.metadata.getXML(), "utf-8"));
      this.metadataRef.end();
      this._root.data.Metadata = this.metadataRef;
    }
  }
};
var PDFDocument = class extends stream.Readable {
  static {
    __name(this, "PDFDocument");
  }
  constructor(options) {
    if (options === void 0) {
      options = {};
    }
    super(options);
    this.options = options;
    switch (options.pdfVersion) {
      case "1.4":
        this.version = 1.4;
        break;
      case "1.5":
        this.version = 1.5;
        break;
      case "1.6":
        this.version = 1.6;
        break;
      case "1.7":
      case "1.7ext3":
        this.version = 1.7;
        break;
      default:
        this.version = 1.3;
        break;
    }
    this.compress = this.options.compress != null ? this.options.compress : true;
    this._pageBuffer = [];
    this._pageBufferStart = 0;
    this._offsets = [];
    this._waiting = 0;
    this._ended = false;
    this._offset = 0;
    const Pages = this.ref({
      Type: "Pages",
      Count: 0,
      Kids: []
    });
    const Names = this.ref({
      Dests: new PDFNameTree()
    });
    this._root = this.ref({
      Type: "Catalog",
      Pages,
      Names
    });
    if (this.options.lang) {
      this._root.data.Lang = new String(this.options.lang);
    }
    this.page = null;
    this.initMetadata();
    this.initColor();
    this.initVector();
    this.initFonts(options.font);
    this.initText();
    this.initImages();
    this.initOutline();
    this.initMarkings(options);
    this.initSubset(options);
    this.info = {
      Producer: "PDFKit",
      Creator: "PDFKit",
      CreationDate: /* @__PURE__ */ new Date()
    };
    if (this.options.info) {
      for (let key in this.options.info) {
        const val = this.options.info[key];
        this.info[key] = val;
      }
    }
    if (this.options.displayTitle) {
      this._root.data.ViewerPreferences = this.ref({
        DisplayDocTitle: true
      });
    }
    this._id = PDFSecurity.generateFileID(this.info);
    this._write(`%PDF-${this.version}`);
    this._write("%\xFF\xFF\xFF\xFF");
    if (this.options.autoFirstPage !== false) {
      this.addPage();
    }
  }
  addPage(options) {
    if (options == null) {
      ({
        options
      } = this);
    }
    if (!this.options.bufferPages) {
      this.flushPages();
    }
    this.page = new PDFPage(this, options);
    this._pageBuffer.push(this.page);
    const pages = this._root.data.Pages.data;
    pages.Kids.push(this.page.dictionary);
    pages.Count++;
    this.x = this.page.margins.left;
    this.y = this.page.margins.top;
    this._ctm = [1, 0, 0, 1, 0, 0];
    this.transform(1, 0, 0, -1, 0, this.page.height);
    this.emit("pageAdded");
    return this;
  }
  continueOnNewPage(options) {
    const pageMarkings = this.endPageMarkings(this.page);
    this.addPage(options !== null && options !== void 0 ? options : this.page._options);
    this.initPageMarkings(pageMarkings);
    return this;
  }
  bufferedPageRange() {
    return {
      start: this._pageBufferStart,
      count: this._pageBuffer.length
    };
  }
  switchToPage(n5) {
    let page;
    if (!(page = this._pageBuffer[n5 - this._pageBufferStart])) {
      throw new Error(`switchToPage(${n5}) out of bounds, current buffer covers pages ${this._pageBufferStart} to ${this._pageBufferStart + this._pageBuffer.length - 1}`);
    }
    return this.page = page;
  }
  flushPages() {
    const pages = this._pageBuffer;
    this._pageBuffer = [];
    this._pageBufferStart += pages.length;
    for (let page of pages) {
      this.endPageMarkings(page);
      page.end();
    }
  }
  addNamedDestination(name) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (args.length === 0) {
      args = ["XYZ", null, null, null];
    }
    if (args[0] === "XYZ" && args[2] !== null) {
      args[2] = this.page.height - args[2];
    }
    args.unshift(this.page.dictionary);
    this._root.data.Names.data.Dests.add(name, args);
  }
  addNamedEmbeddedFile(name, ref2) {
    if (!this._root.data.Names.data.EmbeddedFiles) {
      this._root.data.Names.data.EmbeddedFiles = new PDFNameTree({
        limits: false
      });
    }
    this._root.data.Names.data.EmbeddedFiles.add(name, ref2);
  }
  addNamedJavaScript(name, js) {
    if (!this._root.data.Names.data.JavaScript) {
      this._root.data.Names.data.JavaScript = new PDFNameTree();
    }
    let data2 = {
      JS: new String(js),
      S: "JavaScript"
    };
    this._root.data.Names.data.JavaScript.add(name, data2);
  }
  ref(data2) {
    const ref2 = new PDFReference(this, this._offsets.length + 1, data2);
    this._offsets.push(null);
    this._waiting++;
    return ref2;
  }
  _read() {
  }
  // do nothing, but this method is required by node
  _write(data2) {
    if (!Buffer$2.isBuffer(data2)) {
      data2 = Buffer$2.from(data2 + "\n", "binary");
    }
    this.push(data2);
    return this._offset += data2.length;
  }
  addContent(data2) {
    this.page.write(data2);
    return this;
  }
  _refEnd(ref2) {
    this._offsets[ref2.id - 1] = ref2.offset;
    if (--this._waiting === 0 && this._ended) {
      this._finalize();
      return this._ended = false;
    }
  }
  end() {
    this.flushPages();
    this._info = this.ref();
    for (let key in this.info) {
      let val = this.info[key];
      if (typeof val === "string") {
        val = new String(val);
      }
      let entry = this.ref(val);
      entry.end();
      this._info.data[key] = entry;
    }
    this._info.end();
    for (let name in this._fontFamilies) {
      const font = this._fontFamilies[name];
      font.finalize();
    }
    this.endOutline();
    this.endMarkings();
    if (this.subset) {
      this.endSubset();
    }
    this.endMetadata();
    this._root.end();
    this._root.data.Pages.end();
    this._root.data.Names.end();
    this.endAcroForm();
    if (this._root.data.ViewerPreferences) {
      this._root.data.ViewerPreferences.end();
    }
    if (this._security) {
      this._security.end();
    }
    if (this._waiting === 0) {
      return this._finalize();
    } else {
      return this._ended = true;
    }
  }
  _finalize() {
    const xRefOffset = this._offset;
    this._write("xref");
    this._write(`0 ${this._offsets.length + 1}`);
    this._write("0000000000 65535 f ");
    for (let offset2 of this._offsets) {
      offset2 = `0000000000${offset2}`.slice(-10);
      this._write(offset2 + " 00000 n ");
    }
    const trailer = {
      Size: this._offsets.length + 1,
      Root: this._root,
      Info: this._info,
      ID: [this._id, this._id]
    };
    if (this._security) {
      trailer.Encrypt = this._security.dictionary;
    }
    this._write("trailer");
    this._write(PDFObject.convert(trailer));
    this._write("startxref");
    this._write(`${xRefOffset}`);
    this._write("%%EOF");
    return this.push(null);
  }
  toString() {
    return "[object PDFDocument]";
  }
};
var mixin = /* @__PURE__ */ __name((methods) => {
  Object.assign(PDFDocument.prototype, methods);
}, "mixin");
mixin(MetadataMixin);
mixin(ColorMixin);
mixin(VectorMixin);
mixin(FontsMixin);
mixin(TextMixin);
mixin(ImagesMixin);
mixin(AnnotationsMixin);
mixin(OutlineMixin);
mixin(MarkingsMixin);
mixin(AcroFormMixin);
mixin(AttachmentsMixin);
mixin(SubsetMixin);
PDFDocument.LineWrapper = LineWrapper;

// ../../node_modules/.pnpm/@react-pdf+font@4.0.4/node_modules/@react-pdf/font/lib/index.browser.js
var STANDARD_FONTS2 = [
  "Courier",
  "Courier-Bold",
  "Courier-Oblique",
  "Courier-BoldOblique",
  "Helvetica",
  "Helvetica-Bold",
  "Helvetica-Oblique",
  "Helvetica-BoldOblique",
  "Times-Roman",
  "Times-Bold",
  "Times-Italic",
  "Times-BoldItalic"
];
var StandardFont2 = class {
  static {
    __name(this, "StandardFont");
  }
  name;
  src;
  fullName;
  familyName;
  subfamilyName;
  postscriptName;
  copyright;
  version;
  underlinePosition;
  underlineThickness;
  italicAngle;
  bbox;
  "OS/2";
  hhea;
  numGlyphs;
  characterSet;
  availableFeatures;
  type;
  constructor(src) {
    this.name = src;
    this.fullName = src;
    this.familyName = src;
    this.subfamilyName = src;
    this.type = "STANDARD";
    this.postscriptName = src;
    this.availableFeatures = [];
    this.copyright = "";
    this.version = 1;
    this.underlinePosition = -100;
    this.underlineThickness = 50;
    this.italicAngle = 0;
    this.bbox = {};
    this["OS/2"] = {};
    this.hhea = {};
    this.numGlyphs = 0;
    this.characterSet = [];
    this.src = PDFFont.open(null, src);
  }
  encode(str) {
    return this.src.encode(str);
  }
  layout(str) {
    const [encoded, positions] = this.encode(str);
    const glyphs = encoded.map((g, i2) => {
      const glyph = this.getGlyph(parseInt(g, 16));
      glyph.advanceWidth = positions[i2].advanceWidth;
      return glyph;
    });
    const advanceWidth2 = positions.reduce((acc, p3) => acc + p3.advanceWidth, 0);
    return {
      positions,
      stringIndices: positions.map((_, i2) => i2),
      glyphs,
      script: "latin",
      language: "dflt",
      direction: "ltr",
      features: {},
      advanceWidth: advanceWidth2,
      advanceHeight: 0,
      bbox: void 0
    };
  }
  glyphForCodePoint(codePoint) {
    const glyph = this.getGlyph(codePoint);
    glyph.advanceWidth = 400;
    return glyph;
  }
  getGlyph(id) {
    return {
      id,
      codePoints: [id],
      isLigature: false,
      name: this.src.font.characterToGlyph(id),
      _font: this.src,
      // @ts-expect-error assign proper value
      advanceWidth: void 0
    };
  }
  hasGlyphForCodePoint(codePoint) {
    return this.src.font.characterToGlyph(codePoint) !== ".notdef";
  }
  // Based on empirical observation
  get ascent() {
    return 900;
  }
  // Based on empirical observation
  get capHeight() {
    switch (this.name) {
      case "Times-Roman":
      case "Times-Bold":
      case "Times-Italic":
      case "Times-BoldItalic":
        return 650;
      case "Courier":
      case "Courier-Bold":
      case "Courier-Oblique":
      case "Courier-BoldOblique":
        return 550;
      default:
        return 690;
    }
  }
  // Based on empirical observation
  get xHeight() {
    switch (this.name) {
      case "Times-Roman":
      case "Times-Bold":
      case "Times-Italic":
      case "Times-BoldItalic":
        return 440;
      case "Courier":
      case "Courier-Bold":
      case "Courier-Oblique":
      case "Courier-BoldOblique":
        return 390;
      default:
        return 490;
    }
  }
  // Based on empirical observation
  get descent() {
    switch (this.name) {
      case "Times-Roman":
      case "Times-Bold":
      case "Times-Italic":
      case "Times-BoldItalic":
        return -220;
      case "Courier":
      case "Courier-Bold":
      case "Courier-Oblique":
      case "Courier-BoldOblique":
        return -230;
      default:
        return -200;
    }
  }
  get lineGap() {
    return 0;
  }
  get unitsPerEm() {
    return 1e3;
  }
  stringsForGlyph() {
    throw new Error("Method not implemented.");
  }
  glyphsForString() {
    throw new Error("Method not implemented.");
  }
  widthOfGlyph() {
    throw new Error("Method not implemented.");
  }
  getAvailableFeatures() {
    throw new Error("Method not implemented.");
  }
  createSubset() {
    throw new Error("Method not implemented.");
  }
  getVariation() {
    throw new Error("Method not implemented.");
  }
  getFont() {
    throw new Error("Method not implemented.");
  }
  getName() {
    throw new Error("Method not implemented.");
  }
  setDefaultLanguage() {
    throw new Error("Method not implemented.");
  }
};
var fetchFont = /* @__PURE__ */ __name(async (src, options) => {
  const response = await fetch(src, options);
  const data2 = await response.arrayBuffer();
  return new Uint8Array(data2);
}, "fetchFont");
var isDataUrl = /* @__PURE__ */ __name((dataUrl) => {
  const header = dataUrl.split(",")[0];
  const hasDataPrefix = header.substring(0, 5) === "data:";
  const hasBase64Prefix = header.split(";")[1] === "base64";
  return hasDataPrefix && hasBase64Prefix;
}, "isDataUrl");
var FontSource = class {
  static {
    __name(this, "FontSource");
  }
  src;
  fontFamily;
  fontStyle;
  fontWeight;
  data;
  options;
  loadResultPromise;
  constructor(src, fontFamily, fontStyle, fontWeight, options) {
    this.src = src;
    this.fontFamily = fontFamily;
    this.fontStyle = fontStyle || "normal";
    this.fontWeight = fontWeight || 400;
    this.data = null;
    this.options = options || {};
    this.loadResultPromise = null;
  }
  async _load() {
    const { postscriptName } = this.options;
    let data2 = null;
    if (STANDARD_FONTS2.includes(this.src)) {
      data2 = new StandardFont2(this.src);
    } else if (isDataUrl(this.src)) {
      const raw2 = this.src.split(",")[1];
      const uint8Array = new Uint8Array(atob(raw2).split("").map((c2) => c2.charCodeAt(0)));
      data2 = $d636bc798e7178db$export$185802fd694ee1f5(uint8Array, postscriptName);
    } else {
      const { headers, body, method = "GET" } = this.options;
      const buffer = await fetchFont(this.src, { method, body, headers });
      data2 = $d636bc798e7178db$export$185802fd694ee1f5(buffer, postscriptName);
    }
    if (data2 && "fonts" in data2) {
      throw new Error("Font collection is not supported");
    }
    this.data = data2;
  }
  async load() {
    if (this.loadResultPromise === null) {
      this.loadResultPromise = this._load();
    }
    return this.loadResultPromise;
  }
};
var FONT_WEIGHTS = {
  thin: 100,
  hairline: 100,
  ultralight: 200,
  extralight: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  demibold: 600,
  bold: 700,
  ultrabold: 800,
  extrabold: 800,
  heavy: 900,
  black: 900
};
var resolveFontWeight = /* @__PURE__ */ __name((value2) => {
  return typeof value2 === "string" ? FONT_WEIGHTS[value2] : value2;
}, "resolveFontWeight");
var sortByFontWeight = /* @__PURE__ */ __name((a4, b3) => a4.fontWeight - b3.fontWeight, "sortByFontWeight");
var FontFamily = class _FontFamily {
  static {
    __name(this, "FontFamily");
  }
  family;
  sources;
  static create(family) {
    return new _FontFamily(family);
  }
  constructor(family) {
    this.family = family;
    this.sources = [];
  }
  register({ src, fontWeight, fontStyle, ...options }) {
    const numericFontWeight = fontWeight ? resolveFontWeight(fontWeight) : void 0;
    this.sources.push(new FontSource(src, this.family, fontStyle, numericFontWeight, options));
  }
  resolve(descriptor) {
    const { fontWeight = 400, fontStyle = "normal" } = descriptor;
    const styleSources = this.sources.filter((s4) => s4.fontStyle === fontStyle);
    const exactFit = styleSources.find((s4) => s4.fontWeight === fontWeight);
    if (exactFit)
      return exactFit;
    let font = null;
    const numericFontWeight = resolveFontWeight(fontWeight);
    if (numericFontWeight >= 400 && numericFontWeight <= 500) {
      const leftOffset = styleSources.filter((s4) => s4.fontWeight <= numericFontWeight);
      const rightOffset = styleSources.filter((s4) => s4.fontWeight > 500);
      const fit = styleSources.filter((s4) => s4.fontWeight >= numericFontWeight && s4.fontWeight < 500);
      font = fit[0] || leftOffset[leftOffset.length - 1] || rightOffset[0];
    }
    const lt = styleSources.filter((s4) => s4.fontWeight < numericFontWeight).sort(sortByFontWeight);
    const gt = styleSources.filter((s4) => s4.fontWeight > numericFontWeight).sort(sortByFontWeight);
    if (numericFontWeight < 400) {
      font = lt[lt.length - 1] || gt[0];
    }
    if (numericFontWeight > 500) {
      font = gt[0] || lt[lt.length - 1];
    }
    if (!font) {
      throw new Error(`Could not resolve font for ${this.family}, fontWeight ${fontWeight}, fontStyle ${fontStyle}`);
    }
    return font;
  }
};
var FontStore = class {
  static {
    __name(this, "FontStore");
  }
  fontFamilies = {};
  emojiSource = null;
  constructor() {
    this.register({
      family: "Helvetica",
      fonts: [
        { src: "Helvetica", fontStyle: "normal", fontWeight: 400 },
        { src: "Helvetica-Bold", fontStyle: "normal", fontWeight: 700 },
        { src: "Helvetica-Oblique", fontStyle: "italic", fontWeight: 400 },
        { src: "Helvetica-BoldOblique", fontStyle: "italic", fontWeight: 700 }
      ]
    });
    this.register({
      family: "Courier",
      fonts: [
        { src: "Courier", fontStyle: "normal", fontWeight: 400 },
        { src: "Courier-Bold", fontStyle: "normal", fontWeight: 700 },
        { src: "Courier-Oblique", fontStyle: "italic", fontWeight: 400 },
        { src: "Courier-BoldOblique", fontStyle: "italic", fontWeight: 700 }
      ]
    });
    this.register({
      family: "Times-Roman",
      fonts: [
        { src: "Times-Roman", fontStyle: "normal", fontWeight: 400 },
        { src: "Times-Bold", fontStyle: "normal", fontWeight: 700 },
        { src: "Times-Italic", fontStyle: "italic", fontWeight: 400 },
        { src: "Times-BoldItalic", fontStyle: "italic", fontWeight: 700 }
      ]
    });
    this.register({
      family: "Helvetica-Bold",
      src: "Helvetica-Bold"
    });
    this.register({
      family: "Helvetica-Oblique",
      src: "Helvetica-Oblique"
    });
    this.register({
      family: "Helvetica-BoldOblique",
      src: "Helvetica-BoldOblique"
    });
    this.register({
      family: "Courier-Bold",
      src: "Courier-Bold"
    });
    this.register({
      family: "Courier-Oblique",
      src: "Courier-Oblique"
    });
    this.register({
      family: "Courier-BoldOblique",
      src: "Courier-BoldOblique"
    });
    this.register({
      family: "Times-Bold",
      src: "Times-Bold"
    });
    this.register({
      family: "Times-Italic",
      src: "Times-Italic"
    });
    this.register({
      family: "Times-BoldItalic",
      src: "Times-BoldItalic"
    });
    this.load({
      fontFamily: "Helvetica",
      fontStyle: "normal",
      fontWeight: 400
    });
    this.load({
      fontFamily: "Helvetica",
      fontStyle: "normal",
      fontWeight: 700
    });
    this.load({
      fontFamily: "Helvetica",
      fontStyle: "italic",
      fontWeight: 400
    });
    this.load({
      fontFamily: "Helvetica",
      fontStyle: "italic",
      fontWeight: 700
    });
  }
  hyphenationCallback = null;
  register = /* @__PURE__ */ __name((data2) => {
    const { family } = data2;
    if (!this.fontFamilies[family]) {
      this.fontFamilies[family] = FontFamily.create(family);
    }
    if ("fonts" in data2) {
      for (let i2 = 0; i2 < data2.fonts.length; i2 += 1) {
        const { src, fontStyle, fontWeight, ...options } = data2.fonts[i2];
        this.fontFamilies[family].register({
          src,
          fontStyle,
          fontWeight,
          ...options
        });
      }
    } else {
      const { src, fontStyle, fontWeight, ...options } = data2;
      this.fontFamilies[family].register({
        src,
        fontStyle,
        fontWeight,
        ...options
      });
    }
  }, "register");
  registerEmojiSource = /* @__PURE__ */ __name((emojiSource) => {
    this.emojiSource = emojiSource;
  }, "registerEmojiSource");
  registerHyphenationCallback = /* @__PURE__ */ __name((callback) => {
    this.hyphenationCallback = callback;
  }, "registerHyphenationCallback");
  getFont = /* @__PURE__ */ __name((descriptor) => {
    const { fontFamily } = descriptor;
    if (!this.fontFamilies[fontFamily]) {
      throw new Error(`Font family not registered: ${fontFamily}. Please register it calling Font.register() method.`);
    }
    return this.fontFamilies[fontFamily].resolve(descriptor);
  }, "getFont");
  load = /* @__PURE__ */ __name(async (descriptor) => {
    const font = this.getFont(descriptor);
    if (font)
      await font.load();
  }, "load");
  reset = /* @__PURE__ */ __name(() => {
    const keys2 = Object.keys(this.fontFamilies);
    for (let i2 = 0; i2 < keys2.length; i2 += 1) {
      const key = keys2[i2];
      for (let j = 0; j < this.fontFamilies[key].sources.length; j++) {
        const fontSource = this.fontFamilies[key].sources[j];
        fontSource.data = null;
      }
    }
  }, "reset");
  clear = /* @__PURE__ */ __name(() => {
    this.fontFamilies = {};
  }, "clear");
  getRegisteredFonts = /* @__PURE__ */ __name(() => this.fontFamilies, "getRegisteredFonts");
  getEmojiSource = /* @__PURE__ */ __name(() => this.emojiSource, "getEmojiSource");
  getHyphenationCallback = /* @__PURE__ */ __name(() => this.hyphenationCallback, "getHyphenationCallback");
  getRegisteredFontFamilies = /* @__PURE__ */ __name(() => Object.keys(this.fontFamilies), "getRegisteredFontFamilies");
};

// ../../node_modules/.pnpm/@react-pdf+render@4.3.2/node_modules/@react-pdf/render/lib/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/@react-pdf+fns@3.1.2/node_modules/@react-pdf/fns/lib/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var adjust = /* @__PURE__ */ __name((index2, fn, collection) => {
  if (index2 >= 0 && index2 >= collection.length)
    return collection;
  if (index2 < 0 && Math.abs(index2) > collection.length)
    return collection;
  const i2 = index2 < 0 ? collection.length + index2 : index2;
  return Object.assign([], collection, { [i2]: fn(collection[i2]) });
}, "adjust");
var asyncCompose = /* @__PURE__ */ __name((...fns) => async (value2, ...args) => {
  let result = value2;
  const reversedFns = fns.slice().reverse();
  for (let i2 = 0; i2 < reversedFns.length; i2 += 1) {
    const fn = reversedFns[i2];
    result = await fn(result, ...args);
  }
  return result;
}, "asyncCompose");
var capitalize = /* @__PURE__ */ __name((value2) => {
  if (!value2)
    return value2;
  return value2.replace(/(^|\s)\S/g, (l4) => l4.toUpperCase());
}, "capitalize");
var castArray = /* @__PURE__ */ __name((value2) => {
  return Array.isArray(value2) ? value2 : [value2];
}, "castArray");
var compose2 = /* @__PURE__ */ __name((...fns) => (value2, ...args) => {
  let result = value2;
  const reversedFns = fns.slice().reverse();
  for (let i2 = 0; i2 < reversedFns.length; i2 += 1) {
    const fn = reversedFns[i2];
    result = fn(result, ...args);
  }
  return result;
}, "compose");
var dropLast = /* @__PURE__ */ __name((array) => array.slice(0, array.length - 1), "dropLast");
function evolve(transformations, object) {
  const result = {};
  const keys2 = Object.keys(object);
  for (let i2 = 0; i2 < keys2.length; i2 += 1) {
    const key = keys2[i2];
    const transformation = transformations[key];
    if (typeof transformation === "function") {
      result[key] = transformation(object[key]);
    } else {
      result[key] = object[key];
    }
  }
  return result;
}
__name(evolve, "evolve");
var isNil = /* @__PURE__ */ __name((value2) => value2 === null || value2 === void 0, "isNil");
function last(value2) {
  return value2 === "" ? "" : value2[value2.length - 1];
}
__name(last, "last");
var mapValues = /* @__PURE__ */ __name((object, fn) => {
  const entries = Object.entries(object);
  const acc = {};
  return entries.reduce((acc2, [key, value2], index2) => {
    acc2[key] = fn(value2, key, index2);
    return acc2;
  }, acc);
}, "mapValues");
var isPercent = /* @__PURE__ */ __name((value2) => /((-)?\d+\.?\d*)%/g.exec(`${value2}`), "isPercent");
var matchPercent = /* @__PURE__ */ __name((value2) => {
  const match2 = isPercent(value2);
  if (match2) {
    const f4 = parseFloat(match2[1]);
    const percent = f4 / 100;
    return { percent, value: f4 };
  }
  return null;
}, "matchPercent");
var omit = /* @__PURE__ */ __name((keys2, object) => {
  const _keys = castArray(keys2);
  const copy5 = Object.assign({}, object);
  _keys.forEach((key) => {
    delete copy5[key];
  });
  return copy5;
}, "omit");
var pick = /* @__PURE__ */ __name((keys2, obj) => {
  const result = {};
  for (let i2 = 0; i2 < keys2.length; i2 += 1) {
    const key = keys2[i2];
    if (key in obj)
      result[key] = obj[key];
  }
  return result;
}, "pick");
var repeat = /* @__PURE__ */ __name((element, length2 = 0) => {
  const result = new Array(length2);
  for (let i2 = 0; i2 < length2; i2 += 1) {
    result[i2] = element;
  }
  return result;
}, "repeat");
var reverse = /* @__PURE__ */ __name((list) => Array.prototype.slice.call(list, 0).reverse(), "reverse");
var upperFirst = /* @__PURE__ */ __name((value2) => {
  if (!value2)
    return value2;
  return value2.charAt(0).toUpperCase() + value2.slice(1);
}, "upperFirst");
var without = /* @__PURE__ */ __name((keys2, array) => {
  const result = [];
  for (let i2 = 0; i2 < array.length; i2 += 1) {
    const value2 = array[i2];
    if (!keys2.includes(value2))
      result.push(value2);
  }
  return result;
}, "without");
var parseFloat$1 = /* @__PURE__ */ __name((value2) => {
  return typeof value2 === "string" ? Number.parseFloat(value2) : value2;
}, "parseFloat$1");

// ../../node_modules/.pnpm/@react-pdf+render@4.3.2/node_modules/@react-pdf/render/lib/index.js
var import_abs_svg_path = __toESM(require_abs_svg_path(), 1);
var import_parse_svg_path = __toESM(require_parse_svg_path(), 1);

// ../../node_modules/.pnpm/normalize-svg-path@1.1.0/node_modules/normalize-svg-path/index.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/svg-arc-to-cubic-bezier@3.2.0/node_modules/svg-arc-to-cubic-bezier/modules/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var _slicedToArray = /* @__PURE__ */ function() {
  function sliceIterator(arr, i2) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2) break;
      }
    } catch (err2) {
      _d = true;
      _e = err2;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  __name(sliceIterator, "sliceIterator");
  return function(arr, i2) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i2);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var TAU = Math.PI * 2;
var mapToEllipse = /* @__PURE__ */ __name(function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x = _ref.x, y3 = _ref.y;
  x *= rx;
  y3 *= ry;
  var xp = cosphi * x - sinphi * y3;
  var yp = sinphi * x + cosphi * y3;
  return {
    x: xp + centerx,
    y: yp + centery
  };
}, "mapToEllipse");
var approxUnitArc = /* @__PURE__ */ __name(function approxUnitArc2(ang1, ang2) {
  var a4 = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y22 = Math.sin(ang1 + ang2);
  return [{
    x: x1 - y1 * a4,
    y: y1 + x1 * a4
  }, {
    x: x2 + y22 * a4,
    y: y22 - x2 * a4
  }, {
    x: x2,
    y: y22
  }];
}, "approxUnitArc");
var vectorAngle = /* @__PURE__ */ __name(function vectorAngle2(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var dot = ux * vx + uy * vy;
  if (dot > 1) {
    dot = 1;
  }
  if (dot < -1) {
    dot = -1;
  }
  return sign * Math.acos(dot);
}, "vectorAngle");
var getArcCenter = /* @__PURE__ */ __name(function getArcCenter2(px2, py2, cx2, cy2, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);
  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;
  var centerx = cosphi * centerxp - sinphi * centeryp + (px2 + cx2) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py2 + cy2) / 2;
  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;
  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  return [centerx, centery, ang1, ang2];
}, "getArcCenter");
var arcToBezier = /* @__PURE__ */ __name(function arcToBezier2(_ref2) {
  var px2 = _ref2.px, py2 = _ref2.py, cx2 = _ref2.cx, cy2 = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
  var curves = [];
  if (rx === 0 || ry === 0) {
    return [];
  }
  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);
  var pxp = cosphi * (px2 - cx2) / 2 + sinphi * (py2 - cy2) / 2;
  var pyp = -sinphi * (px2 - cx2) / 2 + cosphi * (py2 - cy2) / 2;
  if (pxp === 0 && pyp === 0) {
    return [];
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var _getArcCenter = getArcCenter(px2, py2, cx2, cy2, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  var segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  for (var i2 = 0; i2 < segments; i2++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }
  return curves.map(function(curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y22 = _mapToEllipse2.y;
    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _mapToEllipse3.x, y3 = _mapToEllipse3.y;
    return { x1, y1, x2, y2: y22, x, y: y3 };
  });
}, "arcToBezier");
var modules_default = arcToBezier;

// ../../node_modules/.pnpm/normalize-svg-path@1.1.0/node_modules/normalize-svg-path/index.mjs
function normalize(path) {
  var prev;
  var result = [];
  var bezierX = 0;
  var bezierY = 0;
  var startX = 0;
  var startY = 0;
  var quadX = null;
  var quadY = null;
  var x = 0;
  var y3 = 0;
  for (var i2 = 0, len = path.length; i2 < len; i2++) {
    var seg = path[i2];
    var command = seg[0];
    switch (command) {
      case "M":
        startX = seg[1];
        startY = seg[2];
        break;
      case "A":
        var curves = modules_default({
          px: x,
          py: y3,
          cx: seg[6],
          cy: seg[7],
          rx: seg[1],
          ry: seg[2],
          xAxisRotation: seg[3],
          largeArcFlag: seg[4],
          sweepFlag: seg[5]
        });
        if (!curves.length) continue;
        for (var j = 0, c2; j < curves.length; j++) {
          c2 = curves[j];
          seg = ["C", c2.x1, c2.y1, c2.x2, c2.y2, c2.x, c2.y];
          if (j < curves.length - 1) result.push(seg);
        }
        break;
      case "S":
        var cx2 = x;
        var cy2 = y3;
        if (prev == "C" || prev == "S") {
          cx2 += cx2 - bezierX;
          cy2 += cy2 - bezierY;
        }
        seg = ["C", cx2, cy2, seg[1], seg[2], seg[3], seg[4]];
        break;
      case "T":
        if (prev == "Q" || prev == "T") {
          quadX = x * 2 - quadX;
          quadY = y3 * 2 - quadY;
        } else {
          quadX = x;
          quadY = y3;
        }
        seg = quadratic(x, y3, quadX, quadY, seg[1], seg[2]);
        break;
      case "Q":
        quadX = seg[1];
        quadY = seg[2];
        seg = quadratic(x, y3, seg[1], seg[2], seg[3], seg[4]);
        break;
      case "L":
        seg = line(x, y3, seg[1], seg[2]);
        break;
      case "H":
        seg = line(x, y3, seg[1], y3);
        break;
      case "V":
        seg = line(x, y3, x, seg[1]);
        break;
      case "Z":
        seg = line(x, y3, startX, startY);
        break;
    }
    prev = command;
    x = seg[seg.length - 2];
    y3 = seg[seg.length - 1];
    if (seg.length > 4) {
      bezierX = seg[seg.length - 4];
      bezierY = seg[seg.length - 3];
    } else {
      bezierX = x;
      bezierY = y3;
    }
    result.push(seg);
  }
  return result;
}
__name(normalize, "normalize");
function line(x1, y1, x2, y22) {
  return ["C", x1, y1, x2, y22, x2, y22];
}
__name(line, "line");
function quadratic(x1, y1, cx2, cy2, x2, y22) {
  return [
    "C",
    x1 / 3 + 2 / 3 * cx2,
    y1 / 3 + 2 / 3 * cy2,
    x2 / 3 + 2 / 3 * cx2,
    y22 / 3 + 2 / 3 * cy2,
    x2,
    y22
  ];
}
__name(quadratic, "quadratic");

// ../../node_modules/.pnpm/@react-pdf+render@4.3.2/node_modules/@react-pdf/render/lib/index.js
var import_color_string = __toESM(require_color_string(), 1);
var renderPath = /* @__PURE__ */ __name((ctx, node) => {
  const d3 = node.props?.d;
  if (d3)
    ctx.path(node.props.d);
}, "renderPath");
var KAPPA$3 = 4 * ((Math.sqrt(2) - 1) / 3);
var renderRect = /* @__PURE__ */ __name((ctx, node) => {
  const x = node.props?.x || 0;
  const y3 = node.props?.y || 0;
  const rx = node.props?.rx || 0;
  const ry = node.props?.ry || 0;
  const width = node.props?.width || 0;
  const height2 = node.props?.height || 0;
  if (!width || !height2)
    return;
  if (rx && ry) {
    const krx = rx * KAPPA$3;
    const kry = ry * KAPPA$3;
    ctx.moveTo(x + rx, y3);
    ctx.lineTo(x - rx + width, y3);
    ctx.bezierCurveTo(x - rx + width + krx, y3, x + width, y3 + ry - kry, x + width, y3 + ry);
    ctx.lineTo(x + width, y3 + height2 - ry);
    ctx.bezierCurveTo(x + width, y3 + height2 - ry + kry, x - rx + width + krx, y3 + height2, x - rx + width, y3 + height2);
    ctx.lineTo(x + rx, y3 + height2);
    ctx.bezierCurveTo(x + rx - krx, y3 + height2, x, y3 + height2 - ry + kry, x, y3 + height2 - ry);
    ctx.lineTo(x, y3 + ry);
    ctx.bezierCurveTo(x, y3 + ry - kry, x + rx - krx, y3, x + rx, y3);
  } else {
    ctx.moveTo(x, y3);
    ctx.lineTo(x + width, y3);
    ctx.lineTo(x + width, y3 + height2);
    ctx.lineTo(x, y3 + height2);
  }
  ctx.closePath();
}, "renderRect");
var renderLine$1 = /* @__PURE__ */ __name((ctx, node) => {
  const { x1, x2, y1, y2: y22 } = node.props || {};
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y22);
}, "renderLine$1");
var renderGroup = /* @__PURE__ */ __name(() => {
}, "renderGroup");
var KAPPA$2 = 4 * ((Math.sqrt(2) - 1) / 3);
var drawEllipse = /* @__PURE__ */ __name((ctx, rx, ry, cx2 = 0, cy2 = 0) => {
  const x = cx2 - rx;
  const y3 = cy2 - ry;
  const ox = rx * KAPPA$2;
  const oy = ry * KAPPA$2;
  const xe = x + rx * 2;
  const ye = y3 + ry * 2;
  const xm = x + rx;
  const ym = y3 + ry;
  ctx.moveTo(x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y3, xm, y3);
  ctx.bezierCurveTo(xm + ox, y3, xe, ym - oy, xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  ctx.closePath();
}, "drawEllipse");
var renderEllipse = /* @__PURE__ */ __name((ctx, node) => {
  const { cx: cx2, cy: cy2, rx, ry } = node.props || {};
  drawEllipse(ctx, rx, ry, cx2, cy2);
}, "renderEllipse");
var renderCircle = /* @__PURE__ */ __name((ctx, node) => {
  const cx2 = node.props?.cx;
  const cy2 = node.props?.cy;
  const r5 = node.props?.r;
  drawEllipse(ctx, r5, r5, cx2, cy2);
}, "renderCircle");
var number2 = /* @__PURE__ */ __name((n5) => {
  if (n5 > -1e21 && n5 < 1e21) {
    return Math.round(n5 * 1e6) / 1e6;
  }
  throw new Error(`unsupported number: ${n5}`);
}, "number");
var _renderGlyphs = /* @__PURE__ */ __name((ctx, encoded, positions, x, y3) => {
  const commands = [];
  const scale2 = ctx._fontSize / 1e3;
  let i2;
  let last2 = 0;
  let hadOffset = false;
  ctx.save();
  ctx.transform(1, 0, 0, -1, 0, ctx.page.height);
  y3 = ctx.page.height - y3;
  if (ctx.page.fonts[ctx._font.id] == null) {
    ctx.page.fonts[ctx._font.id] = ctx._font.ref();
  }
  ctx.addContent("BT");
  ctx.addContent(`1 0 0 1 ${number2(x)} ${number2(y3)} Tm`);
  ctx.addContent(`/${ctx._font.id} ${number2(ctx._fontSize)} Tf`);
  const addSegment = /* @__PURE__ */ __name((cur) => {
    if (last2 < cur) {
      const hex = encoded.slice(last2, cur).join("");
      const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;
      commands.push(`<${hex}> ${number2(-advance)}`);
    }
    return last2 = cur;
  }, "addSegment");
  const flush = /* @__PURE__ */ __name((s4) => {
    addSegment(s4);
    if (commands.length > 0) {
      ctx.addContent(`[${commands.join(" ")}] TJ`);
      return commands.length = 0;
    }
  }, "flush");
  for (i2 = 0; i2 < positions.length; i2 += 1) {
    const pos = positions[i2];
    if (pos.xOffset || pos.yOffset) {
      flush(i2);
      ctx.addContent(`1 0 0 1 ${number2(x + pos.xOffset * scale2)} ${number2(y3 + pos.yOffset * scale2)} Tm`);
      flush(i2 + 1);
      hadOffset = true;
    } else {
      if (hadOffset) {
        ctx.addContent(`1 0 0 1 ${number2(x)} ${number2(y3)} Tm`);
        hadOffset = false;
      }
      if (pos.xAdvance - pos.advanceWidth !== 0) {
        addSegment(i2 + 1);
      }
    }
    x += pos.xAdvance * scale2;
  }
  flush(i2);
  ctx.addContent("ET");
  return ctx.restore();
}, "_renderGlyphs");
var renderGlyphs = /* @__PURE__ */ __name((ctx, glyphs, positions, x, y3) => {
  const scale2 = 1e3 / ctx._fontSize;
  const unitsPerEm = ctx._font.font.unitsPerEm || 1e3;
  const advanceWidthScale = 1e3 / unitsPerEm;
  const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);
  const encodedPositions = positions.map((pos, i2) => ({
    xAdvance: pos.xAdvance * scale2,
    yAdvance: pos.yAdvance * scale2,
    xOffset: pos.xOffset,
    yOffset: pos.yOffset,
    advanceWidth: glyphs[i2].advanceWidth * advanceWidthScale
  }));
  return _renderGlyphs(ctx, encodedGlyphs, encodedPositions, x, y3);
}, "renderGlyphs");
var renderRun$1 = /* @__PURE__ */ __name((ctx, run) => {
  if (!run.glyphs)
    return;
  if (!run.positions)
    return;
  const runAdvanceWidth = run.xAdvance;
  const font = run.attributes.font?.[0];
  const { fontSize, color, opacity } = run.attributes;
  if (color)
    ctx.fillColor(color);
  ctx.fillOpacity(opacity);
  if (font) {
    ctx.font(font.type === "STANDARD" ? font.fullName : font, fontSize);
  }
  try {
    renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);
  } catch (error3) {
    console.log(error3);
  }
  ctx.translate(runAdvanceWidth, 0);
}, "renderRun$1");
var renderSpan = /* @__PURE__ */ __name((ctx, line2, textAnchor, dominantBaseline) => {
  ctx.save();
  const x = line2.box?.x || 0;
  const y3 = line2.box?.y || 0;
  const font = line2.runs[0]?.attributes.font?.[0];
  const scale2 = line2.runs[0]?.attributes?.scale || 1;
  const width = line2.xAdvance;
  if (!font)
    return;
  const ascent2 = font.ascent * scale2;
  const xHeight = font.xHeight * scale2;
  const descent2 = font.descent * scale2;
  const capHeight = font.capHeight * scale2;
  let xTranslate = x;
  let yTranslate = y3;
  switch (textAnchor) {
    case "middle":
      xTranslate = x - width / 2;
      break;
    case "end":
      xTranslate = x - width;
      break;
    default:
      xTranslate = x;
      break;
  }
  switch (dominantBaseline) {
    case "middle":
    case "central":
      yTranslate = y3 + capHeight / 2;
      break;
    case "hanging":
      yTranslate = y3 + capHeight;
      break;
    case "mathematical":
      yTranslate = y3 + xHeight;
      break;
    case "text-after-edge":
      yTranslate = y3 + descent2;
      break;
    case "text-before-edge":
      yTranslate = y3 + ascent2;
      break;
    default:
      yTranslate = y3;
      break;
  }
  ctx.translate(xTranslate, yTranslate);
  line2.runs.forEach((run) => renderRun$1(ctx, run));
  ctx.restore();
}, "renderSpan");
var renderSvgText = /* @__PURE__ */ __name((ctx, node) => {
  const children = node.children;
  children.forEach((span) => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));
}, "renderSvgText");
var pairs = /* @__PURE__ */ __name((values) => {
  const result = [];
  for (let i2 = 0; i2 < values.length; i2 += 2) {
    result.push([values[i2], values[i2 + 1]]);
  }
  return result;
}, "pairs");
var parsePoints = /* @__PURE__ */ __name((points) => {
  let values = (points || "").trim().replace(/,/g, " ").replace(/(\d)-(\d)/g, "$1 -$2").split(/\s+/);
  if (values.length % 2 !== 0) {
    values = values.slice(0, -1);
  }
  const mappedValues = values.map(parseFloat);
  return pairs(mappedValues);
}, "parsePoints");
var drawPolyline = /* @__PURE__ */ __name((ctx, points) => {
  if (points.length > 0) {
    ctx.moveTo(points[0][0], points[0][1]);
    points.slice(1).forEach((p3) => ctx.lineTo(p3[0], p3[1]));
  }
}, "drawPolyline");
var renderPolyline = /* @__PURE__ */ __name((ctx, node) => {
  const points = parsePoints(node.props.points || "");
  drawPolyline(ctx, points);
}, "renderPolyline");
var renderPolygon = /* @__PURE__ */ __name((ctx, node) => {
  const points = parsePoints(node.props.points || "");
  drawPolyline(ctx, points);
  ctx.closePath();
}, "renderPolygon");
var renderImage$1 = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  if (!node.image?.data)
    return;
  const { x = 0, y: y3 = 0 } = node.props;
  const { width, height: height2, opacity } = node.style;
  const paddingTop = node.box.paddingLeft || 0;
  const paddingLeft = node.box.paddingLeft || 0;
  if (width === 0 || height2 === 0) {
    console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);
    return;
  }
  if (typeof width === "string" || typeof height2 === "string") {
    console.warn(`Image with src '${node.props.href}' skipped due to percentage width or height`);
    return;
  }
  ctx.save();
  ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y3 + paddingTop, {
    width,
    height: height2
  });
  ctx.restore();
}, "renderImage$1");
var KAPPA$1 = 4 * ((Math.sqrt(2) - 1) / 3);
var clipNode = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  if (!node.style)
    return;
  const { top, left, width, height: height2 } = node.box;
  const { borderTopLeftRadius = 0, borderTopRightRadius = 0, borderBottomRightRadius = 0, borderBottomLeftRadius = 0 } = node.style;
  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height2);
  const ctr = rtr * (1 - KAPPA$1);
  ctx.moveTo(left + rtr, top);
  ctx.lineTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);
  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height2);
  const cbr = rbr * (1 - KAPPA$1);
  ctx.lineTo(left + width, top + height2 - rbr);
  ctx.bezierCurveTo(left + width, top + height2 - cbr, left + width - cbr, top + height2, left + width - rbr, top + height2);
  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height2);
  const cbl = rbl * (1 - KAPPA$1);
  ctx.lineTo(left + rbl, top + height2);
  ctx.bezierCurveTo(left + cbl, top + height2, left, top + height2 - cbl, left, top + height2 - rbl);
  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height2);
  const ctl = rtl * (1 - KAPPA$1);
  ctx.lineTo(left, top + rtl);
  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);
  ctx.closePath();
  ctx.clip();
}, "clipNode");
var applySingleTransformation = /* @__PURE__ */ __name((ctx, transform, origin) => {
  const { operation, value: value2 } = transform;
  switch (operation) {
    case "scale": {
      const [scaleX, scaleY] = value2;
      ctx.scale(scaleX, scaleY, { origin });
      break;
    }
    case "rotate": {
      const [angle] = value2;
      ctx.rotate(angle, { origin });
      break;
    }
    case "translate": {
      const [x, y3 = 0] = value2;
      ctx.translate(x, y3, { origin });
      break;
    }
    case "skew": {
      const [xAngle = 0, yAngle = 0] = value2;
      const radx = xAngle * Math.PI / 180;
      const rady = yAngle * Math.PI / 180;
      const tanx = Math.tan(radx);
      const tany = Math.tan(rady);
      let x = 0;
      let y3 = 0;
      if (origin != null) {
        [x, y3] = Array.from(origin);
        const x1 = x + tanx * y3;
        const y1 = y3 + tany * x;
        x -= x1;
        y3 -= y1;
      }
      ctx.transform(1, tany, tanx, 1, x, y3);
      break;
    }
    case "matrix": {
      ctx.transform(...value2);
      break;
    }
    default: {
      console.error(`Transform operation: '${operation}' doesn't supported`);
    }
  }
}, "applySingleTransformation");
var applyTransformations = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.origin)
    return;
  const { props, style } = node;
  const origin = [node.origin.left, node.origin.top];
  const propsTransform = "transform" in props ? props.transform : void 0;
  const operations = style?.transform || propsTransform || [];
  operations.forEach((operation) => {
    applySingleTransformation(ctx, operation, origin);
  });
}, "applyTransformations");
var getPathBoundingBox = /* @__PURE__ */ __name((node) => {
  const path = normalize((0, import_abs_svg_path.default)((0, import_parse_svg_path.default)(node.props?.d || "")));
  if (!path.length)
    return [0, 0, 0, 0];
  const bounds = [Infinity, Infinity, -Infinity, -Infinity];
  for (let i2 = 0, l4 = path.length; i2 < l4; i2 += 1) {
    const points = path[i2].slice(1);
    for (let j = 0; j < points.length; j += 2) {
      if (points[j + 0] < bounds[0])
        bounds[0] = points[j + 0];
      if (points[j + 1] < bounds[1])
        bounds[1] = points[j + 1];
      if (points[j + 0] > bounds[2])
        bounds[2] = points[j + 0];
      if (points[j + 1] > bounds[3])
        bounds[3] = points[j + 1];
    }
  }
  return bounds;
}, "getPathBoundingBox");
var getCircleBoundingBox = /* @__PURE__ */ __name((node) => {
  const r5 = node.props?.r || 0;
  const cx2 = node.props?.cx || 0;
  const cy2 = node.props?.cy || 0;
  return [cx2 - r5, cy2 - r5, cx2 + r5, cy2 + r5];
}, "getCircleBoundingBox");
var getEllipseBoundingBox = /* @__PURE__ */ __name((node) => {
  const cx2 = node.props?.cx || 0;
  const cy2 = node.props?.cy || 0;
  const rx = node.props?.rx || 0;
  const ry = node.props?.ry || 0;
  return [cx2 - rx, cy2 - ry, cx2 + rx, cy2 + ry];
}, "getEllipseBoundingBox");
var getLineBoundingBox = /* @__PURE__ */ __name((node) => {
  const x1 = node.props?.x1 || 0;
  const y1 = node.props?.y1 || 0;
  const x2 = node.props?.x2 || 0;
  const y22 = node.props?.y2 || 0;
  return [
    Math.min(x1, x2),
    Math.min(y1, y22),
    Math.max(x1, x2),
    Math.max(y1, y22)
  ];
}, "getLineBoundingBox");
var getRectBoundingBox = /* @__PURE__ */ __name((node) => {
  const x = node.props?.x || 0;
  const y3 = node.props?.y || 0;
  const width = node.props?.width || 0;
  const height2 = node.props?.height || 0;
  return [x, y3, x + width, y3 + height2];
}, "getRectBoundingBox");
var max = /* @__PURE__ */ __name((values) => Math.max(-Infinity, ...values), "max");
var min = /* @__PURE__ */ __name((values) => Math.min(Infinity, ...values), "min");
var getPolylineBoundingBox = /* @__PURE__ */ __name((node) => {
  const points = parsePoints(node.props?.points);
  const xValues = points.map((p3) => p3[0]);
  const yValues = points.map((p3) => p3[1]);
  return [min(xValues), min(yValues), max(xValues), max(yValues)];
}, "getPolylineBoundingBox");
var boundingBoxFns = {
  [Rect]: getRectBoundingBox,
  [Line]: getLineBoundingBox,
  [Path]: getPathBoundingBox,
  [Circle]: getCircleBoundingBox,
  [Ellipse]: getEllipseBoundingBox,
  [Polygon]: getPolylineBoundingBox,
  [Polyline]: getPolylineBoundingBox
};
var getBoundingBox = /* @__PURE__ */ __name((node) => {
  const boundingBoxFn = boundingBoxFns[node.type];
  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];
}, "getBoundingBox");
var setStrokeWidth = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.props)
    return;
  if (!("strokeWidth" in node.props))
    return;
  const lineWidth = node.props.strokeWidth;
  if (lineWidth)
    ctx.lineWidth(lineWidth);
}, "setStrokeWidth");
var setStrokeColor = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.props)
    return;
  if (!("stroke" in node.props))
    return;
  const strokeColor = node.props.stroke;
  if (strokeColor)
    ctx.strokeColor(strokeColor);
}, "setStrokeColor");
var setOpacity = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.props)
    return;
  if (!("opacity" in node.props))
    return;
  const opacity = node.props.opacity;
  if (!isNil(opacity))
    ctx.opacity(opacity);
}, "setOpacity");
var setFillOpacity = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.props)
    return;
  if (!("fillOpacity" in node.props))
    return;
  const fillOpacity = node.props.fillOpacity || null;
  if (!isNil(fillOpacity))
    ctx.fillOpacity(fillOpacity);
}, "setFillOpacity");
var setStrokeOpacity = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.props)
    return;
  if (!("strokeOpacity" in node.props))
    return;
  const strokeOpacity = node.props?.strokeOpacity;
  if (!isNil(strokeOpacity))
    ctx.strokeOpacity(strokeOpacity);
}, "setStrokeOpacity");
var setLineJoin = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.props)
    return;
  if (!("strokeLinejoin" in node.props))
    return;
  const lineJoin = node.props.strokeLinejoin;
  if (lineJoin)
    ctx.lineJoin(lineJoin);
}, "setLineJoin");
var setLineCap = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.props)
    return;
  if (!("strokeLinecap" in node.props))
    return;
  const lineCap = node.props?.strokeLinecap;
  if (lineCap)
    ctx.lineCap(lineCap);
}, "setLineCap");
var setLineDash = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.props)
    return;
  if (!("strokeDasharray" in node.props))
    return;
  const value2 = node.props?.strokeDasharray || null;
  if (value2)
    ctx.dash(value2.split(/[\s,]+/).map(Number));
}, "setLineDash");
var hasLinearGradientFill = /* @__PURE__ */ __name((node) => {
  if (!node.props)
    return false;
  if (!("fill" in node.props))
    return false;
  if (typeof node.props.fill === "string")
    return false;
  return node.props.fill?.type === LinearGradient;
}, "hasLinearGradientFill");
var hasRadialGradientFill = /* @__PURE__ */ __name((node) => {
  if (!node.props)
    return false;
  if (!("fill" in node.props))
    return false;
  if (typeof node.props.fill === "string")
    return false;
  return node.props.fill?.type === RadialGradient;
}, "hasRadialGradientFill");
function multiplyMatrices(m1, m22) {
  const a4 = m1[0] * m22[0] + m1[2] * m22[1];
  const b3 = m1[1] * m22[0] + m1[3] * m22[1];
  const c2 = m1[0] * m22[2] + m1[2] * m22[3];
  const d3 = m1[1] * m22[2] + m1[3] * m22[3];
  const e4 = m1[0] * m22[4] + m1[2] * m22[5] + m1[4];
  const f4 = m1[1] * m22[4] + m1[3] * m22[5] + m1[5];
  return [a4, b3, c2, d3, e4, f4];
}
__name(multiplyMatrices, "multiplyMatrices");
var transformGradient = /* @__PURE__ */ __name((grad, transforms, bbox, units) => {
  const matrices = transforms.map((transform) => {
    switch (transform.operation) {
      case "scale": {
        const value2 = transform.value;
        return [value2[0], 0, 0, value2[1], 0, 0];
      }
      case "translate": {
        const value2 = transform.value;
        let x = value2[0] || 0;
        let y3 = value2[1] || 0;
        if (units === "objectBoundingBox") {
          x = (bbox[2] - bbox[0]) * x;
          y3 = (bbox[3] - bbox[1]) * y3;
        }
        return [1, 0, 0, 1, x, y3];
      }
      case "rotate": {
        const value2 = transform.value;
        const cos = Math.cos(value2[0]);
        const sin = Math.sin(value2[0]);
        return [cos, sin, -sin, cos, 0, 0];
      }
      case "skew": {
        const value2 = transform.value;
        return [1, Math.tan(value2[0]), Math.tan(value2[1]), 1, 0, 0];
      }
      case "matrix": {
        const value2 = transform.value;
        let x = value2[4] || 0;
        let y3 = value2[5] || 0;
        if (units === "objectBoundingBox") {
          x = (bbox[2] - bbox[0]) * x;
          y3 = (bbox[3] - bbox[1]) * y3;
        }
        return [value2[0], value2[1], value2[2], value2[3], x, y3];
      }
      default:
        return [1, 0, 0, 1, 0, 0];
    }
  });
  const matrix = matrices.reduce(multiplyMatrices, [1, 0, 0, 1, 0, 0]);
  grad.setTransform(...matrix);
}, "transformGradient");
var setLinearGradientFill = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.props)
    return;
  if (!("fill" in node.props))
    return;
  const bbox = getBoundingBox(node);
  const gradient = node.props?.fill;
  if (!gradient)
    return;
  const units = gradient.props.gradientUnits || "objectBoundingBox";
  const transforms = gradient.props.gradientTransform || [];
  let x1 = gradient.props.x1 || 0;
  let y1 = gradient.props.y1 || 0;
  let x2 = gradient.props.x2 || 1;
  let y22 = gradient.props.y2 || 0;
  if (units === "objectBoundingBox") {
    const m0 = bbox[2] - bbox[0];
    const m3 = bbox[3] - bbox[1];
    const m4 = bbox[0];
    const m5 = bbox[1];
    x1 = m0 * x1 + m4;
    y1 = m3 * y1 + m5;
    x2 = m0 * x2 + m4;
    y22 = m3 * y22 + m5;
  }
  const grad = ctx.linearGradient(x1, y1, x2, y22);
  transformGradient(grad, transforms, bbox, units);
  gradient.children?.forEach((stop) => {
    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);
  });
  ctx.fill(grad);
}, "setLinearGradientFill");
var setRadialGradientFill = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.props)
    return;
  if (!("fill" in node.props))
    return;
  const bbox = getBoundingBox(node);
  const gradient = node.props?.fill;
  if (!gradient)
    return;
  const units = gradient.props.gradientUnits || "objectBoundingBox";
  const transforms = gradient.props.gradientTransform || [];
  let r5 = gradient.props.r || 0.5;
  let cx2 = gradient.props.cx || 0.5;
  let cy2 = gradient.props.cy || 0.5;
  let fx = gradient.props.fx || cx2;
  let fy = gradient.props.fy || cy2;
  if (units === "objectBoundingBox") {
    const m0 = bbox[2] - bbox[0];
    const m3 = bbox[3] - bbox[1];
    const m4 = bbox[0];
    const m5 = bbox[1];
    r5 = r5 * m0;
    cx2 = m0 * cx2 + m4;
    cy2 = m3 * cy2 + m5;
    fx = m0 * fx + m4;
    fy = m3 * fy + m5;
  }
  const grad = ctx.radialGradient(cx2, cy2, 0, fx, fy, r5);
  transformGradient(grad, transforms, bbox, units);
  gradient.children?.forEach((stop) => {
    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);
  });
  ctx.fill(grad);
}, "setRadialGradientFill");
var setFillColor = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.props)
    return;
  if (!("fill" in node.props))
    return;
  const fillColor = node.props?.fill;
  if (fillColor)
    ctx.fillColor(fillColor);
}, "setFillColor");
var setFill = /* @__PURE__ */ __name((ctx, node) => {
  if (hasLinearGradientFill(node))
    return setLinearGradientFill(ctx, node);
  if (hasRadialGradientFill(node))
    return setRadialGradientFill(ctx, node);
  return setFillColor(ctx, node);
}, "setFill");
var draw = /* @__PURE__ */ __name((ctx, node) => {
  const props = node.props || {};
  if ("fill" in props && "stroke" in props && props.fill && props.stroke) {
    ctx.fillAndStroke(props.fillRule);
  } else if ("fill" in props && props.fill) {
    ctx.fill(props.fillRule);
  } else if ("stroke" in props && props.stroke) {
    ctx.stroke();
  } else {
    ctx.save();
    ctx.opacity(0);
    ctx.fill(null);
    ctx.restore();
  }
}, "draw");
var noop3 = /* @__PURE__ */ __name(() => {
}, "noop");
var renderFns$1 = {
  [Tspan]: noop3,
  [TextInstance]: noop3,
  [Path]: renderPath,
  [Rect]: renderRect,
  [Line]: renderLine$1,
  [G]: renderGroup,
  [Text]: renderSvgText,
  [Circle]: renderCircle,
  [Image]: renderImage$1,
  [Ellipse]: renderEllipse,
  [Polygon]: renderPolygon,
  [Polyline]: renderPolyline
};
var renderNode$1 = /* @__PURE__ */ __name((ctx, node) => {
  const renderFn = renderFns$1[node.type];
  if (renderFn) {
    renderFn(ctx, node);
  } else {
    console.warn(`SVG node of type ${node.type} is not currently supported`);
  }
}, "renderNode$1");
var drawNode = /* @__PURE__ */ __name((ctx, node) => {
  setLineCap(ctx, node);
  setLineDash(ctx, node);
  setLineJoin(ctx, node);
  setStrokeWidth(ctx, node);
  setStrokeColor(ctx, node);
  setFill(ctx, node);
  setStrokeOpacity(ctx, node);
  setFillOpacity(ctx, node);
  setOpacity(ctx, node);
  applyTransformations(ctx, node);
  renderNode$1(ctx, node);
  draw(ctx, node);
}, "drawNode");
var clipPath = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.props)
    return;
  if (!("clipPath" in node.props))
    return;
  const value2 = node.props.clipPath;
  if (value2) {
    const children = value2.children || [];
    children.forEach((child) => renderNode$1(ctx, child));
    ctx.clip();
  }
}, "clipPath");
var drawChildren = /* @__PURE__ */ __name((ctx, node) => {
  const children = node.children || [];
  children.forEach((child) => {
    ctx.save();
    clipPath(ctx, child);
    drawNode(ctx, child);
    drawChildren(ctx, child);
    ctx.restore();
  });
}, "drawChildren");
var resolveAspectRatio = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  const { width, height: height2 } = node.box;
  const { viewBox, preserveAspectRatio } = node.props;
  const { meetOrSlice = "meet", align = "xMidYMid" } = preserveAspectRatio || {};
  if (viewBox == null || width == null || height2 == null)
    return;
  const x = viewBox?.minX || 0;
  const y3 = viewBox?.minY || 0;
  const logicalWidth = viewBox?.maxX || width;
  const logicalHeight = viewBox?.maxY || height2;
  const logicalRatio = logicalWidth / logicalHeight;
  const physicalRatio = width / height2;
  const scaleX = width / logicalWidth;
  const scaleY = height2 / logicalHeight;
  if (align === "none") {
    ctx.scale(scaleX, scaleY);
    ctx.translate(-x, -y3);
    return;
  }
  if (logicalRatio < physicalRatio && meetOrSlice === "meet" || logicalRatio >= physicalRatio && meetOrSlice === "slice") {
    ctx.scale(scaleY, scaleY);
    switch (align) {
      case "xMinYMin":
      case "xMinYMid":
      case "xMinYMax":
        ctx.translate(-x, -y3);
        break;
      case "xMidYMin":
      case "xMidYMid":
      case "xMidYMax":
        ctx.translate(-x - (logicalWidth - width * logicalHeight / height2) / 2, -y3);
        break;
      default:
        ctx.translate(-x - (logicalWidth - width * logicalHeight / height2), -y3);
    }
  } else {
    ctx.scale(scaleX, scaleX);
    switch (align) {
      case "xMinYMin":
      case "xMidYMin":
      case "xMaxYMin":
        ctx.translate(-x, -y3);
        break;
      case "xMinYMid":
      case "xMidYMid":
      case "xMaxYMid":
        ctx.translate(-x, -y3 - (logicalHeight - height2 * logicalWidth / width) / 2);
        break;
      default:
        ctx.translate(-x, -y3 - (logicalHeight - height2 * logicalWidth / width));
    }
  }
}, "resolveAspectRatio");
var moveToOrigin = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  const { top, left } = node.box;
  const paddingLeft = node.box.paddingLeft || 0;
  const paddingTop = node.box.paddingTop || 0;
  ctx.translate(left + paddingLeft, top + paddingTop);
}, "moveToOrigin");
var renderSvg = /* @__PURE__ */ __name((ctx, node) => {
  ctx.save();
  clipNode(ctx, node);
  moveToOrigin(ctx, node);
  resolveAspectRatio(ctx, node);
  drawChildren(ctx, node);
  ctx.restore();
}, "renderSvg");
var black = { value: "#000", opacity: 1 };
var parseColor = /* @__PURE__ */ __name((hex) => {
  if (!hex)
    return black;
  const parsed = import_color_string.default.get(hex);
  if (!parsed)
    return black;
  const value2 = import_color_string.default.to.hex(parsed.value.slice(0, 3));
  const opacity = parsed.value[3];
  return { value: value2, opacity };
}, "parseColor");
var DEST_REGEXP = /^#.+/;
var isSrcId$1 = /* @__PURE__ */ __name((src) => src.match(DEST_REGEXP), "isSrcId$1");
var renderAttachment = /* @__PURE__ */ __name((ctx, attachment) => {
  const { xOffset = 0, yOffset = 0, width, height: height2, image } = attachment;
  ctx.translate(-width + xOffset, -height2 + yOffset);
  ctx.image(image, 0, 0, {
    fit: [width, height2],
    align: "center",
    valign: "bottom"
  });
}, "renderAttachment");
var renderAttachments = /* @__PURE__ */ __name((ctx, run, glyphs) => {
  if (!glyphs)
    return;
  if (!run.positions)
    return;
  const font = run.attributes.font?.[0];
  if (!font)
    return;
  ctx.save();
  const space = font.glyphForCodePoint(32);
  const objectReplacement = font.glyphForCodePoint(65532);
  let attachmentAdvance = 0;
  for (let i2 = 0; i2 < glyphs.length; i2 += 1) {
    const position = run.positions[i2];
    const glyph = glyphs[i2];
    attachmentAdvance += position.xAdvance || 0;
    if (glyph.id === objectReplacement.id && run.attributes.attachment) {
      ctx.translate(attachmentAdvance, position.yOffset || 0);
      renderAttachment(ctx, run.attributes.attachment);
      glyphs[i2] = space;
      attachmentAdvance = 0;
    }
  }
  ctx.restore();
}, "renderAttachments");
var renderRun = /* @__PURE__ */ __name((ctx, run) => {
  if (!run.glyphs)
    return;
  if (!run.positions)
    return;
  const font = run.attributes.font?.[0];
  if (!font)
    return;
  const { fontSize, link: link3 } = run.attributes;
  const color = parseColor(run.attributes.color);
  const opacity = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;
  const { height: height2 = 0, descent: descent2 = 0, xAdvance = 0 } = run;
  ctx.fillColor(color.value);
  ctx.fillOpacity(opacity);
  if (link3) {
    if (isSrcId$1(link3)) {
      ctx.goTo(0, -height2 - descent2, xAdvance, height2, link3.slice(1));
    } else {
      ctx.link(0, -height2 - descent2, xAdvance, height2, link3);
    }
  }
  const glyphs = [...run.glyphs];
  renderAttachments(ctx, run, glyphs);
  ctx.font(font.type === "STANDARD" ? font.fullName : font, fontSize);
  try {
    renderGlyphs(ctx, glyphs, run.positions, 0, 0);
  } catch (error3) {
    console.log(error3);
  }
  ctx.translate(xAdvance, 0);
}, "renderRun");
var renderBackground$1 = /* @__PURE__ */ __name((ctx, rect, backgroundColor) => {
  const color = parseColor(backgroundColor);
  ctx.save();
  ctx.fillOpacity(color.opacity);
  ctx.rect(rect.x, rect.y, rect.width, rect.height);
  ctx.fill(color.value);
  ctx.restore();
}, "renderBackground$1");
var renderDecorationLine = /* @__PURE__ */ __name((ctx, decorationLine) => {
  ctx.save();
  ctx.lineWidth(decorationLine.rect.height);
  ctx.strokeOpacity(decorationLine.opacity);
  if (/dashed/.test(decorationLine.style)) {
    ctx.dash(3 * decorationLine.rect.height, {});
  } else if (/dotted/.test(decorationLine.style)) {
    ctx.dash(decorationLine.rect.height, {});
  }
  if (/wavy/.test(decorationLine.style)) {
    const dist = Math.max(2, decorationLine.rect.height);
    let step = 1.1 * dist;
    const stepCount = Math.floor(decorationLine.rect.width / (2 * step));
    const remainingWidth = decorationLine.rect.width - stepCount * 2 * step;
    const adjustment = remainingWidth / stepCount / 2;
    step += adjustment;
    const cp1y = decorationLine.rect.y + dist;
    const cp2y = decorationLine.rect.y - dist;
    let { x } = decorationLine.rect;
    ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);
    for (let i2 = 0; i2 < stepCount; i2 += 1) {
      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, decorationLine.rect.y);
      x += 2 * step;
    }
  } else {
    ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);
    ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y);
    if (/double/.test(decorationLine.style)) {
      ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y + decorationLine.rect.height * 2);
      ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y + decorationLine.rect.height * 2);
    }
  }
  ctx.stroke(decorationLine.color);
  ctx.restore();
}, "renderDecorationLine");
var renderLine = /* @__PURE__ */ __name((ctx, line2) => {
  if (!line2.box)
    return;
  const lineAscent = line2.ascent || 0;
  ctx.save();
  ctx.translate(line2.box.x, line2.box.y + lineAscent);
  for (let i2 = 0; i2 < line2.runs.length; i2 += 1) {
    const run = line2.runs[i2];
    const isLastRun = i2 === line2.runs.length - 1;
    if (run.attributes.backgroundColor) {
      const xAdvance = run.xAdvance ?? 0;
      const overflowRight = isLastRun ? line2.overflowRight ?? 0 : 0;
      const backgroundRect = {
        x: 0,
        y: -lineAscent,
        height: line2.box.height,
        width: xAdvance - overflowRight
      };
      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);
    }
    renderRun(ctx, run);
  }
  ctx.restore();
  ctx.save();
  ctx.translate(line2.box.x, line2.box.y);
  if (line2.decorationLines) {
    for (let i2 = 0; i2 < line2.decorationLines.length; i2 += 1) {
      const decorationLine = line2.decorationLines[i2];
      renderDecorationLine(ctx, decorationLine);
    }
  }
  ctx.restore();
}, "renderLine");
var renderBlock = /* @__PURE__ */ __name((ctx, block) => {
  block.forEach((line2) => {
    renderLine(ctx, line2);
  });
}, "renderBlock");
var renderText = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  if (!node.lines)
    return;
  const { top, left } = node.box;
  const blocks = [node.lines];
  const paddingTop = node.box?.paddingTop || 0;
  const paddingLeft = node.box?.paddingLeft || 0;
  const initialY = node.lines[0] ? node.lines[0].box.y : 0;
  const offsetX = node.alignOffset || 0;
  ctx.save();
  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);
  blocks.forEach((block) => {
    renderBlock(ctx, block);
  });
  ctx.restore();
}, "renderText");
var renderPage = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  const { width, height: height2 } = node.box;
  const dpi = node.props?.dpi || 72;
  const userUnit = dpi / 72;
  ctx.addPage({ size: [width, height2], margin: 0, userUnit });
}, "renderPage");
var renderNote = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  const { top, left } = node.box;
  const value2 = node?.children?.[0].value || "";
  const color = node.style?.backgroundColor;
  ctx.note(left, top, 0, 0, value2, { color });
}, "renderNote");
var embedImage = /* @__PURE__ */ __name((ctx, node) => {
  const src = node.image.data;
  let image;
  if (typeof src === "string") {
    image = ctx._imageRegistry[src];
  }
  if (!image) {
    image = ctx.openImage(src);
  }
  if (!image.obj) {
    image.embed(ctx);
  }
  return image;
}, "embedImage");
var isNumeric = /* @__PURE__ */ __name((n5) => {
  return !Number.isNaN(parseFloat(n5)) && Number.isFinite(n5);
}, "isNumeric");
var applyContainObjectFit = /* @__PURE__ */ __name((cw, ch, iw, ih, px2, py2) => {
  const cr = cw / ch;
  const ir = iw / ih;
  const pxp = matchPercent(px2 ?? null);
  const pyp = matchPercent(py2 ?? null);
  const pxv = pxp ? pxp.percent : 0.5;
  const pyv = pyp ? pyp.percent : 0.5;
  if (cr > ir) {
    const height3 = ch;
    const width2 = height3 * ir;
    const yOffset2 = isNumeric(py2) ? py2 : 0;
    const xOffset2 = isNumeric(px2) ? px2 : (cw - width2) * pxv;
    return { width: width2, height: height3, xOffset: xOffset2, yOffset: yOffset2 };
  }
  const width = cw;
  const height2 = width / ir;
  const xOffset = isNumeric(px2) ? px2 : 0;
  const yOffset = isNumeric(py2) ? py2 : (ch - height2) * pyv;
  return { width, height: height2, yOffset, xOffset };
}, "applyContainObjectFit");
var applyNoneObjectFit = /* @__PURE__ */ __name((cw, ch, iw, ih, px2, py2) => {
  const width = iw;
  const height2 = ih;
  const pxp = matchPercent(px2 ?? null);
  const pyp = matchPercent(py2 ?? null);
  const pxv = pxp ? pxp.percent : 0.5;
  const pyv = pyp ? pyp.percent : 0.5;
  const xOffset = isNumeric(px2) ? px2 : (cw - width) * pxv;
  const yOffset = isNumeric(py2) ? py2 : (ch - height2) * pyv;
  return { width, height: height2, xOffset, yOffset };
}, "applyNoneObjectFit");
var applyCoverObjectFit = /* @__PURE__ */ __name((cw, ch, iw, ih, px2, py2) => {
  const ir = iw / ih;
  const cr = cw / ch;
  const pxp = matchPercent(px2 ?? null);
  const pyp = matchPercent(py2 ?? null);
  const pxv = pxp ? pxp.percent : 0.5;
  const pyv = pyp ? pyp.percent : 0.5;
  if (cr > ir) {
    const width2 = cw;
    const height3 = width2 / ir;
    const xOffset2 = isNumeric(px2) ? px2 : 0;
    const yOffset2 = isNumeric(py2) ? py2 : (ch - height3) * pyv;
    return { width: width2, height: height3, yOffset: yOffset2, xOffset: xOffset2 };
  }
  const height2 = ch;
  const width = height2 * ir;
  const xOffset = isNumeric(px2) ? px2 : (cw - width) * pxv;
  const yOffset = isNumeric(py2) ? py2 : 0;
  return { width, height: height2, xOffset, yOffset };
}, "applyCoverObjectFit");
var applyScaleDownObjectFit = /* @__PURE__ */ __name((cw, ch, iw, ih, px2, py2) => {
  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px2, py2);
  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px2, py2);
  return containDimension.width < noneDimension.width ? containDimension : noneDimension;
}, "applyScaleDownObjectFit");
var applyFillObjectFit = /* @__PURE__ */ __name((cw, ch, px2, py2) => {
  return {
    width: cw,
    height: ch,
    xOffset: matchPercent(px2 ?? null) ? 0 : px2 || 0,
    yOffset: matchPercent(py2 ?? null) ? 0 : py2 || 0
  };
}, "applyFillObjectFit");
var resolveObjectFit = /* @__PURE__ */ __name((type2 = "fill", cw, ch, iw, ih, px2, py2) => {
  switch (type2) {
    case "contain":
      return applyContainObjectFit(cw, ch, iw, ih, px2, py2);
    case "cover":
      return applyCoverObjectFit(cw, ch, iw, ih, px2, py2);
    case "none":
      return applyNoneObjectFit(cw, ch, iw, ih, px2, py2);
    case "scale-down":
      return applyScaleDownObjectFit(cw, ch, iw, ih, px2, py2);
    default:
      return applyFillObjectFit(cw, ch, px2, py2);
  }
}, "resolveObjectFit");
var drawImage = /* @__PURE__ */ __name((ctx, node, options) => {
  if (!node.box)
    return;
  if (!node.image)
    return;
  const { left, top } = node.box;
  const opacity = node.style?.opacity;
  const objectFit = node.style?.objectFit;
  const objectPositionX = node.style?.objectPositionX;
  const objectPositionY = node.style?.objectPositionY;
  const paddingTop = node.box.paddingTop || 0;
  const paddingRight = node.box.paddingRight || 0;
  const paddingBottom = node.box.paddingBottom || 0;
  const paddingLeft = node.box.paddingLeft || 0;
  const imageCache = options.imageCache || /* @__PURE__ */ new Map();
  const { width, height: height2, xOffset, yOffset } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);
  if (node.image.data) {
    if (width !== 0 && height2 !== 0) {
      const cacheKey = node.image.key;
      const image = imageCache.get(cacheKey) || embedImage(ctx, node);
      if (cacheKey)
        imageCache.set(cacheKey, image);
      const imageOpacity = isNil(opacity) ? 1 : opacity;
      ctx.fillOpacity(imageOpacity).image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {
        width,
        height: height2
      });
    } else {
      console.warn(`Image with src '${JSON.stringify(node.props.src || node.props.source)}' skipped due to invalid dimensions`);
    }
  }
}, "drawImage");
var renderImage = /* @__PURE__ */ __name((ctx, node, options) => {
  ctx.save();
  clipNode(ctx, node);
  drawImage(ctx, node, options);
  ctx.restore();
}, "renderImage");
var CONTENT_COLOR = "#a1c6e7";
var PADDING_COLOR = "#c4deb9";
var MARGIN_COLOR = "#f8cca1";
var debugContent = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  const { left, top, width, height: height2, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0 } = node.box;
  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height2 - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();
}, "debugContent");
var debugPadding = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  const { left, top, width, height: height2, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0 } = node.box;
  ctx.fillColor(PADDING_COLOR).opacity(0.5);
  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill();
  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height2 - borderTopWidth - borderBottomWidth).fill();
  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height2 - borderTopWidth - borderBottomWidth).fill();
  ctx.rect(left + paddingLeft + borderLeftWidth, top + height2 - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();
}, "debugPadding");
var debugMargin = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  const { left, top, width, height: height2 } = node.box;
  const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0 } = node.box;
  ctx.fillColor(MARGIN_COLOR).opacity(0.5);
  ctx.rect(left, top - marginTop, width, marginTop).fill();
  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height2 + marginTop + marginBottom).fill();
  ctx.rect(left + width, top - marginTop, marginRight, height2 + marginTop + marginBottom).fill();
  ctx.rect(left, top + height2, width, marginBottom).fill();
}, "debugMargin");
var debugText = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  const { left, top, width, height: height2 } = node.box;
  const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0 } = node.box;
  const roundedWidth = Math.round(width + marginLeft + marginRight);
  const roundedHeight = Math.round(height2 + marginTop + marginBottom);
  ctx.fontSize(6).opacity(1).fillColor("black").text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1), { width: Infinity });
}, "debugText");
var debugOrigin = /* @__PURE__ */ __name((ctx, node) => {
  if (node.origin) {
    ctx.circle(node.origin.left, node.origin.top, 3).fill("red").circle(node.origin.left, node.origin.top, 5).stroke("red");
  }
}, "debugOrigin");
var renderDebug = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.props)
    return;
  if (!("debug" in node.props) || !node.props.debug)
    return;
  ctx.save();
  debugContent(ctx, node);
  debugPadding(ctx, node);
  debugMargin(ctx, node);
  debugText(ctx, node);
  debugOrigin(ctx, node);
  ctx.restore();
}, "renderDebug");
var availableMethods = [
  "dash",
  "clip",
  "save",
  "path",
  "fill",
  "font",
  "text",
  "rect",
  "scale",
  "moveTo",
  "lineTo",
  "stroke",
  "rotate",
  "circle",
  "lineCap",
  "opacity",
  "ellipse",
  "polygon",
  "restore",
  "lineJoin",
  "fontSize",
  "fillColor",
  "lineWidth",
  "translate",
  "miterLimit",
  "strokeColor",
  "fillOpacity",
  "roundedRect",
  "fillAndStroke",
  "strokeOpacity",
  "bezierCurveTo",
  "quadraticCurveTo",
  "linearGradient",
  "radialGradient"
];
var painter = /* @__PURE__ */ __name((ctx) => {
  const p3 = availableMethods.reduce((acc, prop) => ({
    ...acc,
    [prop]: (...args) => {
      ctx[prop](...args);
      return p3;
    }
  }), {});
  return p3;
}, "painter");
var renderCanvas = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const paddingTop = node.box.paddingTop || 0;
  const paddingLeft = node.box.paddingLeft || 0;
  const paddingRight = node.box.paddingRight || 0;
  const paddingBottom = node.box.paddingBottom || 0;
  const availableWidth = width - paddingLeft - paddingRight;
  const availableHeight = height2 - paddingTop - paddingBottom;
  if (!availableWidth || !availableHeight) {
    console.warn("Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.");
  }
  ctx.save().translate(left + paddingLeft, top + paddingTop);
  if (node.props.paint) {
    node.props.paint(painter(ctx), availableWidth, availableHeight);
  }
  ctx.restore();
}, "renderCanvas");
var KAPPA2 = 4 * ((Math.sqrt(2) - 1) / 3);
var clipBorderTop = /* @__PURE__ */ __name((ctx, layout2, style, rtr, rtl) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderTopWidth, borderRightWidth, borderLeftWidth } = style;
  ctx.moveTo(left + rtl, top);
  ctx.lineTo(left + width - rtr, top);
  const c0 = rtr * (1 - KAPPA2);
  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);
  const topRightYCoord = top + Math.max(borderTopWidth, rtr);
  ctx.lineTo(left + width, topRightYCoord);
  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);
  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);
  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);
  const c1 = innerTopRightRadiusX * (1 - KAPPA2);
  const c2 = innerTopRightRadiusY * (1 - KAPPA2);
  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);
  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);
  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);
  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);
  const c3 = innerTopLeftRadiusX * (1 - KAPPA2);
  const c4 = innerTopLeftRadiusY * (1 - KAPPA2);
  const topLeftYCoord = top + Math.max(borderTopWidth, rtl);
  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);
  ctx.lineTo(left, topLeftYCoord);
  ctx.lineTo(left, top + rtl);
  const c5 = rtl * (1 - KAPPA2);
  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);
  ctx.closePath();
  ctx.clip();
  if (borderRightWidth) {
    const trSlope = -borderTopWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left, top);
    ctx.lineTo(left, top + height2);
    ctx.closePath();
    ctx.clip();
  }
  if (borderLeftWidth) {
    const trSlope = -borderTopWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left, top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left + width, top + height2);
    ctx.closePath();
    ctx.clip();
  }
}, "clipBorderTop");
var fillBorderTop = /* @__PURE__ */ __name((ctx, layout2, style, rtr, rtl) => {
  const { top, left, width } = layout2;
  const { borderTopColor, borderTopWidth, borderTopStyle, borderRightWidth, borderLeftWidth } = style;
  const c0 = rtl * (1 - KAPPA2);
  const c1 = rtr * (1 - KAPPA2);
  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));
  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);
  ctx.lineTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);
  ctx.strokeColor(borderTopColor);
  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);
  if (borderTopStyle === "dashed") {
    ctx.dash(borderTopWidth * 2, { space: borderTopWidth * 1.2 });
  } else if (borderTopStyle === "dotted") {
    ctx.dash(borderTopWidth, { space: borderTopWidth * 1.2 });
  }
  ctx.stroke();
  ctx.undash();
}, "fillBorderTop");
var clipBorderRight = /* @__PURE__ */ __name((ctx, layout2, style, rtr, rbr) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderTopWidth, borderRightWidth, borderBottomWidth } = style;
  ctx.moveTo(left + width, top + rtr);
  ctx.lineTo(left + width, top + height2 - rbr);
  const c0 = rbr * (1 - KAPPA2);
  ctx.bezierCurveTo(left + width, top + height2 - c0, left + width - c0, top + height2, left + width - rbr, top + height2);
  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);
  ctx.lineTo(topBottomXCoord, top + height2);
  ctx.lineTo(topBottomXCoord, top + height2 - borderBottomWidth);
  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);
  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);
  const c1 = innerBottomRightRadiusX * (1 - KAPPA2);
  const c2 = innerBottomRightRadiusY * (1 - KAPPA2);
  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height2 - borderBottomWidth, left + width - borderRightWidth, top + height2 - borderBottomWidth - c2, left + width - borderRightWidth, top + height2 - Math.max(rbr, borderBottomWidth));
  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));
  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);
  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);
  const c3 = innerTopRightRadiusX * (1 - KAPPA2);
  const c4 = innerTopRightRadiusY * (1 - KAPPA2);
  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);
  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);
  ctx.lineTo(topRightXCoord, top);
  ctx.lineTo(left + width - rtr, top);
  const c5 = rtr * (1 - KAPPA2);
  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);
  ctx.closePath();
  ctx.clip();
  if (borderTopWidth) {
    const trSlope = -borderTopWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left, top + height2);
    ctx.closePath();
    ctx.clip();
  }
  if (borderBottomWidth) {
    const brSlope = borderBottomWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left, top);
    ctx.closePath();
    ctx.clip();
  }
}, "clipBorderRight");
var fillBorderRight = /* @__PURE__ */ __name((ctx, layout2, style, rtr, rbr) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderRightColor, borderRightStyle, borderRightWidth, borderTopWidth, borderBottomWidth } = style;
  const c0 = rbr * (1 - KAPPA2);
  const c1 = rtr * (1 - KAPPA2);
  ctx.moveTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);
  ctx.lineTo(left + width, top + height2 - rbr);
  ctx.bezierCurveTo(left + width, top + height2 - c0, left + width - c0, top + height2, left + width - rbr, top + height2);
  ctx.strokeColor(borderRightColor);
  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);
  if (borderRightStyle === "dashed") {
    ctx.dash(borderRightWidth * 2, { space: borderRightWidth * 1.2 });
  } else if (borderRightStyle === "dotted") {
    ctx.dash(borderRightWidth, { space: borderRightWidth * 1.2 });
  }
  ctx.stroke();
  ctx.undash();
}, "fillBorderRight");
var clipBorderBottom = /* @__PURE__ */ __name((ctx, layout2, style, rbl, rbr) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderBottomWidth, borderRightWidth, borderLeftWidth } = style;
  ctx.moveTo(left + width - rbr, top + height2);
  ctx.lineTo(left + rbl, top + height2);
  const c0 = rbl * (1 - KAPPA2);
  ctx.bezierCurveTo(left + c0, top + height2, left, top + height2 - c0, left, top + height2 - rbl);
  const bottomLeftYCoord = top + height2 - Math.max(borderBottomWidth, rbl);
  ctx.lineTo(left, bottomLeftYCoord);
  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);
  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);
  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);
  const c1 = innerBottomLeftRadiusX * (1 - KAPPA2);
  const c2 = innerBottomLeftRadiusY * (1 - KAPPA2);
  ctx.bezierCurveTo(left + borderLeftWidth, top + height2 - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height2 - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height2 - borderBottomWidth);
  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height2 - borderBottomWidth);
  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);
  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);
  const c3 = innerBottomRightRadiusX * (1 - KAPPA2);
  const c4 = innerBottomRightRadiusY * (1 - KAPPA2);
  const bottomRightYCoord = top + height2 - Math.max(borderBottomWidth, rbr);
  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height2 - borderBottomWidth, left + width - borderRightWidth, top + height2 - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);
  ctx.lineTo(left + width, bottomRightYCoord);
  ctx.lineTo(left + width, top + height2 - rbr);
  const c5 = rbr * (1 - KAPPA2);
  ctx.bezierCurveTo(left + width, top + height2 - c5, left + width - c5, top + height2, left + width - rbr, top + height2);
  ctx.closePath();
  ctx.clip();
  if (borderRightWidth) {
    const brSlope = borderBottomWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left, top);
    ctx.closePath();
    ctx.clip();
  }
  if (borderLeftWidth) {
    const trSlope = -borderBottomWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height2);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left + width, top);
    ctx.closePath();
    ctx.clip();
  }
}, "clipBorderBottom");
var fillBorderBottom = /* @__PURE__ */ __name((ctx, layout2, style, rbl, rbr) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderBottomColor, borderBottomStyle, borderBottomWidth, borderRightWidth, borderLeftWidth } = style;
  const c0 = rbl * (1 - KAPPA2);
  const c1 = rbr * (1 - KAPPA2);
  ctx.moveTo(left + width, top + height2 - rbr);
  ctx.bezierCurveTo(left + width, top + height2 - c1, left + width - c1, top + height2, left + width - rbr, top + height2);
  ctx.lineTo(left + rbl, top + height2);
  ctx.bezierCurveTo(left + c0, top + height2, left, top + height2 - c0, left, top + height2 - rbl);
  ctx.strokeColor(borderBottomColor);
  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);
  if (borderBottomStyle === "dashed") {
    ctx.dash(borderBottomWidth * 2, { space: borderBottomWidth * 1.2 });
  } else if (borderBottomStyle === "dotted") {
    ctx.dash(borderBottomWidth, { space: borderBottomWidth * 1.2 });
  }
  ctx.stroke();
  ctx.undash();
}, "fillBorderBottom");
var clipBorderLeft = /* @__PURE__ */ __name((ctx, layout2, style, rbl, rtl) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderTopWidth, borderLeftWidth, borderBottomWidth } = style;
  ctx.moveTo(left, top + height2 - rbl);
  ctx.lineTo(left, top + rtl);
  const c0 = rtl * (1 - KAPPA2);
  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);
  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);
  ctx.lineTo(topLeftCoordX, top);
  ctx.lineTo(topLeftCoordX, top + borderTopWidth);
  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);
  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);
  const c1 = innerTopLeftRadiusX * (1 - KAPPA2);
  const c2 = innerTopLeftRadiusY * (1 - KAPPA2);
  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));
  ctx.lineTo(left + borderLeftWidth, top + height2 - Math.max(rbl, borderBottomWidth));
  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);
  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);
  const c3 = innerBottomLeftRadiusX * (1 - KAPPA2);
  const c4 = innerBottomLeftRadiusY * (1 - KAPPA2);
  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);
  ctx.bezierCurveTo(left + borderLeftWidth, top + height2 - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height2 - borderBottomWidth, bottomLeftXCoord, top + height2 - borderBottomWidth);
  ctx.lineTo(bottomLeftXCoord, top + height2);
  ctx.lineTo(left + rbl, top + height2);
  const c5 = rbl * (1 - KAPPA2);
  ctx.bezierCurveTo(left + c5, top + height2, left, top + height2 - c5, left, top + height2 - rbl);
  ctx.closePath();
  ctx.clip();
  if (borderBottomWidth) {
    const trSlope = -borderBottomWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height2);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left, top);
    ctx.lineTo(left + width, top);
    ctx.closePath();
    ctx.clip();
  }
  if (borderBottomWidth) {
    const trSlope = -borderTopWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left, top);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.closePath();
    ctx.clip();
  }
}, "clipBorderLeft");
var fillBorderLeft = /* @__PURE__ */ __name((ctx, layout2, style, rbl, rtl) => {
  const { top, left, height: height2 } = layout2;
  const { borderLeftColor, borderLeftStyle, borderLeftWidth, borderTopWidth, borderBottomWidth } = style;
  const c0 = rbl * (1 - KAPPA2);
  const c1 = rtl * (1 - KAPPA2);
  ctx.moveTo(left + rbl, top + height2);
  ctx.bezierCurveTo(left + c0, top + height2, left, top + height2 - c0, left, top + height2 - rbl);
  ctx.lineTo(left, top + rtl);
  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);
  ctx.strokeColor(borderLeftColor);
  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);
  if (borderLeftStyle === "dashed") {
    ctx.dash(borderLeftWidth * 2, { space: borderLeftWidth * 1.2 });
  } else if (borderLeftStyle === "dotted") {
    ctx.dash(borderLeftWidth, { space: borderLeftWidth * 1.2 });
  }
  ctx.stroke();
  ctx.undash();
}, "fillBorderLeft");
var shouldRenderBorders = /* @__PURE__ */ __name((node) => node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth), "shouldRenderBorders");
var renderBorders = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  if (!shouldRenderBorders(node))
    return;
  const { width, height: height2, borderTopWidth = 0, borderLeftWidth = 0, borderRightWidth = 0, borderBottomWidth = 0 } = node.box;
  const { opacity = 1, borderTopColor = "black", borderTopStyle = "solid", borderLeftColor = "black", borderLeftStyle = "solid", borderRightColor = "black", borderRightStyle = "solid", borderBottomColor = "black", borderBottomStyle = "solid" } = node.style;
  const borderTopLeftRadius = node.style.borderTopLeftRadius || 0;
  const borderTopRightRadius = node.style.borderTopRightRadius || 0;
  const borderBottomLeftRadius = node.style.borderBottomLeftRadius || 0;
  const borderBottomRightRadius = node.style.borderBottomRightRadius || 0;
  const style = {
    borderTopColor,
    borderTopWidth,
    borderTopStyle,
    borderLeftColor,
    borderLeftWidth,
    borderLeftStyle,
    borderRightColor,
    borderRightWidth,
    borderRightStyle,
    borderBottomColor,
    borderBottomWidth,
    borderBottomStyle
  };
  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height2);
  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height2);
  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height2);
  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height2);
  ctx.save();
  ctx.strokeOpacity(opacity);
  if (borderTopWidth) {
    ctx.save();
    clipBorderTop(ctx, node.box, style, rtr, rtl);
    fillBorderTop(ctx, node.box, style, rtr, rtl);
    ctx.restore();
  }
  if (borderRightWidth) {
    ctx.save();
    clipBorderRight(ctx, node.box, style, rtr, rbr);
    fillBorderRight(ctx, node.box, style, rtr, rbr);
    ctx.restore();
  }
  if (borderBottomWidth) {
    ctx.save();
    clipBorderBottom(ctx, node.box, style, rbl, rbr);
    fillBorderBottom(ctx, node.box, style, rbl, rbr);
    ctx.restore();
  }
  if (borderLeftWidth) {
    ctx.save();
    clipBorderLeft(ctx, node.box, style, rbl, rtl);
    fillBorderLeft(ctx, node.box, style, rbl, rtl);
    ctx.restore();
  }
  ctx.restore();
}, "renderBorders");
var drawBackground = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const color = parseColor(node.style.backgroundColor);
  const nodeOpacity = isNil(node.style?.opacity) ? 1 : node.style.opacity;
  const opacity = Math.min(color.opacity, nodeOpacity);
  ctx.fillOpacity(opacity).fillColor(color.value).rect(left, top, width, height2).fill();
}, "drawBackground");
var renderBackground = /* @__PURE__ */ __name((ctx, node) => {
  const hasBackground = !!node.box && !!node.style?.backgroundColor;
  if (hasBackground) {
    ctx.save();
    clipNode(ctx, node);
    drawBackground(ctx, node);
    ctx.restore();
  }
}, "renderBackground");
var isString3 = /* @__PURE__ */ __name((value2) => typeof value2 === "string", "isString");
var isSrcId = /* @__PURE__ */ __name((value2) => /^#.+/.test(value2), "isSrcId");
var renderLink = /* @__PURE__ */ __name((ctx, node, src) => {
  if (!src || !node.box)
    return;
  const isId = isSrcId(src);
  const method = isId ? "goTo" : "link";
  const value2 = isId ? src.slice(1) : src;
  const { top, left, width, height: height2 } = node.box;
  ctx[method](left, top, width, height2, value2);
}, "renderLink");
var setLink = /* @__PURE__ */ __name((ctx, node) => {
  const props = node.props || {};
  if ("src" in props && isString3(props.src))
    return renderLink(ctx, node, props.src);
  if ("href" in props && isString3(props.href))
    return renderLink(ctx, node, props.href);
}, "setLink");
var setDestination = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  if (!node.props)
    return;
  if ("id" in node.props) {
    ctx.addNamedDestination(node.props.id, "XYZ", null, node.box.top, null);
  }
}, "setDestination");
var clean = /* @__PURE__ */ __name((options) => {
  const opt = { ...options };
  Object.entries(opt).forEach((pair) => {
    if (!pair[1]) {
      delete opt[pair[0]];
    }
  });
  return opt;
}, "clean");
var parseCommonFormOptions = /* @__PURE__ */ __name((node) => {
  return {
    required: node.props?.required || false,
    noExport: node.props?.noExport || false,
    readOnly: node.props?.readOnly || false,
    value: node.props?.value || void 0,
    defaultValue: node.props?.defaultValue || void 0
  };
}, "parseCommonFormOptions");
var parseTextInputOptions = /* @__PURE__ */ __name((node, fieldSet) => {
  return clean({
    ...parseCommonFormOptions(node),
    parent: fieldSet || void 0,
    align: node.props?.align || "left",
    multiline: node.props?.multiline || void 0,
    password: node.props?.password || false,
    noSpell: node.props?.noSpell || false,
    format: node.props?.format || void 0,
    fontSize: node.props?.fontSize || void 0,
    MaxLen: node.props?.maxLength || void 0
  });
}, "parseTextInputOptions");
var parseSelectAndListFieldOptions = /* @__PURE__ */ __name((node) => {
  return clean({
    ...parseCommonFormOptions(node),
    sort: node.props?.sort || false,
    edit: node.props?.edit || false,
    multiSelect: node.props?.multiSelect || false,
    noSpell: node.props?.noSpell || false,
    select: node.props?.select || [""]
  });
}, "parseSelectAndListFieldOptions");
var getAppearance = /* @__PURE__ */ __name((ctx, codepoint, width, height2) => {
  const appearance = ctx.ref({
    Type: "XObject",
    Subtype: "Form",
    BBox: [0, 0, width, height2],
    Resources: {
      ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
      Font: {
        ZaDi: ctx._acroform.fonts.ZaDi
      }
    }
  });
  appearance.initDeflate();
  appearance.write(`/Tx BMC
q
/ZaDi ${height2 * 0.8} Tf
BT
${width * 0.45} ${height2 / 4} Td (${codepoint}) Tj
ET
Q
EMC`);
  appearance.end(null);
  return appearance;
}, "getAppearance");
var parseCheckboxOptions = /* @__PURE__ */ __name((ctx, node, fieldSet) => {
  const { width, height: height2 } = node.box || {};
  const onOption = node.props?.onState || "Yes";
  const offOption = node.props?.offState || "Off";
  const xMark = node.props?.xMark || false;
  if (!Object.prototype.hasOwnProperty.call(ctx._acroform.fonts, "ZaDi")) {
    const ref2 = ctx.ref({
      Type: "Font",
      Subtype: "Type1",
      BaseFont: "ZapfDingbats"
    });
    ctx._acroform.fonts.ZaDi = ref2;
    ref2.end(null);
  }
  const normalAppearance = {
    [onOption]: getAppearance(ctx, xMark ? "8" : "4", width, height2),
    [offOption]: getAppearance(ctx, xMark ? " " : "8", width, height2)
  };
  return clean({
    ...parseCommonFormOptions(node),
    backgroundColor: node.props?.backgroundColor || void 0,
    borderColor: node.props?.borderColor || void 0,
    parent: fieldSet || void 0,
    value: `/${node.props?.checked === true ? onOption : offOption}`,
    defaultValue: `/${node.props?.checked === true ? onOption : offOption}`,
    AS: node.props?.checked === true ? onOption : offOption,
    AP: { N: normalAppearance, D: normalAppearance }
  });
}, "parseCheckboxOptions");
var renderTextInput = /* @__PURE__ */ __name((ctx, node, options) => {
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const name = node.props?.name || "";
  const fieldSetOptions = options.fieldSets?.at(0);
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formText(name, left, top, width, height2, parseTextInputOptions(node, fieldSetOptions));
}, "renderTextInput");
var renderSelect = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const name = node.props?.name || "";
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formCombo(name, left, top, width, height2, parseSelectAndListFieldOptions(node));
}, "renderSelect");
var renderFieldSet = /* @__PURE__ */ __name((ctx, node, options) => {
  const name = node.props?.name || "";
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  const formField = ctx.formField(name);
  const option = options;
  if (!option.fieldSets) {
    option.fieldSets = [formField];
  } else {
    option.fieldSets.push(formField);
  }
}, "renderFieldSet");
var cleanUpFieldSet = /* @__PURE__ */ __name((_ctx, _node, options) => {
  options.fieldSets.pop();
}, "cleanUpFieldSet");
var renderList = /* @__PURE__ */ __name((ctx, node) => {
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box || {};
  const name = "name" in node.props ? node.props.name || "" : "";
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formList(name, left, top, width, height2, parseSelectAndListFieldOptions(node));
}, "renderList");
var renderCheckbox = /* @__PURE__ */ __name((ctx, node, options) => {
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const name = node.props?.name || "";
  const fieldSetOptions = options.fieldSets?.at(0);
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formCheckbox(name, left, top, width, height2, parseCheckboxOptions(ctx, node, fieldSetOptions));
}, "renderCheckbox");
var isRecursiveNode = /* @__PURE__ */ __name((node) => node.type !== Text && node.type !== Svg, "isRecursiveNode");
var renderChildren = /* @__PURE__ */ __name((ctx, node, options) => {
  ctx.save();
  if (node.box) {
    ctx.translate(node.box.left, node.box.top);
  }
  const children = node.children || [];
  const renderChild = /* @__PURE__ */ __name((child) => renderNode(ctx, child, options), "renderChild");
  children.forEach(renderChild);
  ctx.restore();
}, "renderChildren");
var renderFns = {
  [Text]: renderText,
  [Note]: renderNote,
  [Image]: renderImage,
  [FieldSet]: renderFieldSet,
  [TextInput]: renderTextInput,
  [Select]: renderSelect,
  [Checkbox]: renderCheckbox,
  [List]: renderList,
  [Canvas]: renderCanvas,
  [Svg]: renderSvg,
  [Link]: setLink
};
var cleanUpFns = {
  [FieldSet]: cleanUpFieldSet
};
var renderNode = /* @__PURE__ */ __name((ctx, node, options) => {
  const overflowHidden = node.style?.overflow === "hidden";
  const shouldRenderChildren = isRecursiveNode(node);
  if (node.type === Page)
    renderPage(ctx, node);
  ctx.save();
  if (overflowHidden)
    clipNode(ctx, node);
  applyTransformations(ctx, node);
  renderBackground(ctx, node);
  renderBorders(ctx, node);
  const renderFn = renderFns[node.type];
  if (renderFn)
    renderFn(ctx, node, options);
  if (shouldRenderChildren)
    renderChildren(ctx, node, options);
  const cleanUpFn = cleanUpFns[node.type];
  if (cleanUpFn)
    cleanUpFn(ctx, node, options);
  setDestination(ctx, node);
  renderDebug(ctx, node);
  ctx.restore();
}, "renderNode");
var addNodeBookmark = /* @__PURE__ */ __name((ctx, node, pageNumber, registry) => {
  if (!node.box)
    return;
  if (!node.props)
    return;
  if ("bookmark" in node.props && node.props.bookmark) {
    const bookmark = node.props.bookmark;
    const { title: title4, parent, expanded, zoom, fit } = bookmark;
    const outline = registry[parent] || ctx.outline;
    const top = bookmark.top || node.box.top;
    const left = bookmark.left || node.box.left;
    const instance = outline.addItem(title4, {
      pageNumber,
      expanded,
      top,
      left,
      zoom,
      fit
    });
    registry[bookmark.ref] = instance;
  }
  if (!node.children)
    return;
  node.children.forEach((child) => addNodeBookmark(ctx, child, pageNumber, registry));
}, "addNodeBookmark");
var addBookmarks = /* @__PURE__ */ __name((ctx, root) => {
  const registry = {};
  const pages = root.children || [];
  pages.forEach((page, i2) => {
    addNodeBookmark(ctx, page, i2, registry);
  });
}, "addBookmarks");
var render = /* @__PURE__ */ __name((ctx, doc) => {
  const pages = doc.children || [];
  const options = { imageCache: /* @__PURE__ */ new Map(), fieldSets: [] };
  pages.forEach((page) => renderNode(ctx, page, options));
  addBookmarks(ctx, doc);
  ctx.end();
  return ctx;
}, "render");

// ../../node_modules/.pnpm/@react-pdf+layout@4.4.2/node_modules/@react-pdf/layout/lib/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/@react-pdf+stylesheet@6.1.2/node_modules/@react-pdf/stylesheet/lib/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_media_engine = __toESM(require_src(), 1);
var import_hsl_to_hex = __toESM(require_hsl_to_hex(), 1);
var import_color_string2 = __toESM(require_color_string(), 1);
var import_parse = __toESM(require_parse(), 1);
var import_unit = __toESM(require_unit(), 1);
var compact = /* @__PURE__ */ __name((array) => array.filter(Boolean), "compact");
var mergeStyles = /* @__PURE__ */ __name((styles11) => styles11.reduce((acc, style) => {
  const s4 = Array.isArray(style) ? flatten(style) : style;
  Object.keys(s4).forEach((key) => {
    if (s4[key] !== null && s4[key] !== void 0) {
      acc[key] = s4[key];
    }
  });
  return acc;
}, {}), "mergeStyles");
var flatten = compose2(mergeStyles, compact, castArray);
var resolveMediaQueries = /* @__PURE__ */ __name((container, style) => {
  return Object.keys(style).reduce((acc, key) => {
    if (/@media/.test(key)) {
      return {
        ...acc,
        ...(0, import_media_engine.default)({ [key]: style[key] }, container)
      };
    }
    return { ...acc, [key]: style[key] };
  }, {});
}, "resolveMediaQueries");
var isRgb = /* @__PURE__ */ __name((value2) => /rgba?/g.test(value2), "isRgb");
var isHsl = /* @__PURE__ */ __name((value2) => /hsla?/g.test(value2), "isHsl");
var parseRgb = /* @__PURE__ */ __name((value2) => {
  const rgb = import_color_string2.default.get.rgb(value2);
  return import_color_string2.default.to.hex(rgb);
}, "parseRgb");
var parseHsl = /* @__PURE__ */ __name((value2) => {
  const hsl = import_color_string2.default.get.hsl(value2).map(Math.round);
  const hex = (0, import_hsl_to_hex.default)(...hsl);
  return hex.toUpperCase();
}, "parseHsl");
var transformColor = /* @__PURE__ */ __name((value2) => {
  if (isRgb(value2))
    return parseRgb(value2);
  if (isHsl(value2))
    return parseHsl(value2);
  return value2;
}, "transformColor");
var parseValue = /* @__PURE__ */ __name((value2) => {
  if (typeof value2 === "number")
    return { value: value2, unit: void 0 };
  const match2 = /^(-?\d*\.?\d+)(in|mm|cm|pt|vh|vw|px|rem)?$/g.exec(value2);
  return match2 ? { value: parseFloat(match2[1]), unit: match2[2] || "pt" } : { value: value2, unit: void 0 };
}, "parseValue");
var transformUnit = /* @__PURE__ */ __name((container, value2) => {
  const scalar = parseValue(value2);
  const outputDpi = 72;
  const inputDpi = container.dpi || 72;
  const mmFactor = 1 / 25.4 * outputDpi;
  const cmFactor = 1 / 2.54 * outputDpi;
  if (typeof scalar.value !== "number")
    return scalar.value;
  switch (scalar.unit) {
    case "rem":
      return scalar.value * (container.remBase || 18);
    case "in":
      return scalar.value * outputDpi;
    case "mm":
      return scalar.value * mmFactor;
    case "cm":
      return scalar.value * cmFactor;
    case "vh":
      return scalar.value * (container.height / 100);
    case "vw":
      return scalar.value * (container.width / 100);
    case "px":
      return Math.round(scalar.value * (outputDpi / inputDpi));
    default:
      return scalar.value;
  }
}, "transformUnit");
var processNumberValue = /* @__PURE__ */ __name((key, value2) => ({
  [key]: parseFloat$1(value2)
}), "processNumberValue");
var processUnitValue = /* @__PURE__ */ __name((key, value2, container) => ({
  [key]: transformUnit(container, value2)
}), "processUnitValue");
var processColorValue = /* @__PURE__ */ __name((key, value2) => {
  const result = { [key]: transformColor(value2) };
  return result;
}, "processColorValue");
var processNoopValue = /* @__PURE__ */ __name((key, value2) => ({
  [key]: value2
}), "processNoopValue");
var BORDER_SHORTHAND_REGEX = /(-?\d+(\.\d+)?(in|mm|cm|pt|vw|vh|px|rem)?)\s(\S+)\s(.+)/;
var matchBorderShorthand = /* @__PURE__ */ __name((value2) => value2.match(BORDER_SHORTHAND_REGEX) || [], "matchBorderShorthand");
var resolveBorderShorthand = /* @__PURE__ */ __name((key, value2, container) => {
  const match2 = matchBorderShorthand(`${value2}`);
  if (match2) {
    const widthMatch = match2[1] || value2;
    const styleMatch = match2[4] || value2;
    const colorMatch = match2[5] || value2;
    const style = styleMatch;
    const color = colorMatch ? transformColor(colorMatch) : void 0;
    const width = widthMatch ? transformUnit(container, widthMatch) : void 0;
    if (key.match(/(Top|Right|Bottom|Left)$/)) {
      return {
        [`${key}Color`]: color,
        [`${key}Style`]: style,
        [`${key}Width`]: width
      };
    }
    if (key.match(/Color$/)) {
      return {
        borderTopColor: color,
        borderRightColor: color,
        borderBottomColor: color,
        borderLeftColor: color
      };
    }
    if (key.match(/Style$/)) {
      if (typeof style === "number")
        throw new Error(`Invalid border style: ${style}`);
      return {
        borderTopStyle: style,
        borderRightStyle: style,
        borderBottomStyle: style,
        borderLeftStyle: style
      };
    }
    if (key.match(/Width$/)) {
      if (typeof width !== "number")
        throw new Error(`Invalid border width: ${width}`);
      return {
        borderTopWidth: width,
        borderRightWidth: width,
        borderBottomWidth: width,
        borderLeftWidth: width
      };
    }
    if (key.match(/Radius$/)) {
      const radius = value2 ? transformUnit(container, value2) : void 0;
      if (typeof radius !== "number")
        throw new Error(`Invalid border radius: ${radius}`);
      return {
        borderTopLeftRadius: radius,
        borderTopRightRadius: radius,
        borderBottomRightRadius: radius,
        borderBottomLeftRadius: radius
      };
    }
    if (typeof width !== "number")
      throw new Error(`Invalid border width: ${width}`);
    if (typeof style === "number")
      throw new Error(`Invalid border style: ${style}`);
    return {
      borderTopColor: color,
      borderTopStyle: style,
      borderTopWidth: width,
      borderRightColor: color,
      borderRightStyle: style,
      borderRightWidth: width,
      borderBottomColor: color,
      borderBottomStyle: style,
      borderBottomWidth: width,
      borderLeftColor: color,
      borderLeftStyle: style,
      borderLeftWidth: width
    };
  }
  return { [key]: value2 };
}, "resolveBorderShorthand");
var handlers$b = {
  border: resolveBorderShorthand,
  borderBottom: resolveBorderShorthand,
  borderBottomColor: processColorValue,
  borderBottomLeftRadius: processUnitValue,
  borderBottomRightRadius: processUnitValue,
  borderBottomStyle: processNoopValue,
  borderBottomWidth: processUnitValue,
  borderColor: resolveBorderShorthand,
  borderLeft: resolveBorderShorthand,
  borderLeftColor: processColorValue,
  borderLeftStyle: processNoopValue,
  borderLeftWidth: processUnitValue,
  borderRadius: resolveBorderShorthand,
  borderRight: resolveBorderShorthand,
  borderRightColor: processColorValue,
  borderRightStyle: processNoopValue,
  borderRightWidth: processUnitValue,
  borderStyle: resolveBorderShorthand,
  borderTop: resolveBorderShorthand,
  borderTopColor: processColorValue,
  borderTopLeftRadius: processUnitValue,
  borderTopRightRadius: processUnitValue,
  borderTopStyle: processNoopValue,
  borderTopWidth: processUnitValue,
  borderWidth: resolveBorderShorthand
};
var handlers$a = {
  backgroundColor: processColorValue,
  color: processColorValue,
  opacity: processNumberValue
};
var handlers$9 = {
  height: processUnitValue,
  maxHeight: processUnitValue,
  maxWidth: processUnitValue,
  minHeight: processUnitValue,
  minWidth: processUnitValue,
  width: processUnitValue
};
var flexDefaults = [1, 1, 0];
var flexAuto = [1, 1, "auto"];
var processFlexShorthand = /* @__PURE__ */ __name((key, value2, container) => {
  let defaults = flexDefaults;
  let matches = [];
  if (value2 === "auto") {
    defaults = flexAuto;
  } else {
    matches = `${value2}`.split(" ");
  }
  const flexGrow = parseFloat$1(matches[0] || defaults[0]);
  const flexShrink = parseFloat$1(matches[1] || defaults[1]);
  const flexBasis = transformUnit(container, matches[2] || defaults[2]);
  return { flexGrow, flexShrink, flexBasis };
}, "processFlexShorthand");
var handlers$8 = {
  alignContent: processNoopValue,
  alignItems: processNoopValue,
  alignSelf: processNoopValue,
  flex: processFlexShorthand,
  flexBasis: processUnitValue,
  flexDirection: processNoopValue,
  flexFlow: processNoopValue,
  flexGrow: processNumberValue,
  flexShrink: processNumberValue,
  flexWrap: processNoopValue,
  justifyContent: processNoopValue,
  justifySelf: processNoopValue
};
var processGapShorthand = /* @__PURE__ */ __name((key, value2, container) => {
  const match2 = `${value2}`.split(" ");
  const rowGap = transformUnit(container, match2?.[0] || value2);
  const columnGap = transformUnit(container, match2?.[1] || value2);
  return { rowGap, columnGap };
}, "processGapShorthand");
var handlers$7 = {
  gap: processGapShorthand,
  columnGap: processUnitValue,
  rowGap: processUnitValue
};
var handlers$6 = {
  aspectRatio: processNumberValue,
  bottom: processUnitValue,
  display: processNoopValue,
  left: processUnitValue,
  position: processNoopValue,
  right: processUnitValue,
  top: processUnitValue,
  overflow: processNoopValue,
  zIndex: processNumberValue
};
var BOX_MODEL_UNITS = "px,in,mm,cm,pt,%,vw,vh";
var logError = /* @__PURE__ */ __name((style, value2) => {
  const name = style.toString();
  console.error(`
    @react-pdf/stylesheet parsing error:
    ${name}: ${value2},
    ${" ".repeat(name.length + 2)}^
    Unsupported ${name} value format
  `);
}, "logError");
var expandBoxModel = /* @__PURE__ */ __name(({ expandsTo, maxValues = 1, autoSupported = false } = {}) => (model, value2, container) => {
  const nodes = (0, import_parse.default)(`${value2}`);
  const parts = [];
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    if (node.type === "function" || node.type === "string" || node.type === "div") {
      logError(model, value2);
      return {};
    }
    if (node.type === "word") {
      if (node.value === "auto" && autoSupported) {
        parts.push(node.value);
      } else {
        const result = (0, import_unit.default)(node.value);
        if (result && BOX_MODEL_UNITS.includes(result.unit)) {
          parts.push(node.value);
        } else {
          logError(model, value2);
          return {};
        }
      }
    }
  }
  if (parts.length > maxValues) {
    logError(model, value2);
    return {};
  }
  const first = transformUnit(container, parts[0]);
  if (expandsTo) {
    const second = transformUnit(container, parts[1] || parts[0]);
    const third = transformUnit(container, parts[2] || parts[0]);
    const fourth = transformUnit(container, parts[3] || parts[1] || parts[0]);
    return expandsTo({ first, second, third, fourth });
  }
  return {
    [model]: first
  };
}, "expandBoxModel");
var processMargin = expandBoxModel({
  expandsTo: /* @__PURE__ */ __name(({ first, second, third, fourth }) => ({
    marginTop: first,
    marginRight: second,
    marginBottom: third,
    marginLeft: fourth
  }), "expandsTo"),
  maxValues: 4,
  autoSupported: true
});
var processMarginVertical = expandBoxModel({
  expandsTo: /* @__PURE__ */ __name(({ first, second }) => ({
    marginTop: first,
    marginBottom: second
  }), "expandsTo"),
  maxValues: 2,
  autoSupported: true
});
var processMarginHorizontal = expandBoxModel({
  expandsTo: /* @__PURE__ */ __name(({ first, second }) => ({
    marginRight: first,
    marginLeft: second
  }), "expandsTo"),
  maxValues: 2,
  autoSupported: true
});
var processMarginSingle = expandBoxModel({
  autoSupported: true
});
var handlers$5 = {
  margin: processMargin,
  marginBottom: processMarginSingle,
  marginHorizontal: processMarginHorizontal,
  marginLeft: processMarginSingle,
  marginRight: processMarginSingle,
  marginTop: processMarginSingle,
  marginVertical: processMarginVertical
};
var processPadding = expandBoxModel({
  expandsTo: /* @__PURE__ */ __name(({ first, second, third, fourth }) => ({
    paddingTop: first,
    paddingRight: second,
    paddingBottom: third,
    paddingLeft: fourth
  }), "expandsTo"),
  maxValues: 4
});
var processPaddingVertical = expandBoxModel({
  expandsTo: /* @__PURE__ */ __name(({ first, second }) => ({
    paddingTop: first,
    paddingBottom: second
  }), "expandsTo"),
  maxValues: 2
});
var processPaddingHorizontal = expandBoxModel({
  expandsTo: /* @__PURE__ */ __name(({ first, second }) => ({
    paddingRight: first,
    paddingLeft: second
  }), "expandsTo"),
  maxValues: 2
});
var processPaddingSingle = expandBoxModel();
var handlers$4 = {
  padding: processPadding,
  paddingBottom: processPaddingSingle,
  paddingHorizontal: processPaddingHorizontal,
  paddingLeft: processPaddingSingle,
  paddingRight: processPaddingSingle,
  paddingTop: processPaddingSingle,
  paddingVertical: processPaddingVertical
};
var offsetKeyword = /* @__PURE__ */ __name((value2) => {
  switch (value2) {
    case "top":
    case "left":
      return "0%";
    case "right":
    case "bottom":
      return "100%";
    case "center":
      return "50%";
    default:
      return value2;
  }
}, "offsetKeyword");
var processObjectPosition = /* @__PURE__ */ __name((key, value2, container) => {
  const match2 = `${value2}`.split(" ");
  const objectPositionX = offsetKeyword(transformUnit(container, match2?.[0] || value2));
  const objectPositionY = offsetKeyword(transformUnit(container, match2?.[1] || value2));
  return { objectPositionX, objectPositionY };
}, "processObjectPosition");
var processObjectPositionValue = /* @__PURE__ */ __name((key, value2, container) => ({
  [key]: offsetKeyword(transformUnit(container, value2))
}), "processObjectPositionValue");
var handlers$3 = {
  objectPosition: processObjectPosition,
  objectPositionX: processObjectPositionValue,
  objectPositionY: processObjectPositionValue,
  objectFit: processNoopValue
};
var castInt = /* @__PURE__ */ __name((value2) => {
  if (typeof value2 === "number")
    return value2;
  return parseInt(value2, 10);
}, "castInt");
var FONT_WEIGHTS2 = {
  thin: 100,
  hairline: 100,
  ultralight: 200,
  extralight: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  demibold: 600,
  bold: 700,
  ultrabold: 800,
  extrabold: 800,
  heavy: 900,
  black: 900
};
var transformFontWeight = /* @__PURE__ */ __name((value2) => {
  if (!value2)
    return FONT_WEIGHTS2.normal;
  if (typeof value2 === "number")
    return value2;
  const lv = value2.toLowerCase();
  if (FONT_WEIGHTS2[lv])
    return FONT_WEIGHTS2[lv];
  return castInt(value2);
}, "transformFontWeight");
var processFontWeight = /* @__PURE__ */ __name((key, value2) => {
  return { [key]: transformFontWeight(value2) };
}, "processFontWeight");
var transformLineHeight = /* @__PURE__ */ __name((value2, styles11, container) => {
  if (value2 === "")
    return value2;
  const fontSize = transformUnit(container, styles11.fontSize || 18);
  const lineHeight = transformUnit(container, value2);
  const { percent } = matchPercent(lineHeight) || {};
  if (percent)
    return percent * fontSize;
  return isNaN(value2) ? lineHeight : lineHeight * fontSize;
}, "transformLineHeight");
var processLineHeight = /* @__PURE__ */ __name((key, value2, container, styles11) => {
  return {
    [key]: transformLineHeight(value2, styles11, container)
  };
}, "processLineHeight");
var handlers$2 = {
  direction: processNoopValue,
  fontFamily: processNoopValue,
  fontSize: processUnitValue,
  fontStyle: processNoopValue,
  fontWeight: processFontWeight,
  letterSpacing: processUnitValue,
  lineHeight: processLineHeight,
  maxLines: processNumberValue,
  textAlign: processNoopValue,
  textDecoration: processNoopValue,
  textDecorationColor: processColorValue,
  textDecorationStyle: processNoopValue,
  textIndent: processNoopValue,
  textOverflow: processNoopValue,
  textTransform: processNoopValue,
  verticalAlign: processNoopValue
};
var matchNumber = /* @__PURE__ */ __name((value2) => typeof value2 === "string" && /^-?\d*\.?\d*$/.test(value2), "matchNumber");
var castFloat = /* @__PURE__ */ __name((value2) => {
  if (typeof value2 !== "string")
    return value2;
  if (matchNumber(value2))
    return parseFloat(value2);
  return value2;
}, "castFloat");
var parse2 = /* @__PURE__ */ __name((transformString) => {
  const transforms = transformString.trim().split(/\)[ ,]|\)/);
  if (transforms.length === 1) {
    return [[transforms[0], true]];
  }
  const parsed = [];
  for (let i2 = 0; i2 < transforms.length; i2 += 1) {
    const transform = transforms[i2];
    if (transform) {
      const [name, rawValue] = transform.split("(");
      const splitChar = rawValue.indexOf(",") >= 0 ? "," : " ";
      const value2 = rawValue.split(splitChar).map((val) => val.trim());
      parsed.push({ operation: name.trim(), value: value2 });
    }
  }
  return parsed;
}, "parse");
var parseAngle = /* @__PURE__ */ __name((value2) => {
  const unitsRegexp = /(-?\d*\.?\d*)(\w*)?/i;
  const [, angle, unit] = unitsRegexp.exec(value2);
  const number3 = Number.parseFloat(angle);
  return unit === "rad" ? number3 * 180 / Math.PI : number3;
}, "parseAngle");
var normalizeTransformOperation = /* @__PURE__ */ __name(({ operation, value: value2 }) => {
  switch (operation) {
    case "scale": {
      const [scaleX, scaleY = scaleX] = value2.map((num) => Number.parseFloat(num));
      return { operation: "scale", value: [scaleX, scaleY] };
    }
    case "scaleX": {
      return { operation: "scale", value: [Number.parseFloat(value2), 1] };
    }
    case "scaleY": {
      return { operation: "scale", value: [1, Number.parseFloat(value2)] };
    }
    case "rotate": {
      return { operation: "rotate", value: [parseAngle(value2)] };
    }
    case "translate": {
      return {
        operation: "translate",
        value: value2.map((num) => Number.parseFloat(num))
      };
    }
    case "translateX": {
      return {
        operation: "translate",
        value: [Number.parseFloat(value2), 0]
      };
    }
    case "translateY": {
      return { operation: "translate", value: [0, Number.parseFloat(value2)] };
    }
    case "skew": {
      return { operation: "skew", value: value2.map(parseAngle) };
    }
    case "skewX": {
      return { operation: "skew", value: [parseAngle(value2), 0] };
    }
    case "skewY": {
      return { operation: "skew", value: [0, parseAngle(value2)] };
    }
    default: {
      return { operation, value: value2.map((num) => Number.parseFloat(num)) };
    }
  }
}, "normalizeTransformOperation");
var normalize2 = /* @__PURE__ */ __name((operations) => {
  return operations.map((operation) => normalizeTransformOperation(operation));
}, "normalize");
var processTransform = /* @__PURE__ */ __name((key, value2) => {
  if (typeof value2 !== "string")
    return { [key]: value2 };
  return { [key]: normalize2(parse2(value2)) };
}, "processTransform");
var Y_AXIS_SHORTHANDS = { top: true, bottom: true };
var sortTransformOriginPair = /* @__PURE__ */ __name((a4, b3) => {
  if (Y_AXIS_SHORTHANDS[a4])
    return 1;
  if (Y_AXIS_SHORTHANDS[b3])
    return -1;
  return 0;
}, "sortTransformOriginPair");
var getTransformOriginPair = /* @__PURE__ */ __name((values) => {
  if (!values || values.length === 0)
    return ["center", "center"];
  const pair = values.length === 1 ? [values[0], "center"] : values;
  return pair.sort(sortTransformOriginPair);
}, "getTransformOriginPair");
var processTransformOriginShorthand = /* @__PURE__ */ __name((key, value2, container) => {
  const match2 = `${value2}`.split(" ");
  const pair = getTransformOriginPair(match2);
  const transformOriginX = transformUnit(container, pair[0]);
  const transformOriginY = transformUnit(container, pair[1]);
  return {
    transformOriginX: offsetKeyword(transformOriginX) || castFloat(transformOriginX),
    transformOriginY: offsetKeyword(transformOriginY) || castFloat(transformOriginY)
  };
}, "processTransformOriginShorthand");
var processTransformOriginValue = /* @__PURE__ */ __name((key, value2, container) => {
  const v3 = transformUnit(container, value2);
  return { [key]: offsetKeyword(v3) || castFloat(v3) };
}, "processTransformOriginValue");
var handlers$1 = {
  transform: processTransform,
  gradientTransform: processTransform,
  transformOrigin: processTransformOriginShorthand,
  transformOriginX: processTransformOriginValue,
  transformOriginY: processTransformOriginValue
};
var handlers = {
  fill: processColorValue,
  stroke: processColorValue,
  strokeDasharray: processNoopValue,
  strokeWidth: processUnitValue,
  fillOpacity: processNumberValue,
  strokeOpacity: processNumberValue,
  fillRule: processNoopValue,
  textAnchor: processNoopValue,
  strokeLinecap: processNoopValue,
  strokeLinejoin: processNoopValue,
  visibility: processNoopValue,
  clipPath: processNoopValue,
  dominantBaseline: processNoopValue
};
var shorthands = {
  ...handlers$b,
  ...handlers$a,
  ...handlers$9,
  ...handlers$8,
  ...handlers$7,
  ...handlers$6,
  ...handlers$5,
  ...handlers$4,
  ...handlers$3,
  ...handlers$2,
  ...handlers$1,
  ...handlers
};
var resolve = /* @__PURE__ */ __name((container) => (style) => {
  const propsArray = Object.keys(style);
  const resolvedStyle = {};
  for (let i2 = 0; i2 < propsArray.length; i2 += 1) {
    const key = propsArray[i2];
    const value2 = style[key];
    if (!shorthands[key]) {
      resolvedStyle[key] = value2;
      continue;
    }
    const resolved = shorthands[key](key, value2, container, style);
    const keys2 = Object.keys(resolved);
    for (let j = 0; j < keys2.length; j += 1) {
      const propName = keys2[j];
      const propValue = resolved[propName];
      resolvedStyle[propName] = propValue;
    }
  }
  return resolvedStyle;
}, "resolve");
var resolveStyles = /* @__PURE__ */ __name((container, style) => {
  const computeMediaQueries = /* @__PURE__ */ __name((value2) => resolveMediaQueries(container, value2), "computeMediaQueries");
  return compose2(resolve(container), computeMediaQueries, flatten)(style);
}, "resolveStyles");

// ../../node_modules/.pnpm/@react-pdf+textkit@6.1.0/node_modules/@react-pdf/textkit/lib/textkit.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/bidi-js@1.0.3/node_modules/bidi-js/dist/bidi.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function bidiFactory() {
  var bidi2 = function(exports) {
    var DATA = {
      "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      "B": "a,3,f+2,2v,690",
      "S": "9,2,k",
      "WS": "c,k,4f4,1vk+a,u,1j,335",
      "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      "LRO": "6ct",
      "RLO": "6cu",
      "LRE": "6cq",
      "RLE": "6cr",
      "PDF": "6cs",
      "LRI": "6ee",
      "RLI": "6ef",
      "FSI": "6eg",
      "PDI": "6eh"
    };
    var TYPES = {};
    var TYPES_TO_NAMES = {};
    TYPES.L = 1;
    TYPES_TO_NAMES[1] = "L";
    Object.keys(DATA).forEach(function(type2, i2) {
      TYPES[type2] = 1 << i2 + 1;
      TYPES_TO_NAMES[TYPES[type2]] = type2;
    });
    Object.freeze(TYPES);
    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;
    var map = null;
    function parseData() {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        var loop = /* @__PURE__ */ __name(function(type3) {
          if (DATA.hasOwnProperty(type3)) {
            var lastCode = 0;
            DATA[type3].split(",").forEach(function(range2) {
              var ref2 = range2.split("+");
              var skip = ref2[0];
              var step = ref2[1];
              skip = parseInt(skip, 36);
              step = step ? parseInt(step, 36) : 0;
              map.set(lastCode += skip, TYPES[type3]);
              for (var i2 = 0; i2 < step; i2++) {
                map.set(++lastCode, TYPES[type3]);
              }
            });
          }
        }, "loop");
        for (var type2 in DATA) loop(type2);
      }
    }
    __name(parseData, "parseData");
    function getBidiCharType(char) {
      parseData();
      return map.get(char.codePointAt(0)) || TYPES.L;
    }
    __name(getBidiCharType, "getBidiCharType");
    function getBidiCharTypeName(char) {
      return TYPES_TO_NAMES[getBidiCharType(char)];
    }
    __name(getBidiCharTypeName, "getBidiCharTypeName");
    var data$1 = {
      "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function parseCharacterMap(encodedString, includeReverse) {
      var radix = 36;
      var lastCode = 0;
      var map2 = /* @__PURE__ */ new Map();
      var reverseMap = includeReverse && /* @__PURE__ */ new Map();
      var prevPair;
      encodedString.split(",").forEach(/* @__PURE__ */ __name(function visit(entry) {
        if (entry.indexOf("+") !== -1) {
          for (var i2 = +entry; i2--; ) {
            visit(prevPair);
          }
        } else {
          prevPair = entry;
          var ref2 = entry.split(">");
          var a4 = ref2[0];
          var b3 = ref2[1];
          a4 = String.fromCodePoint(lastCode += parseInt(a4, radix));
          b3 = String.fromCodePoint(lastCode += parseInt(b3, radix));
          map2.set(a4, b3);
          includeReverse && reverseMap.set(b3, a4);
        }
      }, "visit"));
      return { map: map2, reverseMap };
    }
    __name(parseCharacterMap, "parseCharacterMap");
    var openToClose, closeToOpen, canonical;
    function parse$12() {
      if (!openToClose) {
        var ref2 = parseCharacterMap(data$1.pairs, true);
        var map2 = ref2.map;
        var reverseMap = ref2.reverseMap;
        openToClose = map2;
        closeToOpen = reverseMap;
        canonical = parseCharacterMap(data$1.canonical, false).map;
      }
    }
    __name(parse$12, "parse$1");
    function openingToClosingBracket(char) {
      parse$12();
      return openToClose.get(char) || null;
    }
    __name(openingToClosingBracket, "openingToClosingBracket");
    function closingToOpeningBracket(char) {
      parse$12();
      return closeToOpen.get(char) || null;
    }
    __name(closingToOpeningBracket, "closingToOpeningBracket");
    function getCanonicalBracket(char) {
      parse$12();
      return canonical.get(char) || null;
    }
    __name(getCanonicalBracket, "getCanonicalBracket");
    var TYPE_L = TYPES.L;
    var TYPE_R = TYPES.R;
    var TYPE_EN = TYPES.EN;
    var TYPE_ES = TYPES.ES;
    var TYPE_ET = TYPES.ET;
    var TYPE_AN = TYPES.AN;
    var TYPE_CS = TYPES.CS;
    var TYPE_B = TYPES.B;
    var TYPE_S = TYPES.S;
    var TYPE_ON = TYPES.ON;
    var TYPE_BN = TYPES.BN;
    var TYPE_NSM = TYPES.NSM;
    var TYPE_AL = TYPES.AL;
    var TYPE_LRO = TYPES.LRO;
    var TYPE_RLO = TYPES.RLO;
    var TYPE_LRE = TYPES.LRE;
    var TYPE_RLE = TYPES.RLE;
    var TYPE_PDF = TYPES.PDF;
    var TYPE_LRI = TYPES.LRI;
    var TYPE_RLI = TYPES.RLI;
    var TYPE_FSI = TYPES.FSI;
    var TYPE_PDI = TYPES.PDI;
    function getEmbeddingLevels(string, baseDirection) {
      var MAX_DEPTH = 125;
      var charTypes = new Uint32Array(string.length);
      for (var i2 = 0; i2 < string.length; i2++) {
        charTypes[i2] = getBidiCharType(string[i2]);
      }
      var charTypeCounts = /* @__PURE__ */ new Map();
      function changeCharType(i3, type3) {
        var oldType = charTypes[i3];
        charTypes[i3] = type3;
        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
        if (oldType & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
        }
        charTypeCounts.set(type3, (charTypeCounts.get(type3) || 0) + 1);
        if (type3 & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
        }
      }
      __name(changeCharType, "changeCharType");
      var embedLevels = new Uint8Array(string.length);
      var isolationPairs = /* @__PURE__ */ new Map();
      var paragraphs = [];
      var paragraph = null;
      for (var i$1 = 0; i$1 < string.length; i$1++) {
        if (!paragraph) {
          paragraphs.push(paragraph = {
            start: i$1,
            end: string.length - 1,
            // 3.3.1 P2-P3: Determine the paragraph level
            level: baseDirection === "rtl" ? 1 : baseDirection === "ltr" ? 0 : determineAutoEmbedLevel(i$1, false)
          });
        }
        if (charTypes[i$1] & TYPE_B) {
          paragraph.end = i$1;
          paragraph = null;
        }
      }
      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
      var nextEven = /* @__PURE__ */ __name(function(n5) {
        return n5 + (n5 & 1 ? 1 : 2);
      }, "nextEven");
      var nextOdd = /* @__PURE__ */ __name(function(n5) {
        return n5 + (n5 & 1 ? 2 : 1);
      }, "nextOdd");
      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
        paragraph = paragraphs[paraIdx];
        var statusStack = [{
          _level: paragraph.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }];
        var stackTop = void 0;
        var overflowIsolateCount = 0;
        var overflowEmbeddingCount = 0;
        var validIsolateCount = 0;
        charTypeCounts.clear();
        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
          var charType = charTypes[i$2];
          stackTop = statusStack[statusStack.length - 1];
          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
          if (charType & NEUTRAL_ISOLATE_TYPES) {
            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
          }
          if (charType & FORMATTING_TYPES) {
            if (charType & (TYPE_RLE | TYPE_LRE)) {
              embedLevels[i$2] = stackTop._level;
              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level,
                  _override: 0,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & (TYPE_RLO | TYPE_LRO)) {
              embedLevels[i$2] = stackTop._level;
              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level$1,
                  _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & ISOLATE_INIT_TYPES) {
              if (charType & TYPE_FSI) {
                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
              }
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
                validIsolateCount++;
                statusStack.push({
                  _level: level$2,
                  _override: 0,
                  _isolate: 1,
                  _isolInitIndex: i$2
                });
              } else {
                overflowIsolateCount++;
              }
            } else if (charType & TYPE_PDI) {
              if (overflowIsolateCount > 0) {
                overflowIsolateCount--;
              } else if (validIsolateCount > 0) {
                overflowEmbeddingCount = 0;
                while (!statusStack[statusStack.length - 1]._isolate) {
                  statusStack.pop();
                }
                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
                if (isolInitIndex != null) {
                  isolationPairs.set(isolInitIndex, i$2);
                  isolationPairs.set(i$2, isolInitIndex);
                }
                statusStack.pop();
                validIsolateCount--;
              }
              stackTop = statusStack[statusStack.length - 1];
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
            } else if (charType & TYPE_PDF) {
              if (overflowIsolateCount === 0) {
                if (overflowEmbeddingCount > 0) {
                  overflowEmbeddingCount--;
                } else if (!stackTop._isolate && statusStack.length > 1) {
                  statusStack.pop();
                  stackTop = statusStack[statusStack.length - 1];
                }
              }
              embedLevels[i$2] = stackTop._level;
            } else if (charType & TYPE_B) {
              embedLevels[i$2] = paragraph.level;
            }
          } else {
            embedLevels[i$2] = stackTop._level;
            if (stackTop._override && charType !== TYPE_BN) {
              changeCharType(i$2, stackTop._override);
            }
          }
        }
        var levelRuns = [];
        var currentRun = null;
        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
          var charType$1 = charTypes[i$3];
          if (!(charType$1 & BN_LIKE_TYPES)) {
            var lvl = embedLevels[i$3];
            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
            var isPDI = charType$1 === TYPE_PDI;
            if (currentRun && lvl === currentRun._level) {
              currentRun._end = i$3;
              currentRun._endsWithIsolInit = isIsolInit;
            } else {
              levelRuns.push(currentRun = {
                _start: i$3,
                _end: i$3,
                _level: lvl,
                _startsWithPDI: isPDI,
                _endsWithIsolInit: isIsolInit
              });
            }
          }
        }
        var isolatingRunSeqs = [];
        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
          var run = levelRuns[runIdx];
          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {
            var seqRuns = [currentRun = run];
            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null; ) {
              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
                if (levelRuns[i$4]._start === pdiIndex) {
                  seqRuns.push(currentRun = levelRuns[i$4]);
                  break;
                }
              }
            }
            var seqIndices = [];
            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
              var run$1 = seqRuns[i$5];
              for (var j = run$1._start; j <= run$1._end; j++) {
                seqIndices.push(j);
              }
            }
            var firstLevel = embedLevels[seqIndices[0]];
            var prevLevel = paragraph.level;
            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {
                prevLevel = embedLevels[i$6];
                break;
              }
            }
            var lastIndex = seqIndices[seqIndices.length - 1];
            var lastLevel = embedLevels[lastIndex];
            var nextLevel = paragraph.level;
            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {
                  nextLevel = embedLevels[i$7];
                  break;
                }
              }
            }
            isolatingRunSeqs.push({
              _seqIndices: seqIndices,
              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
            });
          }
        }
        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
          var ref2 = isolatingRunSeqs[seqIdx];
          var seqIndices$1 = ref2._seqIndices;
          var sosType = ref2._sosType;
          var eosType = ref2._eosType;
          var embedDirection = embedLevels[seqIndices$1[0]] & 1 ? TYPE_R : TYPE_L;
          if (charTypeCounts.get(TYPE_NSM)) {
            for (var si = 0; si < seqIndices$1.length; si++) {
              var i$8 = seqIndices$1[si];
              if (charTypes[i$8] & TYPE_NSM) {
                var prevType = sosType;
                for (var sj = si - 1; sj >= 0; sj--) {
                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {
                    prevType = charTypes[seqIndices$1[sj]];
                    break;
                  }
                }
                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
              var i$9 = seqIndices$1[si$1];
              if (charTypes[i$9] & TYPE_EN) {
                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
                  if (prevCharType & STRONG_TYPES) {
                    if (prevCharType === TYPE_AL) {
                      changeCharType(i$9, TYPE_AN);
                    }
                    break;
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_AL)) {
            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
              var i$10 = seqIndices$1[si$2];
              if (charTypes[i$10] & TYPE_AL) {
                changeCharType(i$10, TYPE_R);
              }
            }
          }
          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
              var i$11 = seqIndices$1[si$3];
              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
                var prevType$1 = 0, nextType = 0;
                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
                  prevType$1 = charTypes[seqIndices$1[sj$2]];
                  if (!(prevType$1 & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
                  nextType = charTypes[seqIndices$1[sj$3]];
                  if (!(nextType & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {
                  changeCharType(i$11, prevType$1);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
              var i$12 = seqIndices$1[si$4];
              if (charTypes[i$12] & TYPE_EN) {
                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {
                  changeCharType(seqIndices$1[sj$4], TYPE_EN);
                }
                for (si$4++; si$4 < seqIndices$1.length && charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN); si$4++) {
                  if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {
                    changeCharType(seqIndices$1[si$4], TYPE_EN);
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
              var i$13 = seqIndices$1[si$5];
              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
                changeCharType(i$13, TYPE_ON);
                for (var sj$5 = si$5 - 1; sj$5 >= 0 && charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES; sj$5--) {
                  changeCharType(seqIndices$1[sj$5], TYPE_ON);
                }
                for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6++) {
                  changeCharType(seqIndices$1[sj$6], TYPE_ON);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
              var i$14 = seqIndices$1[si$6];
              var type2 = charTypes[i$14];
              if (type2 & TYPE_EN) {
                if (prevStrongType === TYPE_L) {
                  changeCharType(i$14, TYPE_L);
                }
              } else if (type2 & STRONG_TYPES) {
                prevStrongType = type2;
              }
            }
          }
          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;
            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;
            var bracketPairs = [];
            {
              var openerStack = [];
              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
                  var char = string[seqIndices$1[si$7]];
                  var oppositeBracket = void 0;
                  if (openingToClosingBracket(char) !== null) {
                    if (openerStack.length < 63) {
                      openerStack.push({ char, seqIndex: si$7 });
                    } else {
                      break;
                    }
                  } else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
                      var stackChar = openerStack[stackIdx].char;
                      if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {
                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
                        openerStack.length = stackIdx;
                        break;
                      }
                    }
                  }
                }
              }
              bracketPairs.sort(function(a4, b3) {
                return a4[0] - b3[0];
              });
            }
            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
              var ref$1 = bracketPairs[pairIdx];
              var openSeqIdx = ref$1[0];
              var closeSeqIdx = ref$1[1];
              var foundStrongType = false;
              var useStrongType = 0;
              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
                var i$15 = seqIndices$1[si$8];
                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
                  foundStrongType = true;
                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                  if (lr === embedDirection) {
                    useStrongType = lr;
                    break;
                  }
                }
              }
              if (foundStrongType && !useStrongType) {
                useStrongType = sosType;
                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
                  var i$16 = seqIndices$1[si$9];
                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    if (lr$1 !== embedDirection) {
                      useStrongType = lr$1;
                    } else {
                      useStrongType = embedDirection;
                    }
                    break;
                  }
                }
              }
              if (useStrongType) {
                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
                if (useStrongType !== embedDirection) {
                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$10]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
                if (useStrongType !== embedDirection) {
                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$11]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
              }
            }
            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
                var niRunStart = si$12, niRunEnd = si$12;
                var prevType$2 = sosType;
                for (var si2 = si$12 - 1; si2 >= 0; si2--) {
                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
                    niRunStart = si2;
                  } else {
                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                var nextType$1 = eosType;
                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                    niRunEnd = si2$1;
                  } else {
                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {
                  charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;
                }
                si$12 = niRunEnd;
              }
            }
          }
        }
        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
          var level$3 = embedLevels[i$17];
          var type$1 = charTypes[i$17];
          if (level$3 & 1) {
            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
              embedLevels[i$17]++;
            }
          } else {
            if (type$1 & TYPE_R) {
              embedLevels[i$17]++;
            } else if (type$1 & (TYPE_AN | TYPE_EN)) {
              embedLevels[i$17] += 2;
            }
          }
          if (type$1 & BN_LIKE_TYPES) {
            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
          }
          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {
              embedLevels[j$1] = paragraph.level;
            }
          }
        }
      }
      return {
        levels: embedLevels,
        paragraphs
      };
      function determineAutoEmbedLevel(start2, isFSI) {
        for (var i3 = start2; i3 < string.length; i3++) {
          var charType2 = charTypes[i3];
          if (charType2 & (TYPE_R | TYPE_AL)) {
            return 1;
          }
          if (charType2 & (TYPE_B | TYPE_L) || isFSI && charType2 === TYPE_PDI) {
            return 0;
          }
          if (charType2 & ISOLATE_INIT_TYPES) {
            var pdi = indexOfMatchingPDI(i3);
            i3 = pdi === -1 ? string.length : pdi;
          }
        }
        return 0;
      }
      __name(determineAutoEmbedLevel, "determineAutoEmbedLevel");
      function indexOfMatchingPDI(isolateStart) {
        var isolationLevel = 1;
        for (var i3 = isolateStart + 1; i3 < string.length; i3++) {
          var charType2 = charTypes[i3];
          if (charType2 & TYPE_B) {
            break;
          }
          if (charType2 & TYPE_PDI) {
            if (--isolationLevel === 0) {
              return i3;
            }
          } else if (charType2 & ISOLATE_INIT_TYPES) {
            isolationLevel++;
          }
        }
        return -1;
      }
      __name(indexOfMatchingPDI, "indexOfMatchingPDI");
    }
    __name(getEmbeddingLevels, "getEmbeddingLevels");
    var data2 = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";
    var mirrorMap;
    function parse3() {
      if (!mirrorMap) {
        var ref2 = parseCharacterMap(data2, true);
        var map2 = ref2.map;
        var reverseMap = ref2.reverseMap;
        reverseMap.forEach(function(value2, key) {
          map2.set(key, value2);
        });
        mirrorMap = map2;
      }
    }
    __name(parse3, "parse");
    function getMirroredCharacter(char) {
      parse3();
      return mirrorMap.get(char) || null;
    }
    __name(getMirroredCharacter, "getMirroredCharacter");
    function getMirroredCharactersMap(string, embeddingLevels, start2, end2) {
      var strLen = string.length;
      start2 = Math.max(0, start2 == null ? 0 : +start2);
      end2 = Math.min(strLen - 1, end2 == null ? strLen - 1 : +end2);
      var map2 = /* @__PURE__ */ new Map();
      for (var i2 = start2; i2 <= end2; i2++) {
        if (embeddingLevels[i2] & 1) {
          var mirror = getMirroredCharacter(string[i2]);
          if (mirror !== null) {
            map2.set(i2, mirror);
          }
        }
      }
      return map2;
    }
    __name(getMirroredCharactersMap, "getMirroredCharactersMap");
    function getReorderSegments(string, embeddingLevelsResult, start2, end2) {
      var strLen = string.length;
      start2 = Math.max(0, start2 == null ? 0 : +start2);
      end2 = Math.min(strLen - 1, end2 == null ? strLen - 1 : +end2);
      var segments = [];
      embeddingLevelsResult.paragraphs.forEach(function(paragraph) {
        var lineStart = Math.max(start2, paragraph.start);
        var lineEnd = Math.min(end2, paragraph.end);
        if (lineStart < lineEnd) {
          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);
          for (var i2 = lineEnd; i2 >= lineStart && getBidiCharType(string[i2]) & TRAILING_TYPES; i2--) {
            lineLevels[i2] = paragraph.level;
          }
          var maxLevel = paragraph.level;
          var minOddLevel = Infinity;
          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
            var level = lineLevels[i$1];
            if (level > maxLevel) {
              maxLevel = level;
            }
            if (level < minOddLevel) {
              minOddLevel = level | 1;
            }
          }
          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
              if (lineLevels[i$2] >= lvl) {
                var segStart = i$2;
                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
                  i$2++;
                }
                if (i$2 > segStart) {
                  segments.push([segStart + lineStart, i$2 + lineStart]);
                }
              }
            }
          }
        }
      });
      return segments;
    }
    __name(getReorderSegments, "getReorderSegments");
    function getReorderedString(string, embedLevelsResult, start2, end2) {
      var indices = getReorderedIndices2(string, embedLevelsResult, start2, end2);
      var chars = [].concat(string);
      indices.forEach(function(charIndex, i2) {
        chars[i2] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];
      });
      return chars.join("");
    }
    __name(getReorderedString, "getReorderedString");
    function getReorderedIndices2(string, embedLevelsResult, start2, end2) {
      var segments = getReorderSegments(string, embedLevelsResult, start2, end2);
      var indices = [];
      for (var i2 = 0; i2 < string.length; i2++) {
        indices[i2] = i2;
      }
      segments.forEach(function(ref2) {
        var start3 = ref2[0];
        var end3 = ref2[1];
        var slice5 = indices.slice(start3, end3 + 1);
        for (var i3 = slice5.length; i3--; ) {
          indices[end3 - i3] = slice5[i3];
        }
      });
      return indices;
    }
    __name(getReorderedIndices2, "getReorderedIndices");
    exports.closingToOpeningBracket = closingToOpeningBracket;
    exports.getBidiCharType = getBidiCharType;
    exports.getBidiCharTypeName = getBidiCharTypeName;
    exports.getCanonicalBracket = getCanonicalBracket;
    exports.getEmbeddingLevels = getEmbeddingLevels;
    exports.getMirroredCharacter = getMirroredCharacter;
    exports.getMirroredCharactersMap = getMirroredCharactersMap;
    exports.getReorderSegments = getReorderSegments;
    exports.getReorderedIndices = getReorderedIndices2;
    exports.getReorderedString = getReorderedString;
    exports.openingToClosingBracket = openingToClosingBracket;
    Object.defineProperty(exports, "__esModule", { value: true });
    return exports;
  }({});
  return bidi2;
}
__name(bidiFactory, "bidiFactory");
var bidi_default = bidiFactory;

// ../../node_modules/.pnpm/@react-pdf+textkit@6.1.0/node_modules/@react-pdf/textkit/lib/textkit.js
var import_hyphen = __toESM(require_hyphen(), 1);
var import_en_us = __toESM(require_en_us(), 1);
var fromFragments = /* @__PURE__ */ __name((fragments) => {
  let offset2 = 0;
  let string = "";
  const runs = [];
  fragments.forEach((fragment) => {
    string += fragment.string;
    runs.push({
      ...fragment,
      start: offset2,
      end: offset2 + fragment.string.length,
      attributes: fragment.attributes || {}
    });
    offset2 += fragment.string.length;
  });
  return { string, runs };
}, "fromFragments");
var SOFT_HYPHEN$1 = "\xAD";
var defaultHyphenate = /* @__PURE__ */ __name((word) => [word], "defaultHyphenate");
var removeSoftHyphens = /* @__PURE__ */ __name((word) => {
  return word.replaceAll(SOFT_HYPHEN$1, "");
}, "removeSoftHyphens");
var wrapWords = /* @__PURE__ */ __name((engines2 = {}, options = {}) => {
  return (attributedString) => {
    const syllables = [];
    const fragments = [];
    const builtinHyphenate = engines2.wordHyphenation?.() || defaultHyphenate;
    const hyphenate = options.hyphenationCallback || builtinHyphenate;
    let offset2 = 0;
    for (let i2 = 0; i2 < attributedString.runs.length; i2 += 1) {
      let string = "";
      const run = attributedString.runs[i2];
      const words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);
      for (let j = 0; j < words.length; j += 1) {
        const word = words[j];
        const parts = hyphenate(word, builtinHyphenate).map(removeSoftHyphens);
        syllables.push(...parts);
        string += parts.join("");
      }
      const runOffset = run.end - run.start - string.length;
      const start2 = run.start - offset2;
      const end2 = run.end - offset2 - runOffset;
      fragments.push({ ...run, start: start2, end: end2, string });
      offset2 += runOffset;
    }
    const result = { ...fromFragments(fragments), syllables };
    return result;
  };
}, "wrapWords");
var copy3 = /* @__PURE__ */ __name((rect) => {
  return Object.assign({}, rect);
}, "copy");
var partition = /* @__PURE__ */ __name((rect, height2) => {
  const a4 = Object.assign({}, rect, { height: height2 });
  const b3 = Object.assign({}, rect, {
    y: rect.y + height2,
    height: rect.height - height2
  });
  return [a4, b3];
}, "partition");
var crop = /* @__PURE__ */ __name((height2, rect) => {
  const [, result] = partition(rect, height2);
  return result;
}, "crop");
var height$2 = /* @__PURE__ */ __name((paragraph) => {
  return paragraph.reduce((acc, block) => acc + block.box.height, 0);
}, "height$2");
var calculateScale = /* @__PURE__ */ __name((run) => {
  const attributes2 = run.attributes || {};
  const fontSize = attributes2.fontSize || 12;
  const font = attributes2.font;
  const unitsPerEm = typeof font === "string" ? null : font?.[0]?.unitsPerEm;
  return unitsPerEm ? fontSize / unitsPerEm : 0;
}, "calculateScale");
var scale = /* @__PURE__ */ __name((run) => {
  return run.attributes?.scale || calculateScale(run);
}, "scale");
var offset = /* @__PURE__ */ __name((index2, run) => {
  if (!run)
    return 0;
  const glyphIndices = run.glyphIndices || [];
  const value2 = glyphIndices[index2];
  return glyphIndices.slice(0, index2).filter((i2) => i2 === value2).length;
}, "offset");
var getFont = /* @__PURE__ */ __name((run) => {
  return run.attributes?.font?.[0] || null;
}, "getFont");
var slice$2 = /* @__PURE__ */ __name((start2, end2, font, glyph) => {
  if (!glyph)
    return [];
  if (start2 === end2)
    return [];
  if (start2 === 0 && end2 === glyph.codePoints.length)
    return [glyph];
  const codePoints = glyph.codePoints.slice(start2, end2);
  const string = String.fromCodePoint(...codePoints);
  return font ? font.layout(string, void 0, void 0, void 0, "ltr").glyphs : [glyph];
}, "slice$2");
var glyphIndexAt = /* @__PURE__ */ __name((index2, run) => {
  const result = run?.glyphIndices?.[index2];
  return isNil(result) ? index2 : result;
}, "glyphIndexAt");
var normalize3 = /* @__PURE__ */ __name((array) => {
  const head = array[0];
  return array.map((value2) => value2 - head);
}, "normalize");
var slice$1 = /* @__PURE__ */ __name((start2, end2, run) => {
  const runScale = scale(run);
  const font = getFont(run);
  const startIndex = glyphIndexAt(start2, run);
  const endIndex = glyphIndexAt(end2, run);
  const startGlyph = run.glyphs?.[startIndex];
  const endGlyph = run.glyphs?.[endIndex];
  const startOffset = offset(start2, run);
  const startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : [];
  const endOffset = offset(end2, run);
  const endGlyphs = slice$2(0, endOffset, font, endGlyph);
  const sliceStart = startIndex + Math.min(1, startOffset);
  const glyphs = (run.glyphs || []).slice(sliceStart, endIndex);
  const glyphPosition = /* @__PURE__ */ __name((g) => ({
    xAdvance: g.advanceWidth * runScale,
    yAdvance: 0,
    xOffset: 0,
    yOffset: 0
  }), "glyphPosition");
  const startPositions = startGlyphs.map(glyphPosition);
  const positions = (run.positions || []).slice(sliceStart, endIndex);
  const endPositions = endGlyphs.map(glyphPosition);
  return Object.assign({}, run, {
    start: run.start + start2,
    end: Math.min(run.end, run.start + end2),
    glyphIndices: normalize3((run.glyphIndices || []).slice(start2, end2)),
    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),
    positions: [startPositions, positions, endPositions].flat()
  });
}, "slice$1");
var runIndexAt$1 = /* @__PURE__ */ __name((index2, runs) => {
  if (!runs)
    return -1;
  return runs.findIndex((run) => run.start <= index2 && index2 < run.end);
}, "runIndexAt$1");
var filter = /* @__PURE__ */ __name((start2, end2, runs) => {
  const startIndex = runIndexAt$1(start2, runs);
  const endIndex = Math.max(runIndexAt$1(end2 - 1, runs), startIndex);
  return runs.slice(startIndex, endIndex + 1);
}, "filter");
var subtract = /* @__PURE__ */ __name((index2, run) => {
  const start2 = run.start - index2;
  const end2 = run.end - index2;
  return Object.assign({}, run, { start: start2, end: end2 });
}, "subtract");
var sliceRuns = /* @__PURE__ */ __name((start2, end2, runs) => {
  const sliceFirstRun = /* @__PURE__ */ __name((a4) => slice$1(start2 - a4.start, end2 - a4.start, a4), "sliceFirstRun");
  const sliceLastRun = /* @__PURE__ */ __name((a4) => slice$1(0, end2 - a4.start, a4), "sliceLastRun");
  return runs.map((run, i2) => {
    let result = run;
    const isFirst = i2 === 0;
    const isLast = !isFirst && i2 === runs.length - 1;
    if (isFirst)
      result = sliceFirstRun(run);
    if (isLast)
      result = sliceLastRun(run);
    return subtract(start2, result);
  });
}, "sliceRuns");
var slice3 = /* @__PURE__ */ __name((start2, end2, attributedString) => {
  if (attributedString.string.length === 0)
    return attributedString;
  const string = attributedString.string.slice(start2, end2);
  const filteredRuns = filter(start2, end2, attributedString.runs);
  const slicedRuns = sliceRuns(start2, end2, filteredRuns);
  return Object.assign({}, attributedString, { string, runs: slicedRuns });
}, "slice");
var findCharIndex = /* @__PURE__ */ __name((string) => {
  return string.search(/\S/g);
}, "findCharIndex");
var findLastCharIndex = /* @__PURE__ */ __name((string) => {
  const match2 = string.match(/\S/g);
  return match2 ? string.lastIndexOf(match2[match2.length - 1]) : -1;
}, "findLastCharIndex");
var trim = /* @__PURE__ */ __name((attributedString) => {
  const start2 = findCharIndex(attributedString.string);
  const end2 = findLastCharIndex(attributedString.string);
  return slice3(start2, end2 + 1, attributedString);
}, "trim");
var empty$1 = /* @__PURE__ */ __name(() => {
  return {
    start: 0,
    end: 0,
    glyphIndices: [],
    glyphs: [],
    positions: [],
    attributes: {}
  };
}, "empty$1");
var isNumber3 = /* @__PURE__ */ __name((value2) => {
  return typeof value2 === "number";
}, "isNumber");
var appendIndices = /* @__PURE__ */ __name((length2, indices) => {
  const lastIndex = last(indices);
  const value2 = isNil(lastIndex) ? 0 : lastIndex + 1;
  const newIndices = Array(length2).fill(value2);
  return indices.concat(newIndices);
}, "appendIndices");
var fromCodePoint = /* @__PURE__ */ __name((value2, font) => {
  if (typeof font === "string")
    return null;
  return font && value2 ? font.glyphForCodePoint(value2) : null;
}, "fromCodePoint");
var appendGlyph = /* @__PURE__ */ __name((glyph, run) => {
  const glyphLength = glyph.codePoints?.length || 0;
  const end2 = run.end + glyphLength;
  const glyphs = run.glyphs.concat(glyph);
  const glyphIndices = appendIndices(glyphLength, run.glyphIndices);
  if (!run.positions)
    return Object.assign({}, run, { end: end2, glyphs, glyphIndices });
  const positions = run.positions.concat({
    xAdvance: glyph.advanceWidth * scale(run),
    yAdvance: 0,
    xOffset: 0,
    yOffset: 0
  });
  return Object.assign({}, run, { end: end2, glyphs, glyphIndices, positions });
}, "appendGlyph");
var append$1 = /* @__PURE__ */ __name((value2, run) => {
  if (!value2)
    return run;
  const font = getFont(run);
  const glyph = isNumber3(value2) ? fromCodePoint(value2, font) : value2;
  return appendGlyph(glyph, run);
}, "append$1");
var stringFromCodePoints = /* @__PURE__ */ __name((codePoints) => {
  return String.fromCodePoint(...codePoints || []);
}, "stringFromCodePoints");
var append = /* @__PURE__ */ __name((glyph, attributedString) => {
  const codePoints = typeof glyph === "number" ? [glyph] : glyph?.codePoints;
  const codePointsString = stringFromCodePoints(codePoints || []);
  const string = attributedString.string + codePointsString;
  const firstRuns = attributedString.runs.slice(0, -1);
  const lastRun = last(attributedString.runs) || empty$1();
  const runs = firstRuns.concat(append$1(glyph, lastRun));
  return Object.assign({}, attributedString, { string, runs });
}, "append");
var ELLIPSIS_UNICODE = 8230;
var ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);
var getEllipsisCodePoint = /* @__PURE__ */ __name((font) => {
  if (!font.encode)
    return ELLIPSIS_UNICODE;
  const [codePoints] = font.encode(ELLIPSIS_STRING);
  return parseInt(codePoints[0], 16);
}, "getEllipsisCodePoint");
var truncate3 = /* @__PURE__ */ __name((paragraph) => {
  const runs = last(paragraph)?.runs || [];
  const font = last(runs)?.attributes?.font[0];
  if (font) {
    const index2 = paragraph.length - 1;
    const codePoint = getEllipsisCodePoint(font);
    const glyph = font.glyphForCodePoint(codePoint);
    const lastBlock = append(glyph, trim(paragraph[index2]));
    return Object.assign([], paragraph, { [index2]: lastBlock });
  }
  return paragraph;
}, "truncate");
var omit2 = /* @__PURE__ */ __name((value2, run) => {
  const attributes2 = Object.assign({}, run.attributes);
  delete attributes2[value2];
  return Object.assign({}, run, { attributes: attributes2 });
}, "omit");
var ascent$1 = /* @__PURE__ */ __name((run) => {
  const { font, attachment } = run.attributes;
  const attachmentHeight = attachment?.height || 0;
  const fontAscent = typeof font === "string" ? 0 : font?.[0]?.ascent || 0;
  return Math.max(attachmentHeight, fontAscent * scale(run));
}, "ascent$1");
var descent = /* @__PURE__ */ __name((run) => {
  const font = run.attributes?.font;
  const fontDescent = typeof font === "string" ? 0 : font?.[0]?.descent || 0;
  return scale(run) * fontDescent;
}, "descent");
var lineGap = /* @__PURE__ */ __name((run) => {
  const font = run.attributes?.font;
  const lineGap2 = typeof font === "string" ? 0 : font?.[0]?.lineGap || 0;
  return lineGap2 * scale(run);
}, "lineGap");
var height$1 = /* @__PURE__ */ __name((run) => {
  const lineHeight = run.attributes?.lineHeight;
  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);
}, "height$1");
var height = /* @__PURE__ */ __name((attributedString) => {
  const reducer = /* @__PURE__ */ __name((acc, run) => Math.max(acc, height$1(run)), "reducer");
  return attributedString.runs.reduce(reducer, 0);
}, "height");
var intersects = /* @__PURE__ */ __name((a4, b3) => {
  const x = Math.max(a4.x, b3.x);
  const num1 = Math.min(a4.x + a4.width, b3.x + b3.width);
  const y3 = Math.max(a4.y, b3.y);
  const num2 = Math.min(a4.y + a4.height, b3.y + b3.height);
  return num1 >= x && num2 >= y3;
}, "intersects");
var getLineFragment = /* @__PURE__ */ __name((lineRect, excludeRect) => {
  if (!intersects(excludeRect, lineRect))
    return [lineRect];
  const eStart = excludeRect.x;
  const eEnd = excludeRect.x + excludeRect.width;
  const lStart = lineRect.x;
  const lEnd = lineRect.x + lineRect.width;
  const a4 = Object.assign({}, lineRect, { width: eStart - lStart });
  const b3 = Object.assign({}, lineRect, { x: eEnd, width: lEnd - eEnd });
  return [a4, b3].filter((r5) => r5.width > 0);
}, "getLineFragment");
var getLineFragments = /* @__PURE__ */ __name((rect, excludeRects) => {
  let fragments = [rect];
  for (let i2 = 0; i2 < excludeRects.length; i2 += 1) {
    const excludeRect = excludeRects[i2];
    fragments = fragments.reduce((acc, fragment) => {
      const pieces = getLineFragment(fragment, excludeRect);
      return acc.concat(pieces);
    }, []);
  }
  return fragments;
}, "getLineFragments");
var generateLineRects = /* @__PURE__ */ __name((container, height2) => {
  const { excludeRects, ...rect } = container;
  if (!excludeRects)
    return [rect];
  const lineRects = [];
  const maxY = Math.max(...excludeRects.map((r5) => r5.y + r5.height));
  let currentRect = rect;
  while (currentRect.y < maxY) {
    const [lineRect, rest] = partition(currentRect, height2);
    const lineRectFragments = getLineFragments(lineRect, excludeRects);
    currentRect = rest;
    lineRects.push(...lineRectFragments);
  }
  return [...lineRects, currentRect];
}, "generateLineRects");
var ATTACHMENT_CODE$1 = "\uFFFC";
var purgeAttachments = /* @__PURE__ */ __name((line2) => {
  const shouldPurge = !line2.string.includes(ATTACHMENT_CODE$1);
  if (!shouldPurge)
    return line2;
  const runs = line2.runs.map((run) => omit2("attachment", run));
  return Object.assign({}, line2, { runs });
}, "purgeAttachments");
var layoutLines = /* @__PURE__ */ __name((rects, lines, indent) => {
  let rect = rects.shift();
  let currentY = rect.y;
  return lines.map((line2, i2) => {
    const lineIndent = i2 === 0 ? indent : 0;
    const style = line2.runs?.[0]?.attributes || {};
    const height$12 = Math.max(height(line2), style.lineHeight);
    if (currentY + height$12 > rect.y + rect.height && rects.length > 0) {
      rect = rects.shift();
      currentY = rect.y;
    }
    const newLine = {
      string: line2.string,
      runs: line2.runs,
      box: {
        x: rect.x + lineIndent,
        y: currentY,
        width: rect.width - lineIndent,
        height: height$12
      }
    };
    currentY += height$12;
    return purgeAttachments(newLine);
  });
}, "layoutLines");
var layoutParagraph = /* @__PURE__ */ __name((engines2, options = {}) => {
  return (container, paragraph) => {
    const height$12 = height(paragraph);
    const indent = paragraph.runs?.[0]?.attributes?.indent || 0;
    const rects = generateLineRects(container, height$12);
    const availableWidths = rects.map((r5) => r5.width);
    availableWidths.unshift(availableWidths[0] - indent);
    const lines = engines2.linebreaker(options)(paragraph, availableWidths);
    return layoutLines(rects, lines, indent);
  };
}, "layoutParagraph");
var sliceAtHeight = /* @__PURE__ */ __name((height2, paragraph) => {
  const newBlock = [];
  let counter = 0;
  for (let i2 = 0; i2 < paragraph.length; i2 += 1) {
    const line2 = paragraph[i2];
    counter += line2.box.height;
    if (counter < height2) {
      newBlock.push(line2);
    } else {
      break;
    }
  }
  return newBlock;
}, "sliceAtHeight");
var typesetter = /* @__PURE__ */ __name((engines2, options, container) => {
  return (attributedStrings) => {
    const result = [];
    const paragraphs = [...attributedStrings];
    const layout2 = layoutParagraph(engines2, options);
    const maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;
    const truncateEllipsis = container.truncateMode === "ellipsis";
    let linesCount = maxLines;
    let paragraphRect = copy3(container);
    let nextParagraph = paragraphs.shift();
    while (linesCount > 0 && nextParagraph) {
      const paragraph = layout2(paragraphRect, nextParagraph);
      const slicedBlock = paragraph.slice(0, linesCount);
      const linesHeight2 = height$2(slicedBlock);
      const shouldTruncate = truncateEllipsis && paragraph.length !== slicedBlock.length;
      linesCount -= slicedBlock.length;
      if (paragraphRect.height >= linesHeight2) {
        result.push(shouldTruncate ? truncate3(slicedBlock) : slicedBlock);
        paragraphRect = crop(linesHeight2, paragraphRect);
        nextParagraph = paragraphs.shift();
      } else {
        result.push(truncate3(sliceAtHeight(paragraphRect.height, slicedBlock)));
        break;
      }
    }
    return result;
  };
}, "typesetter");
var start = /* @__PURE__ */ __name((attributedString) => {
  const { runs } = attributedString;
  return runs.length === 0 ? 0 : runs[0].start;
}, "start");
var end = /* @__PURE__ */ __name((attributedString) => {
  const { runs } = attributedString;
  return runs.length === 0 ? 0 : last(runs).end;
}, "end");
var length$1 = /* @__PURE__ */ __name((attributedString) => {
  return end(attributedString) - start(attributedString);
}, "length$1");
var bidi$2 = bidi_default();
var getBidiLevels$1 = /* @__PURE__ */ __name((runs) => {
  return runs.reduce((acc, run) => {
    const length2 = run.end - run.start;
    const levels = repeat(run.attributes.bidiLevel, length2);
    return acc.concat(levels);
  }, []);
}, "getBidiLevels$1");
var getReorderedIndices = /* @__PURE__ */ __name((string, segments) => {
  const indices = [];
  for (let i2 = 0; i2 < string.length; i2 += 1) {
    indices[i2] = i2;
  }
  segments.forEach(([start2, end2]) => {
    const slice5 = indices.slice(start2, end2 + 1);
    for (let i2 = slice5.length - 1; i2 >= 0; i2 -= 1) {
      indices[end2 - i2] = slice5[i2];
    }
  });
  return indices;
}, "getReorderedIndices");
var getItemAtIndex = /* @__PURE__ */ __name((runs, objectName, index2) => {
  for (let i2 = 0; i2 < runs.length; i2 += 1) {
    const run = runs[i2];
    const updatedIndex = run.glyphIndices[index2 - run.start];
    if (index2 >= run.start && index2 < run.end) {
      return run[objectName][updatedIndex];
    }
  }
  throw new Error(`index ${index2} out of range`);
}, "getItemAtIndex");
var reorderLine = /* @__PURE__ */ __name((line2) => {
  const levels = getBidiLevels$1(line2.runs);
  const direction = line2.runs[0]?.attributes.direction;
  const level = direction === "rtl" ? 1 : 0;
  const end2 = length$1(line2) - 1;
  const paragraphs = [{ start: 0, end: end2, level }];
  const embeddingLevels = { paragraphs, levels };
  const segments = bidi$2.getReorderSegments(line2.string, embeddingLevels);
  if (segments.length === 0)
    return line2;
  const indices = getReorderedIndices(line2.string, segments);
  const updatedString = bidi$2.getReorderedString(line2.string, embeddingLevels);
  const updatedRuns = line2.runs.map((run) => {
    const selectedIndices = indices.slice(run.start, run.end);
    const updatedGlyphs = [];
    const updatedPositions = [];
    const addedGlyphs = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < selectedIndices.length; i2 += 1) {
      const index2 = selectedIndices[i2];
      const glyph = getItemAtIndex(line2.runs, "glyphs", index2);
      if (addedGlyphs.has(glyph.id))
        continue;
      updatedGlyphs.push(glyph);
      updatedPositions.push(getItemAtIndex(line2.runs, "positions", index2));
      if (glyph.isLigature) {
        addedGlyphs.add(glyph.id);
      }
    }
    return {
      ...run,
      glyphs: updatedGlyphs,
      positions: updatedPositions
    };
  });
  return {
    box: line2.box,
    runs: updatedRuns,
    string: updatedString
  };
}, "reorderLine");
var reorderParagraph = /* @__PURE__ */ __name((paragraph) => paragraph.map(reorderLine), "reorderParagraph");
var bidiReordering = /* @__PURE__ */ __name(() => {
  return (paragraphs) => paragraphs.map(reorderParagraph);
}, "bidiReordering");
var DUMMY_CODEPOINT = 123;
var resolve2 = /* @__PURE__ */ __name((glyphs = []) => {
  return glyphs.reduce((acc, glyph) => {
    const codePoints = glyph?.codePoints || [DUMMY_CODEPOINT];
    if (acc.length === 0)
      return codePoints.map(() => 0);
    const last2 = acc[acc.length - 1];
    const next = codePoints.map(() => last2 + 1);
    return [...acc, ...next];
  }, []);
}, "resolve");
var getCharacterSpacing = /* @__PURE__ */ __name((run) => {
  return run.attributes?.characterSpacing || 0;
}, "getCharacterSpacing");
var scalePositions = /* @__PURE__ */ __name((run, positions) => {
  const runScale = scale(run);
  const characterSpacing = getCharacterSpacing(run);
  return positions.map((position, i2) => {
    const isLast = i2 === positions.length;
    const xSpacing = isLast ? 0 : characterSpacing;
    return Object.assign({}, position, {
      xAdvance: position.xAdvance * runScale + xSpacing,
      yAdvance: position.yAdvance * runScale,
      xOffset: position.xOffset * runScale,
      yOffset: position.yOffset * runScale
    });
  });
}, "scalePositions");
var layoutRun = /* @__PURE__ */ __name((string) => {
  return (run) => {
    const { start: start2, end: end2, attributes: attributes2 = {} } = run;
    const { font } = attributes2;
    if (!font)
      return { ...run, glyphs: [], glyphIndices: [], positions: [] };
    const runString = string.slice(start2, end2);
    if (typeof font === "string")
      throw new Error("Invalid font");
    const glyphRun = font[0].layout(runString, void 0, void 0, void 0, "ltr");
    const positions = scalePositions(run, glyphRun.positions);
    const glyphIndices = resolve2(glyphRun.glyphs);
    const result = {
      ...run,
      positions,
      glyphIndices,
      glyphs: glyphRun.glyphs
    };
    return result;
  };
}, "layoutRun");
var generateGlyphs = /* @__PURE__ */ __name(() => {
  return (attributedString) => {
    const runs = attributedString.runs.map(layoutRun(attributedString.string));
    const res = Object.assign({}, attributedString, { runs });
    return res;
  };
}, "generateGlyphs");
var resolveRunYOffset = /* @__PURE__ */ __name((run) => {
  if (!run.positions)
    return run;
  const unitsPerEm = run.attributes?.font?.[0]?.unitsPerEm || 0;
  const yOffset = (run.attributes?.yOffset || 0) * unitsPerEm;
  const positions = run.positions.map((p3) => Object.assign({}, p3, { yOffset }));
  return Object.assign({}, run, { positions });
}, "resolveRunYOffset");
var resolveYOffset = /* @__PURE__ */ __name(() => {
  return (attributedString) => {
    const runs = attributedString.runs.map(resolveRunYOffset);
    const res = Object.assign({}, attributedString, { runs });
    return res;
  };
}, "resolveYOffset");
var sort = /* @__PURE__ */ __name((runs) => {
  return runs.sort((a4, b3) => a4.start - b3.start || a4.end - b3.end);
}, "sort");
var isEmpty = /* @__PURE__ */ __name((run) => {
  return run.start === run.end;
}, "isEmpty");
var sortPoints = /* @__PURE__ */ __name((a4, b3) => {
  return a4[1] - b3[1] || a4[3] - b3[3];
}, "sortPoints");
var generatePoints = /* @__PURE__ */ __name((runs) => {
  const result = runs.reduce((acc, run, i2) => {
    return acc.concat([
      ["start", run.start, run.attributes, i2],
      ["end", run.end, run.attributes, i2]
    ]);
  }, []);
  return result.sort(sortPoints);
}, "generatePoints");
var mergeRuns = /* @__PURE__ */ __name((runs) => {
  return runs.reduce((acc, run) => {
    const attributes2 = Object.assign({}, acc.attributes, run.attributes);
    return Object.assign({}, run, { attributes: attributes2 });
  }, {});
}, "mergeRuns");
var groupEmptyRuns = /* @__PURE__ */ __name((runs) => {
  const groups = runs.reduce((acc, run) => {
    if (!acc[run.start])
      acc[run.start] = [];
    acc[run.start].push(run);
    return acc;
  }, []);
  return Object.values(groups);
}, "groupEmptyRuns");
var flattenEmptyRuns = /* @__PURE__ */ __name((runs) => {
  return groupEmptyRuns(runs).map(mergeRuns);
}, "flattenEmptyRuns");
var flattenRegularRuns = /* @__PURE__ */ __name((runs) => {
  const res = [];
  const points = generatePoints(runs);
  let start2 = -1;
  let attrs = {};
  const stack = [];
  for (let i2 = 0; i2 < points.length; i2 += 1) {
    const [type2, offset2, attributes2] = points[i2];
    if (start2 !== -1 && start2 < offset2) {
      res.push({
        start: start2,
        end: offset2,
        attributes: attrs,
        glyphIndices: [],
        glyphs: [],
        positions: []
      });
    }
    if (type2 === "start") {
      stack.push(attributes2);
      attrs = Object.assign({}, attrs, attributes2);
    } else {
      attrs = {};
      for (let j = 0; j < stack.length; j += 1) {
        if (stack[j] === attributes2) {
          stack.splice(j--, 1);
        } else {
          attrs = Object.assign({}, attrs, stack[j]);
        }
      }
    }
    start2 = offset2;
  }
  return res;
}, "flattenRegularRuns");
var flatten2 = /* @__PURE__ */ __name((runs = []) => {
  const emptyRuns = flattenEmptyRuns(runs.filter((run) => isEmpty(run)));
  const regularRuns = flattenRegularRuns(runs.filter((run) => !isEmpty(run)));
  return sort(emptyRuns.concat(regularRuns));
}, "flatten");
var empty = /* @__PURE__ */ __name(() => ({ string: "", runs: [] }), "empty");
var omitFont = /* @__PURE__ */ __name((attributedString) => {
  const runs = attributedString.runs.map((run) => omit2("font", run));
  return Object.assign({}, attributedString, { runs });
}, "omitFont");
var preprocessRuns = /* @__PURE__ */ __name((engines2) => {
  return (attributedString) => {
    if (isNil(attributedString))
      return empty();
    const { string } = attributedString;
    const { fontSubstitution: fontSubstitution2, scriptItemizer: scriptItemizer2, bidi: bidi2 } = engines2;
    const { runs: omittedFontRuns } = omitFont(attributedString);
    const { runs: itemizationRuns } = scriptItemizer2()(attributedString);
    const { runs: substitutedRuns } = fontSubstitution2()(attributedString);
    const { runs: bidiRuns } = bidi2()(attributedString);
    const runs = bidiRuns.concat(substitutedRuns).concat(itemizationRuns).concat(omittedFontRuns);
    return { string, runs: flatten2(runs) };
  };
}, "preprocessRuns");
var splitParagraphs = /* @__PURE__ */ __name(() => {
  return (attributedString) => {
    const paragraphs = [];
    let start2 = 0;
    let breakPoint = attributedString.string.indexOf("\n") + 1;
    while (breakPoint > 0) {
      paragraphs.push(slice3(start2, breakPoint, attributedString));
      start2 = breakPoint;
      breakPoint = attributedString.string.indexOf("\n", breakPoint) + 1;
    }
    if (start2 === 0) {
      paragraphs.push(attributedString);
    } else if (start2 < attributedString.string.length) {
      paragraphs.push(slice3(start2, length$1(attributedString), attributedString));
    }
    return paragraphs;
  };
}, "splitParagraphs");
var advanceWidth$2 = /* @__PURE__ */ __name((positions) => {
  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);
}, "advanceWidth$2");
var advanceWidth$1 = /* @__PURE__ */ __name((run) => {
  return advanceWidth$2(run.positions || []);
}, "advanceWidth$1");
var advanceWidth = /* @__PURE__ */ __name((attributedString) => {
  const reducer = /* @__PURE__ */ __name((acc, run) => acc + advanceWidth$1(run), "reducer");
  return attributedString.runs.reduce(reducer, 0);
}, "advanceWidth");
var WHITE_SPACES_CODE = 32;
var isWhiteSpace = /* @__PURE__ */ __name((glyph) => {
  const codePoints = glyph?.codePoints || [];
  return codePoints.includes(WHITE_SPACES_CODE);
}, "isWhiteSpace");
var leadingPositions = /* @__PURE__ */ __name((run) => {
  const glyphs = run.glyphs || [];
  const positions = run.positions || [];
  const leadingWhitespaces = glyphs.findIndex((g) => !isWhiteSpace(g));
  return positions.slice(0, leadingWhitespaces);
}, "leadingPositions");
var leadingOffset$1 = /* @__PURE__ */ __name((run) => {
  const positions = leadingPositions(run);
  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);
}, "leadingOffset$1");
var leadingOffset = /* @__PURE__ */ __name((attributedString) => {
  const runs = attributedString.runs || [];
  return leadingOffset$1(runs[0]);
}, "leadingOffset");
var trailingPositions = /* @__PURE__ */ __name((run) => {
  const glyphs = reverse(run.glyphs || []);
  const positions = reverse(run.positions || []);
  const leadingWhitespaces = glyphs.findIndex((g) => !isWhiteSpace(g));
  return positions.slice(0, leadingWhitespaces);
}, "trailingPositions");
var trailingOffset$1 = /* @__PURE__ */ __name((run) => {
  const positions = trailingPositions(run);
  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);
}, "trailingOffset$1");
var trailingOffset = /* @__PURE__ */ __name((attributedString) => {
  const runs = attributedString.runs || [];
  return trailingOffset$1(last(runs));
}, "trailingOffset");
var dropLast$1 = /* @__PURE__ */ __name((run) => {
  return slice$1(0, run.end - run.start - 1, run);
}, "dropLast$1");
var dropLast2 = /* @__PURE__ */ __name((attributedString) => {
  const string = dropLast(attributedString.string);
  const runs = adjust(-1, dropLast$1, attributedString.runs);
  return Object.assign({}, attributedString, { string, runs });
}, "dropLast");
var ALIGNMENT_FACTORS = { center: 0.5, right: 1 };
var removeNewLine = /* @__PURE__ */ __name((line2) => {
  return last(line2.string) === "\n" ? dropLast2(line2) : line2;
}, "removeNewLine");
var getOverflowLeft = /* @__PURE__ */ __name((line2) => {
  return leadingOffset(line2) + (line2.overflowLeft || 0);
}, "getOverflowLeft");
var getOverflowRight = /* @__PURE__ */ __name((line2) => {
  return trailingOffset(line2) + (line2.overflowRight || 0);
}, "getOverflowRight");
var adjustOverflow = /* @__PURE__ */ __name((line2) => {
  const overflowLeft = getOverflowLeft(line2);
  const overflowRight = getOverflowRight(line2);
  const x = line2.box.x - overflowLeft;
  const width = line2.box.width + overflowLeft + overflowRight;
  const box = Object.assign({}, line2.box, { x, width });
  return Object.assign({}, line2, { box, overflowLeft, overflowRight });
}, "adjustOverflow");
var justifyLine$1 = /* @__PURE__ */ __name((engines2, options, align) => {
  return (line2) => {
    const lineWidth = advanceWidth(line2);
    const alignFactor = ALIGNMENT_FACTORS[align] || 0;
    const remainingWidth = Math.max(0, line2.box.width - lineWidth);
    const shouldJustify = align === "justify" || lineWidth > line2.box.width;
    const x = line2.box.x + remainingWidth * alignFactor;
    const box = Object.assign({}, line2.box, { x });
    const newLine = Object.assign({}, line2, { box });
    return shouldJustify ? engines2.justification(options)(newLine) : newLine;
  };
}, "justifyLine$1");
var finalizeLine = /* @__PURE__ */ __name((line2) => {
  let lineAscent = 0;
  let lineDescent = 0;
  let lineHeight = 0;
  let lineXAdvance = 0;
  const runs = line2.runs.map((run) => {
    const height2 = height$1(run);
    const ascent2 = ascent$1(run);
    const descent$1 = descent(run);
    const xAdvance = advanceWidth$1(run);
    lineHeight = Math.max(lineHeight, height2);
    lineAscent = Math.max(lineAscent, ascent2);
    lineDescent = Math.max(lineDescent, descent$1);
    lineXAdvance += xAdvance;
    return Object.assign({}, run, { height: height2, ascent: ascent2, descent: descent$1, xAdvance });
  });
  return Object.assign({}, line2, {
    runs,
    height: lineHeight,
    ascent: lineAscent,
    descent: lineDescent,
    xAdvance: lineXAdvance
  });
}, "finalizeLine");
var finalizeBlock = /* @__PURE__ */ __name((engines2, options) => {
  return (line2, index2, lines) => {
    const isLastFragment = index2 === lines.length - 1;
    const style = line2.runs?.[0]?.attributes || {};
    const align = isLastFragment ? style.alignLastLine : style.align;
    return compose2(finalizeLine, engines2.textDecoration(), justifyLine$1(engines2, options, align), adjustOverflow, removeNewLine)(line2);
  };
}, "finalizeBlock");
var finalizeFragments = /* @__PURE__ */ __name((engines2, options) => {
  return (paragraphs) => {
    const blockFinalizer = finalizeBlock(engines2, options);
    return paragraphs.map((paragraph) => paragraph.map(blockFinalizer));
  };
}, "finalizeFragments");
var ATTACHMENT_CODE = 65532;
var isReplaceGlyph = /* @__PURE__ */ __name((glyph) => glyph.codePoints.includes(ATTACHMENT_CODE), "isReplaceGlyph");
var resolveRunAttachments = /* @__PURE__ */ __name((run) => {
  if (!run.positions)
    return run;
  const glyphs = run.glyphs || [];
  const attachment = run.attributes?.attachment;
  if (!attachment)
    return run;
  const positions = run.positions.map((position, i2) => {
    const glyph = glyphs[i2];
    if (attachment.width && isReplaceGlyph(glyph)) {
      return Object.assign({}, position, { xAdvance: attachment.width });
    }
    return Object.assign({}, position);
  });
  return Object.assign({}, run, { positions });
}, "resolveRunAttachments");
var resolveAttachments = /* @__PURE__ */ __name(() => {
  return (attributedString) => {
    const runs = attributedString.runs.map(resolveRunAttachments);
    const res = Object.assign({}, attributedString, { runs });
    return res;
  };
}, "resolveAttachments");
var applyAttributes = /* @__PURE__ */ __name((a4) => {
  return {
    align: a4.align || (a4.direction === "rtl" ? "right" : "left"),
    alignLastLine: a4.alignLastLine || (a4.align === "justify" ? "left" : a4.align || "left"),
    attachment: a4.attachment || null,
    backgroundColor: a4.backgroundColor || null,
    bullet: a4.bullet || null,
    characterSpacing: a4.characterSpacing || 0,
    color: a4.color || "black",
    direction: a4.direction || "ltr",
    features: a4.features || [],
    fill: a4.fill !== false,
    font: a4.font || [],
    fontSize: a4.fontSize || 12,
    hangingPunctuation: a4.hangingPunctuation || false,
    hyphenationFactor: a4.hyphenationFactor || 0,
    indent: a4.indent || 0,
    justificationFactor: a4.justificationFactor || 1,
    lineHeight: a4.lineHeight || null,
    lineSpacing: a4.lineSpacing || 0,
    link: a4.link || null,
    marginLeft: a4.marginLeft || a4.margin || 0,
    marginRight: a4.marginRight || a4.margin || 0,
    opacity: a4.opacity,
    paddingTop: a4.paddingTop || a4.padding || 0,
    paragraphSpacing: a4.paragraphSpacing || 0,
    script: a4.script || null,
    shrinkFactor: a4.shrinkFactor || 0,
    strike: a4.strike || false,
    strikeColor: a4.strikeColor || a4.color || "black",
    strikeStyle: a4.strikeStyle || "solid",
    stroke: a4.stroke || false,
    underline: a4.underline || false,
    underlineColor: a4.underlineColor || a4.color || "black",
    underlineStyle: a4.underlineStyle || "solid",
    verticalAlign: a4.verticalAlign || null,
    wordSpacing: a4.wordSpacing || 0,
    yOffset: a4.yOffset || 0
  };
}, "applyAttributes");
var applyRunStyles = /* @__PURE__ */ __name((run) => {
  const attributes2 = applyAttributes(run.attributes);
  return Object.assign({}, run, { attributes: attributes2 });
}, "applyRunStyles");
var applyDefaultStyles = /* @__PURE__ */ __name(() => {
  return (attributedString) => {
    const string = attributedString.string || "";
    const runs = (attributedString.runs || []).map(applyRunStyles);
    return { string, runs };
  };
}, "applyDefaultStyles");
var verticalAlignment = /* @__PURE__ */ __name(() => {
  return (attributedString) => {
    attributedString.runs.forEach((run) => {
      const { attributes: attributes2 } = run;
      const { verticalAlign } = attributes2;
      if (verticalAlign === "sub") {
        attributes2.yOffset = -0.2;
      } else if (verticalAlign === "super") {
        attributes2.yOffset = 0.4;
      }
    });
    return attributedString;
  };
}, "verticalAlignment");
var bidi$1 = bidi_default();
var getBidiLevels = /* @__PURE__ */ __name((runs) => {
  return runs.reduce((acc, run) => {
    const length2 = run.end - run.start;
    const levels = repeat(run.attributes.bidiLevel, length2);
    return acc.concat(levels);
  }, []);
}, "getBidiLevels");
var mirrorString = /* @__PURE__ */ __name(() => {
  return (attributedString) => {
    const levels = getBidiLevels(attributedString.runs);
    let updatedString = "";
    attributedString.string.split("").forEach((char, index2) => {
      const isRTL = levels[index2] % 2 === 1;
      const mirroredChar = isRTL ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index2)) : null;
      updatedString += mirroredChar || char;
    });
    const result = {
      ...attributedString,
      string: updatedString
    };
    return result;
  };
}, "mirrorString");
var layoutEngine = /* @__PURE__ */ __name((engines2) => {
  return (attributedString, container, options = {}) => {
    const processParagraph = compose2(resolveYOffset(), resolveAttachments(), verticalAlignment(), generateGlyphs(), wrapWords(engines2, options), mirrorString(), preprocessRuns(engines2));
    const processParagraphs = /* @__PURE__ */ __name((paragraphs) => paragraphs.map(processParagraph), "processParagraphs");
    return compose2(finalizeFragments(engines2, options), bidiReordering(), typesetter(engines2, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);
  };
}, "layoutEngine");
var bidi = bidi_default();
var bidiEngine = /* @__PURE__ */ __name(() => {
  return (attributedString) => {
    const { string } = attributedString;
    const direction = attributedString.runs[0]?.attributes.direction;
    const { levels } = bidi.getEmbeddingLevels(string, direction);
    let lastLevel = null;
    let lastIndex = 0;
    let index2 = 0;
    const runs = [];
    for (let i2 = 0; i2 < levels.length; i2 += 1) {
      const level = levels[i2];
      if (level !== lastLevel) {
        if (lastLevel !== null) {
          runs.push({
            start: lastIndex,
            end: index2,
            attributes: { bidiLevel: lastLevel }
          });
        }
        lastIndex = index2;
        lastLevel = level;
      }
      index2 += 1;
    }
    if (lastIndex < string.length) {
      runs.push({
        start: lastIndex,
        end: string.length,
        attributes: { bidiLevel: lastLevel }
      });
    }
    const result = { string, runs };
    return result;
  };
}, "bidiEngine");
var INFINITY = 1e4;
var skipPastGlueAndPenalty = /* @__PURE__ */ __name((nodes, start2) => {
  let j = start2 + 1;
  for (; j < nodes.length; j++) {
    if (nodes[j].type !== "glue" && nodes[j].type !== "penalty") {
      break;
    }
  }
  return nodes[j - 1];
}, "skipPastGlueAndPenalty");
var getNextBreakpoint = /* @__PURE__ */ __name((subnodes, widths, lineNumber) => {
  let position = null;
  let minimumBadness = Infinity;
  const sum = { width: 0, stretch: 0, shrink: 0 };
  const lineLength = widths[Math.min(lineNumber, widths.length - 1)];
  const calculateRatio = /* @__PURE__ */ __name((node) => {
    const stretch = "stretch" in node ? node.stretch : null;
    if (sum.width < lineLength) {
      if (!stretch)
        return INFINITY;
      return sum.stretch - stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;
    }
    const shrink = "shrink" in node ? node.shrink : null;
    if (sum.width > lineLength) {
      if (!shrink)
        return INFINITY;
      return sum.shrink - shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;
    }
    return 0;
  }, "calculateRatio");
  let hyphenWidth = 0;
  for (let i2 = 0; i2 < subnodes.length; i2 += 1) {
    const node = subnodes[i2];
    if (node.type === "box") {
      sum.width += node.width;
    }
    if (node.type === "glue") {
      sum.width += node.width;
      sum.stretch += node.stretch;
      sum.shrink += node.shrink;
    }
    const potentialEndOfLine = skipPastGlueAndPenalty(subnodes, i2);
    hyphenWidth = potentialEndOfLine.type === "penalty" ? potentialEndOfLine.width : 0;
    if (sum.width - sum.shrink + hyphenWidth > lineLength) {
      if (position === null) {
        let j = i2 === 0 ? i2 + 1 : i2;
        while (j < subnodes.length && (subnodes[j].type === "glue" || subnodes[j].type === "penalty")) {
          j++;
        }
        position = j - 1;
      }
      break;
    }
    if (node.type === "penalty" || node.type === "glue") {
      const ratio = calculateRatio(node);
      const penalty = node.type === "penalty" ? node.penalty : 0;
      const badness = 100 * Math.abs(ratio) ** 3 + penalty;
      if (minimumBadness >= badness) {
        position = i2;
        minimumBadness = badness;
      }
    }
  }
  return sum.width - sum.shrink + hyphenWidth > lineLength ? position : null;
}, "getNextBreakpoint");
var applyBestFit = /* @__PURE__ */ __name((nodes, widths) => {
  let count3 = 0;
  let lineNumber = 0;
  let subnodes = nodes;
  const breakpoints = [0];
  while (subnodes.length > 0) {
    const breakpoint2 = getNextBreakpoint(subnodes, widths, lineNumber);
    if (breakpoint2 !== null) {
      count3 += breakpoint2;
      breakpoints.push(count3);
      subnodes = subnodes.slice(breakpoint2 + 1, subnodes.length);
      count3++;
      lineNumber++;
    } else {
      subnodes = [];
    }
  }
  return breakpoints;
}, "applyBestFit");
var LinkedListNode = class {
  static {
    __name(this, "LinkedListNode");
  }
  data;
  prev;
  next;
  constructor(data2) {
    this.data = data2;
    this.prev = null;
    this.next = null;
  }
};
var LinkedList = class {
  static {
    __name(this, "LinkedList");
  }
  static Node = LinkedListNode;
  head;
  tail;
  listSize;
  listLength;
  constructor() {
    this.head = null;
    this.tail = null;
    this.listSize = 0;
    this.listLength = 0;
  }
  isLinked(node) {
    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());
  }
  size() {
    return this.listSize;
  }
  isEmpty() {
    return this.listSize === 0;
  }
  first() {
    return this.head;
  }
  last() {
    return this.last;
  }
  forEach(callback) {
    let node = this.head;
    while (node !== null) {
      callback(node);
      node = node.next;
    }
  }
  at(i2) {
    let node = this.head;
    let index2 = 0;
    if (i2 >= this.listLength || i2 < 0) {
      return null;
    }
    while (node !== null) {
      if (i2 === index2) {
        return node;
      }
      node = node.next;
      index2 += 1;
    }
    return null;
  }
  insertAfter(node, newNode) {
    if (!this.isLinked(node))
      return this;
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next === null) {
      this.tail = newNode;
    } else {
      node.next.prev = newNode;
    }
    node.next = newNode;
    this.listSize += 1;
    return this;
  }
  insertBefore(node, newNode) {
    if (!this.isLinked(node))
      return this;
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev === null) {
      this.head = newNode;
    } else {
      node.prev.next = newNode;
    }
    node.prev = newNode;
    this.listSize += 1;
    return this;
  }
  push(node) {
    if (this.head === null) {
      this.unshift(node);
    } else {
      this.insertAfter(this.tail, node);
    }
    return this;
  }
  unshift(node) {
    if (this.head === null) {
      this.head = node;
      this.tail = node;
      node.prev = null;
      node.next = null;
      this.listSize += 1;
    } else {
      this.insertBefore(this.head, node);
    }
    return this;
  }
  remove(node) {
    if (!this.isLinked(node))
      return this;
    if (node.prev === null) {
      this.head = node.next;
    } else {
      node.prev.next = node.next;
    }
    if (node.next === null) {
      this.tail = node.prev;
    } else {
      node.next.prev = node.prev;
    }
    this.listSize -= 1;
    return this;
  }
};
function breakpoint(position, demerits, line2, fitnessClass, totals, previous) {
  return {
    position,
    demerits,
    line: line2,
    fitnessClass,
    totals: totals || {
      width: 0,
      stretch: 0,
      shrink: 0
    },
    previous
  };
}
__name(breakpoint, "breakpoint");
function computeCost(nodes, lineLengths, sum, end2, active, currentLine) {
  let width = sum.width - active.totals.width;
  let stretch = 0;
  let shrink = 0;
  const lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];
  if (nodes[end2].type === "penalty") {
    width += nodes[end2].width;
  }
  if (width < lineLength) {
    stretch = sum.stretch - active.totals.stretch;
    if (stretch > 0) {
      return (lineLength - width) / stretch;
    }
    return linebreak.infinity;
  }
  if (width > lineLength) {
    shrink = sum.shrink - active.totals.shrink;
    if (shrink > 0) {
      return (lineLength - width) / shrink;
    }
    return linebreak.infinity;
  }
  return 0;
}
__name(computeCost, "computeCost");
function computeSum(nodes, sum, breakPointIndex) {
  const result = {
    width: sum.width,
    stretch: sum.stretch,
    shrink: sum.shrink
  };
  for (let i2 = breakPointIndex; i2 < nodes.length; i2 += 1) {
    const node = nodes[i2];
    if (node.type === "glue") {
      result.width += node.width;
      result.stretch += node.stretch;
      result.shrink += node.shrink;
    } else if (node.type === "box" || node.type === "penalty" && node.penalty === -linebreak.infinity && i2 > breakPointIndex) {
      break;
    }
  }
  return result;
}
__name(computeSum, "computeSum");
function findBestBreakpoints(activeNodes) {
  const breakpoints = [];
  if (activeNodes.size() === 0)
    return [];
  let tmp = { data: { demerits: Infinity } };
  activeNodes.forEach((node) => {
    if (node.data.demerits < tmp.data.demerits) {
      tmp = node;
    }
  });
  while (tmp !== null) {
    breakpoints.push(tmp.data.position);
    tmp = tmp.data.previous;
  }
  return breakpoints.reverse();
}
__name(findBestBreakpoints, "findBestBreakpoints");
var linebreak = /* @__PURE__ */ __name((nodes, availableWidths, tolerance) => {
  const options = {
    demerits: { line: 10, flagged: 100, fitness: 3e3 },
    tolerance: tolerance || 3
  };
  const activeNodes = new LinkedList();
  const sum = { width: 0, stretch: 0, shrink: 0 };
  const lineLengths = availableWidths;
  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, void 0, null)));
  function mainLoop(node, index2, nodes2) {
    let active = activeNodes.first();
    while (active !== null) {
      let currentLine = 0;
      const candidates = [
        { active: void 0, demerits: Infinity },
        { active: void 0, demerits: Infinity },
        { active: void 0, demerits: Infinity },
        { active: void 0, demerits: Infinity }
      ];
      while (active !== null) {
        currentLine = active.data.line + 1;
        const ratio = computeCost(nodes2, lineLengths, sum, index2, active.data, currentLine);
        if (ratio < -1 || node.type === "penalty" && node.penalty === -linebreak.infinity) {
          activeNodes.remove(active);
        }
        if (ratio >= -1 && ratio <= options.tolerance) {
          const badness = 100 * Math.pow(Math.abs(ratio), 3);
          let demerits = 0;
          if (node.type === "penalty" && node.penalty >= 0) {
            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2);
          } else if (node.type === "penalty" && node.penalty !== -linebreak.infinity) {
            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2);
          } else {
            demerits = Math.pow(options.demerits.line + badness, 2);
          }
          if (node.type === "penalty" && nodes2[active.data.position].type === "penalty") {
            demerits += options.demerits.flagged * node.flagged * // @ts-expect-error node is penalty here
            nodes2[active.data.position].flagged;
          }
          let currentClass;
          if (ratio < -0.5) {
            currentClass = 0;
          } else if (ratio <= 0.5) {
            currentClass = 1;
          } else if (ratio <= 1) {
            currentClass = 2;
          } else {
            currentClass = 3;
          }
          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {
            demerits += options.demerits.fitness;
          }
          demerits += active.data.demerits;
          if (demerits < candidates[currentClass].demerits) {
            candidates[currentClass] = { active, demerits };
          }
        }
        active = active.next;
        if (active !== null && active.data.line >= currentLine) {
          break;
        }
      }
      const tmpSum = computeSum(nodes2, sum, index2);
      for (let fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {
        const candidate = candidates[fitnessClass];
        if (candidate.demerits === Infinity)
          continue;
        const newNode = new LinkedList.Node(breakpoint(index2, candidate.demerits, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));
        if (active !== null) {
          activeNodes.insertBefore(active, newNode);
        } else {
          activeNodes.push(newNode);
        }
      }
    }
  }
  __name(mainLoop, "mainLoop");
  nodes.forEach((node, index2, nodes2) => {
    if (node.type === "box") {
      sum.width += node.width;
      return;
    }
    if (node.type === "glue") {
      const precedesBox = index2 > 0 && nodes2[index2 - 1].type === "box";
      if (precedesBox)
        mainLoop(node, index2, nodes2);
      sum.width += node.width;
      sum.stretch += node.stretch;
      sum.shrink += node.shrink;
      return;
    }
    if (node.type === "penalty" && node.penalty !== linebreak.infinity) {
      mainLoop(node, index2, nodes2);
    }
  });
  return findBestBreakpoints(activeNodes);
}, "linebreak");
linebreak.infinity = 1e4;
linebreak.glue = (width, start2, end2, stretch, shrink) => ({
  type: "glue",
  start: start2,
  end: end2,
  width,
  stretch,
  shrink
});
linebreak.box = (width, start2, end2, hyphenated = false) => ({
  type: "box",
  width,
  start: start2,
  end: end2,
  hyphenated
});
linebreak.penalty = (width, penalty, flagged) => ({
  type: "penalty",
  width,
  penalty,
  flagged
});
var add = /* @__PURE__ */ __name((index2, run) => {
  const start2 = run.start + index2;
  const end2 = run.end + index2;
  return Object.assign({}, run, { start: start2, end: end2 });
}, "add");
var length = /* @__PURE__ */ __name((run) => {
  return run.end - run.start;
}, "length");
var concat3 = /* @__PURE__ */ __name((runA, runB) => {
  const end2 = runA.end + length(runB);
  const glyphs = (runA.glyphs || []).concat(runB.glyphs || []);
  const positions = (runA.positions || []).concat(runB.positions || []);
  const attributes2 = Object.assign({}, runA.attributes, runB.attributes);
  const runAIndices = runA.glyphIndices || [];
  const runALastIndex = last(runAIndices) || 0;
  const runBIndices = (runB.glyphIndices || []).map((i2) => i2 + runALastIndex + 1);
  const glyphIndices = normalize3(runAIndices.concat(runBIndices));
  return Object.assign({}, runA, {
    end: end2,
    glyphs,
    positions,
    attributes: attributes2,
    glyphIndices
  });
}, "concat");
var insertGlyph$1 = /* @__PURE__ */ __name((index2, glyph, run) => {
  if (!glyph)
    return run;
  const leadingRun = slice$1(0, index2, run);
  const trailingRun = slice$1(index2, Infinity, run);
  return concat3(append$1(glyph, leadingRun), trailingRun);
}, "insertGlyph$1");
var insert = /* @__PURE__ */ __name((index2, value2, run) => {
  const font = getFont(run);
  const glyph = isNumber3(value2) ? fromCodePoint(value2, font) : value2;
  return insertGlyph$1(index2, glyph, run);
}, "insert");
var runIndexAt = /* @__PURE__ */ __name((index2, attributedString) => {
  return runIndexAt$1(index2, attributedString.runs);
}, "runIndexAt");
var insertGlyph = /* @__PURE__ */ __name((index2, glyph, attributedString) => {
  const runIndex = runIndexAt(index2, attributedString);
  if (runIndex === -1)
    return append(glyph, attributedString);
  const codePoints = [glyph];
  const string = attributedString.string.slice(0, index2) + stringFromCodePoints(codePoints) + attributedString.string.slice(index2);
  const runs = attributedString.runs.map((run, i2) => {
    if (i2 === runIndex)
      return insert(index2 - run.start, glyph, run);
    if (i2 > runIndex)
      return add(codePoints.length, run);
    return run;
  });
  return Object.assign({}, attributedString, { string, runs });
}, "insertGlyph");
var advanceWidthBetween$1 = /* @__PURE__ */ __name((start2, end2, run) => {
  const runStart = run.start || 0;
  const glyphStartIndex = Math.max(0, glyphIndexAt(start2 - runStart, run));
  const glyphEndIndex = Math.max(0, glyphIndexAt(end2 - runStart, run));
  const positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);
  return advanceWidth$2(positions);
}, "advanceWidthBetween$1");
var advanceWidthBetween = /* @__PURE__ */ __name((start2, end2, attributedString) => {
  const runs = filter(start2, end2, attributedString.runs);
  return runs.reduce((acc, run) => acc + advanceWidthBetween$1(start2, end2, run), 0);
}, "advanceWidthBetween");
var HYPHEN2 = 45;
var TOLERANCE_STEPS = 5;
var TOLERANCE_LIMIT = 50;
var opts = {
  width: 3,
  stretch: 6,
  shrink: 9
};
var breakLines = /* @__PURE__ */ __name((attributedString, nodes, breaks) => {
  let start2 = 0;
  let end2 = null;
  const lines = breaks.reduce((acc, breakPoint) => {
    const node = nodes[breakPoint];
    const prevNode = nodes[breakPoint - 1];
    if (breakPoint === nodes.length - 1)
      return acc;
    let line2;
    if (node.type === "penalty") {
      end2 = prevNode.end;
      line2 = slice3(start2, end2, attributedString);
      line2 = insertGlyph(line2.string.length, HYPHEN2, line2);
    } else {
      end2 = node.end;
      line2 = slice3(start2, end2, attributedString);
    }
    start2 = end2;
    return [...acc, line2];
  }, []);
  lines.push(slice3(start2, attributedString.string.length, attributedString));
  return lines;
}, "breakLines");
var getNodes = /* @__PURE__ */ __name((attributedString, { align }, options) => {
  let start2 = 0;
  const hyphenWidth = 5;
  const { syllables } = attributedString;
  const hyphenPenalty = options.hyphenationPenalty || (align === "justify" ? 100 : 600);
  const result = syllables.reduce((acc, s4, index2) => {
    const width = advanceWidthBetween(start2, start2 + s4.length, attributedString);
    if (s4.trim() === "") {
      const stretch = width * opts.width / opts.stretch;
      const shrink = width * opts.width / opts.shrink;
      const end2 = start2 + s4.length;
      acc.push(linebreak.glue(width, start2, end2, stretch, shrink));
    } else {
      const hyphenated = syllables[index2 + 1] !== " ";
      const end2 = start2 + s4.length;
      acc.push(linebreak.box(width, start2, end2, hyphenated));
      if (syllables[index2 + 1] && hyphenated) {
        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));
      }
    }
    start2 += s4.length;
    return acc;
  }, []);
  result.push(linebreak.glue(0, start2, start2, linebreak.infinity, 0));
  result.push(linebreak.penalty(0, -linebreak.infinity, 1));
  return result;
}, "getNodes");
var getAttributes = /* @__PURE__ */ __name((attributedString) => {
  return attributedString.runs?.[0]?.attributes || {};
}, "getAttributes");
var linebreaker = /* @__PURE__ */ __name((options) => {
  return (attributedString, availableWidths) => {
    let tolerance = options.tolerance || 4;
    const attributes2 = getAttributes(attributedString);
    const nodes = getNodes(attributedString, attributes2, options);
    let breaks = linebreak(nodes, availableWidths, tolerance);
    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {
      tolerance += TOLERANCE_STEPS;
      breaks = linebreak(nodes, availableWidths, tolerance);
    }
    if (breaks.length === 0 || breaks.length === 1 && breaks[0] === 0) {
      breaks = applyBestFit(nodes, availableWidths);
    }
    return breakLines(attributedString, nodes, breaks.slice(1));
  };
}, "linebreaker");
var Direction;
(function(Direction3) {
  Direction3[Direction3["GROW"] = 0] = "GROW";
  Direction3[Direction3["SHRINK"] = 1] = "SHRINK";
})(Direction || (Direction = {}));
var WHITESPACE_PRIORITY = 1;
var LETTER_PRIORITY = 2;
var EXPAND_WHITESPACE_FACTOR = {
  before: 0.5,
  after: 0.5,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};
var EXPAND_CHAR_FACTOR = {
  before: 0.14453125,
  // 37/256
  after: 0.14453125,
  priority: LETTER_PRIORITY,
  unconstrained: false
};
var SHRINK_WHITESPACE_FACTOR = {
  before: -0.04296875,
  // -11/256
  after: -0.04296875,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};
var SHRINK_CHAR_FACTOR = {
  before: -0.04296875,
  after: -0.04296875,
  priority: LETTER_PRIORITY,
  unconstrained: false
};
var getCharFactor = /* @__PURE__ */ __name((direction, options) => {
  const expandCharFactor = options.expandCharFactor || {};
  const shrinkCharFactor = options.shrinkCharFactor || {};
  return direction === Direction.GROW ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);
}, "getCharFactor");
var getWhitespaceFactor = /* @__PURE__ */ __name((direction, options) => {
  const expandWhitespaceFactor = options.expandWhitespaceFactor || {};
  const shrinkWhitespaceFactor2 = options.shrinkWhitespaceFactor || {};
  return direction === Direction.GROW ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor2);
}, "getWhitespaceFactor");
var factor = /* @__PURE__ */ __name((direction, options) => (glyphs) => {
  const charFactor = getCharFactor(direction, options);
  const whitespaceFactor = getWhitespaceFactor(direction, options);
  const factors = [];
  for (let index2 = 0; index2 < glyphs.length; index2 += 1) {
    let f4;
    const glyph = glyphs[index2];
    if (isWhiteSpace(glyph)) {
      f4 = Object.assign({}, whitespaceFactor);
      if (index2 === glyphs.length - 1) {
        f4.before = 0;
        if (index2 > 0) {
          factors[index2 - 1].after = 0;
        }
      }
    } else if (glyph.isMark && index2 > 0) {
      f4 = Object.assign({}, factors[index2 - 1]);
      f4.before = 0;
      factors[index2 - 1].after = 0;
    } else {
      f4 = Object.assign({}, charFactor);
    }
    factors.push(f4);
  }
  return factors;
}, "factor");
var getFactors = /* @__PURE__ */ __name((gap, line2, options) => {
  const direction = gap > 0 ? Direction.GROW : Direction.SHRINK;
  const getFactor = factor(direction, options);
  const factors = line2.runs.reduce((acc, run) => {
    return acc.concat(getFactor(run.glyphs));
  }, []);
  factors[0].before = 0;
  factors[factors.length - 1].after = 0;
  return factors;
}, "getFactors");
var KASHIDA_PRIORITY = 0;
var NULL_PRIORITY = 3;
var getDistances = /* @__PURE__ */ __name((gap, factors) => {
  let total = 0;
  const priorities = [];
  const unconstrained = [];
  for (let priority3 = KASHIDA_PRIORITY; priority3 <= NULL_PRIORITY; priority3 += 1) {
    priorities[priority3] = unconstrained[priority3] = 0;
  }
  for (let j = 0; j < factors.length; j += 1) {
    const f4 = factors[j];
    const sum = f4.before + f4.after;
    total += sum;
    priorities[f4.priority] += sum;
    if (f4.unconstrained) {
      unconstrained[f4.priority] += sum;
    }
  }
  let highestPriority = -1;
  let highestPrioritySum = 0;
  let remainingGap = gap;
  let priority2;
  for (priority2 = KASHIDA_PRIORITY; priority2 <= NULL_PRIORITY; priority2 += 1) {
    const prioritySum = priorities[priority2];
    if (prioritySum !== 0) {
      if (highestPriority === -1) {
        highestPriority = priority2;
        highestPrioritySum = prioritySum;
      }
      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {
        priorities[priority2] = remainingGap / prioritySum;
        unconstrained[priority2] = 0;
        remainingGap = 0;
        break;
      }
      priorities[priority2] = 1;
      remainingGap -= prioritySum;
      if (unconstrained[priority2] !== 0) {
        unconstrained[priority2] = remainingGap / unconstrained[priority2];
        remainingGap = 0;
        break;
      }
    }
  }
  for (let p3 = priority2 + 1; p3 <= NULL_PRIORITY; p3 += 1) {
    priorities[p3] = 0;
    unconstrained[p3] = 0;
  }
  if (remainingGap > 0 && highestPriority > -1) {
    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;
  }
  const distances = [];
  for (let index2 = 0; index2 < factors.length; index2 += 1) {
    const f4 = factors[index2];
    const next = factors[index2 + 1];
    let dist = f4.after * priorities[f4.priority];
    if (next) {
      dist += next.before * priorities[next.priority];
    }
    if (f4.unconstrained) {
      dist += f4.after * unconstrained[f4.priority];
      if (next) {
        dist += next.before * unconstrained[next.priority];
      }
    }
    distances.push(dist);
  }
  return distances;
}, "getDistances");
var justifyLine = /* @__PURE__ */ __name((distances, line2) => {
  let index2 = 0;
  for (const run of line2.runs) {
    for (const position of run.positions) {
      position.xAdvance += distances[index2++];
    }
  }
  return line2;
}, "justifyLine");
var justification = /* @__PURE__ */ __name((options) => {
  return (line2) => {
    const gap = line2.box.width - advanceWidth(line2);
    if (gap === 0)
      return line2;
    const factors = getFactors(gap, line2, options);
    const distances = getDistances(gap, factors);
    return justifyLine(distances, line2);
  };
}, "justification");
var ascent = /* @__PURE__ */ __name((attributedString) => {
  const reducer = /* @__PURE__ */ __name((acc, run) => Math.max(acc, ascent$1(run)), "reducer");
  return attributedString.runs.reduce(reducer, 0);
}, "ascent");
var BASE_FONT_SIZE = 12;
var textDecoration = /* @__PURE__ */ __name(() => (line2) => {
  let x = line2.overflowLeft || 0;
  const overflowRight = line2.overflowRight || 0;
  const maxX = advanceWidth(line2) - overflowRight;
  line2.decorationLines = [];
  for (let i2 = 0; i2 < line2.runs.length; i2 += 1) {
    const run = line2.runs[i2];
    const width = Math.min(maxX - x, advanceWidth$1(run));
    const thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));
    if (run.attributes.underline) {
      const rect = {
        x,
        y: ascent(line2) + thickness * 2,
        width,
        height: thickness
      };
      const decorationLine = {
        rect,
        opacity: run.attributes.opacity,
        color: run.attributes.underlineColor || "black",
        style: run.attributes.underlineStyle || "solid"
      };
      line2.decorationLines.push(decorationLine);
    }
    if (run.attributes.strike) {
      const y3 = ascent(line2) - ascent$1(run) / 3;
      const rect = { x, y: y3, width, height: thickness };
      const decorationLine = {
        rect,
        opacity: run.attributes.opacity,
        color: run.attributes.strikeColor || "black",
        style: run.attributes.strikeStyle || "solid"
      };
      line2.decorationLines.push(decorationLine);
    }
    x += width;
  }
  return line2;
}, "textDecoration");
var ignoredScripts = ["Common", "Inherited", "Unknown"];
var scriptItemizer = /* @__PURE__ */ __name(() => {
  return (attributedString) => {
    const { string } = attributedString;
    let lastScript = "Unknown";
    let lastIndex = 0;
    let index2 = 0;
    const runs = [];
    if (!string)
      return empty();
    for (let i2 = 0; i2 < string.length; i2 += 1) {
      const char = string[i2];
      const codePoint = char.codePointAt(0);
      const script = $747425b437e121da$export$2e2bcd8739ae039.getScript(codePoint);
      if (script !== lastScript && !ignoredScripts.includes(script)) {
        if (lastScript !== "Unknown") {
          runs.push({
            start: lastIndex,
            end: index2,
            attributes: { script: lastScript }
          });
        }
        lastIndex = index2;
        lastScript = script;
      }
      index2 += char.length;
    }
    if (lastIndex < string.length) {
      runs.push({
        start: lastIndex,
        end: string.length,
        attributes: { script: lastScript }
      });
    }
    const result = { string, runs };
    return result;
  };
}, "scriptItemizer");
var SOFT_HYPHEN2 = "\xAD";
var hyphenator = (0, import_hyphen.default)(import_en_us.default);
var splitHyphen = /* @__PURE__ */ __name((word) => {
  return word.split(SOFT_HYPHEN2);
}, "splitHyphen");
var cache = {};
var getParts = /* @__PURE__ */ __name((word) => {
  const base = word.includes(SOFT_HYPHEN2) ? word : hyphenator(word);
  return splitHyphen(base);
}, "getParts");
var wordHyphenation = /* @__PURE__ */ __name(() => {
  return (word) => {
    const cacheKey = `_${word}`;
    if (isNil(word))
      return [];
    if (cache[cacheKey])
      return cache[cacheKey];
    cache[cacheKey] = getParts(word);
    return cache[cacheKey];
  };
}, "wordHyphenation");
var IGNORED_CODE_POINTS = [173];
var getFontSize = /* @__PURE__ */ __name((run) => run.attributes.fontSize || 12, "getFontSize");
var pickFontFromFontStack = /* @__PURE__ */ __name((codePoint, fontStack, lastFont) => {
  if (IGNORED_CODE_POINTS.includes(codePoint))
    return lastFont;
  const fontStackWithFallback = [...fontStack, lastFont];
  for (let i2 = 0; i2 < fontStackWithFallback.length; i2 += 1) {
    const font = fontStackWithFallback[i2];
    if (font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {
      return font;
    }
  }
  return fontStack.at(-1);
}, "pickFontFromFontStack");
var fontSubstitution = /* @__PURE__ */ __name(() => ({ string, runs }) => {
  let lastFont = null;
  let lastFontSize = null;
  let lastIndex = 0;
  let index2 = 0;
  const res = [];
  for (let i2 = 0; i2 < runs.length; i2 += 1) {
    const run = runs[i2];
    if (string.length === 0) {
      res.push({
        start: 0,
        end: 0,
        attributes: { font: run.attributes.font }
      });
      break;
    }
    const chars = string.slice(run.start, run.end);
    for (let j = 0; j < chars.length; j += 1) {
      const char = chars[j];
      const codePoint = char.codePointAt(0);
      const font = pickFontFromFontStack(codePoint, run.attributes.font, lastFont);
      const fontSize = getFontSize(run);
      if (font !== lastFont || fontSize !== lastFontSize || font.unitsPerEm !== lastFont.unitsPerEm) {
        if (lastFont) {
          res.push({
            start: lastIndex,
            end: index2,
            attributes: {
              font: [lastFont],
              scale: lastFontSize / lastFont.unitsPerEm
            }
          });
        }
        lastFont = font;
        lastFontSize = fontSize;
        lastIndex = index2;
      }
      index2 += char.length;
    }
  }
  if (lastIndex < string.length) {
    const fontSize = getFontSize(last(runs));
    res.push({
      start: lastIndex,
      end: string.length,
      attributes: {
        font: [lastFont],
        scale: fontSize / lastFont.unitsPerEm
      }
    });
  }
  return { string, runs: res };
}, "fontSubstitution");

// ../../node_modules/.pnpm/yoga-layout@3.2.1/node_modules/yoga-layout/dist/src/load.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/yoga-layout@3.2.1/node_modules/yoga-layout/dist/binaries/yoga-wasm-base64-esm.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var loadYoga = (() => {
  var _scriptDir = import.meta.url;
  return function(loadYoga4) {
    loadYoga4 = loadYoga4 || {};
    var h;
    h || (h = typeof loadYoga4 !== "undefined" ? loadYoga4 : {});
    var aa, ca;
    h.ready = new Promise(function(a4, b3) {
      aa = a4;
      ca = b3;
    });
    var da = Object.assign({}, h), q = "";
    "undefined" != typeof document && document.currentScript && (q = document.currentScript.src);
    _scriptDir && (q = _scriptDir);
    0 !== q.indexOf("blob:") ? q = q.substr(0, q.replace(/[?#].*/, "").lastIndexOf("/") + 1) : q = "";
    var ea = h.print || console.log.bind(console), v3 = h.printErr || console.warn.bind(console);
    Object.assign(h, da);
    da = null;
    var w;
    h.wasmBinary && (w = h.wasmBinary);
    var noExitRuntime = h.noExitRuntime || true;
    "object" != typeof WebAssembly && x("no native wasm support detected");
    var fa, ha = false;
    function z(a4, b3, c2) {
      c2 = b3 + c2;
      for (var d3 = ""; !(b3 >= c2); ) {
        var e4 = a4[b3++];
        if (!e4) break;
        if (e4 & 128) {
          var f4 = a4[b3++] & 63;
          if (192 == (e4 & 224)) d3 += String.fromCharCode((e4 & 31) << 6 | f4);
          else {
            var g = a4[b3++] & 63;
            e4 = 224 == (e4 & 240) ? (e4 & 15) << 12 | f4 << 6 | g : (e4 & 7) << 18 | f4 << 12 | g << 6 | a4[b3++] & 63;
            65536 > e4 ? d3 += String.fromCharCode(e4) : (e4 -= 65536, d3 += String.fromCharCode(55296 | e4 >> 10, 56320 | e4 & 1023));
          }
        } else d3 += String.fromCharCode(e4);
      }
      return d3;
    }
    __name(z, "z");
    var ia, ja, A, C, ka, D, E, la, ma;
    function na() {
      var a4 = fa.buffer;
      ia = a4;
      h.HEAP8 = ja = new Int8Array(a4);
      h.HEAP16 = C = new Int16Array(a4);
      h.HEAP32 = D = new Int32Array(a4);
      h.HEAPU8 = A = new Uint8Array(a4);
      h.HEAPU16 = ka = new Uint16Array(a4);
      h.HEAPU32 = E = new Uint32Array(a4);
      h.HEAPF32 = la = new Float32Array(a4);
      h.HEAPF64 = ma = new Float64Array(a4);
    }
    __name(na, "na");
    var oa, pa = [], qa = [], ra = [];
    function sa() {
      var a4 = h.preRun.shift();
      pa.unshift(a4);
    }
    __name(sa, "sa");
    var F = 0, ta = null, G2 = null;
    function x(a4) {
      if (h.onAbort) h.onAbort(a4);
      a4 = "Aborted(" + a4 + ")";
      v3(a4);
      ha = true;
      a4 = new WebAssembly.RuntimeError(a4 + ". Build with -sASSERTIONS for more info.");
      ca(a4);
      throw a4;
    }
    __name(x, "x");
    function ua(a4) {
      return a4.startsWith("data:application/octet-stream;base64,");
    }
    __name(ua, "ua");
    var H;
    H = "data:application/octet-stream;base64,AGFzbQEAAAABugM3YAF/AGACf38AYAF/AX9gA39/fwBgAn98AGACf38Bf2ADf39/AX9gBH9/f30BfWADf398AGAAAGAEf39/fwBgAX8BfGACf38BfGAFf39/f38Bf2AAAX9gA39/fwF9YAZ/f31/fX8AYAV/f39/fwBgAn9/AX1gBX9/f319AX1gAX8BfWADf35/AX5gB39/f39/f38AYAZ/f39/f38AYAR/f39/AX9gBn9/f319fQF9YAR/f31/AGADf399AX1gBn98f39/fwF/YAR/fHx/AGACf30AYAh/f39/f39/fwBgDX9/f39/f39/f39/f38AYAp/f39/f39/f39/AGAFf39/f38BfGAEfHx/fwF9YA1/fX1/f399fX9/f39/AX9gB39/f319f38AYAJ+fwF/YAN/fX0BfWABfAF8YAN/fHwAYAR/f319AGAHf39/fX19fQF9YA1/fX99f31/fX19fX1/AX9gC39/f39/f399fX19AX9gCH9/f39/f319AGAEf39+fgBgB39/f39/f38Bf2ACfH8BfGAFf398fH8AYAN/f38BfGAEf39/fABgA39/fQBgBn9/fX99fwF/ArUBHgFhAWEAHwFhAWIAAwFhAWMACQFhAWQAFgFhAWUAEQFhAWYAIAFhAWcAAAFhAWgAIQFhAWkAAwFhAWoAAAFhAWsAFwFhAWwACgFhAW0ABQFhAW4AAwFhAW8AAQFhAXAAFwFhAXEABgFhAXIAAAFhAXMAIgFhAXQACgFhAXUADQFhAXYAFgFhAXcAAgFhAXgAAwFhAXkAGAFhAXoAAgFhAUEAAQFhAUIAEQFhAUMAAQFhAUQAAAOiAqACAgMSBwcACRkDAAoRBgYKEwAPDxMBBiMTCgcHGgMUASQFJRQHAwMKCgMmAQYYDxobFAAKBw8KBwMDAgkCAAAFGwACBwIHBgIDAQMIDAABKAkHBQURACkZASoAAAIrLAIALQcHBy4HLwkFCgMCMA0xAgMJAgACAQYKAQIBBQEACQIFAQEABQAODQ0GFQIBHBUGAgkCEAAAAAUyDzMMBQYINAUCAwUODg41AgMCAgIDBgICNgIBDAwMAQsLCwsLCx0CAAIAAAABABABBQICAQMCEgMMCwEBAQEBAQsLAQICAwICAgICAgIDAgIICAEICAgEBAQEBAQEBAQABAQABAQEBAAE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GiABQQA2AvADIAFCADcC6AMgAigC7AMiAyACKALoAyIERwRAIAMgBGsiBEEASA0FIAEgBBAeIgM2AuwDIAEgAzYC6AMgASADIARqNgLwAyACKALoAyIEIAIoAuwDIghHBEADQCADIAQoAgA2AgAgA0EEaiEDIARBBGoiBCAIRw0ACwsgASADNgLsAwsgASACKQL0AzcC9AMgASACKAKEBDYChAQgASACKQL8AzcC/AMgAUEANgLkAwsgBSABNgIAIAEgADYC5AMLIAZBAWohBiAFQQRqIgUgB0cNAAsLDwsQAgALUAACQAJAAkACQAJAIAIOBAQAAQIDCyAAIAEgAUEwahBDDwsgACABIAFBMGogAxBEDwsgACABIAFBMGoQQg8LECQACyAAIAEgAUEwaiADEEULcAIBfwF9IwBBEGsiBCQAIARBCGogACABQQJ0QdwlaigCACACEDZDAADAfyEFAkACQAJAIAQtAAxBAWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwt5AgF/AX0jAEEQayIDJAAgA0EIaiAAIAFBAnRB7CVqKAIAIAIQU0MAAMB/IQQCQAJAAkAgAy0ADEEBaw4CAAECCyADKgIIIQQMAQsgAyoCCEMAAAAAlEMK1yM8lCEECyADQRBqJAAgBEMAAAAAl0MAAAAAIAQgBFsbC1QAAkACQAJAAkACQCACDgQEAAECAwsgACABIAFBwgBqEEMPCyAAIAEgAUHCAGogAxBEDwsgACABIAFBwgBqEEIPCxAkAAsgACABIAFBwgBqIAMQRQsvACAAIAJFQQF0IgIgASADEGAgACACIAEQS5IgACACIAEgAxB/IAAgAiABEFKSkgvOAQIDfwJ9IwBBEGsiAyQAQQEhBCADQQhqIABB/ABqIgUgACABQQF0akH2AGoiAS8BABAfAkACQCADKgIIIgcgAioCACIGXARAIAcgB1sEQCACLQAEIQIMAgsgBiAGXCEECyACLQAEIQIgBEUNACADLQAMIAJB/wFxRg0BCyAFIAEgBiACEDkDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCyADQRBqJAALzgECA38CfSMAQRBrIgMk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AWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwscACAAIAFBCCACpyACQiCIpyADpyADQiCIpxAVCwUAEFgACzkAIABFBEBBAA8LAn8gAUGAf3FBgL8DRiABQf8ATXJFBEBB/DtBGTYCAEF/DAELIAAgAToAAEEBCwvEAgACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQQlrDhIACgsMCgsCAwQFDAsMDAoLBwgJCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCwALIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LAAsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAQALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC84BAgN/An0jAEEQayIDJABBASEEIANBCGogAEH8AGoiBSAAIAFBAXRqQegAaiIBLwEAEB8CQAJAIAMqAggiByACKgIAIgZcBEAgByAHWwRAIAItAAQhAgwCCyAGIAZcIQQLIAItAAQhAiAERQ0AIAMtAAwgAkH/AXFGDQELIAUgASAGIAIQOQNAIAAtAAAiAUEEcQ0BIAAgAUEEcjoAACAAKAIQIgEEQCAAIAERAAALIABBgICA/gc2ApwBIAAoAuQDIgANAAsLIANBEGokAAtdAQR/IAAoAgAhAgNAIAIsAAAiAxBXBEBBfyEEIAAgAkEBaiICNgIAIAFBzJmz5gBNBH9BfyADQTBrIgMgAUEKbCIEaiADIARB/////wdzShsFIAQLIQEMAQsLIAELrhQCEn8BfiMAQdAAayIIJAAgCCABNgJMIAhBN2ohFyAIQThqIRQCQAJAAkACQANAIAEhDSAHIA5B/////wdzSg0BIAcgDmohDgJAAkACQCANIgctAAAiCQRAA0ACQAJAIAlB/wFxIgFFBEAgByEBDAELIAFBJUcNASAH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IQEgAEIANwIEIAAgATYCACABIAA2AgQgAkEQaiQAIAALGwEBfyAABEAgACgCACIBBEAgARAjCyAAECMLC0kBAn9BBBAeIQFBIBAeIgBBADYCHCAAQoCAgICAgIDAPzcCFCAAQgA3AgwgAEEAOgAIIABBAzYCBCAAQQA2AgAgASAANgIAIAELIAAgAkEFR0EAIAIbRQRAQbgwIAMgBBBJDwsgAyAEEHALIgEBfiABIAKtIAOtQiCGhCAEIAARFQAiBUIgiKckASAFpwuoAQEFfyAAKAJUIgMoAgAhBSADKAIEIgQgACgCFCAAKAIcIgdrIgYgBCAGSRsiBgRAIAUgByAGECsaIAMgAygCACAGaiIFNgIAIAMgAygCBCAGayIENgIECyAEIAIgAiAESxsiBARAIAUgASAEECsaIAMgAygCACAEaiIFNgIAIAMgAygCBCAEazYCBAsgBUEAOgAAIAAgACgCLCIBNgIcIAAgATYCFCACCwQAQgALBABBAAuKBQIGfgJ/IAEgASgCAEEHakF4cSIBQRBqNgIAIAAhCSABKQMAIQMgASkDCCEGIwBBIGsiCCQAAkAgBkL///////////8AgyIEQoCAgICAgMCAPH0gBEKAgICAgIDA/8MAfVQEQCAGQgSGIANCPIiEIQQgA0L//////////w+DIgNCgYCAgICAgIAIWgRAIARCgYCAgICAgIDAAHwhAgwCCyAEQoCAgICAgICAQH0hAiADQoCAgICAgICACFINASACIARCAYN8IQIMAQsgA1AgBEKAgICAgIDA//8AVCAEQoCAgICAgMD//wBRG0UEQCAGQgSGIANCPIiEQv////////8Dg0KAgICAgICA/P8AhCECDAELQoCAgICAgID4/wAhAiAEQv///////7//wwBWDQBCACECIARCMIinIgBBkfcASQ0AIAMhAiAGQv///////z+DQoCAgICAgMAAhCIFIQcCQCAAQYH3AGsiAUHAAHEEQCACIAFBQGqthiEHQgAhAgwBCyABRQ0AIAcgAa0iBIYgAkHAACABa62IhCEHIAIgBIYhAgsgCCACNwMQIAggBzcDGAJAQYH4ACAAayIAQcAAcQRAIAUgAEFAaq2IIQNCACEFDAELIABFDQAgBUHAACAAa62GIAMgAK0iAoiEIQMgBSACiCEFCyAIIAM3AwAgCCAF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ASAAKAIAIQAgASACQQFxBH8gASgCACAAaigCAAUgAAsRCwALYQECfyMAQRBrIgIkACABIAAoAgQiA0EBdWohASAAKAIAIQAgAiABIANBAXEEfyABKAIAIABqKAIABSAACxEBAEEQEB4iACACKQMINwMIIAAgAikDADcDACACQRBqJAAgAAtjAQJ/IwBBEGsiAyQAIAEgACgCBCIEQQF1aiEBIAAoAgAhACADIAEgAiAEQQFxBH8gASgCACAAaigCAAUgAAsRAwBBEBAeIgAgAykDCDcDCCAAIAMpAwA3AwAgA0EQaiQAIAALNwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEEAAs5AQF/IAEgACgCBCIEQQF1aiEBIAAoAgAhACABIAIgAyAEQQFxBH8gASgCACAAaigCAAUgAAsRCAALCQAgASAAEQIACwUAQcM7Cw8AIAEgACgCAGogAjYCAAsNACABIAAoAgBqKAIACxgBAX9BEBAeIgBCADcDCCAAQQA2AgAgAAsYAQF/QRAQHiIAQgA3AwAgAEIANwMIIAALDABBMBAeQQBBMBAqCzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRHgALBQBBvjsLIQAgACABKAIAIAEgASwAC0EASBtBuzsgAigCABAQNgIACyoBAX9BDBAeIgFBADoABCABIAAoAgA2AgggAEEANgIAIAFB2Cc2AgAgAQsFAEG7OwsFAEG4OwshACAAIAEoAgAgASABLAALQQBIG0GkOyACKAIAEBA2AgAL2AEBBH8jAEEgayIDJAAgASgCACIEQfD///8HSQRAAkACQCAEQQtPBEAgBEEPckEBaiIFEB4hBiADIAVBgICAgHhyNgIQIAMgBjYCCCADIAQ2AgwgBCAGaiEFDAELIAMgBDoAEyADQQhqIgYgBGohBSAERQ0BCyAGIAFBBGogBBArGgsgBUEAOgAAIAMgAjYCACADQRhqIANBCGogAyAAEQMAIAMoAhgQHSADKAIYIgAQBiADKAIAEAYgAywAE0EASARAIAMoAggQIwsgA0EgaiQAIAAPCxACAAsqAQF/QQwQHiIBQQA6AAQgASAAKAIANgIIIABBADYCACABQeAmNgIA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AkEIaiAIIAYQHyACIAcgAC8AABAfQQEhAyACKgIIIgogAioCACILXAR/IAogClsNAyALIAtcBSADC0UNAiACLQAMIAItAARHDQILIABBAmohAEEBIQMgBCEGQQEhBCAGRQ0ACyABLwB6IgBBB3FFBEAgBS0AekEHcUUNAgsgCCAAECAiCiAHIAUvAHoQICILWw0BIAogClsNACALIAtcDQELIAFBFGogBUEUakHoABArGiABQfwAaiAFQfwAahCgAQNAIAEtAAAiAEEEcQ0BIAEgAEEEcjoAACABKAIQIgAEQCABIAARAAALIAFBgICA/gc2ApwBIAEoAuQDIgENAAsLIAJBEGokAAvGAwEEfyMAQaAEayICJAAgACgCBCEBIABBADYCBCABBEAgASABKAIAKAIEEQAACyAAKAIIIQEgAEEANgIIIAEEQCABIAEoAgAoAgQRAAALAkAgACgCACIAKALoAyAAKALsA0YEQCAAKALkAw0BIAAgAkEYaiAAKAL0AxBcIgEpAgA3AgAgACABKAIQNgIQIAAgASkCCDcCCCAAQRRqIAFBFGpB6AAQKxogACABKQKMATcCjAEgACABKQKEATcChAEgACABKQJ8NwJ8IAEoApQBIQQgAUEANgKUASAAKAKUASEDIAAgBDYClAEgAwRAIAMQWwsgAEGYAWogAUGYAWpB0AIQKxogACgC6AMiAwRAIAAgAzYC7AMgAxAjCyAAIAEoAugDNgLoAyAAIAEoAuwDNgLsAyAAIAEoAvADNgLwAyABQQA2AvADIAFCADcC6AMgACABKQL8AzcC/AMgACABKQL0AzcC9AMgACABKAKEBDYChAQgASgClAEhACABQQA2ApQBIAAEQCAAEFsLIAJBoARqJAAPCyACQfAcNgIQIABBBUHYJSACQRBqECwQJAALIAJB5hE2AgAgAEEFQdglIAIQLBAkAAsLAEEMEB4gABCiAQsLAEEMEB5BABCiAQsNACAAKAIALQAIQQFxCwoAIAAoAgAoAhQLGQAgAUH/AXEEQBACAAsgACgCACgCEEEBcQsYACAAKAIAIgAgAC0ACEH+AXEgAXI6AAgLJgAgASAAKAIAIgAoAhRHBEAgACABNgIUIAAgACgCDEEBajYCDAsLkgEBAn8jAEEQayICJAAgACgCACEAIAFDAAAAAGAEQCABIAAqAhhcBEAgACABOAIYIAAgACgCDEEBajYCDAsgAkEQaiQADwsgAkGIFDYCACMAQRBrIgMkACADIAI2AgwCQCAARQRAQbgwQdglIAIQSRoMAQsgAEEAQQVB2CUgAiAAKAIEEQ0AGgsgA0EQaiQAECQACz8AIAFB/wFxRQRAIAIgACgCACIAKAIQIgFBAXFHBEAgACABQX5xIAJyNgIQIAAgACgCDEEBajYCDAsPCxACAAsL4CYjAEGACAuBHk9ubHkgbGVhZiBub2RlcyB3aXRoIGN1c3RvbSBtZWFzdXJlIGZ1bmN0aW9ucyBzaG91bGQgbWFudWFsbHkgbWFyayB0aGVtc2VsdmVzIGFzIGRpcnR5AGlzRGlydHkAbWFya0RpcnR5AGRlc3Ryb3kAc2V0RGlzcGxheQBnZXREaXNwbGF5AHNldEZsZXgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABzZXRGbGV4R3JvdwBnZXRGbGV4R3JvdwBzZXRPdmVyZmxvdwBnZXRPdmVyZmxvdwBoYXNOZXdMYXlvdXQAY2FsY3VsYXRlTGF5b3V0AGdldENvbXB1dGVkTGF5b3V0AHVuc2lnbmVkIHNob3J0AGdldENoaWxkQ291bnQAdW5zaWduZWQgaW50AHNldEp1c3RpZnlDb250ZW50AGdldEp1c3RpZnlDb250ZW50AGF2YWlsYWJsZUhlaWdodCBpcyBpbmRlZmluaXRlIHNvIGhlaWdodFNpemluZ01vZGUgbXVzdCBiZSBTaXppbmdNb2RlOjpNYXhDb250ZW50AGF2YWlsYWJsZVdpZHRoIGlzIGluZGVmaW5pdGUgc28gd2lkdGhTaXppbmdNb2RlIG11c3QgYmUgU2l6aW5nTW9kZTo6TWF4Q29udGVudABzZXRBbGlnbkNvbnRlbnQAZ2V0QWxpZ25Db250ZW50AGdldFBhcmVudABpbXBsZW1lbnQAc2V0TWF4SGVpZ2h0UGVyY2VudABzZXRIZWlnaHRQZXJjZW50AHNldE1pbkhlaWdodFBlcmNlbnQAc2V0RmxleEJhc2lzUGVyY2VudABzZXRHYXBQZXJjZW50AHNldFBvc2l0aW9uUGVyY2VudABzZXRNYXJnaW5QZXJjZW50AHNldE1heFdpZHRoUGVyY2VudABzZXRXaWR0aFBlcmNlbnQAc2V0TWluV2lkdGhQZXJjZW50AHNldFBhZGRpbmdQZXJjZW50AGhhbmRsZS50eXBlKCkgPT0gU3R5bGVWYWx1ZUhhbmRsZTo6VHlwZTo6UG9pbnQgfHwgaGFuZGxlLnR5cGUoKSA9PSBTdHlsZVZhbHVlSGFuZGxlOjpUeXBlOjpQZXJjZW50AGNyZWF0ZURlZmF1bHQAdW5pdAByaWdodABoZWlnaHQAc2V0TWF4SGVpZ2h0AGdldE1heEhlaWdodABzZXRIZWlnaHQAZ2V0SGVpZ2h0AHNldE1pbkhlaWdodABnZXRNaW5IZWlnaHQAZ2V0Q29tcHV0ZWRIZWlnaHQAZ2V0Q29tcHV0ZWRSaWdodABsZWZ0AGdldENvbXB1dGVkTGVmdAByZXNldABfX2Rlc3RydWN0AGZsb2F0AHVpbnQ2NF90AHVzZVdlYkRlZmF1bHRzAHNldFVzZVdlYkRlZmF1bHRzAHNldEFsaWduSXRlbXMAZ2V0QWxpZ25JdGVtcwBzZXRGbGV4QmFzaXMAZ2V0RmxleEJhc2lzAENhbm5vdCBnZXQgbGF5b3V0IHByb3BlcnRpZXMgb2YgbXVsdGktZWRnZSBzaG9ydGhhbmRzAHNldFBvaW50U2NhbGVGYWN0b3IATWVhc3VyZUNhbGxiYWNrV3JhcHBlcgBEaXJ0aWVkQ2FsbGJhY2tXcmFwcGVyAENhbm5vdCByZXNldCBhIG5vZGUgc3RpbGwgYXR0YWNoZWQgdG8gYSBvd25lcgBzZXRCb3JkZXIAZ2V0Qm9yZGVyAGdldENvbXB1dGVkQm9yZGVyAGdldE51bWJlcgBoYW5kbGUudHlwZSgpID09IFN0eWxlVmFsdWVIYW5kbGU6OlR5cGU6Ok51bWJlcgB1bnNpZ25lZCBjaGFyAHRvcABnZXRDb21wdXRlZFRvcABzZXRGbGV4V3JhcABnZXRGbGV4V3JhcABzZXRHYXAAZ2V0R2FwACVwAHNldEhlaWdodEF1dG8Ac2V0RmxleEJhc2lzQXV0bwBzZXRQb3NpdGlvbkF1dG8Ac2V0TWFyZ2luQXV0bwBzZXRXaWR0aEF1dG8AU2NhbGUgZmFjdG9yIHNob3VsZCBub3QgYmUgbGVzcyB0aGFuIHplcm8Ac2V0QXNwZWN0UmF0aW8AZ2V0QXNwZWN0UmF0aW8Ac2V0UG9zaXRpb24AZ2V0UG9zaXRpb24Abm90aWZ5T25EZXN0cnVjdGlvbgBzZXRGbGV4RGlyZWN0aW9uAGdldEZsZXhEaXJlY3Rpb24Ac2V0RGlyZWN0aW9uAGdldERpcmVjdGlvbgBzZXRNYXJnaW4AZ2V0TWFyZ2luAGdldENvbXB1dGVkTWFyZ2luAG1hcmtMYXlvdXRTZWVuAG5hbgBib3R0b20AZ2V0Q29tcHV0ZWRCb3R0b20AYm9vbABlbXNjcmlwdGVuOjp2YWwAc2V0RmxleFNocmluawBnZXRGbGV4U2hyaW5rAHNldEFsd2F5c0Zvcm1zQ29udGFpbmluZ0Jsb2NrAE1lYXN1cmVDYWxsYmFjawBEaXJ0aWVkQ2FsbGJhY2sAZ2V0TGVuZ3RoAHdpZHRoAHNldE1heFdpZHRoAGdldE1heFdpZHRoAHNldFdpZHRoAGdldFdpZHRoAHNldE1pbldpZHRoAGdldE1pbldpZHRoAGdldENvbXB1dGVkV2lkdGgAcHVzaAAvaG9tZS9ydW5uZXIvd29yay95b2dhL3lvZ2EvamF2YXNjcmlwdC8uLi95b2dhL3N0eWxlL1NtYWxsVmFsdWVCdWZmZXIuaAAvaG9tZS9ydW5uZXIvd29yay95b2dhL3lvZ2EvamF2YXNjcmlwdC8uLi95b2dhL3N0eWxlL1N0eWxlVmFsdWVQb29sLmgAdW5zaWduZWQgbG9uZwBzZXRCb3hTaXppbmcAZ2V0Qm94U2l6aW5nAHN0ZDo6d3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBzZXRQYWRkaW5nAGdldFBhZGRpbmcAZ2V0Q29tcHV0ZWRQYWRkaW5nAFRyaWVkIHRvIGNvbnN0cnVjdCBZR05vZGUgd2l0aCBudWxsIGNvbmZpZwBBdHRlbXB0aW5nIHRvIGNvbnN0cnVjdCBOb2RlIHdpdGggbnVsbCBjb25maWcAY3JlYXRlV2l0aENvbmZpZwBpbmYAc2V0QWxpZ25TZWxmAGdldEFsaWduU2VsZgBTaXplAHZhbHVlAFZhbHVlAGNyZWF0ZQBtZWFzdXJlAHNldFBvc2l0aW9uVHlwZQBnZXRQb3NpdGlvblR5cGUAaXNSZWZlcmVuY2VCYXNlbGluZQBzZXRJc1JlZmVyZW5jZUJhc2VsaW5lAGNvcHlTdHlsZQBkb3VibGUATm9kZQBleHRlbmQAaW5zZXJ0Q2hpbGQAZ2V0Q2hpbGQAcmVtb3ZlQ2hpbGQAdm9pZABzZXRFeHBlcmltZW50YWxGZWF0dXJlRW5hYmxlZABpc0V4cGVyaW1lbnRhbEZlYXR1cmVFbmFibGVkAGRpcnRpZWQAQ2Fubm90IHJlc2V0IGEgbm9kZSB3aGljaCBzdGlsbCBoYXMgY2hpbGRyZW4gYXR0YWNoZWQAdW5zZXRNZWFzdXJlRnVuYwB1bnNldERpcnRpZWRGdW5jAHNldEVycmF0YQBnZXRFcnJhdGEATWVhc3VyZSBmdW5jdGlvbiByZXR1cm5lZCBhbiBpbnZhbGlkIGRpbWVuc2lvbiB0byBZb2dhOiBbd2lkdGg9JWYsIGhlaWdodD0lZl0ARXhwZWN0IGN1c3RvbSBiYXNlbGluZSBmdW5jdGlvbiB0byBub3QgcmV0dXJuIE5hTgBOQU4ASU5GAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVk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";
    if (!ua(H)) {
      var va = H;
      H = h.locateFile ? h.locateFile(va, q) : q + va;
    }
    function wa() {
      var a4 = H;
      try {
        if (a4 == H && w) return new Uint8Array(w);
        if (ua(a4)) try {
          var b3 = xa(a4.slice(37)), c2 = new Uint8Array(b3.length);
          for (a4 = 0; a4 < b3.length; ++a4) c2[a4] = b3.charCodeAt(a4);
          var d3 = c2;
        } catch (f4) {
          throw Error("Converting base64 string to bytes failed.");
        }
        else d3 = void 0;
        var e4 = d3;
        if (e4) return e4;
        throw "both async and sync fetching of the wasm failed";
      } catch (f4) {
        x(f4);
      }
    }
    __name(wa, "wa");
    function ya() {
      return w || "function" != typeof fetch ? Promise.resolve().then(function() {
        return wa();
      }) : fetch(H, { credentials: "same-origin" }).then(function(a4) {
        if (!a4.ok) throw "failed to load wasm binary file at '" + H + "'";
        return a4.arrayBuffer();
      }).catch(function() {
        return wa();
      });
    }
    __name(ya, "ya");
    function za(a4) {
      for (; 0 < a4.length; ) a4.shift()(h);
    }
    __name(za, "za");
    function Aa(a4) {
      if (void 0 === a4) return "_unknown";
      a4 = a4.replace(/[^a-zA-Z0-9_]/g, "$");
      var b3 = a4.charCodeAt(0);
      return 48 <= b3 && 57 >= b3 ? "_" + a4 : a4;
    }
    __name(Aa, "Aa");
    function Ba(a4, b3) {
      a4 = Aa(a4);
      return function() {
        return b3.apply(this, arguments);
      };
    }
    __name(Ba, "Ba");
    var J = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }], Ca = [];
    function Da(a4) {
      var b3 = Error, c2 = Ba(a4, function(d3) {
        this.name = a4;
        this.message = d3;
        d3 = Error(d3).stack;
        void 0 !== d3 && (this.stack = this.toString() + "\n" + d3.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      c2.prototype = Object.create(b3.prototype);
      c2.prototype.constructor = c2;
      c2.prototype.toString = function() {
        return void 0 === this.message ? this.name : this.name + ": " + this.message;
      };
      return c2;
    }
    __name(Da, "Da");
    var K = void 0;
    function L(a4) {
      throw new K(a4);
    }
    __name(L, "L");
    var M = /* @__PURE__ */ __name((a4) => {
      a4 || L("Cannot use deleted val. handle = " + a4);
      return J[a4].value;
    }, "M"), Ea = /* @__PURE__ */ __name((a4) => {
      switch (a4) {
        case void 0:
          return 1;
        case null:
          return 2;
        case true:
          return 3;
        case false:
          return 4;
        default:
          var b3 = Ca.length ? Ca.pop() : J.length;
          J[b3] = { ga: 1, value: a4 };
          return b3;
      }
    }, "Ea"), Fa = void 0, Ga = void 0;
    function N(a4) {
      for (var b3 = ""; A[a4]; ) b3 += Ga[A[a4++]];
      return b3;
    }
    __name(N, "N");
    var O = [];
    function Ha() {
      for (; O.length; ) {
        var a4 = O.pop();
        a4.M.$ = false;
        a4["delete"]();
      }
    }
    __name(Ha, "Ha");
    var P = void 0, Q = {};
    function Ia(a4, b3) {
      for (void 0 === b3 && L("ptr should not be undefined"); a4.R; ) b3 = a4.ba(b3), a4 = a4.R;
      return b3;
    }
    __name(Ia, "Ia");
    var R = {};
    function Ja(a4) {
      a4 = Ka(a4);
      var b3 = N(a4);
      S3(a4);
      return b3;
    }
    __name(Ja, "Ja");
    function La(a4, b3) {
      var c2 = R[a4];
      void 0 === c2 && L(b3 + " has unknown type " + Ja(a4));
      return c2;
    }
    __name(La, "La");
    function Ma() {
    }
    __name(Ma, "Ma");
    var Na = false;
    function Oa(a4) {
      --a4.count.value;
      0 === a4.count.value && (a4.T ? a4.U.W(a4.T) : a4.P.N.W(a4.O));
    }
    __name(Oa, "Oa");
    function Pa(a4, b3, c2) {
      if (b3 === c2) return a4;
      if (void 0 === c2.R) return null;
      a4 = Pa(a4, b3, c2.R);
      return null === a4 ? null : c2.na(a4);
    }
    __name(Pa, "Pa");
    var Qa = {};
    function Ra(a4, b3) {
      b3 = Ia(a4, b3);
      return Q[b3];
    }
    __name(Ra, "Ra");
    var Sa = void 0;
    function Ta(a4) {
      throw new Sa(a4);
    }
    __name(Ta, "Ta");
    function Ua(a4, b3) {
      b3.P && b3.O || Ta("makeClassHandle requires ptr and ptrType");
      !!b3.U !== !!b3.T && Ta("Both smartPtrType and smartPtr must be specified");
      b3.count = { value: 1 };
      return T(Object.create(a4, { M: { value: b3 } }));
    }
    __name(Ua, "Ua");
    function T(a4) {
      if ("undefined" === typeof FinalizationRegistry) return T = /* @__PURE__ */ __name((b3) => b3, "T"), a4;
      Na = new FinalizationRegistry((b3) => {
        Oa(b3.M);
      });
      T = /* @__PURE__ */ __name((b3) => {
        var c2 = b3.M;
        c2.T && Na.register(b3, { M: c2 }, b3);
        return b3;
      }, "T");
      Ma = /* @__PURE__ */ __name((b3) => {
        Na.unregister(b3);
      }, "Ma");
      return T(a4);
    }
    __name(T, "T");
    var Va = {};
    function Wa(a4) {
      for (; a4.length; ) {
        var b3 = a4.pop();
        a4.pop()(b3);
      }
    }
    __name(Wa, "Wa");
    function Xa(a4) {
      return this.fromWireType(D[a4 >> 2]);
    }
    __name(Xa, "Xa");
    var U = {}, Ya = {};
    function V(a4, b3, c2) {
      function d3(k3) {
        k3 = c2(k3);
        k3.length !== a4.length && Ta("Mismatched type converter count");
        for (var m3 = 0; m3 < a4.length; ++m3) W(a4[m3], k3[m3]);
      }
      __name(d3, "d");
      a4.forEach(function(k3) {
        Ya[k3] = b3;
      });
      var e4 = Array(b3.length), f4 = [], g = 0;
      b3.forEach((k3, m3) => {
        R.hasOwnProperty(k3) ? e4[m3] = R[k3] : (f4.push(k3), U.hasOwnProperty(k3) || (U[k3] = []), U[k3].push(() => {
          e4[m3] = R[k3];
          ++g;
          g === f4.length && d3(e4);
        }));
      });
      0 === f4.length && d3(e4);
    }
    __name(V, "V");
    function Za(a4) {
      switch (a4) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError("Unknown type size: " + a4);
      }
    }
    __name(Za, "Za");
    function W(a4, b3, c2 = {}) {
      if (!("argPackAdvance" in b3)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
      var d3 = b3.name;
      a4 || L('type "' + d3 + '" must have a positive integer typeid pointer');
      if (R.hasOwnProperty(a4)) {
        if (c2.ua) return;
        L("Cannot register type '" + d3 + "' twice");
      }
      R[a4] = b3;
      delete Ya[a4];
      U.hasOwnProperty(a4) && (b3 = U[a4], delete U[a4], b3.forEach((e4) => e4()));
    }
    __name(W, "W");
    function $a(a4) {
      L(a4.M.P.N.name + " instance already deleted");
    }
    __name($a, "$a");
    function X() {
    }
    __name(X, "X");
    function ab(a4, b3, c2) {
      if (void 0 === a4[b3].S) {
        var d3 = a4[b3];
        a4[b3] = function() {
          a4[b3].S.hasOwnProperty(arguments.length) || L("Function '" + c2 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a4[b3].S + ")!");
          return a4[b3].S[arguments.length].apply(this, arguments);
        };
        a4[b3].S = [];
        a4[b3].S[d3.Z] = d3;
      }
    }
    __name(ab, "ab");
    function bb(a4, b3) {
      h.hasOwnProperty(a4) ? (L("Cannot register public name '" + a4 + "' twice"), ab(h, a4, a4), h.hasOwnProperty(void 0) && L("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), h[a4].S[void 0] = b3) : h[a4] = b3;
    }
    __name(bb, "bb");
    function cb(a4, b3, c2, d3, e4, f4, g, k3) {
      this.name = a4;
      this.constructor = b3;
      this.X = c2;
      this.W = d3;
      this.R = e4;
      this.pa = f4;
      this.ba = g;
      this.na = k3;
      this.ja = [];
    }
    __name(cb, "cb");
    function db(a4, b3, c2) {
      for (; b3 !== c2; ) b3.ba || L("Expected null or instance of " + c2.name + ", got an instance of " + b3.name), a4 = b3.ba(a4), b3 = b3.R;
      return a4;
    }
    __name(db, "db");
    function eb(a4, b3) {
      if (null === b3) return this.ea && L("null is not a valid " + this.name), 0;
      b3.M || L('Cannot pass "' + fb(b3) + '" as a ' + this.name);
      b3.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      return db(b3.M.O, b3.M.P.N, this.N);
    }
    __name(eb, "eb");
    function gb(a4, b3) {
      if (null === b3) {
        this.ea && L("null is not a valid " + this.name);
        if (this.da) {
          var c2 = this.fa();
          null !== a4 && a4.push(this.W, c2);
          return c2;
        }
        return 0;
      }
      b3.M || L('Cannot pass "' + fb(b3) + '" as a ' + this.name);
      b3.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      !this.ca && b3.M.P.ca && L("Cannot convert argument of type " + (b3.M.U ? b3.M.U.name : b3.M.P.name) + " to parameter type " + this.name);
      c2 = db(b3.M.O, b3.M.P.N, this.N);
      if (this.da) switch (void 0 === b3.M.T && L("Passing raw pointer to smart pointer is illegal"), this.Ba) {
        case 0:
          b3.M.U === this ? c2 = b3.M.T : L("Cannot convert argument of type " + (b3.M.U ? b3.M.U.name : b3.M.P.name) + " to parameter type " + this.name);
          break;
        case 1:
          c2 = b3.M.T;
          break;
        case 2:
          if (b3.M.U === this) c2 = b3.M.T;
          else {
            var d3 = b3.clone();
            c2 = this.xa(c2, Ea(function() {
              d3["delete"]();
            }));
            null !== a4 && a4.push(this.W, c2);
          }
          break;
        default:
          L("Unsupporting sharing policy");
      }
      return c2;
    }
    __name(gb, "gb");
    function hb(a4, b3) {
      if (null === b3) return this.ea && L("null is not a valid " + this.name), 0;
      b3.M || L('Cannot pass "' + fb(b3) + '" as a ' + this.name);
      b3.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      b3.M.P.ca && L("Cannot convert argument of type " + b3.M.P.name + " to parameter type " + this.name);
      return db(b3.M.O, b3.M.P.N, this.N);
    }
    __name(hb, "hb");
    function Y(a4, b3, c2, d3) {
      this.name = a4;
      this.N = b3;
      this.ea = c2;
      this.ca = d3;
      this.da = false;
      this.W = this.xa = this.fa = this.ka = this.Ba = this.wa = void 0;
      void 0 !== b3.R ? this.toWireType = gb : (this.toWireType = d3 ? eb : hb, this.V = null);
    }
    __name(Y, "Y");
    function ib(a4, b3) {
      h.hasOwnProperty(a4) || Ta("Replacing nonexistant public symbol");
      h[a4] = b3;
      h[a4].Z = void 0;
    }
    __name(ib, "ib");
    function jb(a4, b3) {
      var c2 = [];
      return function() {
        c2.length = 0;
        Object.assign(c2, arguments);
        if (a4.includes("j")) {
          var d3 = h["dynCall_" + a4];
          d3 = c2 && c2.length ? d3.apply(null, [b3].concat(c2)) : d3.call(null, b3);
        } else d3 = oa.get(b3).apply(null, c2);
        return d3;
      };
    }
    __name(jb, "jb");
    function Z(a4, b3) {
      a4 = N(a4);
      var c2 = a4.includes("j") ? jb(a4, b3) : oa.get(b3);
      "function" != typeof c2 && L("unknown function pointer with signature " + a4 + ": " + b3);
      return c2;
    }
    __name(Z, "Z");
    var mb = void 0;
    function nb(a4, b3) {
      function c2(f4) {
        e4[f4] || R[f4] || (Ya[f4] ? Ya[f4].forEach(c2) : (d3.push(f4), e4[f4] = true));
      }
      __name(c2, "c");
      var d3 = [], e4 = {};
      b3.forEach(c2);
      throw new mb(a4 + ": " + d3.map(Ja).join([", "]));
    }
    __name(nb, "nb");
    function ob(a4, b3, c2, d3, e4) {
      var f4 = b3.length;
      2 > f4 && L("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var g = null !== b3[1] && null !== c2, k3 = false;
      for (c2 = 1; c2 < b3.length; ++c2) if (null !== b3[c2] && void 0 === b3[c2].V) {
        k3 = true;
        break;
      }
      var m3 = "void" !== b3[0].name, l4 = f4 - 2, n5 = Array(l4), p3 = [], r5 = [];
      return function() {
        arguments.length !== l4 && L("function " + a4 + " called with " + arguments.length + " arguments, expected " + l4 + " args!");
        r5.length = 0;
        p3.length = g ? 2 : 1;
        p3[0] = e4;
        if (g) {
          var u4 = b3[1].toWireType(r5, this);
          p3[1] = u4;
        }
        for (var t4 = 0; t4 < l4; ++t4) n5[t4] = b3[t4 + 2].toWireType(r5, arguments[t4]), p3.push(n5[t4]);
        t4 = d3.apply(null, p3);
        if (k3) Wa(r5);
        else for (var y3 = g ? 1 : 2; y3 < b3.length; y3++) {
          var B = 1 === y3 ? u4 : n5[y3 - 2];
          null !== b3[y3].V && b3[y3].V(B);
        }
        u4 = m3 ? b3[0].fromWireType(t4) : void 0;
        return u4;
      };
    }
    __name(ob, "ob");
    function pb(a4, b3) {
      for (var c2 = [], d3 = 0; d3 < a4; d3++) c2.push(E[b3 + 4 * d3 >> 2]);
      return c2;
    }
    __name(pb, "pb");
    function qb(a4) {
      4 < a4 && 0 === --J[a4].ga && (J[a4] = void 0, Ca.push(a4));
    }
    __name(qb, "qb");
    function fb(a4) {
      if (null === a4) return "null";
      var b3 = typeof a4;
      return "object" === b3 || "array" === b3 || "function" === b3 ? a4.toString() : "" + a4;
    }
    __name(fb, "fb");
    function rb(a4, b3) {
      switch (b3) {
        case 2:
          return function(c2) {
            return this.fromWireType(la[c2 >> 2]);
          };
        case 3:
          return function(c2) {
            return this.fromWireType(ma[c2 >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + a4);
      }
    }
    __name(rb, "rb");
    function sb(a4, b3, c2) {
      switch (b3) {
        case 0:
          return c2 ? function(d3) {
            return ja[d3];
          } : function(d3) {
            return A[d3];
          };
        case 1:
          return c2 ? function(d3) {
            return C[d3 >> 1];
          } : function(d3) {
            return ka[d3 >> 1];
          };
        case 2:
          return c2 ? function(d3) {
            return D[d3 >> 2];
          } : function(d3) {
            return E[d3 >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + a4);
      }
    }
    __name(sb, "sb");
    function tb(a4, b3) {
      for (var c2 = "", d3 = 0; !(d3 >= b3 / 2); ++d3) {
        var e4 = C[a4 + 2 * d3 >> 1];
        if (0 == e4) break;
        c2 += String.fromCharCode(e4);
      }
      return c2;
    }
    __name(tb, "tb");
    function ub(a4, b3, c2) {
      void 0 === c2 && (c2 = 2147483647);
      if (2 > c2) return 0;
      c2 -= 2;
      var d3 = b3;
      c2 = c2 < 2 * a4.length ? c2 / 2 : a4.length;
      for (var e4 = 0; e4 < c2; ++e4) C[b3 >> 1] = a4.charCodeAt(e4), b3 += 2;
      C[b3 >> 1] = 0;
      return b3 - d3;
    }
    __name(ub, "ub");
    function vb(a4) {
      return 2 * a4.length;
    }
    __name(vb, "vb");
    function wb(a4, b3) {
      for (var c2 = 0, d3 = ""; !(c2 >= b3 / 4); ) {
        var e4 = D[a4 + 4 * c2 >> 2];
        if (0 == e4) break;
        ++c2;
        65536 <= e4 ? (e4 -= 65536, d3 += String.fromCharCode(55296 | e4 >> 10, 56320 | e4 & 1023)) : d3 += String.fromCharCode(e4);
      }
      return d3;
    }
    __name(wb, "wb");
    function xb(a4, b3, c2) {
      void 0 === c2 && (c2 = 2147483647);
      if (4 > c2) return 0;
      var d3 = b3;
      c2 = d3 + c2 - 4;
      for (var e4 = 0; e4 < a4.length; ++e4) {
        var f4 = a4.charCodeAt(e4);
        if (55296 <= f4 && 57343 >= f4) {
          var g = a4.charCodeAt(++e4);
          f4 = 65536 + ((f4 & 1023) << 10) | g & 1023;
        }
        D[b3 >> 2] = f4;
        b3 += 4;
        if (b3 + 4 > c2) break;
      }
      D[b3 >> 2] = 0;
      return b3 - d3;
    }
    __name(xb, "xb");
    function yb(a4) {
      for (var b3 = 0, c2 = 0; c2 < a4.length; ++c2) {
        var d3 = a4.charCodeAt(c2);
        55296 <= d3 && 57343 >= d3 && ++c2;
        b3 += 4;
      }
      return b3;
    }
    __name(yb, "yb");
    var zb = {};
    function Ab(a4) {
      var b3 = zb[a4];
      return void 0 === b3 ? N(a4) : b3;
    }
    __name(Ab, "Ab");
    var Bb = [];
    function Cb(a4) {
      var b3 = Bb.length;
      Bb.push(a4);
      return b3;
    }
    __name(Cb, "Cb");
    function Db(a4, b3) {
      for (var c2 = Array(a4), d3 = 0; d3 < a4; ++d3) c2[d3] = La(E[b3 + 4 * d3 >> 2], "parameter " + d3);
      return c2;
    }
    __name(Db, "Db");
    var Eb = [], Fb = [null, [], []];
    K = h.BindingError = Da("BindingError");
    h.count_emval_handles = function() {
      for (var a4 = 0, b3 = 5; b3 < J.length; ++b3) void 0 !== J[b3] && ++a4;
      return a4;
    };
    h.get_first_emval = function() {
      for (var a4 = 5; a4 < J.length; ++a4) if (void 0 !== J[a4]) return J[a4];
      return null;
    };
    Fa = h.PureVirtualError = Da("PureVirtualError");
    for (var Gb = Array(256), Hb = 0; 256 > Hb; ++Hb) Gb[Hb] = String.fromCharCode(Hb);
    Ga = Gb;
    h.getInheritedInstanceCount = function() {
      return Object.keys(Q).length;
    };
    h.getLiveInheritedInstances = function() {
      var a4 = [], b3;
      for (b3 in Q) Q.hasOwnProperty(b3) && a4.push(Q[b3]);
      return a4;
    };
    h.flushPendingDeletes = Ha;
    h.setDelayFunction = function(a4) {
      P = a4;
      O.length && P && P(Ha);
    };
    Sa = h.InternalError = Da("InternalError");
    X.prototype.isAliasOf = function(a4) {
      if (!(this instanceof X && a4 instanceof X)) return false;
      var b3 = this.M.P.N, c2 = this.M.O, d3 = a4.M.P.N;
      for (a4 = a4.M.O; b3.R; ) c2 = b3.ba(c2), b3 = b3.R;
      for (; d3.R; ) a4 = d3.ba(a4), d3 = d3.R;
      return b3 === d3 && c2 === a4;
    };
    X.prototype.clone = function() {
      this.M.O || $a(this);
      if (this.M.aa) return this.M.count.value += 1, this;
      var a4 = T, b3 = Object, c2 = b3.create, d3 = Object.getPrototypeOf(this), e4 = this.M;
      a4 = a4(c2.call(b3, d3, { M: { value: { count: e4.count, $: e4.$, aa: e4.aa, O: e4.O, P: e4.P, T: e4.T, U: e4.U } } }));
      a4.M.count.value += 1;
      a4.M.$ = false;
      return a4;
    };
    X.prototype["delete"] = function() {
      this.M.O || $a(this);
      this.M.$ && !this.M.aa && L("Object already scheduled for deletion");
      Ma(this);
      Oa(this.M);
      this.M.aa || (this.M.T = void 0, this.M.O = void 0);
    };
    X.prototype.isDeleted = function() {
      return !this.M.O;
    };
    X.prototype.deleteLater = function() {
      this.M.O || $a(this);
      this.M.$ && !this.M.aa && L("Object already scheduled for deletion");
      O.push(this);
      1 === O.length && P && P(Ha);
      this.M.$ = true;
      return this;
    };
    Y.prototype.qa = function(a4) {
      this.ka && (a4 = this.ka(a4));
      return a4;
    };
    Y.prototype.ha = function(a4) {
      this.W && this.W(a4);
    };
    Y.prototype.argPackAdvance = 8;
    Y.prototype.readValueFromPointer = Xa;
    Y.prototype.deleteObject = function(a4) {
      if (null !== a4) a4["delete"]();
    };
    Y.prototype.fromWireType = function(a4) {
      function b3() {
        return this.da ? Ua(this.N.X, { P: this.wa, O: c2, U: this, T: a4 }) : Ua(this.N.X, { P: this, O: a4 });
      }
      __name(b3, "b");
      var c2 = this.qa(a4);
      if (!c2) return this.ha(a4), null;
      var d3 = Ra(this.N, c2);
      if (void 0 !== d3) {
        if (0 === d3.M.count.value) return d3.M.O = c2, d3.M.T = a4, d3.clone();
        d3 = d3.clone();
        this.ha(a4);
        return d3;
      }
      d3 = this.N.pa(c2);
      d3 = Qa[d3];
      if (!d3) return b3.call(this);
      d3 = this.ca ? d3.la : d3.pointerType;
      var e4 = Pa(c2, this.N, d3.N);
      return null === e4 ? b3.call(this) : this.da ? Ua(d3.N.X, { P: d3, O: e4, U: this, T: a4 }) : Ua(d3.N.X, { P: d3, O: e4 });
    };
    mb = h.UnboundTypeError = Da("UnboundTypeError");
    var xa = "function" == typeof atob ? atob : function(a4) {
      var b3 = "", c2 = 0;
      a4 = a4.replace(/[^A-Za-z0-9\+\/=]/g, "");
      do {
        var d3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a4.charAt(c2++));
        var e4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a4.charAt(c2++));
        var f4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a4.charAt(c2++));
        var g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a4.charAt(c2++));
        d3 = d3 << 2 | e4 >> 4;
        e4 = (e4 & 15) << 4 | f4 >> 2;
        var k3 = (f4 & 3) << 6 | g;
        b3 += String.fromCharCode(d3);
        64 !== f4 && (b3 += String.fromCharCode(e4));
        64 !== g && (b3 += String.fromCharCode(k3));
      } while (c2 < a4.length);
      return b3;
    }, Jb = {
      l: /* @__PURE__ */ __name(function(a4, b3, c2, d3) {
        x("Assertion failed: " + (a4 ? z(A, a4) : "") + ", at: " + [b3 ? b3 ? z(A, b3) : "" : "unknown filename", c2, d3 ? d3 ? z(A, d3) : "" : "unknown function"]);
      }, "l"),
      q: /* @__PURE__ */ __name(function(a4, b3, c2) {
        a4 = N(a4);
        b3 = La(b3, "wrapper");
        c2 = M(c2);
        var d3 = [].slice, e4 = b3.N, f4 = e4.X, g = e4.R.X, k3 = e4.R.constructor;
        a4 = Ba(a4, function() {
          e4.R.ja.forEach(function(l4) {
            if (this[l4] === g[l4]) throw new Fa("Pure virtual function " + l4 + " must be implemented in JavaScript");
          }.bind(this));
          Object.defineProperty(this, "__parent", { value: f4 });
          this.__construct.apply(this, d3.call(arguments));
        });
        f4.__construct = function() {
          this === f4 && L("Pass correct 'this' to __construct");
          var l4 = k3.implement.apply(void 0, [this].concat(d3.call(arguments)));
          Ma(l4);
          var n5 = l4.M;
          l4.notifyOnDestruction();
          n5.aa = true;
          Object.defineProperties(this, { M: { value: n5 } });
          T(this);
          l4 = n5.O;
          l4 = Ia(e4, l4);
          Q.hasOwnProperty(l4) ? L("Tried to register registered instance: " + l4) : Q[l4] = this;
        };
        f4.__destruct = function() {
          this === f4 && L("Pass correct 'this' to __destruct");
          Ma(this);
          var l4 = this.M.O;
          l4 = Ia(e4, l4);
          Q.hasOwnProperty(l4) ? delete Q[l4] : L("Tried to unregister unregistered instance: " + l4);
        };
        a4.prototype = Object.create(f4);
        for (var m3 in c2) a4.prototype[m3] = c2[m3];
        return Ea(a4);
      }, "q"),
      j: /* @__PURE__ */ __name(function(a4) {
        var b3 = Va[a4];
        delete Va[a4];
        var c2 = b3.fa, d3 = b3.W, e4 = b3.ia, f4 = e4.map((g) => g.ta).concat(e4.map((g) => g.za));
        V([a4], f4, (g) => {
          var k3 = {};
          e4.forEach((m3, l4) => {
            var n5 = g[l4], p3 = m3.ra, r5 = m3.sa, u4 = g[l4 + e4.length], t4 = m3.ya, y3 = m3.Aa;
            k3[m3.oa] = { read: /* @__PURE__ */ __name((B) => n5.fromWireType(p3(r5, B)), "read"), write: /* @__PURE__ */ __name((B, ba) => {
              var I = [];
              t4(
                y3,
                B,
                u4.toWireType(I, ba)
              );
              Wa(I);
            }, "write") };
          });
          return [{ name: b3.name, fromWireType: /* @__PURE__ */ __name(function(m3) {
            var l4 = {}, n5;
            for (n5 in k3) l4[n5] = k3[n5].read(m3);
            d3(m3);
            return l4;
          }, "fromWireType"), toWireType: /* @__PURE__ */ __name(function(m3, l4) {
            for (var n5 in k3) if (!(n5 in l4)) throw new TypeError('Missing field:  "' + n5 + '"');
            var p3 = c2();
            for (n5 in k3) k3[n5].write(p3, l4[n5]);
            null !== m3 && m3.push(d3, p3);
            return p3;
          }, "toWireType"), argPackAdvance: 8, readValueFromPointer: Xa, V: d3 }];
        });
      }, "j"),
      v: /* @__PURE__ */ __name(function() {
      }, "v"),
      B: /* @__PURE__ */ __name(function(a4, b3, c2, d3, e4) {
        var f4 = Za(c2);
        b3 = N(b3);
        W(a4, {
          name: b3,
          fromWireType: /* @__PURE__ */ __name(function(g) {
            return !!g;
          }, "fromWireType"),
          toWireType: /* @__PURE__ */ __name(function(g, k3) {
            return k3 ? d3 : e4;
          }, "toWireType"),
          argPackAdvance: 8,
          readValueFromPointer: /* @__PURE__ */ __name(function(g) {
            if (1 === c2) var k3 = ja;
            else if (2 === c2) k3 = C;
            else if (4 === c2) k3 = D;
            else throw new TypeError("Unknown boolean type size: " + b3);
            return this.fromWireType(k3[g >> f4]);
          }, "readValueFromPointer"),
          V: null
        });
      }, "B"),
      f: /* @__PURE__ */ __name(function(a4, b3, c2, d3, e4, f4, g, k3, m3, l4, n5, p3, r5) {
        n5 = N(n5);
        f4 = Z(e4, f4);
        k3 && (k3 = Z(g, k3));
        l4 && (l4 = Z(m3, l4));
        r5 = Z(p3, r5);
        var u4 = Aa(n5);
        bb(u4, function() {
          nb("Cannot construct " + n5 + " due to unbound types", [d3]);
        });
        V([a4, b3, c2], d3 ? [d3] : [], function(t4) {
          t4 = t4[0];
          if (d3) {
            var y3 = t4.N;
            var B = y3.X;
          } else B = X.prototype;
          t4 = Ba(u4, function() {
            if (Object.getPrototypeOf(this) !== ba) throw new K("Use 'new' to construct " + n5);
            if (void 0 === I.Y) throw new K(n5 + " has no accessible constructor");
            var kb = I.Y[arguments.length];
            if (void 0 === kb) throw new K("Tried to invoke ctor of " + n5 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(I.Y).toString() + ") parameters instead!");
            return kb.apply(this, arguments);
          });
          var ba = Object.create(B, { constructor: { value: t4 } });
          t4.prototype = ba;
          var I = new cb(n5, t4, ba, r5, y3, f4, k3, l4);
          y3 = new Y(n5, I, true, false);
          B = new Y(n5 + "*", I, false, false);
          var lb = new Y(n5 + " const*", I, false, true);
          Qa[a4] = {
            pointerType: B,
            la: lb
          };
          ib(u4, t4);
          return [y3, B, lb];
        });
      }, "f"),
      d: /* @__PURE__ */ __name(function(a4, b3, c2, d3, e4, f4, g) {
        var k3 = pb(c2, d3);
        b3 = N(b3);
        f4 = Z(e4, f4);
        V([], [a4], function(m3) {
          function l4() {
            nb("Cannot call " + n5 + " due to unbound types", k3);
          }
          __name(l4, "l");
          m3 = m3[0];
          var n5 = m3.name + "." + b3;
          b3.startsWith("@@") && (b3 = Symbol[b3.substring(2)]);
          var p3 = m3.N.constructor;
          void 0 === p3[b3] ? (l4.Z = c2 - 1, p3[b3] = l4) : (ab(p3, b3, n5), p3[b3].S[c2 - 1] = l4);
          V([], k3, function(r5) {
            r5 = ob(n5, [r5[0], null].concat(r5.slice(1)), null, f4, g);
            void 0 === p3[b3].S ? (r5.Z = c2 - 1, p3[b3] = r5) : p3[b3].S[c2 - 1] = r5;
            return [];
          });
          return [];
        });
      }, "d"),
      p: /* @__PURE__ */ __name(function(a4, b3, c2, d3, e4, f4) {
        0 < b3 || x();
        var g = pb(
          b3,
          c2
        );
        e4 = Z(d3, e4);
        V([], [a4], function(k3) {
          k3 = k3[0];
          var m3 = "constructor " + k3.name;
          void 0 === k3.N.Y && (k3.N.Y = []);
          if (void 0 !== k3.N.Y[b3 - 1]) throw new K("Cannot register multiple constructors with identical number of parameters (" + (b3 - 1) + ") for class '" + k3.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          k3.N.Y[b3 - 1] = () => {
            nb("Cannot construct " + k3.name + " due to unbound types", g);
          };
          V([], g, function(l4) {
            l4.splice(1, 0, null);
            k3.N.Y[b3 - 1] = ob(m3, l4, null, e4, f4);
            return [];
          });
          return [];
        });
      }, "p"),
      a: /* @__PURE__ */ __name(function(a4, b3, c2, d3, e4, f4, g, k3) {
        var m3 = pb(c2, d3);
        b3 = N(b3);
        f4 = Z(e4, f4);
        V([], [a4], function(l4) {
          function n5() {
            nb("Cannot call " + p3 + " due to unbound types", m3);
          }
          __name(n5, "n");
          l4 = l4[0];
          var p3 = l4.name + "." + b3;
          b3.startsWith("@@") && (b3 = Symbol[b3.substring(2)]);
          k3 && l4.N.ja.push(b3);
          var r5 = l4.N.X, u4 = r5[b3];
          void 0 === u4 || void 0 === u4.S && u4.className !== l4.name && u4.Z === c2 - 2 ? (n5.Z = c2 - 2, n5.className = l4.name, r5[b3] = n5) : (ab(r5, b3, p3), r5[b3].S[c2 - 2] = n5);
          V([], m3, function(t4) {
            t4 = ob(p3, t4, l4, f4, g);
            void 0 === r5[b3].S ? (t4.Z = c2 - 2, r5[b3] = t4) : r5[b3].S[c2 - 2] = t4;
            return [];
          });
          return [];
        });
      }, "a"),
      A: /* @__PURE__ */ __name(function(a4, b3) {
        b3 = N(b3);
        W(
          a4,
          { name: b3, fromWireType: /* @__PURE__ */ __name(function(c2) {
            var d3 = M(c2);
            qb(c2);
            return d3;
          }, "fromWireType"), toWireType: /* @__PURE__ */ __name(function(c2, d3) {
            return Ea(d3);
          }, "toWireType"), argPackAdvance: 8, readValueFromPointer: Xa, V: null }
        );
      }, "A"),
      n: /* @__PURE__ */ __name(function(a4, b3, c2) {
        c2 = Za(c2);
        b3 = N(b3);
        W(a4, { name: b3, fromWireType: /* @__PURE__ */ __name(function(d3) {
          return d3;
        }, "fromWireType"), toWireType: /* @__PURE__ */ __name(function(d3, e4) {
          return e4;
        }, "toWireType"), argPackAdvance: 8, readValueFromPointer: rb(b3, c2), V: null });
      }, "n"),
      e: /* @__PURE__ */ __name(function(a4, b3, c2, d3, e4) {
        b3 = N(b3);
        -1 === e4 && (e4 = 4294967295);
        e4 = Za(c2);
        var f4 = /* @__PURE__ */ __name((k3) => k3, "f");
        if (0 === d3) {
          var g = 32 - 8 * c2;
          f4 = /* @__PURE__ */ __name((k3) => k3 << g >>> g, "f");
        }
        c2 = b3.includes("unsigned") ? function(k3, m3) {
          return m3 >>> 0;
        } : function(k3, m3) {
          return m3;
        };
        W(a4, { name: b3, fromWireType: f4, toWireType: c2, argPackAdvance: 8, readValueFromPointer: sb(b3, e4, 0 !== d3), V: null });
      }, "e"),
      b: /* @__PURE__ */ __name(function(a4, b3, c2) {
        function d3(f4) {
          f4 >>= 2;
          var g = E;
          return new e4(ia, g[f4 + 1], g[f4]);
        }
        __name(d3, "d");
        var e4 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b3];
        c2 = N(c2);
        W(a4, { name: c2, fromWireType: d3, argPackAdvance: 8, readValueFromPointer: d3 }, { ua: true });
      }, "b"),
      o: /* @__PURE__ */ __name(function(a4, b3) {
        b3 = N(b3);
        var c2 = "std::string" === b3;
        W(a4, { name: b3, fromWireType: /* @__PURE__ */ __name(function(d3) {
          var e4 = E[d3 >> 2], f4 = d3 + 4;
          if (c2) for (var g = f4, k3 = 0; k3 <= e4; ++k3) {
            var m3 = f4 + k3;
            if (k3 == e4 || 0 == A[m3]) {
              g = g ? z(A, g, m3 - g) : "";
              if (void 0 === l4) var l4 = g;
              else l4 += String.fromCharCode(0), l4 += g;
              g = m3 + 1;
            }
          }
          else {
            l4 = Array(e4);
            for (k3 = 0; k3 < e4; ++k3) l4[k3] = String.fromCharCode(A[f4 + k3]);
            l4 = l4.join("");
          }
          S3(d3);
          return l4;
        }, "fromWireType"), toWireType: /* @__PURE__ */ __name(function(d3, e4) {
          e4 instanceof ArrayBuffer && (e4 = new Uint8Array(e4));
          var f4, g = "string" == typeof e4;
          g || e4 instanceof Uint8Array || e4 instanceof Uint8ClampedArray || e4 instanceof Int8Array || L("Cannot pass non-string to std::string");
          if (c2 && g) {
            var k3 = 0;
            for (f4 = 0; f4 < e4.length; ++f4) {
              var m3 = e4.charCodeAt(f4);
              127 >= m3 ? k3++ : 2047 >= m3 ? k3 += 2 : 55296 <= m3 && 57343 >= m3 ? (k3 += 4, ++f4) : k3 += 3;
            }
            f4 = k3;
          } else f4 = e4.length;
          k3 = Ib(4 + f4 + 1);
          m3 = k3 + 4;
          E[k3 >> 2] = f4;
          if (c2 && g) {
            if (g = m3, m3 = f4 + 1, f4 = A, 0 < m3) {
              m3 = g + m3 - 1;
              for (var l4 = 0; l4 < e4.length; ++l4) {
                var n5 = e4.charCodeAt(l4);
                if (55296 <= n5 && 57343 >= n5) {
                  var p3 = e4.charCodeAt(++l4);
                  n5 = 65536 + ((n5 & 1023) << 10) | p3 & 1023;
                }
                if (127 >= n5) {
                  if (g >= m3) break;
                  f4[g++] = n5;
                } else {
                  if (2047 >= n5) {
                    if (g + 1 >= m3) break;
                    f4[g++] = 192 | n5 >> 6;
                  } else {
                    if (65535 >= n5) {
                      if (g + 2 >= m3) break;
                      f4[g++] = 224 | n5 >> 12;
                    } else {
                      if (g + 3 >= m3) break;
                      f4[g++] = 240 | n5 >> 18;
                      f4[g++] = 128 | n5 >> 12 & 63;
                    }
                    f4[g++] = 128 | n5 >> 6 & 63;
                  }
                  f4[g++] = 128 | n5 & 63;
                }
              }
              f4[g] = 0;
            }
          } else if (g) for (g = 0; g < f4; ++g) l4 = e4.charCodeAt(g), 255 < l4 && (S3(m3), L("String has UTF-16 code units that do not fit in 8 bits")), A[m3 + g] = l4;
          else for (g = 0; g < f4; ++g) A[m3 + g] = e4[g];
          null !== d3 && d3.push(S3, k3);
          return k3;
        }, "toWireType"), argPackAdvance: 8, readValueFromPointer: Xa, V: /* @__PURE__ */ __name(function(d3) {
          S3(d3);
        }, "V") });
      }, "o"),
      i: /* @__PURE__ */ __name(function(a4, b3, c2) {
        c2 = N(c2);
        if (2 === b3) {
          var d3 = tb;
          var e4 = ub;
          var f4 = vb;
          var g = /* @__PURE__ */ __name(() => ka, "g");
          var k3 = 1;
        } else 4 === b3 && (d3 = wb, e4 = xb, f4 = yb, g = /* @__PURE__ */ __name(() => E, "g"), k3 = 2);
        W(a4, { name: c2, fromWireType: /* @__PURE__ */ __name(function(m3) {
          for (var l4 = E[m3 >> 2], n5 = g(), p3, r5 = m3 + 4, u4 = 0; u4 <= l4; ++u4) {
            var t4 = m3 + 4 + u4 * b3;
            if (u4 == l4 || 0 == n5[t4 >> k3]) r5 = d3(r5, t4 - r5), void 0 === p3 ? p3 = r5 : (p3 += String.fromCharCode(0), p3 += r5), r5 = t4 + b3;
          }
          S3(m3);
          return p3;
        }, "fromWireType"), toWireType: /* @__PURE__ */ __name(function(m3, l4) {
          "string" != typeof l4 && L("Cannot pass non-string to C++ string type " + c2);
          var n5 = f4(l4), p3 = Ib(4 + n5 + b3);
          E[p3 >> 2] = n5 >> k3;
          e4(l4, p3 + 4, n5 + b3);
          null !== m3 && m3.push(S3, p3);
          return p3;
        }, "toWireType"), argPackAdvance: 8, readValueFromPointer: Xa, V: /* @__PURE__ */ __name(function(m3) {
          S3(m3);
        }, "V") });
      }, "i"),
      k: /* @__PURE__ */ __name(function(a4, b3, c2, d3, e4, f4) {
        Va[a4] = { name: N(b3), fa: Z(c2, d3), W: Z(e4, f4), ia: [] };
      }, "k"),
      h: /* @__PURE__ */ __name(function(a4, b3, c2, d3, e4, f4, g, k3, m3, l4) {
        Va[a4].ia.push({ oa: N(b3), ta: c2, ra: Z(d3, e4), sa: f4, za: g, ya: Z(k3, m3), Aa: l4 });
      }, "h"),
      C: /* @__PURE__ */ __name(function(a4, b3) {
        b3 = N(b3);
        W(a4, {
          va: true,
          name: b3,
          argPackAdvance: 0,
          fromWireType: /* @__PURE__ */ __name(function() {
          }, "fromWireType"),
          toWireType: /* @__PURE__ */ __name(function() {
          }, "toWireType")
        });
      }, "C"),
      s: /* @__PURE__ */ __name(function(a4, b3, c2, d3, e4) {
        a4 = Bb[a4];
        b3 = M(b3);
        c2 = Ab(c2);
        var f4 = [];
        E[d3 >> 2] = Ea(f4);
        return a4(b3, c2, f4, e4);
      }, "s"),
      t: /* @__PURE__ */ __name(function(a4, b3, c2, d3) {
        a4 = Bb[a4];
        b3 = M(b3);
        c2 = Ab(c2);
        a4(b3, c2, null, d3);
      }, "t"),
      g: qb,
      m: /* @__PURE__ */ __name(function(a4, b3) {
        var c2 = Db(a4, b3), d3 = c2[0];
        b3 = d3.name + "_$" + c2.slice(1).map(function(g) {
          return g.name;
        }).join("_") + "$";
        var e4 = Eb[b3];
        if (void 0 !== e4) return e4;
        var f4 = Array(a4 - 1);
        e4 = Cb((g, k3, m3, l4) => {
          for (var n5 = 0, p3 = 0; p3 < a4 - 1; ++p3) f4[p3] = c2[p3 + 1].readValueFromPointer(l4 + n5), n5 += c2[p3 + 1].argPackAdvance;
          g = g[k3].apply(
            g,
            f4
          );
          for (p3 = 0; p3 < a4 - 1; ++p3) c2[p3 + 1].ma && c2[p3 + 1].ma(f4[p3]);
          if (!d3.va) return d3.toWireType(m3, g);
        });
        return Eb[b3] = e4;
      }, "m"),
      D: /* @__PURE__ */ __name(function(a4) {
        4 < a4 && (J[a4].ga += 1);
      }, "D"),
      r: /* @__PURE__ */ __name(function(a4) {
        var b3 = M(a4);
        Wa(b3);
        qb(a4);
      }, "r"),
      c: /* @__PURE__ */ __name(function() {
        x("");
      }, "c"),
      x: /* @__PURE__ */ __name(function(a4, b3, c2) {
        A.copyWithin(a4, b3, b3 + c2);
      }, "x"),
      w: /* @__PURE__ */ __name(function(a4) {
        var b3 = A.length;
        a4 >>>= 0;
        if (2147483648 < a4) return false;
        for (var c2 = 1; 4 >= c2; c2 *= 2) {
          var d3 = b3 * (1 + 0.2 / c2);
          d3 = Math.min(d3, a4 + 100663296);
          var e4 = Math;
          d3 = Math.max(a4, d3);
          e4 = e4.min.call(e4, 2147483648, d3 + (65536 - d3 % 65536) % 65536);
          a: {
            try {
              fa.grow(e4 - ia.byteLength + 65535 >>> 16);
              na();
              var f4 = 1;
              break a;
            } catch (g) {
            }
            f4 = void 0;
          }
          if (f4) return true;
        }
        return false;
      }, "w"),
      z: /* @__PURE__ */ __name(function() {
        return 52;
      }, "z"),
      u: /* @__PURE__ */ __name(function() {
        return 70;
      }, "u"),
      y: /* @__PURE__ */ __name(function(a4, b3, c2, d3) {
        for (var e4 = 0, f4 = 0; f4 < c2; f4++) {
          var g = E[b3 >> 2], k3 = E[b3 + 4 >> 2];
          b3 += 8;
          for (var m3 = 0; m3 < k3; m3++) {
            var l4 = A[g + m3], n5 = Fb[a4];
            0 === l4 || 10 === l4 ? ((1 === a4 ? ea : v3)(z(n5, 0)), n5.length = 0) : n5.push(l4);
          }
          e4 += k3;
        }
        E[d3 >> 2] = e4;
        return 0;
      }, "y")
    };
    (function() {
      function a4(e4) {
        h.asm = e4.exports;
        fa = h.asm.E;
        na();
        oa = h.asm.J;
        qa.unshift(h.asm.F);
        F--;
        h.monitorRunDependencies && h.monitorRunDependencies(F);
        0 == F && (null !== ta && (clearInterval(ta), ta = null), G2 && (e4 = G2, G2 = null, e4()));
      }
      __name(a4, "a");
      function b3(e4) {
        a4(e4.instance);
      }
      __name(b3, "b");
      function c2(e4) {
        return ya().then(function(f4) {
          return WebAssembly.instantiate(f4, d3);
        }).then(function(f4) {
          return f4;
        }).then(e4, function(f4) {
          v3("failed to asynchronously prepare wasm: " + f4);
          x(f4);
        });
      }
      __name(c2, "c");
      var d3 = { a: Jb };
      F++;
      h.monitorRunDependencies && h.monitorRunDependencies(F);
      if (h.instantiateWasm) try {
        return h.instantiateWasm(
          d3,
          a4
        );
      } catch (e4) {
        v3("Module.instantiateWasm callback failed with error: " + e4), ca(e4);
      }
      (function() {
        return w || "function" != typeof WebAssembly.instantiateStreaming || ua(H) || "function" != typeof fetch ? c2(b3) : fetch(H, { credentials: "same-origin" }).then(function(e4) {
          return WebAssembly.instantiateStreaming(e4, d3).then(b3, function(f4) {
            v3("wasm streaming compile failed: " + f4);
            v3("falling back to ArrayBuffer instantiation");
            return c2(b3);
          });
        });
      })().catch(ca);
      return {};
    })();
    h.___wasm_call_ctors = function() {
      return (h.___wasm_call_ctors = h.asm.F).apply(null, arguments);
    };
    var Ka = h.___getTypeName = function() {
      return (Ka = h.___getTypeName = h.asm.G).apply(null, arguments);
    };
    h.__embind_initialize_bindings = function() {
      return (h.__embind_initialize_bindings = h.asm.H).apply(null, arguments);
    };
    var Ib = h._malloc = function() {
      return (Ib = h._malloc = h.asm.I).apply(null, arguments);
    }, S3 = h._free = function() {
      return (S3 = h._free = h.asm.K).apply(null, arguments);
    };
    h.dynCall_jiji = function() {
      return (h.dynCall_jiji = h.asm.L).apply(null, arguments);
    };
    var Kb;
    G2 = /* @__PURE__ */ __name(function Lb() {
      Kb || Mb();
      Kb || (G2 = Lb);
    }, "Lb");
    function Mb() {
      function a4() {
        if (!Kb && (Kb = true, h.calledRun = true, !ha)) {
          za(qa);
          aa(h);
          if (h.onRuntimeInitialized) h.onRuntimeInitialized();
          if (h.postRun) for ("function" == typeof h.postRun && (h.postRun = [h.postRun]); h.postRun.length; ) {
            var b3 = h.postRun.shift();
            ra.unshift(b3);
          }
          za(ra);
        }
      }
      __name(a4, "a");
      if (!(0 < F)) {
        if (h.preRun) for ("function" == typeof h.preRun && (h.preRun = [h.preRun]); h.preRun.length; ) sa();
        za(pa);
        0 < F || (h.setStatus ? (h.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            h.setStatus("");
          }, 1);
          a4();
        }, 1)) : a4());
      }
    }
    __name(Mb, "Mb");
    if (h.preInit) for ("function" == typeof h.preInit && (h.preInit = [h.preInit]); 0 < h.preInit.length; ) h.preInit.pop()();
    Mb();
    return loadYoga4.ready;
  };
})();
var yoga_wasm_base64_esm_default = loadYoga;

// ../../node_modules/.pnpm/yoga-layout@3.2.1/node_modules/yoga-layout/dist/src/wrapAssembly.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../node_modules/.pnpm/yoga-layout@3.2.1/node_modules/yoga-layout/dist/src/generated/YGEnums.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Align = /* @__PURE__ */ function(Align2) {
  Align2[Align2["Auto"] = 0] = "Auto";
  Align2[Align2["FlexStart"] = 1] = "FlexStart";
  Align2[Align2["Center"] = 2] = "Center";
  Align2[Align2["FlexEnd"] = 3] = "FlexEnd";
  Align2[Align2["Stretch"] = 4] = "Stretch";
  Align2[Align2["Baseline"] = 5] = "Baseline";
  Align2[Align2["SpaceBetween"] = 6] = "SpaceBetween";
  Align2[Align2["SpaceAround"] = 7] = "SpaceAround";
  Align2[Align2["SpaceEvenly"] = 8] = "SpaceEvenly";
  return Align2;
}({});
var BoxSizing = /* @__PURE__ */ function(BoxSizing2) {
  BoxSizing2[BoxSizing2["BorderBox"] = 0] = "BorderBox";
  BoxSizing2[BoxSizing2["ContentBox"] = 1] = "ContentBox";
  return BoxSizing2;
}({});
var Dimension = /* @__PURE__ */ function(Dimension2) {
  Dimension2[Dimension2["Width"] = 0] = "Width";
  Dimension2[Dimension2["Height"] = 1] = "Height";
  return Dimension2;
}({});
var Direction2 = /* @__PURE__ */ function(Direction3) {
  Direction3[Direction3["Inherit"] = 0] = "Inherit";
  Direction3[Direction3["LTR"] = 1] = "LTR";
  Direction3[Direction3["RTL"] = 2] = "RTL";
  return Direction3;
}({});
var Display = /* @__PURE__ */ function(Display2) {
  Display2[Display2["Flex"] = 0] = "Flex";
  Display2[Display2["None"] = 1] = "None";
  Display2[Display2["Contents"] = 2] = "Contents";
  return Display2;
}({});
var Edge = /* @__PURE__ */ function(Edge2) {
  Edge2[Edge2["Left"] = 0] = "Left";
  Edge2[Edge2["Top"] = 1] = "Top";
  Edge2[Edge2["Right"] = 2] = "Right";
  Edge2[Edge2["Bottom"] = 3] = "Bottom";
  Edge2[Edge2["Start"] = 4] = "Start";
  Edge2[Edge2["End"] = 5] = "End";
  Edge2[Edge2["Horizontal"] = 6] = "Horizontal";
  Edge2[Edge2["Vertical"] = 7] = "Vertical";
  Edge2[Edge2["All"] = 8] = "All";
  return Edge2;
}({});
var Errata = /* @__PURE__ */ function(Errata2) {
  Errata2[Errata2["None"] = 0] = "None";
  Errata2[Errata2["StretchFlexBasis"] = 1] = "StretchFlexBasis";
  Errata2[Errata2["AbsolutePositionWithoutInsetsExcludesPadding"] = 2] = "AbsolutePositionWithoutInsetsExcludesPadding";
  Errata2[Errata2["AbsolutePercentAgainstInnerSize"] = 4] = "AbsolutePercentAgainstInnerSize";
  Errata2[Errata2["All"] = 2147483647] = "All";
  Errata2[Errata2["Classic"] = 2147483646] = "Classic";
  return Errata2;
}({});
var ExperimentalFeature = /* @__PURE__ */ function(ExperimentalFeature2) {
  ExperimentalFeature2[ExperimentalFeature2["WebFlexBasis"] = 0] = "WebFlexBasis";
  return ExperimentalFeature2;
}({});
var FlexDirection = /* @__PURE__ */ function(FlexDirection2) {
  FlexDirection2[FlexDirection2["Column"] = 0] = "Column";
  FlexDirection2[FlexDirection2["ColumnReverse"] = 1] = "ColumnReverse";
  FlexDirection2[FlexDirection2["Row"] = 2] = "Row";
  FlexDirection2[FlexDirection2["RowReverse"] = 3] = "RowReverse";
  return FlexDirection2;
}({});
var Gutter = /* @__PURE__ */ function(Gutter2) {
  Gutter2[Gutter2["Column"] = 0] = "Column";
  Gutter2[Gutter2["Row"] = 1] = "Row";
  Gutter2[Gutter2["All"] = 2] = "All";
  return Gutter2;
}({});
var Justify = /* @__PURE__ */ function(Justify2) {
  Justify2[Justify2["FlexStart"] = 0] = "FlexStart";
  Justify2[Justify2["Center"] = 1] = "Center";
  Justify2[Justify2["FlexEnd"] = 2] = "FlexEnd";
  Justify2[Justify2["SpaceBetween"] = 3] = "SpaceBetween";
  Justify2[Justify2["SpaceAround"] = 4] = "SpaceAround";
  Justify2[Justify2["SpaceEvenly"] = 5] = "SpaceEvenly";
  return Justify2;
}({});
var LogLevel = /* @__PURE__ */ function(LogLevel2) {
  LogLevel2[LogLevel2["Error"] = 0] = "Error";
  LogLevel2[LogLevel2["Warn"] = 1] = "Warn";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Debug"] = 3] = "Debug";
  LogLevel2[LogLevel2["Verbose"] = 4] = "Verbose";
  LogLevel2[LogLevel2["Fatal"] = 5] = "Fatal";
  return LogLevel2;
}({});
var MeasureMode = /* @__PURE__ */ function(MeasureMode2) {
  MeasureMode2[MeasureMode2["Undefined"] = 0] = "Undefined";
  MeasureMode2[MeasureMode2["Exactly"] = 1] = "Exactly";
  MeasureMode2[MeasureMode2["AtMost"] = 2] = "AtMost";
  return MeasureMode2;
}({});
var NodeType = /* @__PURE__ */ function(NodeType2) {
  NodeType2[NodeType2["Default"] = 0] = "Default";
  NodeType2[NodeType2["Text"] = 1] = "Text";
  return NodeType2;
}({});
var Overflow = /* @__PURE__ */ function(Overflow2) {
  Overflow2[Overflow2["Visible"] = 0] = "Visible";
  Overflow2[Overflow2["Hidden"] = 1] = "Hidden";
  Overflow2[Overflow2["Scroll"] = 2] = "Scroll";
  return Overflow2;
}({});
var PositionType = /* @__PURE__ */ function(PositionType2) {
  PositionType2[PositionType2["Static"] = 0] = "Static";
  PositionType2[PositionType2["Relative"] = 1] = "Relative";
  PositionType2[PositionType2["Absolute"] = 2] = "Absolute";
  return PositionType2;
}({});
var Unit = /* @__PURE__ */ function(Unit2) {
  Unit2[Unit2["Undefined"] = 0] = "Undefined";
  Unit2[Unit2["Point"] = 1] = "Point";
  Unit2[Unit2["Percent"] = 2] = "Percent";
  Unit2[Unit2["Auto"] = 3] = "Auto";
  return Unit2;
}({});
var Wrap = /* @__PURE__ */ function(Wrap2) {
  Wrap2[Wrap2["NoWrap"] = 0] = "NoWrap";
  Wrap2[Wrap2["Wrap"] = 1] = "Wrap";
  Wrap2[Wrap2["WrapReverse"] = 2] = "WrapReverse";
  return Wrap2;
}({});
var constants2 = {
  ALIGN_AUTO: Align.Auto,
  ALIGN_FLEX_START: Align.FlexStart,
  ALIGN_CENTER: Align.Center,
  ALIGN_FLEX_END: Align.FlexEnd,
  ALIGN_STRETCH: Align.Stretch,
  ALIGN_BASELINE: Align.Baseline,
  ALIGN_SPACE_BETWEEN: Align.SpaceBetween,
  ALIGN_SPACE_AROUND: Align.SpaceAround,
  ALIGN_SPACE_EVENLY: Align.SpaceEvenly,
  BOX_SIZING_BORDER_BOX: BoxSizing.BorderBox,
  BOX_SIZING_CONTENT_BOX: BoxSizing.ContentBox,
  DIMENSION_WIDTH: Dimension.Width,
  DIMENSION_HEIGHT: Dimension.Height,
  DIRECTION_INHERIT: Direction2.Inherit,
  DIRECTION_LTR: Direction2.LTR,
  DIRECTION_RTL: Direction2.RTL,
  DISPLAY_FLEX: Display.Flex,
  DISPLAY_NONE: Display.None,
  DISPLAY_CONTENTS: Display.Contents,
  EDGE_LEFT: Edge.Left,
  EDGE_TOP: Edge.Top,
  EDGE_RIGHT: Edge.Right,
  EDGE_BOTTOM: Edge.Bottom,
  EDGE_START: Edge.Start,
  EDGE_END: Edge.End,
  EDGE_HORIZONTAL: Edge.Horizontal,
  EDGE_VERTICAL: Edge.Vertical,
  EDGE_ALL: Edge.All,
  ERRATA_NONE: Errata.None,
  ERRATA_STRETCH_FLEX_BASIS: Errata.StretchFlexBasis,
  ERRATA_ABSOLUTE_POSITION_WITHOUT_INSETS_EXCLUDES_PADDING: Errata.AbsolutePositionWithoutInsetsExcludesPadding,
  ERRATA_ABSOLUTE_PERCENT_AGAINST_INNER_SIZE: Errata.AbsolutePercentAgainstInnerSize,
  ERRATA_ALL: Errata.All,
  ERRATA_CLASSIC: Errata.Classic,
  EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS: ExperimentalFeature.WebFlexBasis,
  FLEX_DIRECTION_COLUMN: FlexDirection.Column,
  FLEX_DIRECTION_COLUMN_REVERSE: FlexDirection.ColumnReverse,
  FLEX_DIRECTION_ROW: FlexDirection.Row,
  FLEX_DIRECTION_ROW_REVERSE: FlexDirection.RowReverse,
  GUTTER_COLUMN: Gutter.Column,
  GUTTER_ROW: Gutter.Row,
  GUTTER_ALL: Gutter.All,
  JUSTIFY_FLEX_START: Justify.FlexStart,
  JUSTIFY_CENTER: Justify.Center,
  JUSTIFY_FLEX_END: Justify.FlexEnd,
  JUSTIFY_SPACE_BETWEEN: Justify.SpaceBetween,
  JUSTIFY_SPACE_AROUND: Justify.SpaceAround,
  JUSTIFY_SPACE_EVENLY: Justify.SpaceEvenly,
  LOG_LEVEL_ERROR: LogLevel.Error,
  LOG_LEVEL_WARN: LogLevel.Warn,
  LOG_LEVEL_INFO: LogLevel.Info,
  LOG_LEVEL_DEBUG: LogLevel.Debug,
  LOG_LEVEL_VERBOSE: LogLevel.Verbose,
  LOG_LEVEL_FATAL: LogLevel.Fatal,
  MEASURE_MODE_UNDEFINED: MeasureMode.Undefined,
  MEASURE_MODE_EXACTLY: MeasureMode.Exactly,
  MEASURE_MODE_AT_MOST: MeasureMode.AtMost,
  NODE_TYPE_DEFAULT: NodeType.Default,
  NODE_TYPE_TEXT: NodeType.Text,
  OVERFLOW_VISIBLE: Overflow.Visible,
  OVERFLOW_HIDDEN: Overflow.Hidden,
  OVERFLOW_SCROLL: Overflow.Scroll,
  POSITION_TYPE_STATIC: PositionType.Static,
  POSITION_TYPE_RELATIVE: PositionType.Relative,
  POSITION_TYPE_ABSOLUTE: PositionType.Absolute,
  UNIT_UNDEFINED: Unit.Undefined,
  UNIT_POINT: Unit.Point,
  UNIT_PERCENT: Unit.Percent,
  UNIT_AUTO: Unit.Auto,
  WRAP_NO_WRAP: Wrap.NoWrap,
  WRAP_WRAP: Wrap.Wrap,
  WRAP_WRAP_REVERSE: Wrap.WrapReverse
};
var YGEnums_default = constants2;

// ../../node_modules/.pnpm/yoga-layout@3.2.1/node_modules/yoga-layout/dist/src/wrapAssembly.js
function wrapAssembly(lib3) {
  function patch(prototype, name, fn) {
    const original = prototype[name];
    prototype[name] = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return fn.call(this, original, ...args);
    };
  }
  __name(patch, "patch");
  for (const fnName of ["setPosition", "setMargin", "setFlexBasis", "setWidth", "setHeight", "setMinWidth", "setMinHeight", "setMaxWidth", "setMaxHeight", "setPadding", "setGap"]) {
    const methods = {
      [Unit.Point]: lib3.Node.prototype[fnName],
      [Unit.Percent]: lib3.Node.prototype[`${fnName}Percent`],
      [Unit.Auto]: lib3.Node.prototype[`${fnName}Auto`]
    };
    patch(lib3.Node.prototype, fnName, function(original) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      const value2 = args.pop();
      let unit, asNumber;
      if (value2 === "auto") {
        unit = Unit.Auto;
        asNumber = void 0;
      } else if (typeof value2 === "object") {
        unit = value2.unit;
        asNumber = value2.valueOf();
      } else {
        unit = typeof value2 === "string" && value2.endsWith("%") ? Unit.Percent : Unit.Point;
        asNumber = parseFloat(value2);
        if (value2 !== void 0 && !Number.isNaN(value2) && Number.isNaN(asNumber)) {
          throw new Error(`Invalid value ${value2} for ${fnName}`);
        }
      }
      if (!methods[unit]) throw new Error(`Failed to execute "${fnName}": Unsupported unit '${value2}'`);
      if (asNumber !== void 0) {
        return methods[unit].call(this, ...args, asNumber);
      } else {
        return methods[unit].call(this, ...args);
      }
    });
  }
  function wrapMeasureFunction(measureFunction) {
    return lib3.MeasureCallback.implement({
      measure: /* @__PURE__ */ __name(function() {
        const {
          width,
          height: height2
        } = measureFunction(...arguments);
        return {
          width: width ?? NaN,
          height: height2 ?? NaN
        };
      }, "measure")
    });
  }
  __name(wrapMeasureFunction, "wrapMeasureFunction");
  patch(lib3.Node.prototype, "setMeasureFunc", function(original, measureFunc) {
    if (measureFunc) {
      return original.call(this, wrapMeasureFunction(measureFunc));
    } else {
      return this.unsetMeasureFunc();
    }
  });
  function wrapDirtiedFunc(dirtiedFunction) {
    return lib3.DirtiedCallback.implement({
      dirtied: dirtiedFunction
    });
  }
  __name(wrapDirtiedFunc, "wrapDirtiedFunc");
  patch(lib3.Node.prototype, "setDirtiedFunc", function(original, dirtiedFunc) {
    original.call(this, wrapDirtiedFunc(dirtiedFunc));
  });
  patch(lib3.Config.prototype, "free", function() {
    lib3.Config.destroy(this);
  });
  patch(lib3.Node, "create", (_, config4) => {
    return config4 ? lib3.Node.createWithConfig(config4) : lib3.Node.createDefault();
  });
  patch(lib3.Node.prototype, "free", function() {
    lib3.Node.destroy(this);
  });
  patch(lib3.Node.prototype, "freeRecursive", function() {
    for (let t4 = 0, T = this.getChildCount(); t4 < T; ++t4) {
      this.getChild(0).freeRecursive();
    }
    this.free();
  });
  patch(lib3.Node.prototype, "calculateLayout", function(original) {
    let width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
    let height2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
    let direction = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Direction2.LTR;
    return original.call(this, width, height2, direction);
  });
  return {
    Config: lib3.Config,
    Node: lib3.Node,
    ...YGEnums_default
  };
}
__name(wrapAssembly, "wrapAssembly");

// ../../node_modules/.pnpm/yoga-layout@3.2.1/node_modules/yoga-layout/dist/src/load.js
async function loadYoga2() {
  return wrapAssembly(await yoga_wasm_base64_esm_default());
}
__name(loadYoga2, "loadYoga");

// ../../node_modules/.pnpm/emoji-regex-xs@1.0.0/node_modules/emoji-regex-xs/index.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var r = String.raw;
var seq = r`(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation})`;
var sTags = r`\u{E0061}-\u{E007A}`;
var emoji_regex_xs_default = /* @__PURE__ */ __name(() => new RegExp(r`[\u{1F1E6}-\u{1F1FF}]{2}|\u{1F3F4}[${sTags}]{2}[\u{E0030}-\u{E0039}${sTags}]{1,3}\u{E007F}|${seq}(?:\u200D${seq})*`, "gu"), "default");

// ../../node_modules/.pnpm/@react-pdf+image@3.0.4/node_modules/@react-pdf/image/lib/index.browser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var global$13 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup3 = [];
var revLookup3 = [];
var Arr3 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited3 = false;
function init3() {
  inited3 = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code.length; i2 < len; ++i2) {
    lookup3[i2] = code[i2];
    revLookup3[code.charCodeAt(i2)] = i2;
  }
  revLookup3["-".charCodeAt(0)] = 62;
  revLookup3["_".charCodeAt(0)] = 63;
}
__name(init3, "init");
function toByteArray3(b64) {
  if (!inited3) {
    init3();
  }
  var i2, j, l4, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr3(len * 3 / 4 - placeHolders);
  l4 = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i2 = 0, j = 0; i2 < l4; i2 += 4, j += 3) {
    tmp = revLookup3[b64.charCodeAt(i2)] << 18 | revLookup3[b64.charCodeAt(i2 + 1)] << 12 | revLookup3[b64.charCodeAt(i2 + 2)] << 6 | revLookup3[b64.charCodeAt(i2 + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup3[b64.charCodeAt(i2)] << 2 | revLookup3[b64.charCodeAt(i2 + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup3[b64.charCodeAt(i2)] << 10 | revLookup3[b64.charCodeAt(i2 + 1)] << 4 | revLookup3[b64.charCodeAt(i2 + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
__name(toByteArray3, "toByteArray");
function tripletToBase643(num) {
  return lookup3[num >> 18 & 63] + lookup3[num >> 12 & 63] + lookup3[num >> 6 & 63] + lookup3[num & 63];
}
__name(tripletToBase643, "tripletToBase64");
function encodeChunk3(uint82, start2, end2) {
  var tmp;
  var output = [];
  for (var i2 = start2; i2 < end2; i2 += 3) {
    tmp = (uint82[i2] << 16) + (uint82[i2 + 1] << 8) + uint82[i2 + 2];
    output.push(tripletToBase643(tmp));
  }
  return output.join("");
}
__name(encodeChunk3, "encodeChunk");
function fromByteArray3(uint82) {
  if (!inited3) {
    init3();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk3(uint82, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup3[tmp >> 2];
    output += lookup3[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup3[tmp >> 10];
    output += lookup3[tmp >> 4 & 63];
    output += lookup3[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
__name(fromByteArray3, "fromByteArray");
function read3(buffer, offset2, isLE, mLen, nBytes) {
  var e4, m3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d3 = isLE ? -1 : 1;
  var s4 = buffer[offset2 + i2];
  i2 += d3;
  e4 = s4 & (1 << -nBits) - 1;
  s4 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e4 = e4 * 256 + buffer[offset2 + i2], i2 += d3, nBits -= 8) {
  }
  m3 = e4 & (1 << -nBits) - 1;
  e4 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m3 = m3 * 256 + buffer[offset2 + i2], i2 += d3, nBits -= 8) {
  }
  if (e4 === 0) {
    e4 = 1 - eBias;
  } else if (e4 === eMax) {
    return m3 ? NaN : (s4 ? -1 : 1) * Infinity;
  } else {
    m3 = m3 + Math.pow(2, mLen);
    e4 = e4 - eBias;
  }
  return (s4 ? -1 : 1) * m3 * Math.pow(2, e4 - mLen);
}
__name(read3, "read");
function write5(buffer, value2, offset2, isLE, mLen, nBytes) {
  var e4, m3, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d3 = isLE ? 1 : -1;
  var s4 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m3 = isNaN(value2) ? 1 : 0;
    e4 = eMax;
  } else {
    e4 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e4)) < 1) {
      e4--;
      c2 *= 2;
    }
    if (e4 + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e4++;
      c2 /= 2;
    }
    if (e4 + eBias >= eMax) {
      m3 = 0;
      e4 = eMax;
    } else if (e4 + eBias >= 1) {
      m3 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e4 = e4 + eBias;
    } else {
      m3 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e4 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset2 + i2] = m3 & 255, i2 += d3, m3 /= 256, mLen -= 8) {
  }
  e4 = e4 << mLen | m3;
  eLen += mLen;
  for (; eLen > 0; buffer[offset2 + i2] = e4 & 255, i2 += d3, e4 /= 256, eLen -= 8) {
  }
  buffer[offset2 + i2 - d3] |= s4 * 128;
}
__name(write5, "write");
var toString5 = {}.toString;
var isArray3 = Array.isArray || function(arr) {
  return toString5.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES3 = 50;
Buffer4.TYPED_ARRAY_SUPPORT = global$13.TYPED_ARRAY_SUPPORT !== void 0 ? global$13.TYPED_ARRAY_SUPPORT : true;
kMaxLength3();
function kMaxLength3() {
  return Buffer4.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
__name(kMaxLength3, "kMaxLength");
function createBuffer3(that, length2) {
  if (kMaxLength3() < length2) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length2);
    that.__proto__ = Buffer4.prototype;
  } else {
    if (that === null) {
      that = new Buffer4(length2);
    }
    that.length = length2;
  }
  return that;
}
__name(createBuffer3, "createBuffer");
function Buffer4(arg, encodingOrOffset, length2) {
  if (!Buffer4.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer4)) {
    return new Buffer4(arg, encodingOrOffset, length2);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe3(this, arg);
  }
  return from3(this, arg, encodingOrOffset, length2);
}
__name(Buffer4, "Buffer");
Buffer4.poolSize = 8192;
Buffer4._augment = function(arr) {
  arr.__proto__ = Buffer4.prototype;
  return arr;
};
function from3(that, value2, encodingOrOffset, length2) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer3(that, value2, encodingOrOffset, length2);
  }
  if (typeof value2 === "string") {
    return fromString3(that, value2, encodingOrOffset);
  }
  return fromObject3(that, value2);
}
__name(from3, "from");
Buffer4.from = function(value2, encodingOrOffset, length2) {
  return from3(null, value2, encodingOrOffset, length2);
};
if (Buffer4.TYPED_ARRAY_SUPPORT) {
  Buffer4.prototype.__proto__ = Uint8Array.prototype;
  Buffer4.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer4[Symbol.species] === Buffer4) ;
}
function assertSize3(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
__name(assertSize3, "assertSize");
function alloc3(that, size, fill4, encoding) {
  assertSize3(size);
  if (size <= 0) {
    return createBuffer3(that, size);
  }
  if (fill4 !== void 0) {
    return typeof encoding === "string" ? createBuffer3(that, size).fill(fill4, encoding) : createBuffer3(that, size).fill(fill4);
  }
  return createBuffer3(that, size);
}
__name(alloc3, "alloc");
Buffer4.alloc = function(size, fill4, encoding) {
  return alloc3(null, size, fill4, encoding);
};
function allocUnsafe3(that, size) {
  assertSize3(size);
  that = createBuffer3(that, size < 0 ? 0 : checked3(size) | 0);
  if (!Buffer4.TYPED_ARRAY_SUPPORT) {
    for (var i2 = 0; i2 < size; ++i2) {
      that[i2] = 0;
    }
  }
  return that;
}
__name(allocUnsafe3, "allocUnsafe");
Buffer4.allocUnsafe = function(size) {
  return allocUnsafe3(null, size);
};
Buffer4.allocUnsafeSlow = function(size) {
  return allocUnsafe3(null, size);
};
function fromString3(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer4.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length2 = byteLength4(string, encoding) | 0;
  that = createBuffer3(that, length2);
  var actual = that.write(string, encoding);
  if (actual !== length2) {
    that = that.slice(0, actual);
  }
  return that;
}
__name(fromString3, "fromString");
function fromArrayLike3(that, array) {
  var length2 = array.length < 0 ? 0 : checked3(array.length) | 0;
  that = createBuffer3(that, length2);
  for (var i2 = 0; i2 < length2; i2 += 1) {
    that[i2] = array[i2] & 255;
  }
  return that;
}
__name(fromArrayLike3, "fromArrayLike");
function fromArrayBuffer3(that, array, byteOffset, length2) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length2 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length2 === void 0) {
    array = new Uint8Array(array);
  } else if (length2 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length2);
  }
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer4.prototype;
  } else {
    that = fromArrayLike3(that, array);
  }
  return that;
}
__name(fromArrayBuffer3, "fromArrayBuffer");
function fromObject3(that, obj) {
  if (internalIsBuffer3(obj)) {
    var len = checked3(obj.length) | 0;
    that = createBuffer3(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan3(obj.length)) {
        return createBuffer3(that, 0);
      }
      return fromArrayLike3(that, obj);
    }
    if (obj.type === "Buffer" && isArray3(obj.data)) {
      return fromArrayLike3(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
__name(fromObject3, "fromObject");
function checked3(length2) {
  if (length2 >= kMaxLength3()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength3().toString(16) + " bytes");
  }
  return length2 | 0;
}
__name(checked3, "checked");
Buffer4.isBuffer = isBuffer$13;
function internalIsBuffer3(b3) {
  return !!(b3 != null && b3._isBuffer);
}
__name(internalIsBuffer3, "internalIsBuffer");
Buffer4.compare = /* @__PURE__ */ __name(function compare7(a4, b3) {
  if (!internalIsBuffer3(a4) || !internalIsBuffer3(b3)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a4 === b3) return 0;
  var x = a4.length;
  var y3 = b3.length;
  for (var i2 = 0, len = Math.min(x, y3); i2 < len; ++i2) {
    if (a4[i2] !== b3[i2]) {
      x = a4[i2];
      y3 = b3[i2];
      break;
    }
  }
  if (x < y3) return -1;
  if (y3 < x) return 1;
  return 0;
}, "compare");
Buffer4.isEncoding = /* @__PURE__ */ __name(function isEncoding3(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, "isEncoding");
Buffer4.concat = /* @__PURE__ */ __name(function concat4(list, length2) {
  if (!isArray3(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer4.alloc(0);
  }
  var i2;
  if (length2 === void 0) {
    length2 = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      length2 += list[i2].length;
    }
  }
  var buffer = Buffer4.allocUnsafe(length2);
  var pos = 0;
  for (i2 = 0; i2 < list.length; ++i2) {
    var buf = list[i2];
    if (!internalIsBuffer3(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
}, "concat");
function byteLength4(string, encoding) {
  if (internalIsBuffer3(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes3(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes3(string).length;
      default:
        if (loweredCase) return utf8ToBytes3(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
__name(byteLength4, "byteLength");
Buffer4.byteLength = byteLength4;
function slowToString3(encoding, start2, end2) {
  var loweredCase = false;
  if (start2 === void 0 || start2 < 0) {
    start2 = 0;
  }
  if (start2 > this.length) {
    return "";
  }
  if (end2 === void 0 || end2 > this.length) {
    end2 = this.length;
  }
  if (end2 <= 0) {
    return "";
  }
  end2 >>>= 0;
  start2 >>>= 0;
  if (end2 <= start2) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice3(this, start2, end2);
      case "utf8":
      case "utf-8":
        return utf8Slice3(this, start2, end2);
      case "ascii":
        return asciiSlice3(this, start2, end2);
      case "latin1":
      case "binary":
        return latin1Slice3(this, start2, end2);
      case "base64":
        return base64Slice3(this, start2, end2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice3(this, start2, end2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
__name(slowToString3, "slowToString");
Buffer4.prototype._isBuffer = true;
function swap3(b3, n5, m3) {
  var i2 = b3[n5];
  b3[n5] = b3[m3];
  b3[m3] = i2;
}
__name(swap3, "swap");
Buffer4.prototype.swap16 = /* @__PURE__ */ __name(function swap163() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 2) {
    swap3(this, i2, i2 + 1);
  }
  return this;
}, "swap16");
Buffer4.prototype.swap32 = /* @__PURE__ */ __name(function swap323() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 4) {
    swap3(this, i2, i2 + 3);
    swap3(this, i2 + 1, i2 + 2);
  }
  return this;
}, "swap32");
Buffer4.prototype.swap64 = /* @__PURE__ */ __name(function swap643() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 8) {
    swap3(this, i2, i2 + 7);
    swap3(this, i2 + 1, i2 + 6);
    swap3(this, i2 + 2, i2 + 5);
    swap3(this, i2 + 3, i2 + 4);
  }
  return this;
}, "swap64");
Buffer4.prototype.toString = /* @__PURE__ */ __name(function toString6() {
  var length2 = this.length | 0;
  if (length2 === 0) return "";
  if (arguments.length === 0) return utf8Slice3(this, 0, length2);
  return slowToString3.apply(this, arguments);
}, "toString");
Buffer4.prototype.equals = /* @__PURE__ */ __name(function equals3(b3) {
  if (!internalIsBuffer3(b3)) throw new TypeError("Argument must be a Buffer");
  if (this === b3) return true;
  return Buffer4.compare(this, b3) === 0;
}, "equals");
Buffer4.prototype.inspect = /* @__PURE__ */ __name(function inspect5() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES3;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2) str += " ... ";
  }
  return "<Buffer " + str + ">";
}, "inspect");
Buffer4.prototype.compare = /* @__PURE__ */ __name(function compare8(target, start2, end2, thisStart, thisEnd) {
  if (!internalIsBuffer3(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start2 === void 0) {
    start2 = 0;
  }
  if (end2 === void 0) {
    end2 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start2 >= end2) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start2 >= end2) {
    return 1;
  }
  start2 >>>= 0;
  end2 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y3 = end2 - start2;
  var len = Math.min(x, y3);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start2, end2);
  for (var i2 = 0; i2 < len; ++i2) {
    if (thisCopy[i2] !== targetCopy[i2]) {
      x = thisCopy[i2];
      y3 = targetCopy[i2];
      break;
    }
  }
  if (x < y3) return -1;
  if (y3 < x) return 1;
  return 0;
}, "compare");
function bidirectionalIndexOf3(buffer, val, byteOffset, encoding, dir3) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir3 ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir3) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir3) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer4.from(val, encoding);
  }
  if (internalIsBuffer3(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf3(buffer, val, byteOffset, encoding, dir3);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer4.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir3) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf3(buffer, [val], byteOffset, encoding, dir3);
  }
  throw new TypeError("val must be string, number or Buffer");
}
__name(bidirectionalIndexOf3, "bidirectionalIndexOf");
function arrayIndexOf3(arr, val, byteOffset, encoding, dir3) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read5(buf, i3) {
    if (indexSize === 1) {
      return buf[i3];
    } else {
      return buf.readUInt16BE(i3 * indexSize);
    }
  }
  __name(read5, "read");
  var i2;
  if (dir3) {
    var foundIndex = -1;
    for (i2 = byteOffset; i2 < arrLength; i2++) {
      if (read5(arr, i2) === read5(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1) foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i2 = byteOffset; i2 >= 0; i2--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read5(arr, i2 + j) !== read5(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i2;
    }
  }
  return -1;
}
__name(arrayIndexOf3, "arrayIndexOf");
Buffer4.prototype.includes = /* @__PURE__ */ __name(function includes4(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
}, "includes");
Buffer4.prototype.indexOf = /* @__PURE__ */ __name(function indexOf5(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, true);
}, "indexOf");
Buffer4.prototype.lastIndexOf = /* @__PURE__ */ __name(function lastIndexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, false);
}, "lastIndexOf");
function hexWrite3(buf, string, offset2, length2) {
  offset2 = Number(offset2) || 0;
  var remaining = buf.length - offset2;
  if (!length2) {
    length2 = remaining;
  } else {
    length2 = Number(length2);
    if (length2 > remaining) {
      length2 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length2 > strLen / 2) {
    length2 = strLen / 2;
  }
  for (var i2 = 0; i2 < length2; ++i2) {
    var parsed = parseInt(string.substr(i2 * 2, 2), 16);
    if (isNaN(parsed)) return i2;
    buf[offset2 + i2] = parsed;
  }
  return i2;
}
__name(hexWrite3, "hexWrite");
function utf8Write3(buf, string, offset2, length2) {
  return blitBuffer3(utf8ToBytes3(string, buf.length - offset2), buf, offset2, length2);
}
__name(utf8Write3, "utf8Write");
function asciiWrite3(buf, string, offset2, length2) {
  return blitBuffer3(asciiToBytes3(string), buf, offset2, length2);
}
__name(asciiWrite3, "asciiWrite");
function latin1Write3(buf, string, offset2, length2) {
  return asciiWrite3(buf, string, offset2, length2);
}
__name(latin1Write3, "latin1Write");
function base64Write3(buf, string, offset2, length2) {
  return blitBuffer3(base64ToBytes3(string), buf, offset2, length2);
}
__name(base64Write3, "base64Write");
function ucs2Write3(buf, string, offset2, length2) {
  return blitBuffer3(utf16leToBytes3(string, buf.length - offset2), buf, offset2, length2);
}
__name(ucs2Write3, "ucs2Write");
Buffer4.prototype.write = /* @__PURE__ */ __name(function write6(string, offset2, length2, encoding) {
  if (offset2 === void 0) {
    encoding = "utf8";
    length2 = this.length;
    offset2 = 0;
  } else if (length2 === void 0 && typeof offset2 === "string") {
    encoding = offset2;
    length2 = this.length;
    offset2 = 0;
  } else if (isFinite(offset2)) {
    offset2 = offset2 | 0;
    if (isFinite(length2)) {
      length2 = length2 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length2;
      length2 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset2;
  if (length2 === void 0 || length2 > remaining) length2 = remaining;
  if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite3(this, string, offset2, length2);
      case "utf8":
      case "utf-8":
        return utf8Write3(this, string, offset2, length2);
      case "ascii":
        return asciiWrite3(this, string, offset2, length2);
      case "latin1":
      case "binary":
        return latin1Write3(this, string, offset2, length2);
      case "base64":
        return base64Write3(this, string, offset2, length2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write3(this, string, offset2, length2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}, "write");
Buffer4.prototype.toJSON = /* @__PURE__ */ __name(function toJSON3() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
}, "toJSON");
function base64Slice3(buf, start2, end2) {
  if (start2 === 0 && end2 === buf.length) {
    return fromByteArray3(buf);
  } else {
    return fromByteArray3(buf.slice(start2, end2));
  }
}
__name(base64Slice3, "base64Slice");
function utf8Slice3(buf, start2, end2) {
  end2 = Math.min(buf.length, end2);
  var res = [];
  var i2 = start2;
  while (i2 < end2) {
    var firstByte = buf[i2];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end2) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i2 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          fourthByte = buf[i2 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i2 += bytesPerSequence;
  }
  return decodeCodePointsArray3(res);
}
__name(utf8Slice3, "utf8Slice");
var MAX_ARGUMENTS_LENGTH3 = 4096;
function decodeCodePointsArray3(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH3) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH3)
    );
  }
  return res;
}
__name(decodeCodePointsArray3, "decodeCodePointsArray");
function asciiSlice3(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i2 = start2; i2 < end2; ++i2) {
    ret += String.fromCharCode(buf[i2] & 127);
  }
  return ret;
}
__name(asciiSlice3, "asciiSlice");
function latin1Slice3(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i2 = start2; i2 < end2; ++i2) {
    ret += String.fromCharCode(buf[i2]);
  }
  return ret;
}
__name(latin1Slice3, "latin1Slice");
function hexSlice3(buf, start2, end2) {
  var len = buf.length;
  if (!start2 || start2 < 0) start2 = 0;
  if (!end2 || end2 < 0 || end2 > len) end2 = len;
  var out = "";
  for (var i2 = start2; i2 < end2; ++i2) {
    out += toHex3(buf[i2]);
  }
  return out;
}
__name(hexSlice3, "hexSlice");
function utf16leSlice3(buf, start2, end2) {
  var bytes = buf.slice(start2, end2);
  var res = "";
  for (var i2 = 0; i2 < bytes.length; i2 += 2) {
    res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
  }
  return res;
}
__name(utf16leSlice3, "utf16leSlice");
Buffer4.prototype.slice = /* @__PURE__ */ __name(function slice4(start2, end2) {
  var len = this.length;
  start2 = ~~start2;
  end2 = end2 === void 0 ? len : ~~end2;
  if (start2 < 0) {
    start2 += len;
    if (start2 < 0) start2 = 0;
  } else if (start2 > len) {
    start2 = len;
  }
  if (end2 < 0) {
    end2 += len;
    if (end2 < 0) end2 = 0;
  } else if (end2 > len) {
    end2 = len;
  }
  if (end2 < start2) end2 = start2;
  var newBuf;
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start2, end2);
    newBuf.__proto__ = Buffer4.prototype;
  } else {
    var sliceLen = end2 - start2;
    newBuf = new Buffer4(sliceLen, void 0);
    for (var i2 = 0; i2 < sliceLen; ++i2) {
      newBuf[i2] = this[i2 + start2];
    }
  }
  return newBuf;
}, "slice");
function checkOffset3(offset2, ext, length2) {
  if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
  if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
}
__name(checkOffset3, "checkOffset");
Buffer4.prototype.readUIntLE = /* @__PURE__ */ __name(function readUIntLE3(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset3(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i2] * mul;
  }
  return val;
}, "readUIntLE");
Buffer4.prototype.readUIntBE = /* @__PURE__ */ __name(function readUIntBE3(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset3(offset2, byteLength5, this.length);
  }
  var val = this[offset2 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset2 + --byteLength5] * mul;
  }
  return val;
}, "readUIntBE");
Buffer4.prototype.readUInt8 = /* @__PURE__ */ __name(function readUInt84(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 1, this.length);
  return this[offset2];
}, "readUInt8");
Buffer4.prototype.readUInt16LE = /* @__PURE__ */ __name(function readUInt16LE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 2, this.length);
  return this[offset2] | this[offset2 + 1] << 8;
}, "readUInt16LE");
Buffer4.prototype.readUInt16BE = /* @__PURE__ */ __name(function readUInt16BE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 2, this.length);
  return this[offset2] << 8 | this[offset2 + 1];
}, "readUInt16BE");
Buffer4.prototype.readUInt32LE = /* @__PURE__ */ __name(function readUInt32LE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
}, "readUInt32LE");
Buffer4.prototype.readUInt32BE = /* @__PURE__ */ __name(function readUInt32BE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
}, "readUInt32BE");
Buffer4.prototype.readIntLE = /* @__PURE__ */ __name(function readIntLE3(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset3(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i2] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
}, "readIntLE");
Buffer4.prototype.readIntBE = /* @__PURE__ */ __name(function readIntBE3(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset3(offset2, byteLength5, this.length);
  var i2 = byteLength5;
  var mul = 1;
  var val = this[offset2 + --i2];
  while (i2 > 0 && (mul *= 256)) {
    val += this[offset2 + --i2] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
}, "readIntBE");
Buffer4.prototype.readInt8 = /* @__PURE__ */ __name(function readInt83(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 1, this.length);
  if (!(this[offset2] & 128)) return this[offset2];
  return (255 - this[offset2] + 1) * -1;
}, "readInt8");
Buffer4.prototype.readInt16LE = /* @__PURE__ */ __name(function readInt16LE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 2, this.length);
  var val = this[offset2] | this[offset2 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
}, "readInt16LE");
Buffer4.prototype.readInt16BE = /* @__PURE__ */ __name(function readInt16BE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 2, this.length);
  var val = this[offset2 + 1] | this[offset2] << 8;
  return val & 32768 ? val | 4294901760 : val;
}, "readInt16BE");
Buffer4.prototype.readInt32LE = /* @__PURE__ */ __name(function readInt32LE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
}, "readInt32LE");
Buffer4.prototype.readInt32BE = /* @__PURE__ */ __name(function readInt32BE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
}, "readInt32BE");
Buffer4.prototype.readFloatLE = /* @__PURE__ */ __name(function readFloatLE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return read3(this, offset2, true, 23, 4);
}, "readFloatLE");
Buffer4.prototype.readFloatBE = /* @__PURE__ */ __name(function readFloatBE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return read3(this, offset2, false, 23, 4);
}, "readFloatBE");
Buffer4.prototype.readDoubleLE = /* @__PURE__ */ __name(function readDoubleLE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 8, this.length);
  return read3(this, offset2, true, 52, 8);
}, "readDoubleLE");
Buffer4.prototype.readDoubleBE = /* @__PURE__ */ __name(function readDoubleBE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 8, this.length);
  return read3(this, offset2, false, 52, 8);
}, "readDoubleBE");
function checkInt3(buf, value2, offset2, ext, max2, min2) {
  if (!internalIsBuffer3(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max2 || value2 < min2) throw new RangeError('"value" argument is out of bounds');
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
}
__name(checkInt3, "checkInt");
Buffer4.prototype.writeUIntLE = /* @__PURE__ */ __name(function writeUIntLE3(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt3(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i2 = 0;
  this[offset2] = value2 & 255;
  while (++i2 < byteLength5 && (mul *= 256)) {
    this[offset2 + i2] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
}, "writeUIntLE");
Buffer4.prototype.writeUIntBE = /* @__PURE__ */ __name(function writeUIntBE3(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt3(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var i2 = byteLength5 - 1;
  var mul = 1;
  this[offset2 + i2] = value2 & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    this[offset2 + i2] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
}, "writeUIntBE");
Buffer4.prototype.writeUInt8 = /* @__PURE__ */ __name(function writeUInt83(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 1, 255, 0);
  if (!Buffer4.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset2] = value2 & 255;
  return offset2 + 1;
}, "writeUInt8");
function objectWriteUInt163(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i2 = 0, j = Math.min(buf.length - offset2, 2); i2 < j; ++i2) {
    buf[offset2 + i2] = (value2 & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
  }
}
__name(objectWriteUInt163, "objectWriteUInt16");
Buffer4.prototype.writeUInt16LE = /* @__PURE__ */ __name(function writeUInt16LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 2, 65535, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt163(this, value2, offset2, true);
  }
  return offset2 + 2;
}, "writeUInt16LE");
Buffer4.prototype.writeUInt16BE = /* @__PURE__ */ __name(function writeUInt16BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 2, 65535, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt163(this, value2, offset2, false);
  }
  return offset2 + 2;
}, "writeUInt16BE");
function objectWriteUInt323(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i2 = 0, j = Math.min(buf.length - offset2, 4); i2 < j; ++i2) {
    buf[offset2 + i2] = value2 >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
  }
}
__name(objectWriteUInt323, "objectWriteUInt32");
Buffer4.prototype.writeUInt32LE = /* @__PURE__ */ __name(function writeUInt32LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2 + 3] = value2 >>> 24;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset2, true);
  }
  return offset2 + 4;
}, "writeUInt32LE");
Buffer4.prototype.writeUInt32BE = /* @__PURE__ */ __name(function writeUInt32BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset2, false);
  }
  return offset2 + 4;
}, "writeUInt32BE");
Buffer4.prototype.writeIntLE = /* @__PURE__ */ __name(function writeIntLE3(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt3(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i2 = 0;
  var mul = 1;
  var sub = 0;
  this[offset2] = value2 & 255;
  while (++i2 < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i2] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
}, "writeIntLE");
Buffer4.prototype.writeIntBE = /* @__PURE__ */ __name(function writeIntBE3(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt3(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i2 = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset2 + i2] = value2 & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i2] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
}, "writeIntBE");
Buffer4.prototype.writeInt8 = /* @__PURE__ */ __name(function writeInt83(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 1, 127, -128);
  if (!Buffer4.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset2] = value2 & 255;
  return offset2 + 1;
}, "writeInt8");
Buffer4.prototype.writeInt16LE = /* @__PURE__ */ __name(function writeInt16LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 2, 32767, -32768);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt163(this, value2, offset2, true);
  }
  return offset2 + 2;
}, "writeInt16LE");
Buffer4.prototype.writeInt16BE = /* @__PURE__ */ __name(function writeInt16BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 2, 32767, -32768);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt163(this, value2, offset2, false);
  }
  return offset2 + 2;
}, "writeInt16BE");
Buffer4.prototype.writeInt32LE = /* @__PURE__ */ __name(function writeInt32LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 4, 2147483647, -2147483648);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt323(this, value2, offset2, true);
  }
  return offset2 + 4;
}, "writeInt32LE");
Buffer4.prototype.writeInt32BE = /* @__PURE__ */ __name(function writeInt32BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset2, false);
  }
  return offset2 + 4;
}, "writeInt32BE");
function checkIEEE7543(buf, value2, offset2, ext, max2, min2) {
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset2 < 0) throw new RangeError("Index out of range");
}
__name(checkIEEE7543, "checkIEEE754");
function writeFloat3(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7543(buf, value2, offset2, 4);
  }
  write5(buf, value2, offset2, littleEndian, 23, 4);
  return offset2 + 4;
}
__name(writeFloat3, "writeFloat");
Buffer4.prototype.writeFloatLE = /* @__PURE__ */ __name(function writeFloatLE3(value2, offset2, noAssert) {
  return writeFloat3(this, value2, offset2, true, noAssert);
}, "writeFloatLE");
Buffer4.prototype.writeFloatBE = /* @__PURE__ */ __name(function writeFloatBE3(value2, offset2, noAssert) {
  return writeFloat3(this, value2, offset2, false, noAssert);
}, "writeFloatBE");
function writeDouble3(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7543(buf, value2, offset2, 8);
  }
  write5(buf, value2, offset2, littleEndian, 52, 8);
  return offset2 + 8;
}
__name(writeDouble3, "writeDouble");
Buffer4.prototype.writeDoubleLE = /* @__PURE__ */ __name(function writeDoubleLE3(value2, offset2, noAssert) {
  return writeDouble3(this, value2, offset2, true, noAssert);
}, "writeDoubleLE");
Buffer4.prototype.writeDoubleBE = /* @__PURE__ */ __name(function writeDoubleBE3(value2, offset2, noAssert) {
  return writeDouble3(this, value2, offset2, false, noAssert);
}, "writeDoubleBE");
Buffer4.prototype.copy = /* @__PURE__ */ __name(function copy4(target, targetStart, start2, end2) {
  if (!start2) start2 = 0;
  if (!end2 && end2 !== 0) end2 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end2 > 0 && end2 < start2) end2 = start2;
  if (end2 === start2) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start2 < 0 || start2 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end2 > this.length) end2 = this.length;
  if (target.length - targetStart < end2 - start2) {
    end2 = target.length - targetStart + start2;
  }
  var len = end2 - start2;
  var i2;
  if (this === target && start2 < targetStart && targetStart < end2) {
    for (i2 = len - 1; i2 >= 0; --i2) {
      target[i2 + targetStart] = this[i2 + start2];
    }
  } else if (len < 1e3 || !Buffer4.TYPED_ARRAY_SUPPORT) {
    for (i2 = 0; i2 < len; ++i2) {
      target[i2 + targetStart] = this[i2 + start2];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start2, start2 + len),
      targetStart
    );
  }
  return len;
}, "copy");
Buffer4.prototype.fill = /* @__PURE__ */ __name(function fill3(val, start2, end2, encoding) {
  if (typeof val === "string") {
    if (typeof start2 === "string") {
      encoding = start2;
      start2 = 0;
      end2 = this.length;
    } else if (typeof end2 === "string") {
      encoding = end2;
      end2 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start2 < 0 || this.length < start2 || this.length < end2) {
    throw new RangeError("Out of range index");
  }
  if (end2 <= start2) {
    return this;
  }
  start2 = start2 >>> 0;
  end2 = end2 === void 0 ? this.length : end2 >>> 0;
  if (!val) val = 0;
  var i2;
  if (typeof val === "number") {
    for (i2 = start2; i2 < end2; ++i2) {
      this[i2] = val;
    }
  } else {
    var bytes = internalIsBuffer3(val) ? val : utf8ToBytes3(new Buffer4(val, encoding).toString());
    var len = bytes.length;
    for (i2 = 0; i2 < end2 - start2; ++i2) {
      this[i2 + start2] = bytes[i2 % len];
    }
  }
  return this;
}, "fill");
var INVALID_BASE64_RE3 = /[^+\/0-9A-Za-z-_]/g;
function base64clean3(str) {
  str = stringtrim3(str).replace(INVALID_BASE64_RE3, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
__name(base64clean3, "base64clean");
function stringtrim3(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
__name(stringtrim3, "stringtrim");
function toHex3(n5) {
  if (n5 < 16) return "0" + n5.toString(16);
  return n5.toString(16);
}
__name(toHex3, "toHex");
function utf8ToBytes3(string, units) {
  units = units || Infinity;
  var codePoint;
  var length2 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i2 = 0; i2 < length2; ++i2) {
    codePoint = string.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length2) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
__name(utf8ToBytes3, "utf8ToBytes");
function asciiToBytes3(str) {
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    byteArray.push(str.charCodeAt(i2) & 255);
  }
  return byteArray;
}
__name(asciiToBytes3, "asciiToBytes");
function utf16leToBytes3(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    if ((units -= 2) < 0) break;
    c2 = str.charCodeAt(i2);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
__name(utf16leToBytes3, "utf16leToBytes");
function base64ToBytes3(str) {
  return toByteArray3(base64clean3(str));
}
__name(base64ToBytes3, "base64ToBytes");
function blitBuffer3(src, dst, offset2, length2) {
  for (var i2 = 0; i2 < length2; ++i2) {
    if (i2 + offset2 >= dst.length || i2 >= src.length) break;
    dst[i2 + offset2] = src[i2];
  }
  return i2;
}
__name(blitBuffer3, "blitBuffer");
function isnan3(val) {
  return val !== val;
}
__name(isnan3, "isnan");
function isBuffer$13(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer3(obj) || isSlowBuffer3(obj));
}
__name(isBuffer$13, "isBuffer$1");
function isFastBuffer3(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
__name(isFastBuffer3, "isFastBuffer");
function isSlowBuffer3(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer3(obj.slice(0, 0));
}
__name(isSlowBuffer3, "isSlowBuffer");
var PNG2 = class {
  static {
    __name(this, "PNG");
  }
  data;
  width;
  height;
  format;
  constructor(data2) {
    const png = new PNG(data2);
    this.data = data2;
    this.width = png.width;
    this.height = png.height;
    this.format = "png";
  }
  static isValid(data2) {
    return data2 && Buffer4.isBuffer(data2) && data2[0] === 137 && data2[1] === 80 && data2[2] === 78 && data2[3] === 71 && data2[4] === 13 && data2[5] === 10 && data2[6] === 26 && data2[7] === 10;
  }
};
var JPEG3 = class {
  static {
    __name(this, "JPEG");
  }
  data;
  width;
  height;
  format;
  constructor(data2) {
    this.data = data2;
    this.format = "jpeg";
    this.width = 0;
    this.height = 0;
    if (data2.readUInt16BE(0) !== 65496) {
      throw new Error("SOI not found in JPEG");
    }
    const markers = src_default.decode(this.data);
    let orientation;
    for (let i2 = 0; i2 < markers.length; i2 += 1) {
      const marker = markers[i2];
      if (marker.name === "EXIF" && marker.entries.orientation) {
        orientation = marker.entries.orientation;
      }
      if (marker.name === "SOF") {
        this.width ||= marker.width;
        this.height ||= marker.height;
      }
    }
    if (orientation > 4) {
      [this.width, this.height] = [this.height, this.width];
    }
  }
  static isValid(data2) {
    return data2 && Buffer4.isBuffer(data2) && data2.readUInt16BE(0) === 65496;
  }
};
var createCache = /* @__PURE__ */ __name(({ limit = 100 } = {}) => {
  let cache2 = /* @__PURE__ */ new Map();
  return {
    get: /* @__PURE__ */ __name((key) => key ? cache2.get(key) ?? void 0 : null, "get"),
    set: /* @__PURE__ */ __name((key, value2) => {
      cache2.delete(key);
      if (cache2.size >= limit) {
        const firstKey = cache2.keys().next().value;
        cache2.delete(firstKey);
      }
      cache2.set(key, value2);
    }, "set"),
    reset: /* @__PURE__ */ __name(() => {
      cache2 = /* @__PURE__ */ new Map();
    }, "reset"),
    length: /* @__PURE__ */ __name(() => cache2.size, "length")
  };
}, "createCache");
var IMAGE_CACHE = createCache({ limit: 30 });
var isBuffer3 = Buffer4.isBuffer;
var isBlob = /* @__PURE__ */ __name((src) => {
  return typeof Blob !== "undefined" && src instanceof Blob;
}, "isBlob");
var isDataImageSrc = /* @__PURE__ */ __name((src) => {
  return "data" in src;
}, "isDataImageSrc");
var isDataUri = /* @__PURE__ */ __name((imageSrc) => "uri" in imageSrc && imageSrc.uri.startsWith("data:"), "isDataUri");
var fetchRemoteFile = /* @__PURE__ */ __name(async (src) => {
  const { method = "GET", headers, body, credentials } = src;
  const response = await fetch(src.uri, {
    method,
    headers,
    body,
    credentials
  });
  const buffer = await response.arrayBuffer();
  return Buffer4.from(buffer);
}, "fetchRemoteFile");
var isValidFormat = /* @__PURE__ */ __name((format3) => {
  const lower = format3.toLowerCase();
  return lower === "jpg" || lower === "jpeg" || lower === "png";
}, "isValidFormat");
var getImageFormat = /* @__PURE__ */ __name((buffer) => {
  let format3;
  if (JPEG3.isValid(buffer)) {
    format3 = "jpg";
  } else if (PNG2.isValid(buffer)) {
    format3 = "png";
  }
  return format3;
}, "getImageFormat");
function getImage(body, format3) {
  switch (format3.toLowerCase()) {
    case "jpg":
    case "jpeg":
      return new JPEG3(body);
    case "png":
      return new PNG2(body);
    default:
      return null;
  }
}
__name(getImage, "getImage");
var resolveBase64Image = /* @__PURE__ */ __name(async ({ uri }) => {
  const match2 = /^data:image\/([a-zA-Z]*);base64,([^"]*)/g.exec(uri);
  if (!match2)
    throw new Error(`Invalid base64 image: ${uri}`);
  const format3 = match2[1];
  const data2 = match2[2];
  if (!isValidFormat(format3))
    throw new Error(`Base64 image invalid format: ${format3}`);
  return getImage(Buffer4.from(data2, "base64"), format3);
}, "resolveBase64Image");
var resolveImageFromData = /* @__PURE__ */ __name(async (src) => {
  if (src.data && src.format) {
    return getImage(src.data, src.format);
  }
  throw new Error(`Invalid data given for local file: ${JSON.stringify(src)}`);
}, "resolveImageFromData");
var resolveBufferImage = /* @__PURE__ */ __name(async (buffer) => {
  const format3 = getImageFormat(buffer);
  if (format3) {
    return getImage(buffer, format3);
  }
  return null;
}, "resolveBufferImage");
var resolveBlobImage = /* @__PURE__ */ __name(async (blob) => {
  const { type: type2 } = blob;
  if (!type2 || type2 === "application/octet-stream") {
    const arrayBuffer = await blob.arrayBuffer();
    const buffer2 = Buffer4.from(arrayBuffer);
    return resolveBufferImage(buffer2);
  }
  if (!type2.startsWith("image/")) {
    throw new Error(`Invalid blob type: ${type2}`);
  }
  const format3 = type2.replace("image/", "");
  if (!isValidFormat(format3)) {
    throw new Error(`Invalid blob type: ${type2}`);
  }
  const buffer = await blob.arrayBuffer();
  return getImage(Buffer4.from(buffer), format3);
}, "resolveBlobImage");
var resolveImageFromUrl = /* @__PURE__ */ __name(async (src) => {
  const data2 = await fetchRemoteFile(src);
  const format3 = getImageFormat(data2);
  if (!format3) {
    throw new Error("Not valid image extension");
  }
  return getImage(data2, format3);
}, "resolveImageFromUrl");
var getCacheKey = /* @__PURE__ */ __name((src) => {
  if (isBlob(src) || isBuffer3(src))
    return null;
  if (isDataImageSrc(src))
    return src.data?.toString("base64") ?? null;
  return src.uri;
}, "getCacheKey");
var resolveImage = /* @__PURE__ */ __name((src, { cache: cache2 = true } = {}) => {
  let image;
  const cacheKey = getCacheKey(src);
  if (isBlob(src)) {
    image = resolveBlobImage(src);
  } else if (isBuffer3(src)) {
    image = resolveBufferImage(src);
  } else if (cache2 && IMAGE_CACHE.get(cacheKey)) {
    return IMAGE_CACHE.get(cacheKey);
  } else if (isDataUri(src)) {
    image = resolveBase64Image(src);
  } else if (isDataImageSrc(src)) {
    image = resolveImageFromData(src);
  } else {
    image = resolveImageFromUrl(src);
  }
  if (cache2 && cacheKey) {
    IMAGE_CACHE.set(cacheKey, image);
  }
  return image;
}, "resolveImage");

// ../../node_modules/.pnpm/@react-pdf+layout@4.4.2/node_modules/@react-pdf/layout/lib/index.js
var transformText = /* @__PURE__ */ __name((text, transformation) => {
  switch (transformation) {
    case "uppercase":
      return text.toUpperCase();
    case "lowercase":
      return text.toLowerCase();
    case "capitalize":
      return capitalize(text);
    case "upperfirst":
      return upperFirst(text);
    default:
      return text;
  }
}, "transformText");
var isTspan = /* @__PURE__ */ __name((node) => node.type === Tspan, "isTspan");
var isTextInstance$4 = /* @__PURE__ */ __name((node) => node.type === TextInstance, "isTextInstance$4");
var engines$1 = {
  bidi: bidiEngine,
  linebreaker,
  justification,
  textDecoration,
  scriptItemizer,
  wordHyphenation,
  fontSubstitution
};
var engine$1 = layoutEngine(engines$1);
var getFragments$1 = /* @__PURE__ */ __name((fontStore2, instance) => {
  if (!instance)
    return [{ string: "" }];
  const fragments = [];
  const { fill: fill4 = "black", fontFamily = "Helvetica", fontWeight, fontStyle, fontSize = 18, textDecorationColor, textDecorationStyle, textTransform, opacity } = instance.props;
  const _textDecoration = instance.props.textDecoration;
  const fontFamilies = typeof fontFamily === "string" ? [fontFamily] : [...fontFamily || []];
  fontFamilies.push("Helvetica");
  const font = fontFamilies.map((fontFamilyName) => {
    const opts2 = { fontFamily: fontFamilyName, fontWeight, fontStyle };
    const obj = fontStore2.getFont(opts2);
    return obj?.data;
  });
  const attributes2 = {
    font,
    opacity,
    fontSize,
    color: fill4,
    underlineStyle: textDecorationStyle,
    underline: _textDecoration === "underline" || _textDecoration === "underline line-through" || _textDecoration === "line-through underline",
    underlineColor: textDecorationColor || fill4,
    strike: _textDecoration === "line-through" || _textDecoration === "underline line-through" || _textDecoration === "line-through underline",
    strikeStyle: textDecorationStyle,
    strikeColor: textDecorationColor || fill4
  };
  for (let i2 = 0; i2 < instance.children.length; i2 += 1) {
    const child = instance.children[i2];
    if (isTextInstance$4(child)) {
      fragments.push({
        string: transformText(child.value, textTransform),
        attributes: attributes2
      });
    } else if (child) {
      fragments.push(...getFragments$1(fontStore2, child));
    }
  }
  return fragments;
}, "getFragments$1");
var getAttributedString$1 = /* @__PURE__ */ __name((fontStore2, instance) => fromFragments(getFragments$1(fontStore2, instance)), "getAttributedString$1");
var AlmostInfinity = 999999999999;
var shrinkWhitespaceFactor = { before: -0.5, after: -0.5 };
var layoutTspan = /* @__PURE__ */ __name((fontStore2) => (node, xOffset) => {
  const attributedString = getAttributedString$1(fontStore2, node);
  const x = node.props.x === void 0 ? xOffset : node.props.x;
  const y3 = node.props?.y || 0;
  const container = { x, y: y3, width: AlmostInfinity, height: AlmostInfinity };
  const hyphenationCallback = node.props.hyphenationCallback || fontStore2?.getHyphenationCallback() || null;
  const layoutOptions = { hyphenationCallback, shrinkWhitespaceFactor };
  const lines = engine$1(attributedString, container, layoutOptions).flat();
  return Object.assign({}, node, { lines });
}, "layoutTspan");
var joinTSpanLines = /* @__PURE__ */ __name((node) => {
  const children = node.children.map((child, index2) => {
    if (!isTspan(child))
      return child;
    const textInstance = child.children[0];
    if (child.props.x === void 0 && index2 < node.children.length - 1 && textInstance?.value) {
      return Object.assign({}, child, {
        children: [{ ...textInstance, value: `${textInstance.value} ` }]
      });
    }
    return child;
  }, []);
  return Object.assign({}, node, { children });
}, "joinTSpanLines");
var layoutText$1 = /* @__PURE__ */ __name((fontStore2, node) => {
  if (!node.children)
    return node;
  let currentXOffset = node.props?.x || 0;
  const layoutFn = layoutTspan(fontStore2);
  const joinedNode = joinTSpanLines(node);
  const children = joinedNode.children.map((child) => {
    const childWithLayout = layoutFn(child, currentXOffset);
    currentXOffset += childWithLayout.lines[0].xAdvance;
    return childWithLayout;
  });
  return Object.assign({}, node, { children });
}, "layoutText$1");
var isDefs = /* @__PURE__ */ __name((node) => node.type === Defs, "isDefs");
var getDefs = /* @__PURE__ */ __name((node) => {
  const children = node.children || [];
  const defs = children.find(isDefs);
  const values = defs?.children || [];
  return values.reduce((acc, value2) => {
    const id = value2.props?.id;
    if (id)
      acc[id] = value2;
    return acc;
  }, {});
}, "getDefs");
var isNotDefs = /* @__PURE__ */ __name((node) => node.type !== Defs, "isNotDefs");
var detachDefs = /* @__PURE__ */ __name((node) => {
  if (!node.children)
    return node;
  const children = node.children.filter(isNotDefs);
  return Object.assign({}, node, { children });
}, "detachDefs");
var URL_REGEX = /url\(['"]?#([^'"]+)['"]?\)/;
var replaceDef = /* @__PURE__ */ __name((defs, value2) => {
  if (!value2)
    return void 0;
  if (!URL_REGEX.test(value2))
    return value2;
  const match2 = value2.match(URL_REGEX);
  return defs[match2[1]];
}, "replaceDef");
var parseNodeDefs = /* @__PURE__ */ __name((defs) => (node) => {
  const props = node.props;
  const fill4 = `fill` in props ? replaceDef(defs, props?.fill) : void 0;
  const clipPath2 = `clipPath` in props ? replaceDef(defs, props?.clipPath) : void 0;
  const newProps = Object.assign({}, node.props, { fill: fill4, clipPath: clipPath2 });
  const children = node.children ? node.children.map(parseNodeDefs(defs)) : void 0;
  return Object.assign({}, node, { props: newProps, children });
}, "parseNodeDefs");
var parseDefs = /* @__PURE__ */ __name((root) => {
  if (!root.children)
    return root;
  const defs = getDefs(root);
  const children = root.children.map(parseNodeDefs(defs));
  return Object.assign({}, root, { children });
}, "parseDefs");
var replaceDefs = /* @__PURE__ */ __name((node) => {
  return detachDefs(parseDefs(node));
}, "replaceDefs");
var parseViewbox = /* @__PURE__ */ __name((value2) => {
  if (!value2)
    return null;
  if (typeof value2 !== "string")
    return value2;
  const values = value2.split(/[,\s]+/).map(parseFloat$1);
  if (values.length !== 4)
    return null;
  return { minX: values[0], minY: values[1], maxX: values[2], maxY: values[3] };
}, "parseViewbox");
var getContainer$1 = /* @__PURE__ */ __name((node) => {
  const viewbox = parseViewbox(node.props.viewBox);
  if (viewbox) {
    return { width: viewbox.maxX, height: viewbox.maxY };
  }
  if (node.props.width && node.props.height) {
    return {
      width: parseFloat$1(node.props.width),
      height: parseFloat$1(node.props.height)
    };
  }
  return { width: 0, height: 0 };
}, "getContainer$1");
var BASE_SVG_INHERITED_PROPS = [
  "x",
  "y",
  "clipPath",
  "clipRule",
  "opacity",
  "fill",
  "fillOpacity",
  "fillRule",
  "stroke",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeOpacity",
  "strokeWidth",
  "textAnchor",
  "dominantBaseline",
  "color",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "opacity",
  "textDecoration",
  "lineHeight",
  "textAlign",
  "visibility",
  "wordSpacing"
];
var TEXT_SVG_INHERITED_PROPS = without(["x"], BASE_SVG_INHERITED_PROPS);
var SVG_INHERITED_PROPS = {
  [Text]: TEXT_SVG_INHERITED_PROPS
};
var getInheritProps = /* @__PURE__ */ __name((node) => {
  const props = node.props || {};
  const svgInheritedProps = SVG_INHERITED_PROPS[node.type] ?? BASE_SVG_INHERITED_PROPS;
  return pick(svgInheritedProps, props);
}, "getInheritProps");
var inheritProps = /* @__PURE__ */ __name((node) => {
  if (!node.children)
    return node;
  const inheritedProps = getInheritProps(node);
  const children = node.children.map((child) => {
    const props = Object.assign({}, inheritedProps, child.props || {});
    const newChild = Object.assign({}, child, { props });
    return inheritProps(newChild);
  });
  return Object.assign({}, node, { children });
}, "inheritProps");
var parseAspectRatio = /* @__PURE__ */ __name((value2) => {
  if (typeof value2 !== "string")
    return value2;
  const match2 = value2.replace(/[\s\r\t\n]+/gm, " ").replace(/^defer\s/, "").split(" ");
  const align = match2[0] || "xMidYMid";
  const meetOrSlice = match2[1] || "meet";
  return { align, meetOrSlice };
}, "parseAspectRatio");
var STYLE_PROPS = [
  "width",
  "height",
  "color",
  "stroke",
  "strokeWidth",
  "opacity",
  "fillOpacity",
  "strokeOpacity",
  "fill",
  "fillRule",
  "clipPath",
  "offset",
  "transform",
  "strokeLinejoin",
  "strokeLinecap",
  "strokeDasharray",
  "gradientUnits",
  "gradientTransform"
];
var VERTICAL_PROPS = ["y", "y1", "y2", "height", "cy", "ry"];
var HORIZONTAL_PROPS = ["x", "x1", "x2", "width", "cx", "rx"];
var isSvg$3 = /* @__PURE__ */ __name((node) => node.type === Svg, "isSvg$3");
var isText$5 = /* @__PURE__ */ __name((node) => node.type === Text, "isText$5");
var isTextInstance$3 = /* @__PURE__ */ __name((node) => node.type === TextInstance, "isTextInstance$3");
var transformPercent = /* @__PURE__ */ __name((container) => (props) => mapValues(props, (value2, key) => {
  const match2 = matchPercent(value2);
  if (match2 && VERTICAL_PROPS.includes(key)) {
    return match2.percent * container.height;
  }
  if (match2 && HORIZONTAL_PROPS.includes(key)) {
    return match2.percent * container.width;
  }
  return value2;
}), "transformPercent");
var parsePercent = /* @__PURE__ */ __name((value2) => {
  const match2 = matchPercent(value2);
  return match2 ? match2.percent : parseFloat$1(value2);
}, "parsePercent");
var parseTransform = /* @__PURE__ */ __name((container) => (value2) => {
  return resolveStyles(container, { transform: value2 }).transform;
}, "parseTransform");
var parseProps = /* @__PURE__ */ __name((container) => (node) => {
  let props = transformPercent(container)(node.props);
  props = evolve({
    x: parseFloat$1,
    x1: parseFloat$1,
    x2: parseFloat$1,
    y: parseFloat$1,
    y1: parseFloat$1,
    y2: parseFloat$1,
    r: parseFloat$1,
    rx: parseFloat$1,
    ry: parseFloat$1,
    cx: parseFloat$1,
    cy: parseFloat$1,
    width: parseFloat$1,
    height: parseFloat$1,
    offset: parsePercent,
    fill: transformColor,
    opacity: parsePercent,
    stroke: transformColor,
    stopOpacity: parsePercent,
    stopColor: transformColor,
    transform: parseTransform(container),
    gradientTransform: parseTransform(container)
  }, props);
  return Object.assign({}, node, { props });
}, "parseProps");
var mergeStyles$1 = /* @__PURE__ */ __name((node) => {
  const style = node.style || {};
  const props = Object.assign({}, style, node.props);
  return Object.assign({}, node, { props });
}, "mergeStyles$1");
var removeNoneValues = /* @__PURE__ */ __name((node) => {
  const removeNone = /* @__PURE__ */ __name((value2) => value2 === "none" ? null : value2, "removeNone");
  const props = mapValues(node.props, removeNone);
  return Object.assign({}, node, { props });
}, "removeNoneValues");
var pickStyleProps = /* @__PURE__ */ __name((node) => {
  const props = node.props || {};
  const styleProps = pick(STYLE_PROPS, props);
  const style = Object.assign({}, styleProps, node.style || {});
  return Object.assign({}, node, { style });
}, "pickStyleProps");
var parseSvgProps = /* @__PURE__ */ __name((node) => {
  const props = evolve({
    width: parseFloat$1,
    height: parseFloat$1,
    viewBox: parseViewbox,
    preserveAspectRatio: parseAspectRatio
  }, node.props);
  return Object.assign({}, node, { props });
}, "parseSvgProps");
var wrapBetweenTspan = /* @__PURE__ */ __name((node) => ({
  type: Tspan,
  props: {},
  style: {},
  children: [node]
}), "wrapBetweenTspan");
var addMissingTspan = /* @__PURE__ */ __name((node) => {
  if (!isText$5(node))
    return node;
  if (!node.children)
    return node;
  const resolveChild = /* @__PURE__ */ __name((child) => isTextInstance$3(child) ? wrapBetweenTspan(child) : child, "resolveChild");
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
}, "addMissingTspan");
var parseText = /* @__PURE__ */ __name((fontStore2) => (node) => {
  if (isText$5(node))
    return layoutText$1(fontStore2, node);
  if (!node.children)
    return node;
  const children = node.children.map(parseText(fontStore2));
  return Object.assign({}, node, { children });
}, "parseText");
var resolveSvgNode = /* @__PURE__ */ __name((container) => compose2(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1), "resolveSvgNode");
var resolveChildren = /* @__PURE__ */ __name((container) => (node) => {
  if (!node.children)
    return node;
  const resolveChild = compose2(resolveChildren(container), resolveSvgNode(container));
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
}, "resolveChildren");
var buildXLinksIndex = /* @__PURE__ */ __name((node) => {
  const idIndex = {};
  const listToExplore = node.children?.slice(0) || [];
  while (listToExplore.length > 0) {
    const child = listToExplore.shift();
    if (child.props && "id" in child.props) {
      idIndex[child.props.id] = child;
    }
    if (child.children)
      listToExplore.push(...child.children);
  }
  return idIndex;
}, "buildXLinksIndex");
var replaceXLinks = /* @__PURE__ */ __name((node, idIndex) => {
  if (node.props && "xlinkHref" in node.props) {
    const linkedNode = idIndex[node.props.xlinkHref.replace(/^#/, "")];
    if (!linkedNode)
      return node;
    const newProps = Object.assign({}, linkedNode.props, node.props);
    delete newProps.xlinkHref;
    return Object.assign({}, linkedNode, { props: newProps });
  }
  const children = node.children?.map((child) => replaceXLinks(child, idIndex));
  return Object.assign({}, node, { children });
}, "replaceXLinks");
var resolveXLinks = /* @__PURE__ */ __name((node) => {
  const idIndex = buildXLinksIndex(node);
  return replaceXLinks(node, idIndex);
}, "resolveXLinks");
var resolveSvgRoot = /* @__PURE__ */ __name((node, fontStore2) => {
  const container = getContainer$1(node);
  return compose2(replaceDefs, parseText(fontStore2), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container), resolveXLinks)(node);
}, "resolveSvgRoot");
var resolveSvg = /* @__PURE__ */ __name((node, fontStore2) => {
  if (!("children" in node))
    return node;
  const resolveChild = /* @__PURE__ */ __name((child) => resolveSvg(child, fontStore2), "resolveChild");
  const root = isSvg$3(node) ? resolveSvgRoot(node, fontStore2) : node;
  const children = root.children?.map(resolveChild);
  return Object.assign({}, root, { children });
}, "resolveSvg");
var instancePromise;
var loadYoga3 = /* @__PURE__ */ __name(async () => {
  const instance = await (instancePromise ??= loadYoga2());
  const config4 = instance.Config.create();
  config4.setPointScaleFactor(0);
  const node = { create: /* @__PURE__ */ __name(() => instance.Node.createWithConfig(config4), "create") };
  return { node };
}, "loadYoga");
var resolveYoga = /* @__PURE__ */ __name(async (root) => {
  const yoga = await loadYoga3();
  return Object.assign({}, root, { yoga });
}, "resolveYoga");
var getZIndex = /* @__PURE__ */ __name((node) => node.style.zIndex, "getZIndex");
var shouldSort = /* @__PURE__ */ __name((node) => node.type !== Document && node.type !== Svg, "shouldSort");
var sortZIndex = /* @__PURE__ */ __name((a4, b3) => {
  const za = getZIndex(a4);
  const zb = getZIndex(b3);
  if (!za && !zb)
    return 0;
  if (!za)
    return 1;
  if (!zb)
    return -1;
  return zb - za;
}, "sortZIndex");
var resolveNodeZIndex = /* @__PURE__ */ __name((node) => {
  if (!node.children)
    return node;
  const sortedChildren = shouldSort(node) ? node.children.sort(sortZIndex) : node.children;
  const children = sortedChildren.map(resolveNodeZIndex);
  return Object.assign({}, node, { children });
}, "resolveNodeZIndex");
var resolveZIndex = /* @__PURE__ */ __name((root) => resolveNodeZIndex(root), "resolveZIndex");
var emojis = {};
var regex3 = emoji_regex_xs_default();
var removeVariationSelectors = /* @__PURE__ */ __name((x) => x !== "\uFE0F", "removeVariationSelectors");
var getCodePoints = /* @__PURE__ */ __name((string, withVariationSelectors = false) => Array.from(string).filter(withVariationSelectors ? () => true : removeVariationSelectors).map((char) => char.codePointAt(0).toString(16)).join("-"), "getCodePoints");
var buildEmojiUrl = /* @__PURE__ */ __name((emoji, source) => {
  if ("builder" in source) {
    return source.builder(getCodePoints(emoji, source.withVariationSelectors));
  }
  const { url, format: format3 = "png", withVariationSelectors } = source;
  return `${url}${getCodePoints(emoji, withVariationSelectors)}.${format3}`;
}, "buildEmojiUrl");
var fetchEmojis = /* @__PURE__ */ __name((string, source) => {
  if (!source)
    return [];
  const promises = [];
  Array.from(string.matchAll(regex3)).forEach((match2) => {
    const emoji = match2[0];
    if (!emojis[emoji] || emojis[emoji].loading) {
      const emojiUrl = buildEmojiUrl(emoji, source);
      emojis[emoji] = { loading: true };
      promises.push(resolveImage({ uri: emojiUrl }).then((image) => {
        emojis[emoji].loading = false;
        emojis[emoji].data = image.data;
      }).catch((e4) => {
        console.warn(e4, "Failed to load emoji image");
        emojis[emoji].loading = false;
      }));
    }
  });
  return promises;
}, "fetchEmojis");
var embedEmojis = /* @__PURE__ */ __name((fragments) => {
  const result = [];
  for (let i2 = 0; i2 < fragments.length; i2 += 1) {
    const fragment = fragments[i2];
    let lastIndex = 0;
    Array.from(fragment.string.matchAll(regex3)).forEach((match2) => {
      const { index: index2 } = match2;
      const emoji = match2[0];
      const emojiSize = fragment.attributes.fontSize;
      const chunk = fragment.string.slice(lastIndex, index2 + match2[0].length);
      if (emojis[emoji] && emojis[emoji].data) {
        result.push({
          string: chunk.replace(match2[0], String.fromCharCode(65532)),
          attributes: {
            ...fragment.attributes,
            attachment: {
              width: emojiSize,
              height: emojiSize,
              yOffset: Math.floor(emojiSize * 0.1),
              image: emojis[emoji].data
            }
          }
        });
      } else {
        result.push({
          string: chunk,
          attributes: fragment.attributes
        });
      }
      lastIndex = index2 + emoji.length;
    });
    if (lastIndex < fragment.string.length) {
      result.push({
        string: fragment.string.slice(lastIndex),
        attributes: fragment.attributes
      });
    }
  }
  return result;
}, "embedEmojis");
var getSource = /* @__PURE__ */ __name((node) => {
  if (node.props.src)
    return node.props.src;
  if (node.props.source)
    return node.props.source;
}, "getSource");
var resolveSource = /* @__PURE__ */ __name(async (src) => {
  const source = typeof src === "function" ? await src() : await src;
  return typeof source === "string" ? { uri: source } : source;
}, "resolveSource");
var fetchImage = /* @__PURE__ */ __name(async (node) => {
  const src = getSource(node);
  const { cache: cache2 } = node.props;
  if (!src) {
    console.warn(false, 'Image should receive either a "src" or "source" prop');
    return;
  }
  try {
    const source = await resolveSource(src);
    if (!source) {
      throw new Error(`Image's "src" or "source" prop returned ${source}`);
    }
    node.image = await resolveImage(source, { cache: cache2 });
    if (Buffer.isBuffer(source) || source instanceof Blob)
      return;
    node.image.key = "data" in source ? source.data.toString() : source.uri;
  } catch (e4) {
    console.warn(e4.message);
  }
}, "fetchImage");
var isImage$2 = /* @__PURE__ */ __name((node) => node.type === Image, "isImage$2");
var fetchAssets = /* @__PURE__ */ __name((fontStore2, node) => {
  const promises = [];
  const listToExplore = node.children?.slice(0) || [];
  const emojiSource = fontStore2 ? fontStore2.getEmojiSource() : null;
  while (listToExplore.length > 0) {
    const n5 = listToExplore.shift();
    if (isImage$2(n5)) {
      promises.push(fetchImage(n5));
    }
    if (fontStore2 && n5.style?.fontFamily) {
      const fontFamilies = castArray(n5.style.fontFamily);
      promises.push(...fontFamilies.map((fontFamily) => fontStore2.load({
        fontFamily,
        fontStyle: n5.style.fontStyle,
        fontWeight: n5.style.fontWeight
      })));
    }
    if (typeof n5 === "string") {
      promises.push(...fetchEmojis(n5, emojiSource));
    }
    if ("value" in n5 && typeof n5.value === "string") {
      promises.push(...fetchEmojis(n5.value, emojiSource));
    }
    if (n5.children) {
      n5.children.forEach((childNode) => {
        listToExplore.push(childNode);
      });
    }
  }
  return promises;
}, "fetchAssets");
var resolveAssets = /* @__PURE__ */ __name(async (node, fontStore2) => {
  const promises = fetchAssets(fontStore2, node);
  await Promise.all(promises);
  return node;
}, "resolveAssets");
var isLink$1 = /* @__PURE__ */ __name((node) => node.type === Link, "isLink$1");
var DEFAULT_LINK_STYLES = {
  color: "blue",
  textDecoration: "underline"
};
var computeStyle = /* @__PURE__ */ __name((container, node) => {
  let baseStyle = [node.style];
  if (isLink$1(node)) {
    baseStyle = Array.isArray(node.style) ? [DEFAULT_LINK_STYLES, ...node.style] : [DEFAULT_LINK_STYLES, node.style];
  }
  return resolveStyles(container, baseStyle);
}, "computeStyle");
var resolveNodeStyles = /* @__PURE__ */ __name((container) => (node) => {
  const style = computeStyle(container, node);
  if (!node.children)
    return Object.assign({}, node, { style });
  const children = node.children.map(resolveNodeStyles(container));
  return Object.assign({}, node, { style, children });
}, "resolveNodeStyles");
var resolvePageStyles = /* @__PURE__ */ __name((page) => {
  const dpi = page.props?.dpi || 72;
  const style = page.style;
  const width = page.box?.width || style.width;
  const height2 = page.box?.height || style.height;
  const orientation = page.props?.orientation || "portrait";
  const remBase = style?.fontSize || 18;
  const container = { width, height: height2, orientation, dpi, remBase };
  return resolveNodeStyles(container)(page);
}, "resolvePageStyles");
var resolveStyles2 = /* @__PURE__ */ __name((root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolvePageStyles);
  return Object.assign({}, root, { children });
}, "resolveStyles");
var getTransformStyle = /* @__PURE__ */ __name((s4) => (node) => isNil(node.style?.[s4]) ? "50%" : node.style?.[s4] ?? null, "getTransformStyle");
var getOrigin = /* @__PURE__ */ __name((node) => {
  if (!node.box)
    return null;
  const { left, top, width, height: height2 } = node.box;
  const transformOriginX = getTransformStyle("transformOriginX")(node);
  const transformOriginY = getTransformStyle("transformOriginY")(node);
  const percentX = matchPercent(transformOriginX);
  const percentY = matchPercent(transformOriginY);
  const offsetX = percentX ? width * percentX.percent : transformOriginX;
  const offsetY = percentY ? height2 * percentY.percent : transformOriginY;
  if (isNil(offsetX) || typeof offsetX === "string")
    throw new Error(`Invalid origin offsetX: ${offsetX}`);
  if (isNil(offsetY) || typeof offsetY === "string")
    throw new Error(`Invalid origin offsetY: ${offsetY}`);
  return { left: left + offsetX, top: top + offsetY };
}, "getOrigin");
var resolveNodeOrigin = /* @__PURE__ */ __name((node) => {
  const origin = getOrigin(node);
  const newNode = Object.assign({}, node, { origin });
  if (!node.children)
    return newNode;
  const children = node.children.map(resolveNodeOrigin);
  return Object.assign({}, newNode, { children });
}, "resolveNodeOrigin");
var resolveOrigin = /* @__PURE__ */ __name((root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolveNodeOrigin);
  return Object.assign({}, root, { children });
}, "resolveOrigin");
var getBookmarkValue = /* @__PURE__ */ __name((bookmark) => {
  return typeof bookmark === "string" ? { title: bookmark, fit: false, expanded: false } : bookmark;
}, "getBookmarkValue");
var resolveBookmarks = /* @__PURE__ */ __name((node) => {
  let refs = 0;
  const children = (node.children || []).slice(0);
  const listToExplore = children.map((value2) => ({
    value: value2,
    parent: null
  }));
  while (listToExplore.length > 0) {
    const element = listToExplore.shift();
    if (!element)
      break;
    const child = element.value;
    let parent = element.parent;
    if (child.props && "bookmark" in child.props && child.props.bookmark) {
      const bookmark = getBookmarkValue(child.props.bookmark);
      const ref2 = refs++;
      const newHierarchy = { ref: ref2, parent: parent?.ref, ...bookmark };
      child.props.bookmark = newHierarchy;
      parent = newHierarchy;
    }
    if (child.children) {
      child.children.forEach((childNode) => {
        listToExplore.push({ value: childNode, parent });
      });
    }
  }
  return node;
}, "resolveBookmarks");
var VALID_ORIENTATIONS = ["portrait", "landscape"];
var getOrientation = /* @__PURE__ */ __name((page) => {
  const value2 = page.props?.orientation || "portrait";
  return VALID_ORIENTATIONS.includes(value2) ? value2 : "portrait";
}, "getOrientation");
var isLandscape = /* @__PURE__ */ __name((page) => getOrientation(page) === "landscape", "isLandscape");
var PAGE_SIZES = {
  "4A0": [4767.87, 6740.79],
  "2A0": [3370.39, 4767.87],
  A0: [2383.94, 3370.39],
  A1: [1683.78, 2383.94],
  A2: [1190.55, 1683.78],
  A3: [841.89, 1190.55],
  A4: [595.28, 841.89],
  A5: [419.53, 595.28],
  A6: [297.64, 419.53],
  A7: [209.76, 297.64],
  A8: [147.4, 209.76],
  A9: [104.88, 147.4],
  A10: [73.7, 104.88],
  B0: [2834.65, 4008.19],
  B1: [2004.09, 2834.65],
  B2: [1417.32, 2004.09],
  B3: [1000.63, 1417.32],
  B4: [708.66, 1000.63],
  B5: [498.9, 708.66],
  B6: [354.33, 498.9],
  B7: [249.45, 354.33],
  B8: [175.75, 249.45],
  B9: [124.72, 175.75],
  B10: [87.87, 124.72],
  C0: [2599.37, 3676.54],
  C1: [1836.85, 2599.37],
  C2: [1298.27, 1836.85],
  C3: [918.43, 1298.27],
  C4: [649.13, 918.43],
  C5: [459.21, 649.13],
  C6: [323.15, 459.21],
  C7: [229.61, 323.15],
  C8: [161.57, 229.61],
  C9: [113.39, 161.57],
  C10: [79.37, 113.39],
  RA0: [2437.8, 3458.27],
  RA1: [1729.13, 2437.8],
  RA2: [1218.9, 1729.13],
  RA3: [864.57, 1218.9],
  RA4: [609.45, 864.57],
  SRA0: [2551.18, 3628.35],
  SRA1: [1814.17, 2551.18],
  SRA2: [1275.59, 1814.17],
  SRA3: [907.09, 1275.59],
  SRA4: [637.8, 907.09],
  EXECUTIVE: [521.86, 756],
  FOLIO: [612, 936],
  LEGAL: [612, 1008],
  LETTER: [612, 792],
  TABLOID: [792, 1224],
  ID1: [153, 243]
};
var parseValue2 = /* @__PURE__ */ __name((value2) => {
  if (typeof value2 === "number")
    return { value: value2, unit: void 0 };
  const match2 = /^(-?\d*\.?\d+)(in|mm|cm|pt|px)?$/g.exec(value2);
  return match2 ? { value: parseFloat(match2[1]), unit: match2[2] || "pt" } : { value: value2, unit: void 0 };
}, "parseValue");
var transformUnit2 = /* @__PURE__ */ __name((value2, inputDpi) => {
  if (!value2)
    return 0;
  const scalar = parseValue2(value2);
  const outputDpi = 72;
  const mmFactor = 1 / 25.4 * outputDpi;
  const cmFactor = 1 / 2.54 * outputDpi;
  if (typeof scalar.value === "string")
    throw new Error(`Invalid page size: ${value2}`);
  switch (scalar.unit) {
    case "in":
      return scalar.value * outputDpi;
    case "mm":
      return scalar.value * mmFactor;
    case "cm":
      return scalar.value * cmFactor;
    case "px":
      return Math.round(scalar.value * (outputDpi / inputDpi));
    default:
      return scalar.value;
  }
}, "transformUnit");
var transformUnits = /* @__PURE__ */ __name(({ width, height: height2 }, dpi) => ({
  width: transformUnit2(width, dpi),
  height: transformUnit2(height2, dpi)
}), "transformUnits");
var toSizeObject = /* @__PURE__ */ __name((v3) => ({
  width: v3[0],
  height: v3[1]
}), "toSizeObject");
var flipSizeObject = /* @__PURE__ */ __name((v3) => ({
  width: v3.height,
  height: v3.width
}), "flipSizeObject");
var getStringSize = /* @__PURE__ */ __name((v3) => {
  return toSizeObject(PAGE_SIZES[v3.toUpperCase()]);
}, "getStringSize");
var getNumberSize = /* @__PURE__ */ __name((n5) => toSizeObject([n5, n5]), "getNumberSize");
var getSize = /* @__PURE__ */ __name((page) => {
  const value2 = page.props?.size || "A4";
  const dpi = page.props?.dpi || 72;
  let size;
  if (typeof value2 === "string") {
    size = getStringSize(value2);
  } else if (Array.isArray(value2)) {
    size = transformUnits(toSizeObject(value2), dpi);
  } else if (typeof value2 === "number") {
    size = transformUnits(getNumberSize(value2), dpi);
  } else {
    size = transformUnits(value2, dpi);
  }
  return isLandscape(page) ? flipSizeObject(size) : size;
}, "getSize");
var resolvePageSize = /* @__PURE__ */ __name((page) => {
  const size = getSize(page);
  const style = flatten(page.style || {});
  return { ...page, style: { ...style, ...size } };
}, "resolvePageSize");
var resolvePageSizes = /* @__PURE__ */ __name((root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolvePageSize);
  return Object.assign({}, root, { children });
}, "resolvePageSizes");
var isFixed = /* @__PURE__ */ __name((node) => {
  if (!node.props)
    return false;
  return "fixed" in node.props ? node.props.fixed === true : false;
}, "isFixed");
var lineIndexAtHeight = /* @__PURE__ */ __name((node, height2) => {
  let y3 = 0;
  if (!node.lines)
    return 0;
  for (let i2 = 0; i2 < node.lines.length; i2 += 1) {
    const line2 = node.lines[i2];
    if (y3 + line2.box.height > height2)
      return i2;
    y3 += line2.box.height;
  }
  return node.lines.length;
}, "lineIndexAtHeight");
var heightAtLineIndex = /* @__PURE__ */ __name((node, index2) => {
  let counter = 0;
  if (!node.lines)
    return counter;
  for (let i2 = 0; i2 < index2; i2 += 1) {
    const line2 = node.lines[i2];
    if (!line2)
      break;
    counter += line2.box.height;
  }
  return counter;
}, "heightAtLineIndex");
var getLineBreak = /* @__PURE__ */ __name((node, height2) => {
  const top = node.box?.top || 0;
  const widows = node.props.widows || 2;
  const orphans = node.props.orphans || 2;
  const linesQuantity = node.lines.length;
  const slicedLine = lineIndexAtHeight(node, height2 - top);
  if (slicedLine === 0) {
    return 0;
  }
  if (linesQuantity < orphans) {
    return linesQuantity;
  }
  if (slicedLine < orphans || linesQuantity < orphans + widows) {
    return 0;
  }
  if (linesQuantity === orphans + widows) {
    return orphans;
  }
  if (linesQuantity - slicedLine < widows) {
    return linesQuantity - widows;
  }
  return slicedLine;
}, "getLineBreak");
var splitText = /* @__PURE__ */ __name((node, height2) => {
  const slicedLineIndex = getLineBreak(node, height2);
  const currentHeight = heightAtLineIndex(node, slicedLineIndex);
  const nextHeight = node.box.height - currentHeight;
  const current = Object.assign({}, node, {
    box: {
      ...node.box,
      height: currentHeight,
      borderBottomWidth: 0
    },
    style: {
      ...node.style,
      marginBottom: 0,
      paddingBottom: 0,
      borderBottomWidth: 0,
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    },
    lines: node.lines.slice(0, slicedLineIndex)
  });
  const next = Object.assign({}, node, {
    box: {
      ...node.box,
      top: 0,
      height: nextHeight,
      borderTopWidth: 0
    },
    style: {
      ...node.style,
      marginTop: 0,
      paddingTop: 0,
      borderTopWidth: 0,
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    },
    lines: node.lines.slice(slicedLineIndex)
  });
  return [current, next];
}, "splitText");
var getTop$1 = /* @__PURE__ */ __name((node) => node.box?.top || 0, "getTop$1");
var hasFixedHeight = /* @__PURE__ */ __name((node) => !isNil(node.style?.height), "hasFixedHeight");
var splitNode = /* @__PURE__ */ __name((node, height2) => {
  if (!node)
    return [null, null];
  const nodeTop = getTop$1(node);
  const current = Object.assign({}, node, {
    box: {
      ...node.box,
      borderBottomWidth: 0
    },
    style: {
      ...node.style,
      marginBottom: 0,
      paddingBottom: 0,
      borderBottomWidth: 0,
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    }
  });
  current.style.height = height2 - nodeTop;
  const nextHeight = hasFixedHeight(node) ? node.box.height - (height2 - nodeTop) : null;
  const next = Object.assign({}, node, {
    box: {
      ...node.box,
      top: 0,
      borderTopWidth: 0
    },
    style: {
      ...node.style,
      marginTop: 0,
      paddingTop: 0,
      borderTopWidth: 0,
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    },
    props: {
      ...node.props,
      bookmark: null
    }
  });
  if (nextHeight) {
    next.style.height = nextHeight;
  }
  return [current, next];
}, "splitNode");
var NON_WRAP_TYPES = [Svg, Note, Image, Canvas];
var getWrap = /* @__PURE__ */ __name((node) => {
  if (NON_WRAP_TYPES.includes(node.type))
    return false;
  if (!node.props)
    return true;
  return "wrap" in node.props ? node.props.wrap : true;
}, "getWrap");
var getComputedPadding = /* @__PURE__ */ __name((node, edge) => {
  const { yogaNode } = node;
  return yogaNode ? yogaNode.getComputedPadding(edge) : null;
}, "getComputedPadding");
var getPadding = /* @__PURE__ */ __name((node) => {
  const { style, box } = node;
  const paddingTop = getComputedPadding(node, Edge.Top) || box?.paddingTop || style?.paddingTop || 0;
  const paddingRight = getComputedPadding(node, Edge.Right) || box?.paddingRight || style?.paddingRight || 0;
  const paddingBottom = getComputedPadding(node, Edge.Bottom) || box?.paddingBottom || style?.paddingBottom || 0;
  const paddingLeft = getComputedPadding(node, Edge.Left) || box?.paddingLeft || style?.paddingLeft || 0;
  return { paddingTop, paddingRight, paddingBottom, paddingLeft };
}, "getPadding");
var getWrapArea = /* @__PURE__ */ __name((page) => {
  const height2 = page.style?.height;
  const { paddingBottom } = getPadding(page);
  return height2 - paddingBottom;
}, "getWrapArea");
var getContentArea = /* @__PURE__ */ __name((page) => {
  const height2 = page.style?.height;
  const { paddingTop, paddingBottom } = getPadding(page);
  return height2 - paddingBottom - paddingTop;
}, "getContentArea");
var isString4 = /* @__PURE__ */ __name((value2) => typeof value2 === "string", "isString");
var isNumber4 = /* @__PURE__ */ __name((value2) => typeof value2 === "number", "isNumber");
var isBoolean3 = /* @__PURE__ */ __name((value2) => typeof value2 === "boolean", "isBoolean");
var isFragment = /* @__PURE__ */ __name((value2) => value2 && value2.type === Symbol.for("react.fragment"), "isFragment");
var createInstances = /* @__PURE__ */ __name((element) => {
  if (!element)
    return [];
  if (Array.isArray(element)) {
    return element.reduce((acc, el) => acc.concat(createInstances(el)), []);
  }
  if (isBoolean3(element)) {
    return [];
  }
  if (isString4(element) || isNumber4(element)) {
    return [{ type: TextInstance, value: `${element}` }];
  }
  if (isFragment(element)) {
    return createInstances(element.props.children);
  }
  if (!isString4(element.type)) {
    return createInstances(element.type(element.props));
  }
  const { type: type2, props: { style = {}, children, ...props } } = element;
  const nextChildren = castArray(children).reduce((acc, child) => acc.concat(createInstances(child)), []);
  return [
    {
      type: type2,
      style,
      props,
      children: nextChildren
    }
  ];
}, "createInstances");
var getBreak = /* @__PURE__ */ __name((node) => "break" in node.props ? node.props.break : false, "getBreak");
var getMinPresenceAhead = /* @__PURE__ */ __name((node) => "minPresenceAhead" in node.props ? node.props.minPresenceAhead : 0, "getMinPresenceAhead");
var getFurthestEnd = /* @__PURE__ */ __name((elements) => Math.max(...elements.map((node) => node.box.top + node.box.height)), "getFurthestEnd");
var getEndOfMinPresenceAhead = /* @__PURE__ */ __name((child) => {
  return child.box.top + child.box.height + child.box.marginBottom + getMinPresenceAhead(child);
}, "getEndOfMinPresenceAhead");
var getEndOfPresence = /* @__PURE__ */ __name((child, futureElements) => {
  const afterMinPresenceAhead = getEndOfMinPresenceAhead(child);
  const endOfFurthestFutureElement = getFurthestEnd(futureElements.filter((node) => !("fixed" in node.props)));
  return Math.min(afterMinPresenceAhead, endOfFurthestFutureElement);
}, "getEndOfPresence");
var shouldBreak = /* @__PURE__ */ __name((child, futureElements, height2, previousElements) => {
  if ("fixed" in child.props)
    return false;
  const shouldSplit = height2 < child.box.top + child.box.height;
  const canWrap = getWrap(child);
  const endOfPresence = getEndOfPresence(child, futureElements);
  const breakingImprovesPresence = previousElements.filter((node) => !isFixed(node)).length > 0;
  return getBreak(child) || shouldSplit && !canWrap || !shouldSplit && endOfPresence > height2 && breakingImprovesPresence;
}, "shouldBreak");
var IGNORABLE_CODEPOINTS = [
  8232,
  // LINE_SEPARATOR
  8233
  // PARAGRAPH_SEPARATOR
];
var buildSubsetForFont = /* @__PURE__ */ __name((font) => IGNORABLE_CODEPOINTS.reduce((acc, codePoint) => {
  if (font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {
    return acc;
  }
  return [...acc, String.fromCharCode(codePoint)];
}, []), "buildSubsetForFont");
var ignoreChars = /* @__PURE__ */ __name((fragments) => fragments.map((fragment) => {
  const charSubset = buildSubsetForFont(fragment.attributes.font[0]);
  const subsetRegex = new RegExp(charSubset.join("|"));
  return {
    string: fragment.string.replace(subsetRegex, ""),
    attributes: fragment.attributes
  };
}), "ignoreChars");
var PREPROCESSORS = [ignoreChars, embedEmojis];
var isImage$1 = /* @__PURE__ */ __name((node) => node.type === Image, "isImage$1");
var isTextInstance$2 = /* @__PURE__ */ __name((node) => node.type === TextInstance, "isTextInstance$2");
var getFragments = /* @__PURE__ */ __name((fontStore2, instance, parentLink = null, level = 0) => {
  if (!instance)
    return [{ string: "" }];
  let fragments = [];
  const { color = "black", direction = "ltr", fontFamily = "Helvetica", fontWeight, fontStyle, fontSize = 18, textAlign, lineHeight, textDecoration: textDecoration2, textDecorationColor, textDecorationStyle, textTransform, letterSpacing, textIndent, opacity, verticalAlign } = instance.style;
  const fontFamilies = typeof fontFamily === "string" ? [fontFamily] : [...fontFamily || []];
  fontFamilies.push("Helvetica");
  const font = fontFamilies.map((fontFamilyName) => {
    const opts2 = { fontFamily: fontFamilyName, fontWeight, fontStyle };
    const obj = fontStore2.getFont(opts2);
    return obj?.data;
  });
  const backgroundColor = level === 0 ? null : instance.style.backgroundColor;
  const attributes2 = {
    font,
    color,
    opacity,
    fontSize,
    lineHeight,
    direction,
    verticalAlign,
    backgroundColor,
    indent: textIndent,
    characterSpacing: letterSpacing,
    strikeStyle: textDecorationStyle,
    underlineStyle: textDecorationStyle,
    underline: textDecoration2 === "underline" || textDecoration2 === "underline line-through" || textDecoration2 === "line-through underline",
    strike: textDecoration2 === "line-through" || textDecoration2 === "underline line-through" || textDecoration2 === "line-through underline",
    strikeColor: textDecorationColor || color,
    underlineColor: textDecorationColor || color,
    // @ts-expect-error allow this props access
    link: parentLink || instance.props?.src || instance.props?.href,
    align: textAlign || (direction === "rtl" ? "right" : "left")
  };
  for (let i2 = 0; i2 < instance.children.length; i2 += 1) {
    const child = instance.children[i2];
    if (isImage$1(child)) {
      fragments.push({
        string: String.fromCharCode(65532),
        attributes: {
          ...attributes2,
          attachment: {
            width: child.style.width || fontSize,
            height: child.style.height || fontSize,
            image: child.image.data
          }
        }
      });
    } else if (isTextInstance$2(child)) {
      fragments.push({
        string: transformText(child.value, textTransform),
        attributes: attributes2
      });
    } else if (child) {
      fragments.push(...getFragments(fontStore2, child, attributes2.link, level + 1));
    }
  }
  for (let i2 = 0; i2 < PREPROCESSORS.length; i2 += 1) {
    const preprocessor = PREPROCESSORS[i2];
    fragments = preprocessor(fragments);
  }
  return fragments;
}, "getFragments");
var getAttributedString = /* @__PURE__ */ __name((fontStore2, instance) => {
  const fragments = getFragments(fontStore2, instance);
  return fromFragments(fragments);
}, "getAttributedString");
var engines = {
  bidi: bidiEngine,
  linebreaker,
  justification,
  textDecoration,
  scriptItemizer,
  wordHyphenation,
  fontSubstitution
};
var engine = layoutEngine(engines);
var getMaxLines = /* @__PURE__ */ __name((node) => node.style?.maxLines, "getMaxLines");
var getTextOverflow = /* @__PURE__ */ __name((node) => node.style?.textOverflow, "getTextOverflow");
var getContainer = /* @__PURE__ */ __name((width, height2, node) => {
  const maxLines = getMaxLines(node);
  const textOverflow = getTextOverflow(node);
  return {
    x: 0,
    y: 0,
    width,
    maxLines,
    height: height2 || Infinity,
    truncateMode: textOverflow
  };
}, "getContainer");
var getLayoutOptions = /* @__PURE__ */ __name((fontStore2, node) => ({
  hyphenationPenalty: node.props.hyphenationPenalty,
  shrinkWhitespaceFactor: { before: -0.5, after: -0.5 },
  hyphenationCallback: node.props.hyphenationCallback || fontStore2?.getHyphenationCallback() || null
}), "getLayoutOptions");
var layoutText = /* @__PURE__ */ __name((node, width, height2, fontStore2) => {
  const attributedString = getAttributedString(fontStore2, node);
  const container = getContainer(width, height2, node);
  const options = getLayoutOptions(fontStore2, node);
  const lines = engine(attributedString, container, options);
  return lines.reduce((acc, line2) => [...acc, ...line2], []);
}, "layoutText");
var isSvg$2 = /* @__PURE__ */ __name((node) => node.type === Svg, "isSvg$2");
var isText$4 = /* @__PURE__ */ __name((node) => node.type === Text, "isText$4");
var shouldIterate = /* @__PURE__ */ __name((node) => !isSvg$2(node) && !isText$4(node), "shouldIterate");
var shouldLayoutText = /* @__PURE__ */ __name((node) => isText$4(node) && !node.lines, "shouldLayoutText");
var resolveTextLayout = /* @__PURE__ */ __name((node, fontStore2) => {
  if (shouldLayoutText(node)) {
    const width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);
    const height2 = node.box.height - (node.box.paddingTop + node.box.paddingBottom);
    node.lines = layoutText(node, width, height2, fontStore2);
  }
  if (shouldIterate(node)) {
    if (!node.children)
      return node;
    const mapChild = /* @__PURE__ */ __name((child) => resolveTextLayout(child, fontStore2), "mapChild");
    const children = node.children.map(mapChild);
    return Object.assign({}, node, { children });
  }
  return node;
}, "resolveTextLayout");
var BASE_INHERITABLE_PROPERTIES = [
  "color",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "opacity",
  "textDecoration",
  "textTransform",
  "lineHeight",
  "textAlign",
  "visibility",
  "wordSpacing"
];
var TEXT_INHERITABLE_PROPERTIES = [
  ...BASE_INHERITABLE_PROPERTIES,
  "backgroundColor"
];
var isType$2 = /* @__PURE__ */ __name((type2) => (node) => node.type === type2, "isType$2");
var isSvg$1 = isType$2(Svg);
var isText$3 = isType$2(Text);
var mergeValues = /* @__PURE__ */ __name((styleName, value2, inheritedValue) => {
  switch (styleName) {
    case "textDecoration": {
      return [inheritedValue, value2].filter((v3) => v3 && v3 !== "none").join(" ");
    }
    default:
      return value2;
  }
}, "mergeValues");
var merge = /* @__PURE__ */ __name((inheritedStyles, style) => {
  const mergedStyles = { ...inheritedStyles };
  Object.entries(style).forEach(([styleName, value2]) => {
    mergedStyles[styleName] = mergeValues(styleName, value2, inheritedStyles[styleName]);
  });
  return mergedStyles;
}, "merge");
var mergeStyles2 = /* @__PURE__ */ __name((inheritedStyles) => (node) => {
  const style = merge(inheritedStyles, node.style || {});
  return Object.assign({}, node, { style });
}, "mergeStyles");
var resolveInheritance = /* @__PURE__ */ __name((node) => {
  if (isSvg$1(node))
    return node;
  if (!("children" in node))
    return node;
  const inheritableProperties = isText$3(node) ? TEXT_INHERITABLE_PROPERTIES : BASE_INHERITABLE_PROPERTIES;
  const inheritStyles = pick(inheritableProperties, node.style || {});
  const resolveChild = compose2(resolveInheritance, mergeStyles2(inheritStyles));
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
}, "resolveInheritance");
var getComputedMargin = /* @__PURE__ */ __name((node, edge) => {
  const { yogaNode } = node;
  return yogaNode ? yogaNode.getComputedMargin(edge) : null;
}, "getComputedMargin");
var getMargin = /* @__PURE__ */ __name((node) => {
  const { style, box } = node;
  const marginTop = getComputedMargin(node, Edge.Top) || box?.marginTop || style?.marginTop || 0;
  const marginRight = getComputedMargin(node, Edge.Right) || box?.marginRight || style?.marginRight || 0;
  const marginBottom = getComputedMargin(node, Edge.Bottom) || box?.marginBottom || style?.marginBottom || 0;
  const marginLeft = getComputedMargin(node, Edge.Left) || box?.marginLeft || style?.marginLeft || 0;
  return { marginTop, marginRight, marginBottom, marginLeft };
}, "getMargin");
var getPosition = /* @__PURE__ */ __name((node) => {
  const { yogaNode } = node;
  return {
    top: yogaNode?.getComputedTop() || 0,
    right: yogaNode?.getComputedRight() || 0,
    bottom: yogaNode?.getComputedBottom() || 0,
    left: yogaNode?.getComputedLeft() || 0
  };
}, "getPosition");
var DEFAULT_DIMENSION = {
  width: 0,
  height: 0
};
var getDimension = /* @__PURE__ */ __name((node) => {
  const { yogaNode } = node;
  if (!yogaNode)
    return DEFAULT_DIMENSION;
  return {
    width: yogaNode.getComputedWidth(),
    height: yogaNode.getComputedHeight()
  };
}, "getDimension");
var getComputedBorder = /* @__PURE__ */ __name((yogaNode, edge) => yogaNode ? yogaNode.getComputedBorder(edge) : 0, "getComputedBorder");
var getBorderWidth = /* @__PURE__ */ __name((node) => {
  const { yogaNode } = node;
  return {
    borderTopWidth: getComputedBorder(yogaNode, Edge.Top),
    borderRightWidth: getComputedBorder(yogaNode, Edge.Right),
    borderBottomWidth: getComputedBorder(yogaNode, Edge.Bottom),
    borderLeftWidth: getComputedBorder(yogaNode, Edge.Left)
  };
}, "getBorderWidth");
var setDisplay = /* @__PURE__ */ __name((value2) => (node) => {
  const { yogaNode } = node;
  if (yogaNode) {
    yogaNode.setDisplay(value2 === "none" ? Display.None : Display.Flex);
  }
  return node;
}, "setDisplay");
var OVERFLOW = {
  hidden: Overflow.Hidden,
  scroll: Overflow.Scroll
};
var setOverflow = /* @__PURE__ */ __name((value2) => (node) => {
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    const overflow = OVERFLOW[value2] || Overflow.Visible;
    yogaNode.setOverflow(overflow);
  }
  return node;
}, "setOverflow");
var FLEX_WRAP = {
  wrap: Wrap.Wrap,
  "wrap-reverse": Wrap.WrapReverse
};
var setFlexWrap = /* @__PURE__ */ __name((value2) => (node) => {
  const { yogaNode } = node;
  if (yogaNode) {
    const flexWrap = FLEX_WRAP[value2] || Wrap.NoWrap;
    yogaNode.setFlexWrap(flexWrap);
  }
  return node;
}, "setFlexWrap");
var setYogaValue = /* @__PURE__ */ __name((attr, edge) => (value2) => (node) => {
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    const hasEdge = !isNil(edge);
    const fixedMethod = `set${upperFirst(attr)}`;
    const autoMethod = `${fixedMethod}Auto`;
    const percentMethod = `${fixedMethod}Percent`;
    const percent = matchPercent(value2);
    if (percent && !yogaNode[percentMethod]) {
      throw new Error(`You can't pass percentage values to ${attr} property`);
    }
    if (percent) {
      if (hasEdge) {
        yogaNode[percentMethod]?.(edge, percent.value);
      } else {
        yogaNode[percentMethod]?.(percent.value);
      }
    } else if (value2 === "auto") {
      if (hasEdge) {
        yogaNode[autoMethod]?.(edge);
      } else {
        yogaNode[autoMethod]?.();
      }
    } else if (hasEdge) {
      yogaNode[fixedMethod]?.(edge, value2);
    } else {
      yogaNode[fixedMethod]?.(value2);
    }
  }
  return node;
}, "setYogaValue");
var setFlexGrow = /* @__PURE__ */ __name((value2) => (node) => {
  return setYogaValue("flexGrow")(value2 || 0)(node);
}, "setFlexGrow");
var setFlexBasis = setYogaValue("flexBasis");
var ALIGN = {
  "flex-start": Align.FlexStart,
  center: Align.Center,
  "flex-end": Align.FlexEnd,
  stretch: Align.Stretch,
  baseline: Align.Baseline,
  "space-between": Align.SpaceBetween,
  "space-around": Align.SpaceAround,
  "space-evenly": Align.SpaceEvenly
};
var setAlign = /* @__PURE__ */ __name((attr) => (value2) => (node) => {
  const { yogaNode } = node;
  const defaultValue = attr === "items" ? Align.Stretch : Align.Auto;
  if (yogaNode) {
    const align = ALIGN[value2] || defaultValue;
    yogaNode[`setAlign${upperFirst(attr)}`](align);
  }
  return node;
}, "setAlign");
var setAlignSelf = setAlign("self");
var setAlignItems = setAlign("items");
var setFlexShrink = /* @__PURE__ */ __name((value2) => (node) => {
  return setYogaValue("flexShrink")(value2 || 1)(node);
}, "setFlexShrink");
var setAspectRatio = /* @__PURE__ */ __name((value2) => (node) => {
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    yogaNode.setAspectRatio(value2);
  }
  return node;
}, "setAspectRatio");
var setAlignContent = setAlign("content");
var POSITION = {
  absolute: PositionType.Absolute,
  relative: PositionType.Relative,
  static: PositionType.Static
};
var setPositionType = /* @__PURE__ */ __name((value2) => (node) => {
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    yogaNode.setPositionType(POSITION[value2]);
  }
  return node;
}, "setPositionType");
var FLEX_DIRECTIONS = {
  row: FlexDirection.Row,
  "row-reverse": FlexDirection.RowReverse,
  "column-reverse": FlexDirection.ColumnReverse
};
var setFlexDirection = /* @__PURE__ */ __name((value2) => (node) => {
  const { yogaNode } = node;
  if (yogaNode) {
    const flexDirection = FLEX_DIRECTIONS[value2] || FlexDirection.Column;
    yogaNode.setFlexDirection(flexDirection);
  }
  return node;
}, "setFlexDirection");
var JUSTIFY_CONTENT = {
  center: Justify.Center,
  "flex-end": Justify.FlexEnd,
  "space-between": Justify.SpaceBetween,
  "space-around": Justify.SpaceAround,
  "space-evenly": Justify.SpaceEvenly
};
var setJustifyContent = /* @__PURE__ */ __name((value2) => (node) => {
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    const justifyContent = JUSTIFY_CONTENT[value2] || Justify.FlexStart;
    yogaNode.setJustifyContent(justifyContent);
  }
  return node;
}, "setJustifyContent");
var setMarginTop = setYogaValue("margin", Edge.Top);
var setMarginRight = setYogaValue("margin", Edge.Right);
var setMarginBottom = setYogaValue("margin", Edge.Bottom);
var setMarginLeft = setYogaValue("margin", Edge.Left);
var setPaddingTop = setYogaValue("padding", Edge.Top);
var setPaddingRight = setYogaValue("padding", Edge.Right);
var setPaddingBottom = setYogaValue("padding", Edge.Bottom);
var setPaddingLeft = setYogaValue("padding", Edge.Left);
var setBorderTop = setYogaValue("border", Edge.Top);
var setBorderRight = setYogaValue("border", Edge.Right);
var setBorderBottom = setYogaValue("border", Edge.Bottom);
var setBorderLeft = setYogaValue("border", Edge.Left);
var setPositionTop = setYogaValue("position", Edge.Top);
var setPositionRight = setYogaValue("position", Edge.Right);
var setPositionBottom = setYogaValue("position", Edge.Bottom);
var setPositionLeft = setYogaValue("position", Edge.Left);
var setWidth = setYogaValue("width");
var setMinWidth = setYogaValue("minWidth");
var setMaxWidth = setYogaValue("maxWidth");
var setHeight = setYogaValue("height");
var setMinHeight = setYogaValue("minHeight");
var setMaxHeight = setYogaValue("maxHeight");
var setRowGap = setYogaValue("gap", Gutter.Row);
var setColumnGap = setYogaValue("gap", Gutter.Column);
var getAspectRatio = /* @__PURE__ */ __name((viewbox) => {
  if (!viewbox)
    return null;
  if (typeof viewbox === "string")
    return null;
  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);
}, "getAspectRatio");
var measureCanvas$1 = /* @__PURE__ */ __name((page, node) => (width, widthMode, height2, heightMode) => {
  const aspectRatio = getAspectRatio(node.props.viewBox) || 1;
  if (widthMode === MeasureMode.Exactly || widthMode === MeasureMode.AtMost) {
    return { width, height: width / aspectRatio };
  }
  if (heightMode === MeasureMode.Exactly) {
    return { width: height2 * aspectRatio };
  }
  return {};
}, "measureCanvas$1");
var linesWidth = /* @__PURE__ */ __name((node) => {
  if (!node.lines)
    return 0;
  return Math.max(0, ...node.lines.map((line2) => line2.xAdvance));
}, "linesWidth");
var linesHeight = /* @__PURE__ */ __name((node) => {
  if (!node.lines)
    return -1;
  return node.lines.reduce((acc, line2) => acc + line2.box.height, 0);
}, "linesHeight");
var ALIGNMENT_FACTORS2 = { center: 0.5, right: 1 };
var measureText = /* @__PURE__ */ __name((page, node, fontStore2) => (width, widthMode, height2) => {
  if (widthMode === MeasureMode.Exactly) {
    if (!node.lines)
      node.lines = layoutText(node, width, height2, fontStore2);
    return { height: linesHeight(node), width };
  }
  if (widthMode === MeasureMode.AtMost) {
    const alignFactor = ALIGNMENT_FACTORS2[node.style?.textAlign] || 0;
    if (!node.lines) {
      node.lines = layoutText(node, width, height2, fontStore2);
      node.alignOffset = (width - linesWidth(node)) * alignFactor;
    }
    return {
      height: linesHeight(node),
      width: Math.min(width, linesWidth(node))
    };
  }
  return {};
}, "measureText");
var getRatio = /* @__PURE__ */ __name((node) => {
  return node.image?.data ? node.image.width / node.image.height : 1;
}, "getRatio");
var isHeightAuto = /* @__PURE__ */ __name((page) => isNil(page.box?.height), "isHeightAuto");
var SAFETY_HEIGHT$1 = 10;
var measureImage = /* @__PURE__ */ __name((page, node) => (width, widthMode, height2, heightMode) => {
  const imageRatio = getRatio(node);
  const imageMargin = getMargin(node);
  const pagePadding = getPadding(page);
  const pageArea = isHeightAuto(page) ? Infinity : (page.box?.height || 0) - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT$1;
  if (!node.image)
    return { width: 0, height: 0 };
  if (widthMode === MeasureMode.Exactly && heightMode === MeasureMode.Undefined) {
    const scaledHeight = width / imageRatio;
    return { height: Math.min(pageArea, scaledHeight) };
  }
  if (heightMode === MeasureMode.Exactly && (widthMode === MeasureMode.AtMost || widthMode === MeasureMode.Undefined)) {
    return { width: Math.min(height2 * imageRatio, width) };
  }
  if (widthMode === MeasureMode.Exactly && heightMode === MeasureMode.AtMost) {
    const scaledHeight = width / imageRatio;
    return { height: Math.min(height2, pageArea, scaledHeight) };
  }
  if (widthMode === MeasureMode.AtMost && heightMode === MeasureMode.AtMost) {
    if (imageRatio > 1) {
      return {
        width,
        height: Math.min(width / imageRatio, height2)
      };
    }
    return {
      height: height2,
      width: Math.min(height2 * imageRatio, width)
    };
  }
  return { height: height2, width };
}, "measureImage");
var SAFETY_HEIGHT = 10;
var getMax = /* @__PURE__ */ __name((values) => Math.max(-Infinity, ...values), "getMax");
var measureCtx = /* @__PURE__ */ __name(() => {
  const ctx = {};
  const points = [];
  const nil = /* @__PURE__ */ __name(() => ctx, "nil");
  const addPoint = /* @__PURE__ */ __name((x, y3) => points.push([x, y3]), "addPoint");
  const moveTo = /* @__PURE__ */ __name((x, y3) => {
    addPoint(x, y3);
    return ctx;
  }, "moveTo");
  const rect = /* @__PURE__ */ __name((x, y3, w, h) => {
    addPoint(x, y3);
    addPoint(x + w, y3);
    addPoint(x, y3 + h);
    addPoint(x + w, y3 + h);
    return ctx;
  }, "rect");
  const ellipse = /* @__PURE__ */ __name((x, y3, rx, ry) => {
    ry = ry || rx;
    addPoint(x - rx, y3 - ry);
    addPoint(x + rx, y3 - ry);
    addPoint(x + rx, y3 + ry);
    addPoint(x - rx, y3 + ry);
    return ctx;
  }, "ellipse");
  const polygon = /* @__PURE__ */ __name((...pts) => {
    points.push(...pts);
    return ctx;
  }, "polygon");
  ctx.rect = rect;
  ctx.moveTo = moveTo;
  ctx.lineTo = moveTo;
  ctx.circle = ellipse;
  ctx.polygon = polygon;
  ctx.ellipse = ellipse;
  ctx.roundedRect = rect;
  ctx.text = nil;
  ctx.path = nil;
  ctx.lineWidth = nil;
  ctx.bezierCurveTo = nil;
  ctx.quadraticCurveTo = nil;
  ctx.scale = nil;
  ctx.rotate = nil;
  ctx.translate = nil;
  ctx.dash = nil;
  ctx.clip = nil;
  ctx.save = nil;
  ctx.fill = nil;
  ctx.font = nil;
  ctx.stroke = nil;
  ctx.lineCap = nil;
  ctx.opacity = nil;
  ctx.restore = nil;
  ctx.lineJoin = nil;
  ctx.fontSize = nil;
  ctx.fillColor = nil;
  ctx.miterLimit = nil;
  ctx.strokeColor = nil;
  ctx.fillOpacity = nil;
  ctx.strokeOpacity = nil;
  ctx.linearGradient = nil;
  ctx.radialGradient = nil;
  ctx.getWidth = () => getMax(points.map((p3) => p3[0]));
  ctx.getHeight = () => getMax(points.map((p3) => p3[1]));
  return ctx;
}, "measureCtx");
var measureCanvas = /* @__PURE__ */ __name((page, node) => () => {
  const imageMargin = getMargin(node);
  const pagePadding = getPadding(page);
  const pageArea = isHeightAuto(page) ? Infinity : (page.box?.height || 0) - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT;
  const ctx = measureCtx();
  node.props.paint(ctx);
  const width = ctx.getWidth();
  const height2 = Math.min(pageArea, ctx.getHeight());
  return { width, height: height2 };
}, "measureCanvas");
var isType$1 = /* @__PURE__ */ __name((type2) => (node) => node.type === type2, "isType$1");
var isSvg = isType$1(Svg);
var isText$2 = isType$1(Text);
var isNote = isType$1(Note);
var isPage = isType$1(Page);
var isImage = isType$1(Image);
var isCanvas = isType$1(Canvas);
var isTextInstance$1 = isType$1(TextInstance);
var setNodeHeight = /* @__PURE__ */ __name((node) => {
  const value2 = isPage(node) ? node.box?.height : node.style?.height;
  return setHeight(value2);
}, "setNodeHeight");
var setYogaValues = /* @__PURE__ */ __name((node) => {
  compose2(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);
}, "setYogaValues");
var insertYogaNodes = /* @__PURE__ */ __name((parent) => (child) => {
  parent.insertChild(child.yogaNode, parent.getChildCount());
  return child;
}, "insertYogaNodes");
var setMeasureFunc = /* @__PURE__ */ __name((node, page, fontStore2) => {
  const { yogaNode } = node;
  if (isText$2(node)) {
    yogaNode.setMeasureFunc(measureText(page, node, fontStore2));
  }
  if (isImage(node)) {
    yogaNode.setMeasureFunc(measureImage(page, node));
  }
  if (isCanvas(node)) {
    yogaNode.setMeasureFunc(measureCanvas(page, node));
  }
  if (isSvg(node)) {
    yogaNode.setMeasureFunc(measureCanvas$1(page, node));
  }
  return node;
}, "setMeasureFunc");
var isLayoutElement = /* @__PURE__ */ __name((node) => !isText$2(node) && !isNote(node) && !isSvg(node), "isLayoutElement");
var createYogaNodes = /* @__PURE__ */ __name((page, fontStore2, yoga) => (node) => {
  const yogaNode = yoga.node.create();
  const result = Object.assign({}, node, { yogaNode });
  setYogaValues(result);
  if (isLayoutElement(node) && node.children) {
    const resolveChild = compose2(insertYogaNodes(yogaNode), createYogaNodes(page, fontStore2, yoga));
    result.children = node.children.map(resolveChild);
  }
  setMeasureFunc(result, page, fontStore2);
  return result;
}, "createYogaNodes");
var calculateLayout = /* @__PURE__ */ __name((page) => {
  page.yogaNode.calculateLayout();
  return page;
}, "calculateLayout");
var persistDimensions = /* @__PURE__ */ __name((node) => {
  if (isTextInstance$1(node))
    return node;
  const box = Object.assign(getPadding(node), getMargin(node), getBorderWidth(node), getPosition(node), getDimension(node));
  const newNode = Object.assign({}, node, { box });
  if (!node.children)
    return newNode;
  const children = node.children.map(persistDimensions);
  return Object.assign({}, newNode, { children });
}, "persistDimensions");
var destroyYogaNodes = /* @__PURE__ */ __name((node) => {
  const newNode = Object.assign({}, node);
  delete newNode.yogaNode;
  if (!node.children)
    return newNode;
  const children = node.children.map(destroyYogaNodes);
  return Object.assign({}, newNode, { children });
}, "destroyYogaNodes");
var freeYogaNodes = /* @__PURE__ */ __name((node) => {
  if (node.yogaNode)
    node.yogaNode.freeRecursive();
  return node;
}, "freeYogaNodes");
var resolvePageDimensions = /* @__PURE__ */ __name((page, fontStore2, yoga) => {
  if (isNil(page))
    return null;
  return compose2(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore2, yoga))(page);
}, "resolvePageDimensions");
var resolveDimensions = /* @__PURE__ */ __name((node, fontStore2) => {
  if (!node.children)
    return node;
  const resolveChild = /* @__PURE__ */ __name((child) => resolvePageDimensions(child, fontStore2, node.yoga), "resolveChild");
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
}, "resolveDimensions");
var isText$1 = /* @__PURE__ */ __name((node) => node.type === Text, "isText$1");
var SAFETY_THRESHOLD = 1e-3;
var assingChildren = /* @__PURE__ */ __name((children, node) => Object.assign({}, node, { children }), "assingChildren");
var getTop = /* @__PURE__ */ __name((node) => node.box?.top || 0, "getTop");
var allFixed = /* @__PURE__ */ __name((nodes) => nodes.every(isFixed), "allFixed");
var isDynamic = /* @__PURE__ */ __name((node) => node.props && "render" in node.props, "isDynamic");
var relayoutPage = compose2(resolveTextLayout, resolvePageDimensions, resolveInheritance, resolvePageStyles);
var warnUnavailableSpace = /* @__PURE__ */ __name((node) => {
  console.warn(`Node of type ${node.type} can't wrap between pages and it's bigger than available page height`);
}, "warnUnavailableSpace");
var splitNodes = /* @__PURE__ */ __name((height2, contentArea, nodes) => {
  const currentChildren = [];
  const nextChildren = [];
  for (let i2 = 0; i2 < nodes.length; i2 += 1) {
    const child = nodes[i2];
    const futureNodes = nodes.slice(i2 + 1);
    const futureFixedNodes = futureNodes.filter(isFixed);
    const nodeTop = getTop(child);
    const nodeHeight = child.box.height;
    const isOutside = height2 <= nodeTop;
    const shouldBreak$1 = shouldBreak(child, futureNodes, height2, currentChildren);
    const shouldSplit = height2 + SAFETY_THRESHOLD < nodeTop + nodeHeight;
    const canWrap = getWrap(child);
    const fitsInsidePage = nodeHeight <= contentArea;
    if (isFixed(child)) {
      nextChildren.push(child);
      currentChildren.push(child);
      continue;
    }
    if (isOutside) {
      const box = Object.assign({}, child.box, { top: child.box.top - height2 });
      const next = Object.assign({}, child, { box });
      nextChildren.push(next);
      continue;
    }
    if (!fitsInsidePage && !canWrap) {
      currentChildren.push(child);
      nextChildren.push(...futureNodes);
      warnUnavailableSpace(child);
      break;
    }
    if (shouldBreak$1) {
      const box = Object.assign({}, child.box, { top: child.box.top - height2 });
      const props = Object.assign({}, child.props, {
        wrap: true,
        break: false
      });
      const next = Object.assign({}, child, { box, props });
      currentChildren.push(...futureFixedNodes);
      nextChildren.push(next, ...futureNodes);
      break;
    }
    if (shouldSplit) {
      const [currentChild, nextChild] = split(child, height2, contentArea);
      if (child.children.length > 0 && currentChild.children.length === 0) {
        if (currentChildren.length === 0) {
          currentChildren.push(child, ...futureFixedNodes);
          nextChildren.push(...futureNodes);
        } else {
          const box = Object.assign({}, child.box, {
            top: child.box.top - height2
          });
          const next = Object.assign({}, child, { box });
          currentChildren.push(...futureFixedNodes);
          nextChildren.push(next, ...futureNodes);
        }
        break;
      }
      if (currentChild)
        currentChildren.push(currentChild);
      if (nextChild)
        nextChildren.push(nextChild);
      continue;
    }
    currentChildren.push(child);
  }
  return [currentChildren, nextChildren];
}, "splitNodes");
var splitChildren = /* @__PURE__ */ __name((height2, contentArea, node) => {
  const children = node.children || [];
  const availableHeight = height2 - getTop(node);
  return splitNodes(availableHeight, contentArea, children);
}, "splitChildren");
var splitView = /* @__PURE__ */ __name((node, height2, contentArea) => {
  const [currentNode, nextNode] = splitNode(node, height2);
  const [currentChilds, nextChildren] = splitChildren(height2, contentArea, node);
  return [
    assingChildren(currentChilds, currentNode),
    assingChildren(nextChildren, nextNode)
  ];
}, "splitView");
var split = /* @__PURE__ */ __name((node, height2, contentArea) => isText$1(node) ? splitText(node, height2) : splitView(node, height2, contentArea), "split");
var shouldResolveDynamicNodes = /* @__PURE__ */ __name((node) => {
  const children = node.children || [];
  return isDynamic(node) || children.some(shouldResolveDynamicNodes);
}, "shouldResolveDynamicNodes");
var resolveDynamicNodes = /* @__PURE__ */ __name((props, node) => {
  const isNodeDynamic = isDynamic(node);
  const resolveChildren2 = /* @__PURE__ */ __name((children2 = []) => {
    if (isNodeDynamic) {
      const res = node.props.render(props);
      return createInstances(res).filter(Boolean).map((n5) => resolveDynamicNodes(props, n5));
    }
    return children2.map((c2) => resolveDynamicNodes(props, c2));
  }, "resolveChildren");
  const resetHeight = isNodeDynamic && isText$1(node);
  const box = resetHeight ? { ...node.box, height: 0 } : node.box;
  const children = resolveChildren2(node.children);
  const lines = isNodeDynamic ? null : node.lines;
  return Object.assign({}, node, { box, lines, children });
}, "resolveDynamicNodes");
var resolveDynamicPage = /* @__PURE__ */ __name((props, page, fontStore2, yoga) => {
  if (shouldResolveDynamicNodes(page)) {
    const resolvedPage = resolveDynamicNodes(props, page);
    return relayoutPage(resolvedPage, fontStore2, yoga);
  }
  return page;
}, "resolveDynamicPage");
var splitPage = /* @__PURE__ */ __name((page, pageNumber, fontStore2, yoga) => {
  const wrapArea = getWrapArea(page);
  const contentArea = getContentArea(page);
  const dynamicPage = resolveDynamicPage({ pageNumber }, page, fontStore2, yoga);
  const height2 = page.style.height;
  const [currentChilds, nextChilds] = splitNodes(wrapArea, contentArea, dynamicPage.children);
  const relayout = /* @__PURE__ */ __name((node) => (
    // @ts-expect-error rework pagination
    relayoutPage(node, fontStore2, yoga)
  ), "relayout");
  const currentBox = { ...page.box, height: height2 };
  const currentPage = relayout(Object.assign({}, page, { box: currentBox, children: currentChilds }));
  if (nextChilds.length === 0 || allFixed(nextChilds))
    return [currentPage, null];
  const nextBox = omit("height", page.box);
  const nextProps = omit("bookmark", page.props);
  const nextPage = relayout(Object.assign({}, page, {
    props: nextProps,
    box: nextBox,
    children: nextChilds
  }));
  return [currentPage, nextPage];
}, "splitPage");
var resolvePageIndices = /* @__PURE__ */ __name((fontStore2, yoga, page, pageNumber, pages) => {
  const totalPages = pages.length;
  const props = {
    totalPages,
    pageNumber: pageNumber + 1,
    subPageNumber: page.subPageNumber + 1,
    subPageTotalPages: page.subPageTotalPages
  };
  return resolveDynamicPage(props, page, fontStore2, yoga);
}, "resolvePageIndices");
var assocSubPageData = /* @__PURE__ */ __name((subpages) => {
  return subpages.map((page, i2) => ({
    ...page,
    subPageNumber: i2,
    subPageTotalPages: subpages.length
  }));
}, "assocSubPageData");
var dissocSubPageData = /* @__PURE__ */ __name((page) => {
  return omit(["subPageNumber", "subPageTotalPages"], page);
}, "dissocSubPageData");
var paginate = /* @__PURE__ */ __name((page, pageNumber, fontStore2, yoga) => {
  if (!page)
    return [];
  if (page.props?.wrap === false)
    return [page];
  let splittedPage = splitPage(page, pageNumber, fontStore2, yoga);
  const pages = [splittedPage[0]];
  let nextPage = splittedPage[1];
  while (nextPage !== null) {
    splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore2, yoga);
    pages.push(splittedPage[0]);
    nextPage = splittedPage[1];
  }
  return pages;
}, "paginate");
var resolvePagination = /* @__PURE__ */ __name((root, fontStore2) => {
  let pages = [];
  let pageNumber = 1;
  for (let i2 = 0; i2 < root.children.length; i2 += 1) {
    const page = root.children[i2];
    let subpages = paginate(page, pageNumber, fontStore2, root.yoga);
    subpages = assocSubPageData(subpages);
    pageNumber += subpages.length;
    pages = pages.concat(subpages);
  }
  pages = pages.map((...args) => dissocSubPageData(resolvePageIndices(fontStore2, root.yoga, ...args)));
  return assingChildren(pages, root);
}, "resolvePagination");
var resolvePageHorizontalPadding = /* @__PURE__ */ __name((container) => (value2) => {
  const match2 = matchPercent(value2);
  const width = container.width;
  return match2 ? match2.percent * width : value2;
}, "resolvePageHorizontalPadding");
var resolvePageVerticalPadding = /* @__PURE__ */ __name((container) => (value2) => {
  const match2 = matchPercent(value2);
  const height2 = container.height;
  return match2 ? match2.percent * height2 : value2;
}, "resolvePageVerticalPadding");
var resolvePagePaddings = /* @__PURE__ */ __name((page) => {
  const container = page.style;
  const style = evolve({
    paddingTop: resolvePageVerticalPadding(container),
    paddingLeft: resolvePageHorizontalPadding(container),
    paddingRight: resolvePageHorizontalPadding(container),
    paddingBottom: resolvePageVerticalPadding(container)
  }, page.style);
  return Object.assign({}, page, { style });
}, "resolvePagePaddings");
var resolvePagesPaddings = /* @__PURE__ */ __name((root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolvePagePaddings);
  return Object.assign({}, root, { children });
}, "resolvePagesPaddings");
var resolveRadius = /* @__PURE__ */ __name((box) => (value2) => {
  if (!value2)
    return void 0;
  const match2 = matchPercent(value2);
  return match2 ? match2.percent * Math.min(box.width, box.height) : value2;
}, "resolveRadius");
var resolvePercentRadius = /* @__PURE__ */ __name((node) => {
  const style = evolve({
    borderTopLeftRadius: resolveRadius(node.box),
    borderTopRightRadius: resolveRadius(node.box),
    borderBottomRightRadius: resolveRadius(node.box),
    borderBottomLeftRadius: resolveRadius(node.box)
  }, node.style || {});
  const newNode = Object.assign({}, node, { style });
  if (!node.children)
    return newNode;
  const children = node.children.map(resolvePercentRadius);
  return Object.assign({}, newNode, { children });
}, "resolvePercentRadius");
var transformHeight = /* @__PURE__ */ __name((pageArea, height2) => {
  const match2 = matchPercent(height2);
  return match2 ? match2.percent * pageArea : height2;
}, "transformHeight");
var getPageArea = /* @__PURE__ */ __name((page) => {
  const pageHeight = page.style.height;
  const pagePaddingTop = page.style?.paddingTop || 0;
  const pagePaddingBottom = page.style?.paddingBottom || 0;
  return pageHeight - pagePaddingTop - pagePaddingBottom;
}, "getPageArea");
var resolveNodePercentHeight = /* @__PURE__ */ __name((page, node) => {
  if (isNil(page.style?.height))
    return node;
  if (isNil(node.style?.height))
    return node;
  const pageArea = getPageArea(page);
  const height2 = transformHeight(pageArea, node.style.height);
  const style = Object.assign({}, node.style, { height: height2 });
  return Object.assign({}, node, { style });
}, "resolveNodePercentHeight");
var resolvePagePercentHeight = /* @__PURE__ */ __name((page) => {
  if (!page.children)
    return page;
  const resolveChild = /* @__PURE__ */ __name((child) => resolveNodePercentHeight(page, child), "resolveChild");
  const children = page.children.map(resolveChild);
  return Object.assign({}, page, { children });
}, "resolvePagePercentHeight");
var resolvePercentHeight = /* @__PURE__ */ __name((root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolvePagePercentHeight);
  return Object.assign({}, root, { children });
}, "resolvePercentHeight");
var isType = /* @__PURE__ */ __name((type2) => (node) => node.type === type2, "isType");
var isLink = isType(Link);
var isText = isType(Text);
var isTextInstance = isType(TextInstance);
var hasRenderProp = /* @__PURE__ */ __name((node) => "render" in node.props, "hasRenderProp");
var isTextType = /* @__PURE__ */ __name((node) => isText(node) || isTextInstance(node), "isTextType");
var isTextLink = /* @__PURE__ */ __name((node) => {
  const children = node.children || [];
  if (children.every(isTextInstance))
    return true;
  if (children.every(isText))
    return false;
  return children.every(isTextType);
}, "isTextLink");
var wrapText = /* @__PURE__ */ __name((node) => {
  const textElement = {
    type: Text,
    props: {},
    style: {},
    box: {},
    children: node.children
  };
  return Object.assign({}, node, { children: [textElement] });
}, "wrapText");
var transformLink = /* @__PURE__ */ __name((node) => {
  if (!isLink(node))
    return node;
  if (hasRenderProp(node))
    return Object.assign({}, node, { type: Text });
  if (isTextLink(node))
    return wrapText(node);
  return node;
}, "transformLink");
var resolveLinkSubstitution = /* @__PURE__ */ __name((node) => {
  if (!node.children)
    return node;
  const resolveChild = compose2(transformLink, resolveLinkSubstitution);
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
}, "resolveLinkSubstitution");
var layout = asyncCompose(resolveZIndex, resolveOrigin, resolveAssets, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles2, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes, resolveYoga);

// ../../node_modules/.pnpm/@react-pdf+reconciler@2.0.0_react@19.2.0/node_modules/@react-pdf/reconciler/lib/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_react4 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@react-pdf+reconciler@2.0.0_react@19.2.0/node_modules/@react-pdf/reconciler/lib/reconciler-31.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_react = __toESM(require_react(), 1);
var n = __toESM(require_scheduler(), 1);
function t(e4) {
  return e4 && e4.__esModule && Object.prototype.hasOwnProperty.call(e4, "default") ? e4.default : e4;
}
__name(t, "t");
function r2(e4) {
  if (e4.__esModule) return e4;
  var n5 = e4.default;
  if ("function" == typeof n5) {
    var t4 = /* @__PURE__ */ __name(function e5() {
      return this instanceof e5 ? Reflect.construct(n5, arguments, this.constructor) : n5.apply(this, arguments);
    }, "e");
    t4.prototype = n5.prototype;
  } else t4 = {};
  return Object.defineProperty(t4, "__esModule", { value: true }), Object.keys(e4).forEach(function(n6) {
    var r5 = Object.getOwnPropertyDescriptor(e4, n6);
    Object.defineProperty(t4, n6, r5.get ? r5 : { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return e4[n6];
    }, "get") });
  }), t4;
}
__name(r2, "r");
var l;
var a = { exports: {} };
var o = { exports: {} };
var u = r2(n);
var s;
true ? a.exports = (l || (l = 1, (s = o).exports = function(n5) {
  function t4(e4, n6, t5, r6) {
    return new $r(e4, n6, t5, r6);
  }
  __name(t4, "t");
  function r5(e4) {
    var n6 = "https://react.dev/errors/" + e4;
    if (1 < arguments.length) {
      n6 += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var t5 = 2; t5 < arguments.length; t5++) n6 += "&args[]=" + encodeURIComponent(arguments[t5]);
    }
    return "Minified React error #" + e4 + "; visit " + n6 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  __name(r5, "r");
  function l4(e4) {
    return null === e4 || "object" != typeof e4 ? null : "function" == typeof (e4 = Cl && e4[Cl] || e4["@@iterator"]) ? e4 : null;
  }
  __name(l4, "l");
  function a4(e4) {
    if (null == e4) return null;
    if ("function" == typeof e4) return e4.$$typeof === El ? null : e4.displayName || e4.name || null;
    if ("string" == typeof e4) return e4;
    switch (e4) {
      case dl:
        return "Fragment";
      case fl:
        return "Portal";
      case ml:
        return "Profiler";
      case pl:
        return "StrictMode";
      case vl:
        return "Suspense";
      case Sl:
        return "SuspenseList";
    }
    if ("object" == typeof e4) switch (e4.$$typeof) {
      case yl:
        return (e4.displayName || "Context") + ".Provider";
      case gl:
        return (e4._context.displayName || "Context") + ".Consumer";
      case bl:
        var n6 = e4.render;
        return (e4 = e4.displayName) || (e4 = "" !== (e4 = n6.displayName || n6.name || "") ? "ForwardRef(" + e4 + ")" : "ForwardRef"), e4;
      case kl:
        return null !== (n6 = e4.displayName || null) ? n6 : a4(e4.type) || "Memo";
      case wl:
        n6 = e4._payload, e4 = e4._init;
        try {
          return a4(e4(n6));
        } catch (e5) {
        }
    }
    return null;
  }
  __name(a4, "a");
  function o4(e4) {
    if (void 0 === rl) try {
      throw Error();
    } catch (e5) {
      var n6 = e5.stack.trim().match(/\n( *(at )?)/);
      rl = n6 && n6[1] || "", ll = -1 < e5.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < e5.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
    return "\n" + rl + e4 + ll;
  }
  __name(o4, "o");
  function i2(e4, n6) {
    if (!e4 || _l) return "";
    _l = true;
    var t5 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var r6 = { DetermineComponentFrameRoot: /* @__PURE__ */ __name(function() {
        try {
          if (n6) {
            var t6 = /* @__PURE__ */ __name(function() {
              throw Error();
            }, "t");
            if (Object.defineProperty(t6.prototype, "props", { set: /* @__PURE__ */ __name(function() {
              throw Error();
            }, "set") }), "object" == typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(t6, []);
              } catch (e5) {
                var r7 = e5;
              }
              Reflect.construct(e4, [], t6);
            } else {
              try {
                t6.call();
              } catch (e5) {
                r7 = e5;
              }
              e4.call(t6.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (e5) {
              r7 = e5;
            }
            (t6 = e4()) && "function" == typeof t6.catch && t6.catch(function() {
            });
          }
        } catch (e5) {
          if (e5 && r7 && "string" == typeof e5.stack) return [e5.stack, r7.stack];
        }
        return [null, null];
      }, "DetermineComponentFrameRoot") };
      r6.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var l5 = Object.getOwnPropertyDescriptor(r6.DetermineComponentFrameRoot, "name");
      l5 && l5.configurable && Object.defineProperty(r6.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
      var a5 = r6.DetermineComponentFrameRoot(), u4 = a5[0], i3 = a5[1];
      if (u4 && i3) {
        var s5 = u4.split("\n"), c3 = i3.split("\n");
        for (l5 = r6 = 0; r6 < s5.length && !s5[r6].includes("DetermineComponentFrameRoot"); ) r6++;
        for (; l5 < c3.length && !c3[l5].includes("DetermineComponentFrameRoot"); ) l5++;
        if (r6 === s5.length || l5 === c3.length) for (r6 = s5.length - 1, l5 = c3.length - 1; 1 <= r6 && 0 <= l5 && s5[r6] !== c3[l5]; ) l5--;
        for (; 1 <= r6 && 0 <= l5; r6--, l5--) if (s5[r6] !== c3[l5]) {
          if (1 !== r6 || 1 !== l5) do {
            if (r6--, 0 > --l5 || s5[r6] !== c3[l5]) {
              var f5 = "\n" + s5[r6].replace(" at new ", " at ");
              return e4.displayName && f5.includes("<anonymous>") && (f5 = f5.replace("<anonymous>", e4.displayName)), f5;
            }
          } while (1 <= r6 && 0 <= l5);
          break;
        }
      }
    } finally {
      _l = false, Error.prepareStackTrace = t5;
    }
    return (t5 = e4 ? e4.displayName || e4.name : "") ? o4(t5) : "";
  }
  __name(i2, "i");
  function s4(e4) {
    switch (e4.tag) {
      case 26:
      case 27:
      case 5:
        return o4(e4.type);
      case 16:
        return o4("Lazy");
      case 13:
        return o4("Suspense");
      case 19:
        return o4("SuspenseList");
      case 0:
      case 15:
        return i2(e4.type, false);
      case 11:
        return i2(e4.type.render, false);
      case 1:
        return i2(e4.type, true);
      default:
        return "";
    }
  }
  __name(s4, "s");
  function c2(e4) {
    try {
      var n6 = "";
      do {
        n6 += s4(e4), e4 = e4.return;
      } while (e4);
      return n6;
    } catch (e5) {
      return "\nError generating stack: " + e5.message + "\n" + e5.stack;
    }
  }
  __name(c2, "c");
  function f4(e4) {
    return { current: e4 };
  }
  __name(f4, "f");
  function d3(e4) {
    0 > Na || (e4.current = Ta[Na], Ta[Na] = null, Na--);
  }
  __name(d3, "d");
  function p3(e4, n6) {
    Na++, Ta[Na] = e4.current, e4.current = n6;
  }
  __name(p3, "p");
  function m3(e4) {
    var n6 = 42 & e4;
    if (0 !== n6) return n6;
    switch (e4 & -e4) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return 4194176 & e4;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return 62914560 & e4;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return e4;
    }
  }
  __name(m3, "m");
  function h(e4, n6) {
    var t5 = e4.pendingLanes;
    if (0 === t5) return 0;
    var r6 = 0, l5 = e4.suspendedLanes;
    e4 = e4.pingedLanes;
    var a5 = 134217727 & t5;
    return 0 !== a5 ? 0 != (t5 = a5 & ~l5) ? r6 = m3(t5) : 0 != (e4 &= a5) && (r6 = m3(e4)) : 0 != (t5 &= ~l5) ? r6 = m3(t5) : 0 !== e4 && (r6 = m3(e4)), 0 === r6 ? 0 : 0 !== n6 && n6 !== r6 && 0 == (n6 & l5) && ((l5 = r6 & -r6) >= (e4 = n6 & -n6) || 32 === l5 && 0 != (4194176 & e4)) ? n6 : r6;
  }
  __name(h, "h");
  function g(e4, n6) {
    switch (e4) {
      case 1:
      case 2:
      case 4:
      case 8:
        return n6 + 250;
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return n6 + 5e3;
      default:
        return -1;
    }
  }
  __name(g, "g");
  function y3() {
    var e4 = Fa;
    return 0 == (4194176 & (Fa <<= 1)) && (Fa = 128), e4;
  }
  __name(y3, "y");
  function b3() {
    var e4 = Ma;
    return 0 == (62914560 & (Ma <<= 1)) && (Ma = 4194304), e4;
  }
  __name(b3, "b");
  function v3(e4) {
    for (var n6 = [], t5 = 0; 31 > t5; t5++) n6.push(e4);
    return n6;
  }
  __name(v3, "v");
  function S3(e4, n6) {
    e4.pendingLanes |= n6, 268435456 !== n6 && (e4.suspendedLanes = 0, e4.pingedLanes = 0, e4.warmLanes = 0);
  }
  __name(S3, "S");
  function k3(e4, n6, t5) {
    e4.pendingLanes |= n6, e4.suspendedLanes &= ~n6;
    var r6 = 31 - Ua(n6);
    e4.entangledLanes |= n6, e4.entanglements[r6] = 1073741824 | e4.entanglements[r6] | 4194218 & t5;
  }
  __name(k3, "k");
  function w(e4, n6) {
    var t5 = e4.entangledLanes |= n6;
    for (e4 = e4.entanglements; t5; ) {
      var r6 = 31 - Ua(t5), l5 = 1 << r6;
      l5 & n6 | e4[r6] & n6 && (e4[r6] |= n6), t5 &= ~l5;
    }
  }
  __name(w, "w");
  function x(e4) {
    return 2 < (e4 &= -e4) ? 8 < e4 ? 0 != (134217727 & e4) ? 32 : 268435456 : 8 : 2;
  }
  __name(x, "x");
  function z(e4) {
    "function" == typeof qa && Ya(e4);
  }
  __name(z, "z");
  function C(e4, n6) {
    if ("object" == typeof e4 && null !== e4) {
      var t5 = Ka.get(e4);
      return void 0 !== t5 ? t5 : (n6 = { value: e4, source: n6, stack: c2(n6) }, Ka.set(e4, n6), n6);
    }
    return { value: e4, source: n6, stack: c2(n6) };
  }
  __name(C, "C");
  function E(e4) {
    for (; e4 === eo; ) eo = Xa[--Za], Xa[Za] = null, Xa[--Za], Xa[Za] = null;
    for (; e4 === ro; ) ro = no[--to], no[to] = null, no[--to], no[to] = null, no[--to], no[to] = null;
  }
  __name(E, "E");
  function P(e4, n6) {
    p3(oo, n6), p3(ao, e4), p3(lo, null), e4 = Nl(n6), d3(lo), p3(lo, e4);
  }
  __name(P, "P");
  function _() {
    d3(lo), d3(ao), d3(oo);
  }
  __name(_, "_");
  function R(e4) {
    null !== e4.memoizedState && p3(uo, e4);
    var n6 = lo.current, t5 = Ll(n6, e4.type);
    n6 !== t5 && (p3(ao, e4), p3(lo, t5));
  }
  __name(R, "R");
  function T(e4) {
    ao.current === e4 && (d3(lo), d3(ao)), uo.current === e4 && (d3(uo), ra._currentValue2 = ta);
  }
  __name(T, "T");
  function N() {
    for (var e4 = fo, n6 = po = fo = 0; n6 < e4; ) {
      var t5 = co[n6];
      co[n6++] = null;
      var r6 = co[n6];
      co[n6++] = null;
      var l5 = co[n6];
      co[n6++] = null;
      var a5 = co[n6];
      if (co[n6++] = null, null !== r6 && null !== l5) {
        var o5 = r6.pending;
        null === o5 ? l5.next = l5 : (l5.next = o5.next, o5.next = l5), r6.pending = l5;
      }
      0 !== a5 && I(t5, l5, a5);
    }
  }
  __name(N, "N");
  function L(e4, n6, t5, r6) {
    co[fo++] = e4, co[fo++] = n6, co[fo++] = t5, co[fo++] = r6, po |= r6, e4.lanes |= r6, null !== (e4 = e4.alternate) && (e4.lanes |= r6);
  }
  __name(L, "L");
  function U(e4, n6, t5, r6) {
    return L(e4, n6, t5, r6), F(e4);
  }
  __name(U, "U");
  function D(e4, n6) {
    return L(e4, null, null, n6), F(e4);
  }
  __name(D, "D");
  function I(e4, n6, t5) {
    e4.lanes |= t5;
    var r6 = e4.alternate;
    null !== r6 && (r6.lanes |= t5);
    for (var l5 = false, a5 = e4.return; null !== a5; ) a5.childLanes |= t5, null !== (r6 = a5.alternate) && (r6.childLanes |= t5), 22 === a5.tag && (null === (e4 = a5.stateNode) || 1 & e4._visibility || (l5 = true)), e4 = a5, a5 = a5.return;
    l5 && null !== n6 && 3 === e4.tag && (a5 = e4.stateNode, l5 = 31 - Ua(t5), null === (e4 = (a5 = a5.hiddenUpdates)[l5]) ? a5[l5] = [n6] : e4.push(n6), n6.lane = 536870912 | t5);
  }
  __name(I, "I");
  function F(e4) {
    if (50 < ti) throw ti = 0, ri = null, Error(r5(185));
    for (var n6 = e4.return; null !== n6; ) n6 = (e4 = n6).return;
    return 3 === e4.tag ? e4.stateNode : null;
  }
  __name(F, "F");
  function M(e4) {
    e4 !== ho && null === e4.next && (null === ho ? mo = ho = e4 : ho = ho.next = e4), yo = true, go || (go = true, Wa(Oa, H));
  }
  __name(M, "M");
  function W(e4, n6) {
    if (!bo && yo) {
      bo = true;
      do {
        for (var t5 = false, r6 = mo; null !== r6; ) {
          if (0 !== e4) {
            var l5 = r6.pendingLanes;
            if (0 === l5) var a5 = 0;
            else {
              var o5 = r6.suspendedLanes, u4 = r6.pingedLanes;
              a5 = (1 << 31 - Ua(42 | e4) + 1) - 1, a5 = 201326677 & (a5 &= l5 & ~(o5 & ~u4)) ? 201326677 & a5 | 1 : a5 ? 2 | a5 : 0;
            }
            0 !== a5 && (t5 = true, Q(r6, a5));
          } else a5 = Lu, 0 != (3 & (a5 = h(r6, r6 === Tu ? a5 : 0))) && (t5 = true, Q(r6, a5));
          r6 = r6.next;
        }
      } while (t5);
      bo = false;
    }
  }
  __name(W, "W");
  function H() {
    yo = go = false;
    var e4 = 0;
    0 !== vo && (Gl() && (e4 = vo), vo = 0);
    for (var n6 = Qa(), t5 = null, r6 = mo; null !== r6; ) {
      var l5 = r6.next, a5 = j(r6, n6);
      0 === a5 ? (r6.next = null, null === t5 ? mo = l5 : t5.next = l5, null === l5 && (ho = t5)) : (t5 = r6, (0 !== e4 || 0 != (3 & a5)) && (yo = true)), r6 = l5;
    }
    W(e4);
  }
  __name(H, "H");
  function j(e4, n6) {
    for (var t5 = e4.suspendedLanes, r6 = e4.pingedLanes, l5 = e4.expirationTimes, a5 = -62914561 & e4.pendingLanes; 0 < a5; ) {
      var o5 = 31 - Ua(a5), u4 = 1 << o5, i3 = l5[o5];
      -1 === i3 ? 0 != (u4 & t5) && 0 == (u4 & r6) || (l5[o5] = g(u4, n6)) : i3 <= n6 && (e4.expiredLanes |= u4), a5 &= ~u4;
    }
    if (t5 = Lu, t5 = h(e4, e4 === (n6 = Tu) ? t5 : 0), r6 = e4.callbackNode, 0 === t5 || e4 === n6 && 2 === Uu || null !== e4.cancelPendingCommit) return null !== r6 && null !== r6 && Ha(r6), e4.callbackNode = null, e4.callbackPriority = 0;
    if (0 != (3 & t5)) return null !== r6 && null !== r6 && Ha(r6), e4.callbackPriority = 2, e4.callbackNode = null, 2;
    if ((n6 = t5 & -t5) === e4.callbackPriority) return n6;
    switch (null !== r6 && Ha(r6), x(t5)) {
      case 2:
        t5 = Oa;
        break;
      case 8:
        t5 = Ba;
        break;
      case 32:
      default:
        t5 = Va;
        break;
      case 268435456:
        t5 = $a;
    }
    return r6 = A.bind(null, e4), t5 = Wa(t5, r6), e4.callbackPriority = n6, e4.callbackNode = t5, n6;
  }
  __name(j, "j");
  function A(e4, n6) {
    var t5 = e4.callbackNode;
    if (Wr() && e4.callbackNode !== t5) return null;
    var r6 = Lu;
    return 0 === (r6 = h(e4, e4 === Tu ? r6 : 0)) ? null : (gr(e4, r6, n6), j(e4, Qa()), e4.callbackNode === t5 ? A.bind(null, e4) : null);
  }
  __name(A, "A");
  function Q(e4, n6) {
    if (Wr()) return null;
    gr(e4, n6, true);
  }
  __name(Q, "Q");
  function O() {
    return 0 === vo && (vo = y3()), vo;
  }
  __name(O, "O");
  function B() {
    if (0 == --ko && null !== So) {
      null !== xo && (xo.status = "fulfilled");
      var e4 = So;
      So = null, wo = 0, xo = null;
      for (var n6 = 0; n6 < e4.length; n6++) (0, e4[n6])();
    }
  }
  __name(B, "B");
  function V(e4) {
    e4.updateQueue = { baseState: e4.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null };
  }
  __name(V, "V");
  function $(e4, n6) {
    e4 = e4.updateQueue, n6.updateQueue === e4 && (n6.updateQueue = { baseState: e4.baseState, firstBaseUpdate: e4.firstBaseUpdate, lastBaseUpdate: e4.lastBaseUpdate, shared: e4.shared, callbacks: null });
  }
  __name($, "$");
  function q(e4) {
    return { lane: e4, tag: 0, payload: null, callback: null, next: null };
  }
  __name(q, "q");
  function Y(e4, n6, t5) {
    var r6 = e4.updateQueue;
    if (null === r6) return null;
    if (r6 = r6.shared, 0 != (2 & Ru)) {
      var l5 = r6.pending;
      return null === l5 ? n6.next = n6 : (n6.next = l5.next, l5.next = n6), r6.pending = n6, n6 = F(e4), I(e4, null, t5), n6;
    }
    return L(e4, r6, n6, t5), F(e4);
  }
  __name(Y, "Y");
  function G2(e4, n6, t5) {
    if (null !== (n6 = n6.updateQueue) && (n6 = n6.shared, 0 != (4194176 & t5))) {
      var r6 = n6.lanes;
      t5 |= r6 &= e4.pendingLanes, n6.lanes = t5, w(e4, t5);
    }
  }
  __name(G2, "G");
  function J(e4, n6) {
    var t5 = e4.updateQueue, r6 = e4.alternate;
    if (null !== r6 && t5 === (r6 = r6.updateQueue)) {
      var l5 = null, a5 = null;
      if (null !== (t5 = t5.firstBaseUpdate)) {
        do {
          var o5 = { lane: t5.lane, tag: t5.tag, payload: t5.payload, callback: null, next: null };
          null === a5 ? l5 = a5 = o5 : a5 = a5.next = o5, t5 = t5.next;
        } while (null !== t5);
        null === a5 ? l5 = a5 = n6 : a5 = a5.next = n6;
      } else l5 = a5 = n6;
      return t5 = { baseState: r6.baseState, firstBaseUpdate: l5, lastBaseUpdate: a5, shared: r6.shared, callbacks: r6.callbacks }, void (e4.updateQueue = t5);
    }
    null === (e4 = t5.lastBaseUpdate) ? t5.firstBaseUpdate = n6 : e4.next = n6, t5.lastBaseUpdate = n6;
  }
  __name(J, "J");
  function K() {
    if (Co && null !== xo) throw xo;
  }
  __name(K, "K");
  function X(e4, n6, t5, r6) {
    Co = false;
    var l5 = e4.updateQueue;
    zo = false;
    var a5 = l5.firstBaseUpdate, o5 = l5.lastBaseUpdate, u4 = l5.shared.pending;
    if (null !== u4) {
      l5.shared.pending = null;
      var i3 = u4, s5 = i3.next;
      i3.next = null, null === o5 ? a5 = s5 : o5.next = s5, o5 = i3;
      var c3 = e4.alternate;
      null !== c3 && (u4 = (c3 = c3.updateQueue).lastBaseUpdate) !== o5 && (null === u4 ? c3.firstBaseUpdate = s5 : u4.next = s5, c3.lastBaseUpdate = i3);
    }
    if (null !== a5) {
      var f5 = l5.baseState;
      for (o5 = 0, c3 = s5 = i3 = null, u4 = a5; ; ) {
        var d4 = -536870913 & u4.lane, p4 = d4 !== u4.lane;
        if (p4 ? (Lu & d4) === d4 : (r6 & d4) === d4) {
          0 !== d4 && d4 === wo && (Co = true), null !== c3 && (c3 = c3.next = { lane: 0, tag: u4.tag, payload: u4.payload, callback: null, next: null });
          e: {
            var m4 = e4, h2 = u4;
            d4 = n6;
            var g2 = t5;
            switch (h2.tag) {
              case 1:
                if ("function" == typeof (m4 = h2.payload)) {
                  f5 = m4.call(g2, f5, d4);
                  break e;
                }
                f5 = m4;
                break e;
              case 3:
                m4.flags = -65537 & m4.flags | 128;
              case 0:
                if (null == (d4 = "function" == typeof (m4 = h2.payload) ? m4.call(g2, f5, d4) : m4)) break e;
                f5 = il({}, f5, d4);
                break e;
              case 2:
                zo = true;
            }
          }
          null !== (d4 = u4.callback) && (e4.flags |= 64, p4 && (e4.flags |= 8192), null === (p4 = l5.callbacks) ? l5.callbacks = [d4] : p4.push(d4));
        } else p4 = { lane: d4, tag: u4.tag, payload: u4.payload, callback: u4.callback, next: null }, null === c3 ? (s5 = c3 = p4, i3 = f5) : c3 = c3.next = p4, o5 |= d4;
        if (null === (u4 = u4.next)) {
          if (null === (u4 = l5.shared.pending)) break;
          u4 = (p4 = u4).next, p4.next = null, l5.lastBaseUpdate = p4, l5.shared.pending = null;
        }
      }
      null === c3 && (i3 = f5), l5.baseState = i3, l5.firstBaseUpdate = s5, l5.lastBaseUpdate = c3, null === a5 && (l5.shared.lanes = 0), Hu |= o5, e4.lanes = o5, e4.memoizedState = f5;
    }
  }
  __name(X, "X");
  function Z(e4, n6) {
    if ("function" != typeof e4) throw Error(r5(191, e4));
    e4.call(n6);
  }
  __name(Z, "Z");
  function ee(e4, n6) {
    var t5 = e4.callbacks;
    if (null !== t5) for (e4.callbacks = null, e4 = 0; e4 < t5.length; e4++) Z(t5[e4], n6);
  }
  __name(ee, "ee");
  function ne(e4, n6) {
    if (Ja(e4, n6)) return true;
    if ("object" != typeof e4 || null === e4 || "object" != typeof n6 || null === n6) return false;
    var t5 = Object.keys(e4), r6 = Object.keys(n6);
    if (t5.length !== r6.length) return false;
    for (r6 = 0; r6 < t5.length; r6++) {
      var l5 = t5[r6];
      if (!Eo.call(n6, l5) || !Ja(e4[l5], n6[l5])) return false;
    }
    return true;
  }
  __name(ne, "ne");
  function te(e4) {
    return "fulfilled" === (e4 = e4.status) || "rejected" === e4;
  }
  __name(te, "te");
  function re() {
  }
  __name(re, "re");
  function le(e4, n6, t5) {
    switch (void 0 === (t5 = e4[t5]) ? e4.push(n6) : t5 !== n6 && (n6.then(re, re), n6 = t5), n6.status) {
      case "fulfilled":
        return n6.value;
      case "rejected":
        if ((e4 = n6.reason) === Po) throw Error(r5(483));
        throw e4;
      default:
        if ("string" == typeof n6.status) n6.then(re, re);
        else {
          if (null !== (e4 = Tu) && 100 < e4.shellSuspendCounter) throw Error(r5(482));
          (e4 = n6).status = "pending", e4.then(function(e5) {
            if ("pending" === n6.status) {
              var t6 = n6;
              t6.status = "fulfilled", t6.value = e5;
            }
          }, function(e5) {
            if ("pending" === n6.status) {
              var t6 = n6;
              t6.status = "rejected", t6.reason = e5;
            }
          });
        }
        switch (n6.status) {
          case "fulfilled":
            return n6.value;
          case "rejected":
            if ((e4 = n6.reason) === Po) throw Error(r5(483));
            throw e4;
        }
        throw To = n6, Po;
    }
  }
  __name(le, "le");
  function ae() {
    if (null === To) throw Error(r5(459));
    var e4 = To;
    return To = null, e4;
  }
  __name(ae, "ae");
  function oe(e4) {
    var n6 = Lo;
    return Lo += 1, null === No && (No = []), le(No, e4, n6);
  }
  __name(oe, "oe");
  function ue(e4, n6, t5, r6) {
    e4 = r6.props.ref, t5.ref = void 0 !== e4 ? e4 : null;
  }
  __name(ue, "ue");
  function ie(e4, n6) {
    if (n6.$$typeof === sl) throw Error(r5(525));
    throw e4 = Object.prototype.toString.call(n6), Error(r5(31, "[object Object]" === e4 ? "object with keys {" + Object.keys(n6).join(", ") + "}" : e4));
  }
  __name(ie, "ie");
  function se(e4) {
    return (0, e4._init)(e4._payload);
  }
  __name(se, "se");
  function ce(e4) {
    function n6(n7, t5) {
      if (e4) {
        var r6 = n7.deletions;
        null === r6 ? (n7.deletions = [t5], n7.flags |= 16) : r6.push(t5);
      }
    }
    __name(n6, "n");
    function a5(t5, r6) {
      if (!e4) return null;
      for (; null !== r6; ) n6(t5, r6), r6 = r6.sibling;
      return null;
    }
    __name(a5, "a");
    function o5(e5) {
      for (var n7 = /* @__PURE__ */ new Map(); null !== e5; ) null !== e5.key ? n7.set(e5.key, e5) : n7.set(e5.index, e5), e5 = e5.sibling;
      return n7;
    }
    __name(o5, "o");
    function u4(e5, n7) {
      return (e5 = Yr(e5, n7)).index = 0, e5.sibling = null, e5;
    }
    __name(u4, "u");
    function i3(n7, t5, r6) {
      return n7.index = r6, e4 ? null !== (r6 = n7.alternate) ? (r6 = r6.index) < t5 ? (n7.flags |= 33554434, t5) : r6 : (n7.flags |= 33554434, t5) : (n7.flags |= 1048576, t5);
    }
    __name(i3, "i");
    function s5(n7) {
      return e4 && null === n7.alternate && (n7.flags |= 33554434), n7;
    }
    __name(s5, "s");
    function c3(e5, n7, t5, r6) {
      return null === n7 || 6 !== n7.tag ? ((n7 = Zr(t5, e5.mode, r6)).return = e5, n7) : ((n7 = u4(n7, t5)).return = e5, n7);
    }
    __name(c3, "c");
    function f5(e5, n7, t5, r6) {
      var l5 = t5.type;
      return l5 === dl ? p4(e5, n7, t5.props.children, r6, t5.key) : null !== n7 && (n7.elementType === l5 || "object" == typeof l5 && null !== l5 && l5.$$typeof === wl && se(l5) === n7.type) ? (ue(e5, 0, r6 = u4(n7, t5.props), t5), r6.return = e5, r6) : (ue(e5, 0, r6 = Jr(t5.type, t5.key, t5.props, null, e5.mode, r6), t5), r6.return = e5, r6);
    }
    __name(f5, "f");
    function d4(e5, n7, t5, r6) {
      return null === n7 || 4 !== n7.tag || n7.stateNode.containerInfo !== t5.containerInfo || n7.stateNode.implementation !== t5.implementation ? ((n7 = el(t5, e5.mode, r6)).return = e5, n7) : ((n7 = u4(n7, t5.children || [])).return = e5, n7);
    }
    __name(d4, "d");
    function p4(e5, n7, t5, r6, l5) {
      return null === n7 || 7 !== n7.tag ? ((n7 = Kr(t5, e5.mode, r6, l5)).return = e5, n7) : ((n7 = u4(n7, t5)).return = e5, n7);
    }
    __name(p4, "p");
    function m4(e5, n7, t5) {
      if ("string" == typeof n7 && "" !== n7 || "number" == typeof n7 || "bigint" == typeof n7) return (n7 = Zr("" + n7, e5.mode, t5)).return = e5, n7;
      if ("object" == typeof n7 && null !== n7) {
        switch (n7.$$typeof) {
          case cl:
            return ue(e5, 0, t5 = Jr(n7.type, n7.key, n7.props, null, e5.mode, t5), n7), t5.return = e5, t5;
          case fl:
            return (n7 = el(n7, e5.mode, t5)).return = e5, n7;
          case wl:
            return m4(e5, n7 = (0, n7._init)(n7._payload), t5);
        }
        if (Rl(n7) || l4(n7)) return (n7 = Kr(n7, e5.mode, t5, null)).return = e5, n7;
        if ("function" == typeof n7.then) return m4(e5, oe(n7), t5);
        if (n7.$$typeof === yl) return m4(e5, yt(e5, n7), t5);
        ie(e5, n7);
      }
      return null;
    }
    __name(m4, "m");
    function h2(e5, n7, t5, r6) {
      var a6 = null !== n7 ? n7.key : null;
      if ("string" == typeof t5 && "" !== t5 || "number" == typeof t5 || "bigint" == typeof t5) return null !== a6 ? null : c3(e5, n7, "" + t5, r6);
      if ("object" == typeof t5 && null !== t5) {
        switch (t5.$$typeof) {
          case cl:
            return t5.key === a6 ? f5(e5, n7, t5, r6) : null;
          case fl:
            return t5.key === a6 ? d4(e5, n7, t5, r6) : null;
          case wl:
            return h2(e5, n7, t5 = (a6 = t5._init)(t5._payload), r6);
        }
        if (Rl(t5) || l4(t5)) return null !== a6 ? null : p4(e5, n7, t5, r6, null);
        if ("function" == typeof t5.then) return h2(e5, n7, oe(t5), r6);
        if (t5.$$typeof === yl) return h2(e5, n7, yt(e5, t5), r6);
        ie(e5, t5);
      }
      return null;
    }
    __name(h2, "h");
    function g2(e5, n7, t5, r6, a6) {
      if ("string" == typeof r6 && "" !== r6 || "number" == typeof r6 || "bigint" == typeof r6) return c3(n7, e5 = e5.get(t5) || null, "" + r6, a6);
      if ("object" == typeof r6 && null !== r6) {
        switch (r6.$$typeof) {
          case cl:
            return f5(n7, e5 = e5.get(null === r6.key ? t5 : r6.key) || null, r6, a6);
          case fl:
            return d4(n7, e5 = e5.get(null === r6.key ? t5 : r6.key) || null, r6, a6);
          case wl:
            return g2(e5, n7, t5, r6 = (0, r6._init)(r6._payload), a6);
        }
        if (Rl(r6) || l4(r6)) return p4(n7, e5 = e5.get(t5) || null, r6, a6, null);
        if ("function" == typeof r6.then) return g2(e5, n7, t5, oe(r6), a6);
        if (r6.$$typeof === yl) return g2(e5, n7, t5, yt(n7, r6), a6);
        ie(n7, r6);
      }
      return null;
    }
    __name(g2, "g");
    function y4(t5, c4, f6, d5) {
      if ("object" == typeof f6 && null !== f6 && f6.type === dl && null === f6.key && (f6 = f6.props.children), "object" == typeof f6 && null !== f6) {
        switch (f6.$$typeof) {
          case cl:
            e: {
              for (var p5 = f6.key, b4 = c4; null !== b4; ) {
                if (b4.key === p5) {
                  if ((p5 = f6.type) === dl) {
                    if (7 === b4.tag) {
                      a5(t5, b4.sibling), (c4 = u4(b4, f6.props.children)).return = t5, t5 = c4;
                      break e;
                    }
                  } else if (b4.elementType === p5 || "object" == typeof p5 && null !== p5 && p5.$$typeof === wl && se(p5) === b4.type) {
                    a5(t5, b4.sibling), ue(t5, 0, c4 = u4(b4, f6.props), f6), c4.return = t5, t5 = c4;
                    break e;
                  }
                  a5(t5, b4);
                  break;
                }
                n6(t5, b4), b4 = b4.sibling;
              }
              f6.type === dl ? ((c4 = Kr(f6.props.children, t5.mode, d5, f6.key)).return = t5, t5 = c4) : (ue(t5, 0, d5 = Jr(f6.type, f6.key, f6.props, null, t5.mode, d5), f6), d5.return = t5, t5 = d5);
            }
            return s5(t5);
          case fl:
            e: {
              for (b4 = f6.key; null !== c4; ) {
                if (c4.key === b4) {
                  if (4 === c4.tag && c4.stateNode.containerInfo === f6.containerInfo && c4.stateNode.implementation === f6.implementation) {
                    a5(t5, c4.sibling), (c4 = u4(c4, f6.children || [])).return = t5, t5 = c4;
                    break e;
                  }
                  a5(t5, c4);
                  break;
                }
                n6(t5, c4), c4 = c4.sibling;
              }
              (c4 = el(f6, t5.mode, d5)).return = t5, t5 = c4;
            }
            return s5(t5);
          case wl:
            return y4(t5, c4, f6 = (b4 = f6._init)(f6._payload), d5);
        }
        if (Rl(f6)) return function(t6, r6, l5, u5) {
          for (var s6 = null, c5 = null, f7 = r6, d6 = r6 = 0, p6 = null; null !== f7 && d6 < l5.length; d6++) {
            f7.index > d6 ? (p6 = f7, f7 = null) : p6 = f7.sibling;
            var y5 = h2(t6, f7, l5[d6], u5);
            if (null === y5) {
              null === f7 && (f7 = p6);
              break;
            }
            e4 && f7 && null === y5.alternate && n6(t6, f7), r6 = i3(y5, r6, d6), null === c5 ? s6 = y5 : c5.sibling = y5, c5 = y5, f7 = p6;
          }
          if (d6 === l5.length) return a5(t6, f7), s6;
          if (null === f7) {
            for (; d6 < l5.length; d6++) null !== (f7 = m4(t6, l5[d6], u5)) && (r6 = i3(f7, r6, d6), null === c5 ? s6 = f7 : c5.sibling = f7, c5 = f7);
            return s6;
          }
          for (f7 = o5(f7); d6 < l5.length; d6++) null !== (p6 = g2(f7, t6, d6, l5[d6], u5)) && (e4 && null !== p6.alternate && f7.delete(null === p6.key ? d6 : p6.key), r6 = i3(p6, r6, d6), null === c5 ? s6 = p6 : c5.sibling = p6, c5 = p6);
          return e4 && f7.forEach(function(e5) {
            return n6(t6, e5);
          }), s6;
        }(t5, c4, f6, d5);
        if (l4(f6)) {
          if ("function" != typeof (b4 = l4(f6))) throw Error(r5(150));
          return function(t6, l5, u5, s6) {
            if (null == u5) throw Error(r5(151));
            for (var c5 = null, f7 = null, d6 = l5, p6 = l5 = 0, y5 = null, b5 = u5.next(); null !== d6 && !b5.done; p6++, b5 = u5.next()) {
              d6.index > p6 ? (y5 = d6, d6 = null) : y5 = d6.sibling;
              var v4 = h2(t6, d6, b5.value, s6);
              if (null === v4) {
                null === d6 && (d6 = y5);
                break;
              }
              e4 && d6 && null === v4.alternate && n6(t6, d6), l5 = i3(v4, l5, p6), null === f7 ? c5 = v4 : f7.sibling = v4, f7 = v4, d6 = y5;
            }
            if (b5.done) return a5(t6, d6), c5;
            if (null === d6) {
              for (; !b5.done; p6++, b5 = u5.next()) null !== (b5 = m4(t6, b5.value, s6)) && (l5 = i3(b5, l5, p6), null === f7 ? c5 = b5 : f7.sibling = b5, f7 = b5);
              return c5;
            }
            for (d6 = o5(d6); !b5.done; p6++, b5 = u5.next()) null !== (b5 = g2(d6, t6, p6, b5.value, s6)) && (e4 && null !== b5.alternate && d6.delete(null === b5.key ? p6 : b5.key), l5 = i3(b5, l5, p6), null === f7 ? c5 = b5 : f7.sibling = b5, f7 = b5);
            return e4 && d6.forEach(function(e5) {
              return n6(t6, e5);
            }), c5;
          }(t5, c4, f6 = b4.call(f6), d5);
        }
        if ("function" == typeof f6.then) return y4(t5, c4, oe(f6), d5);
        if (f6.$$typeof === yl) return y4(t5, c4, yt(t5, f6), d5);
        ie(t5, f6);
      }
      return "string" == typeof f6 && "" !== f6 || "number" == typeof f6 || "bigint" == typeof f6 ? (f6 = "" + f6, null !== c4 && 6 === c4.tag ? (a5(t5, c4.sibling), (c4 = u4(c4, f6)).return = t5, t5 = c4) : (a5(t5, c4), (c4 = Zr(f6, t5.mode, d5)).return = t5, t5 = c4), s5(t5)) : a5(t5, c4);
    }
    __name(y4, "y");
    return function(e5, n7, r6, l5) {
      try {
        Lo = 0;
        var a6 = y4(e5, n7, r6, l5);
        return No = null, a6;
      } catch (n8) {
        if (n8 === Po) throw n8;
        var o6 = t4(29, n8, null, e5.mode);
        return o6.lanes = l5, o6.return = e5, o6;
      }
    };
  }
  __name(ce, "ce");
  function fe(e4, n6) {
    p3(Fo, e4 = Mu), p3(Io, n6), Mu = e4 | n6.baseLanes;
  }
  __name(fe, "fe");
  function de() {
    p3(Fo, Mu), p3(Io, Io.current);
  }
  __name(de, "de");
  function pe() {
    Mu = Fo.current, d3(Io), d3(Fo);
  }
  __name(pe, "pe");
  function me(e4) {
    var n6 = e4.alternate;
    p3(Ho, 1 & Ho.current), p3(Mo, e4), null === Wo && (null === n6 || null !== Io.current || null !== n6.memoizedState) && (Wo = e4);
  }
  __name(me, "me");
  function he(e4) {
    if (22 === e4.tag) {
      if (p3(Ho, Ho.current), p3(Mo, e4), null === Wo) {
        var n6 = e4.alternate;
        null !== n6 && null !== n6.memoizedState && (Wo = e4);
      }
    } else ge();
  }
  __name(he, "he");
  function ge() {
    p3(Ho, Ho.current), p3(Mo, Mo.current);
  }
  __name(ge, "ge");
  function ye(e4) {
    d3(Mo), Wo === e4 && (Wo = null), d3(Ho);
  }
  __name(ye, "ye");
  function be(e4) {
    for (var n6 = e4; null !== n6; ) {
      if (13 === n6.tag) {
        var t5 = n6.memoizedState;
        if (null !== t5 && (null === (t5 = t5.dehydrated) || Sa(t5) || ka(t5))) return n6;
      } else if (19 === n6.tag && void 0 !== n6.memoizedProps.revealOrder) {
        if (0 != (128 & n6.flags)) return n6;
      } else if (null !== n6.child) {
        n6.child.return = n6, n6 = n6.child;
        continue;
      }
      if (n6 === e4) break;
      for (; null === n6.sibling; ) {
        if (null === n6.return || n6.return === e4) return null;
        n6 = n6.return;
      }
      n6.sibling.return = n6.return, n6 = n6.sibling;
    }
    return null;
  }
  __name(be, "be");
  function ve() {
    throw Error(r5(321));
  }
  __name(ve, "ve");
  function Se(e4, n6) {
    if (null === n6) return false;
    for (var t5 = 0; t5 < n6.length && t5 < e4.length; t5++) if (!Ja(e4[t5], n6[t5])) return false;
    return true;
  }
  __name(Se, "Se");
  function ke(e4, n6, t5, r6, l5, a5) {
    return jo = a5, Ao = n6, n6.memoizedState = null, n6.updateQueue = null, n6.lanes = 0, Pl.H = null === e4 || null === e4.memoizedState ? Zo : eu, $o = false, a5 = t5(r6, l5), $o = false, Vo && (a5 = xe(n6, t5, r6, l5)), we(e4), a5;
  }
  __name(ke, "ke");
  function we(e4) {
    Pl.H = Xo;
    var n6 = null !== Qo && null !== Qo.next;
    if (jo = 0, Oo = Qo = Ao = null, Bo = false, Yo = 0, Go = null, n6) throw Error(r5(300));
    null === e4 || lu || null !== (e4 = e4.dependencies) && mt(e4) && (lu = true);
  }
  __name(we, "we");
  function xe(e4, n6, t5, l5) {
    Ao = e4;
    var a5 = 0;
    do {
      if (Vo && (Go = null), Yo = 0, Vo = false, 25 <= a5) throw Error(r5(301));
      if (a5 += 1, Oo = Qo = null, null != e4.updateQueue) {
        var o5 = e4.updateQueue;
        o5.lastEffect = null, o5.events = null, o5.stores = null, null != o5.memoCache && (o5.memoCache.index = 0);
      }
      Pl.H = nu, o5 = n6(t5, l5);
    } while (Vo);
    return o5;
  }
  __name(xe, "xe");
  function ze() {
    var e4 = Pl.H, n6 = e4.useState()[0];
    return n6 = "function" == typeof n6.then ? Te(n6) : n6, e4 = e4.useState()[0], (null !== Qo ? Qo.memoizedState : null) !== e4 && (Ao.flags |= 1024), n6;
  }
  __name(ze, "ze");
  function Ce() {
    var e4 = 0 !== qo;
    return qo = 0, e4;
  }
  __name(Ce, "Ce");
  function Ee(e4, n6, t5) {
    n6.updateQueue = e4.updateQueue, n6.flags &= -2053, e4.lanes &= ~t5;
  }
  __name(Ee, "Ee");
  function Pe(e4) {
    if (Bo) {
      for (e4 = e4.memoizedState; null !== e4; ) {
        var n6 = e4.queue;
        null !== n6 && (n6.pending = null), e4 = e4.next;
      }
      Bo = false;
    }
    jo = 0, Oo = Qo = Ao = null, Vo = false, Yo = qo = 0, Go = null;
  }
  __name(Pe, "Pe");
  function _e() {
    var e4 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return null === Oo ? Ao.memoizedState = Oo = e4 : Oo = Oo.next = e4, Oo;
  }
  __name(_e, "_e");
  function Re() {
    if (null === Qo) {
      var e4 = Ao.alternate;
      e4 = null !== e4 ? e4.memoizedState : null;
    } else e4 = Qo.next;
    var n6 = null === Oo ? Ao.memoizedState : Oo.next;
    if (null !== n6) Oo = n6, Qo = e4;
    else {
      if (null === e4) {
        if (null === Ao.alternate) throw Error(r5(467));
        throw Error(r5(310));
      }
      e4 = { memoizedState: (Qo = e4).memoizedState, baseState: Qo.baseState, baseQueue: Qo.baseQueue, queue: Qo.queue, next: null }, null === Oo ? Ao.memoizedState = Oo = e4 : Oo = Oo.next = e4;
    }
    return Oo;
  }
  __name(Re, "Re");
  function Te(e4) {
    var n6 = Yo;
    return Yo += 1, null === Go && (Go = []), e4 = le(Go, e4, n6), n6 = Ao, null === (null === Oo ? n6.memoizedState : Oo.next) && (n6 = n6.alternate, Pl.H = null === n6 || null === n6.memoizedState ? Zo : eu), e4;
  }
  __name(Te, "Te");
  function Ne(e4) {
    if (null !== e4 && "object" == typeof e4) {
      if ("function" == typeof e4.then) return Te(e4);
      if (e4.$$typeof === yl) return gt(e4);
    }
    throw Error(r5(438, String(e4)));
  }
  __name(Ne, "Ne");
  function Le(e4) {
    var n6 = null, t5 = Ao.updateQueue;
    if (null !== t5 && (n6 = t5.memoCache), null == n6) {
      var r6 = Ao.alternate;
      null !== r6 && null !== (r6 = r6.updateQueue) && null != (r6 = r6.memoCache) && (n6 = { data: r6.data.map(function(e5) {
        return e5.slice();
      }), index: 0 });
    }
    if (null == n6 && (n6 = { data: [], index: 0 }), null === t5 && (t5 = Ko(), Ao.updateQueue = t5), t5.memoCache = n6, void 0 === (t5 = n6.data[n6.index])) for (t5 = n6.data[n6.index] = Array(e4), r6 = 0; r6 < e4; r6++) t5[r6] = zl;
    return n6.index++, t5;
  }
  __name(Le, "Le");
  function Ue(e4, n6) {
    return "function" == typeof n6 ? n6(e4) : n6;
  }
  __name(Ue, "Ue");
  function De(e4) {
    return Ie(Re(), Qo, e4);
  }
  __name(De, "De");
  function Ie(e4, n6, t5) {
    var l5 = e4.queue;
    if (null === l5) throw Error(r5(311));
    l5.lastRenderedReducer = t5;
    var a5 = e4.baseQueue, o5 = l5.pending;
    if (null !== o5) {
      if (null !== a5) {
        var u4 = a5.next;
        a5.next = o5.next, o5.next = u4;
      }
      n6.baseQueue = a5 = o5, l5.pending = null;
    }
    if (o5 = e4.baseState, null === a5) e4.memoizedState = o5;
    else {
      var i3 = u4 = null, s5 = null, c3 = n6 = a5.next, f5 = false;
      do {
        var d4 = -536870913 & c3.lane;
        if (d4 !== c3.lane ? (Lu & d4) === d4 : (jo & d4) === d4) {
          var p4 = c3.revertLane;
          if (0 === p4) null !== s5 && (s5 = s5.next = { lane: 0, revertLane: 0, action: c3.action, hasEagerState: c3.hasEagerState, eagerState: c3.eagerState, next: null }), d4 === wo && (f5 = true);
          else {
            if ((jo & p4) === p4) {
              c3 = c3.next, p4 === wo && (f5 = true);
              continue;
            }
            d4 = { lane: 0, revertLane: c3.revertLane, action: c3.action, hasEagerState: c3.hasEagerState, eagerState: c3.eagerState, next: null }, null === s5 ? (i3 = s5 = d4, u4 = o5) : s5 = s5.next = d4, Ao.lanes |= p4, Hu |= p4;
          }
          d4 = c3.action, $o && t5(o5, d4), o5 = c3.hasEagerState ? c3.eagerState : t5(o5, d4);
        } else p4 = { lane: d4, revertLane: c3.revertLane, action: c3.action, hasEagerState: c3.hasEagerState, eagerState: c3.eagerState, next: null }, null === s5 ? (i3 = s5 = p4, u4 = o5) : s5 = s5.next = p4, Ao.lanes |= d4, Hu |= d4;
        c3 = c3.next;
      } while (null !== c3 && c3 !== n6);
      if (null === s5 ? u4 = o5 : s5.next = i3, !Ja(o5, e4.memoizedState) && (lu = true, f5 && null !== (t5 = xo))) throw t5;
      e4.memoizedState = o5, e4.baseState = u4, e4.baseQueue = s5, l5.lastRenderedState = o5;
    }
    return null === a5 && (l5.lanes = 0), [e4.memoizedState, l5.dispatch];
  }
  __name(Ie, "Ie");
  function Fe(e4) {
    var n6 = Re(), t5 = n6.queue;
    if (null === t5) throw Error(r5(311));
    t5.lastRenderedReducer = e4;
    var l5 = t5.dispatch, a5 = t5.pending, o5 = n6.memoizedState;
    if (null !== a5) {
      t5.pending = null;
      var u4 = a5 = a5.next;
      do {
        o5 = e4(o5, u4.action), u4 = u4.next;
      } while (u4 !== a5);
      Ja(o5, n6.memoizedState) || (lu = true), n6.memoizedState = o5, null === n6.baseQueue && (n6.baseState = o5), t5.lastRenderedState = o5;
    }
    return [o5, l5];
  }
  __name(Fe, "Fe");
  function Me(e4, n6, t5) {
    var l5 = Ao, a5 = Re();
    t5 = n6();
    var o5 = !Ja((Qo || a5).memoizedState, t5);
    if (o5 && (a5.memoizedState = t5, lu = true), a5 = a5.queue, sn(je.bind(null, l5, a5, e4), [e4]), a5.getSnapshot !== n6 || o5 || null !== Oo && 1 & Oo.memoizedState.tag) {
      if (l5.flags |= 2048, rn(9, He.bind(null, l5, a5, t5, n6), { destroy: void 0 }, null), null === Tu) throw Error(r5(349));
      0 != (60 & jo) || We(l5, n6, t5);
    }
    return t5;
  }
  __name(Me, "Me");
  function We(e4, n6, t5) {
    e4.flags |= 16384, e4 = { getSnapshot: n6, value: t5 }, null === (n6 = Ao.updateQueue) ? (n6 = Ko(), Ao.updateQueue = n6, n6.stores = [e4]) : null === (t5 = n6.stores) ? n6.stores = [e4] : t5.push(e4);
  }
  __name(We, "We");
  function He(e4, n6, t5, r6) {
    n6.value = t5, n6.getSnapshot = r6, Ae(n6) && Qe(e4);
  }
  __name(He, "He");
  function je(e4, n6, t5) {
    return t5(function() {
      Ae(n6) && Qe(e4);
    });
  }
  __name(je, "je");
  function Ae(e4) {
    var n6 = e4.getSnapshot;
    e4 = e4.value;
    try {
      var t5 = n6();
      return !Ja(e4, t5);
    } catch (e5) {
      return true;
    }
  }
  __name(Ae, "Ae");
  function Qe(e4) {
    var n6 = D(e4, 2);
    null !== n6 && hr(n6, 0, 2);
  }
  __name(Qe, "Qe");
  function Oe(e4) {
    var n6 = _e();
    if ("function" == typeof e4) {
      var t5 = e4;
      if (e4 = t5(), $o) {
        z(true);
        try {
          t5();
        } finally {
          z(false);
        }
      }
    }
    return n6.memoizedState = n6.baseState = e4, n6.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Ue, lastRenderedState: e4 }, n6;
  }
  __name(Oe, "Oe");
  function Be(e4, n6, t5, r6) {
    return e4.baseState = t5, Ie(e4, Qo, "function" == typeof r6 ? r6 : Ue);
  }
  __name(Be, "Be");
  function Ve(e4, n6, t5, l5, a5) {
    if (_n(e4)) throw Error(r5(485));
    if (null !== (e4 = n6.action)) {
      var o5 = { payload: a5, action: e4, next: null, isTransition: true, status: "pending", value: null, reason: null, listeners: [], then: /* @__PURE__ */ __name(function(e5) {
        o5.listeners.push(e5);
      }, "then") };
      null !== Pl.T ? t5(true) : o5.isTransition = false, l5(o5), null === (t5 = n6.pending) ? (o5.next = n6.pending = o5, $e(n6, o5)) : (o5.next = t5.next, n6.pending = t5.next = o5);
    }
  }
  __name(Ve, "Ve");
  function $e(e4, n6) {
    var t5 = n6.action, r6 = n6.payload, l5 = e4.state;
    if (n6.isTransition) {
      var a5 = Pl.T, o5 = {};
      Pl.T = o5;
      try {
        var u4 = t5(l5, r6), i3 = Pl.S;
        null !== i3 && i3(o5, u4), qe(e4, n6, u4);
      } catch (t6) {
        Ge(e4, n6, t6);
      } finally {
        Pl.T = a5;
      }
    } else try {
      qe(e4, n6, a5 = t5(l5, r6));
    } catch (t6) {
      Ge(e4, n6, t6);
    }
  }
  __name($e, "$e");
  function qe(e4, n6, t5) {
    null !== t5 && "object" == typeof t5 && "function" == typeof t5.then ? t5.then(function(t6) {
      Ye(e4, n6, t6);
    }, function(t6) {
      return Ge(e4, n6, t6);
    }) : Ye(e4, n6, t5);
  }
  __name(qe, "qe");
  function Ye(e4, n6, t5) {
    n6.status = "fulfilled", n6.value = t5, Je(n6), e4.state = t5, null !== (n6 = e4.pending) && ((t5 = n6.next) === n6 ? e4.pending = null : (t5 = t5.next, n6.next = t5, $e(e4, t5)));
  }
  __name(Ye, "Ye");
  function Ge(e4, n6, t5) {
    var r6 = e4.pending;
    if (e4.pending = null, null !== r6) {
      r6 = r6.next;
      do {
        n6.status = "rejected", n6.reason = t5, Je(n6), n6 = n6.next;
      } while (n6 !== r6);
    }
    e4.action = null;
  }
  __name(Ge, "Ge");
  function Je(e4) {
    e4 = e4.listeners;
    for (var n6 = 0; n6 < e4.length; n6++) (0, e4[n6])();
  }
  __name(Je, "Je");
  function Ke(e4, n6) {
    return n6;
  }
  __name(Ke, "Ke");
  function Xe(e4, n6) {
    var t5, r6, l5;
    (t5 = _e()).memoizedState = t5.baseState = n6, r6 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Ke, lastRenderedState: n6 }, t5.queue = r6, t5 = Cn.bind(null, Ao, r6), r6.dispatch = t5, r6 = Oe(false);
    var a5 = Pn.bind(null, Ao, false, r6.queue);
    return l5 = { state: n6, dispatch: null, action: e4, pending: null }, (r6 = _e()).queue = l5, t5 = Ve.bind(null, Ao, l5, a5, t5), l5.dispatch = t5, r6.memoizedState = e4, [n6, t5, false];
  }
  __name(Xe, "Xe");
  function Ze(e4) {
    return en(Re(), Qo, e4);
  }
  __name(Ze, "Ze");
  function en(e4, n6, t5) {
    n6 = Ie(e4, n6, Ke)[0], e4 = De(Ue)[0], n6 = "object" == typeof n6 && null !== n6 && "function" == typeof n6.then ? Te(n6) : n6;
    var r6 = Re(), l5 = r6.queue, a5 = l5.dispatch;
    return t5 !== r6.memoizedState && (Ao.flags |= 2048, rn(9, nn.bind(null, l5, t5), { destroy: void 0 }, null)), [n6, a5, e4];
  }
  __name(en, "en");
  function nn(e4, n6) {
    e4.action = n6;
  }
  __name(nn, "nn");
  function tn(e4) {
    var n6 = Re(), t5 = Qo;
    if (null !== t5) return en(n6, t5, e4);
    Re(), n6 = n6.memoizedState;
    var r6 = (t5 = Re()).queue.dispatch;
    return t5.memoizedState = e4, [n6, r6, false];
  }
  __name(tn, "tn");
  function rn(e4, n6, t5, r6) {
    return e4 = { tag: e4, create: n6, inst: t5, deps: r6, next: null }, null === (n6 = Ao.updateQueue) && (n6 = Ko(), Ao.updateQueue = n6), null === (t5 = n6.lastEffect) ? n6.lastEffect = e4.next = e4 : (r6 = t5.next, t5.next = e4, e4.next = r6, n6.lastEffect = e4), e4;
  }
  __name(rn, "rn");
  function ln() {
    return Re().memoizedState;
  }
  __name(ln, "ln");
  function an(e4, n6, t5, r6) {
    var l5 = _e();
    Ao.flags |= e4, l5.memoizedState = rn(1 | n6, t5, { destroy: void 0 }, void 0 === r6 ? null : r6);
  }
  __name(an, "an");
  function on4(e4, n6, t5, r6) {
    var l5 = Re();
    r6 = void 0 === r6 ? null : r6;
    var a5 = l5.memoizedState.inst;
    null !== Qo && null !== r6 && Se(r6, Qo.memoizedState.deps) ? l5.memoizedState = rn(n6, t5, a5, r6) : (Ao.flags |= e4, l5.memoizedState = rn(1 | n6, t5, a5, r6));
  }
  __name(on4, "on");
  function un(e4, n6) {
    an(8390656, 8, e4, n6);
  }
  __name(un, "un");
  function sn(e4, n6) {
    on4(2048, 8, e4, n6);
  }
  __name(sn, "sn");
  function cn(e4, n6) {
    return on4(4, 2, e4, n6);
  }
  __name(cn, "cn");
  function fn(e4, n6) {
    return on4(4, 4, e4, n6);
  }
  __name(fn, "fn");
  function dn(e4, n6) {
    if ("function" == typeof n6) {
      e4 = e4();
      var t5 = n6(e4);
      return function() {
        "function" == typeof t5 ? t5() : n6(null);
      };
    }
    if (null != n6) return e4 = e4(), n6.current = e4, function() {
      n6.current = null;
    };
  }
  __name(dn, "dn");
  function pn(e4, n6, t5) {
    t5 = null != t5 ? t5.concat([e4]) : null, on4(4, 4, dn.bind(null, n6, e4), t5);
  }
  __name(pn, "pn");
  function mn() {
  }
  __name(mn, "mn");
  function hn(e4, n6) {
    var t5 = Re();
    n6 = void 0 === n6 ? null : n6;
    var r6 = t5.memoizedState;
    return null !== n6 && Se(n6, r6[1]) ? r6[0] : (t5.memoizedState = [e4, n6], e4);
  }
  __name(hn, "hn");
  function gn(e4, n6) {
    var t5 = Re();
    n6 = void 0 === n6 ? null : n6;
    var r6 = t5.memoizedState;
    if (null !== n6 && Se(n6, r6[1])) return r6[0];
    if (r6 = e4(), $o) {
      z(true);
      try {
        e4();
      } finally {
        z(false);
      }
    }
    return t5.memoizedState = [r6, n6], r6;
  }
  __name(gn, "gn");
  function yn(e4, n6, t5) {
    return void 0 === t5 || 0 != (1073741824 & jo) ? e4.memoizedState = n6 : (e4.memoizedState = t5, e4 = mr(), Ao.lanes |= e4, Hu |= e4, t5);
  }
  __name(yn, "yn");
  function bn(e4, n6, t5, r6) {
    return Ja(t5, n6) ? t5 : null !== Io.current ? (e4 = yn(e4, t5, r6), Ja(e4, n6) || (lu = true), e4) : 0 == (42 & jo) ? (lu = true, e4.memoizedState = t5) : (e4 = mr(), Ao.lanes |= e4, Hu |= e4, n6);
  }
  __name(bn, "bn");
  function vn(e4, n6, t5, r6, l5) {
    var a5 = ql();
    $l(0 !== a5 && 8 > a5 ? a5 : 8);
    var o5, u4, i3, s5 = Pl.T, c3 = {};
    Pl.T = c3, Pn(e4, false, n6, t5);
    try {
      var f5 = l5(), d4 = Pl.S;
      null !== d4 && d4(c3, f5), null !== f5 && "object" == typeof f5 && "function" == typeof f5.then ? En(e4, n6, (o5 = r6, u4 = [], i3 = { status: "pending", value: null, reason: null, then: /* @__PURE__ */ __name(function(e5) {
        u4.push(e5);
      }, "then") }, f5.then(function() {
        i3.status = "fulfilled", i3.value = o5;
        for (var e5 = 0; e5 < u4.length; e5++) (0, u4[e5])(o5);
      }, function(e5) {
        for (i3.status = "rejected", i3.reason = e5, e5 = 0; e5 < u4.length; e5++) (0, u4[e5])(void 0);
      }), i3), pr()) : En(e4, n6, r6, pr());
    } catch (t6) {
      En(e4, n6, { then: /* @__PURE__ */ __name(function() {
      }, "then"), status: "rejected", reason: t6 }, pr());
    } finally {
      $l(a5), Pl.T = s5;
    }
  }
  __name(vn, "vn");
  function Sn() {
    return gt(ra);
  }
  __name(Sn, "Sn");
  function kn() {
    return Re().memoizedState;
  }
  __name(kn, "kn");
  function wn() {
    return Re().memoizedState;
  }
  __name(wn, "wn");
  function xn(e4) {
    for (var n6 = e4.return; null !== n6; ) {
      switch (n6.tag) {
        case 24:
        case 3:
          var t5 = pr(), r6 = Y(n6, e4 = q(t5), t5);
          return null !== r6 && (hr(r6, 0, t5), G2(r6, n6, t5)), n6 = { cache: vt() }, void (e4.payload = n6);
      }
      n6 = n6.return;
    }
  }
  __name(xn, "xn");
  function zn(e4, n6, t5) {
    var r6 = pr();
    t5 = { lane: r6, revertLane: 0, action: t5, hasEagerState: false, eagerState: null, next: null }, _n(e4) ? Rn(n6, t5) : null !== (t5 = U(e4, n6, t5, r6)) && (hr(t5, 0, r6), Tn(t5, n6, r6));
  }
  __name(zn, "zn");
  function Cn(e4, n6, t5) {
    En(e4, n6, t5, pr());
  }
  __name(Cn, "Cn");
  function En(e4, n6, t5, r6) {
    var l5 = { lane: r6, revertLane: 0, action: t5, hasEagerState: false, eagerState: null, next: null };
    if (_n(e4)) Rn(n6, l5);
    else {
      var a5 = e4.alternate;
      if (0 === e4.lanes && (null === a5 || 0 === a5.lanes) && null !== (a5 = n6.lastRenderedReducer)) try {
        var o5 = n6.lastRenderedState, u4 = a5(o5, t5);
        if (l5.hasEagerState = true, l5.eagerState = u4, Ja(u4, o5)) return L(e4, n6, l5, 0), null === Tu && N(), false;
      } catch (e5) {
      }
      if (null !== (t5 = U(e4, n6, l5, r6))) return hr(t5, 0, r6), Tn(t5, n6, r6), true;
    }
    return false;
  }
  __name(En, "En");
  function Pn(e4, n6, t5, l5) {
    if (l5 = { lane: 2, revertLane: O(), action: l5, hasEagerState: false, eagerState: null, next: null }, _n(e4)) {
      if (n6) throw Error(r5(479));
    } else null !== (n6 = U(e4, t5, l5, 2)) && hr(n6, 0, 2);
  }
  __name(Pn, "Pn");
  function _n(e4) {
    var n6 = e4.alternate;
    return e4 === Ao || null !== n6 && n6 === Ao;
  }
  __name(_n, "_n");
  function Rn(e4, n6) {
    Vo = Bo = true;
    var t5 = e4.pending;
    null === t5 ? n6.next = n6 : (n6.next = t5.next, t5.next = n6), e4.pending = n6;
  }
  __name(Rn, "Rn");
  function Tn(e4, n6, t5) {
    if (0 != (4194176 & t5)) {
      var r6 = n6.lanes;
      t5 |= r6 &= e4.pendingLanes, n6.lanes = t5, w(e4, t5);
    }
  }
  __name(Tn, "Tn");
  function Nn(e4, n6, t5, r6) {
    t5 = null == (t5 = t5(r6, n6 = e4.memoizedState)) ? n6 : il({}, n6, t5), e4.memoizedState = t5, 0 === e4.lanes && (e4.updateQueue.baseState = t5);
  }
  __name(Nn, "Nn");
  function Ln(e4, n6, t5, r6, l5, a5, o5) {
    return "function" == typeof (e4 = e4.stateNode).shouldComponentUpdate ? e4.shouldComponentUpdate(r6, a5, o5) : !(n6.prototype && n6.prototype.isPureReactComponent && ne(t5, r6) && ne(l5, a5));
  }
  __name(Ln, "Ln");
  function Un(e4, n6, t5, r6) {
    e4 = n6.state, "function" == typeof n6.componentWillReceiveProps && n6.componentWillReceiveProps(t5, r6), "function" == typeof n6.UNSAFE_componentWillReceiveProps && n6.UNSAFE_componentWillReceiveProps(t5, r6), n6.state !== e4 && tu.enqueueReplaceState(n6, n6.state, null);
  }
  __name(Un, "Un");
  function Dn(e4, n6) {
    var t5 = n6;
    if ("ref" in n6) for (var r6 in t5 = {}, n6) "ref" !== r6 && (t5[r6] = n6[r6]);
    if (e4 = e4.defaultProps) for (var l5 in t5 === n6 && (t5 = il({}, t5)), e4) void 0 === t5[l5] && (t5[l5] = e4[l5]);
    return t5;
  }
  __name(Dn, "Dn");
  function In(e4, n6) {
    try {
      (0, e4.onUncaughtError)(n6.value, { componentStack: n6.stack });
    } catch (e5) {
      setTimeout(function() {
        throw e5;
      });
    }
  }
  __name(In, "In");
  function Fn(e4, n6, t5) {
    try {
      (0, e4.onCaughtError)(t5.value, { componentStack: t5.stack, errorBoundary: 1 === n6.tag ? n6.stateNode : null });
    } catch (e5) {
      setTimeout(function() {
        throw e5;
      });
    }
  }
  __name(Fn, "Fn");
  function Mn(e4, n6, t5) {
    return (t5 = q(t5)).tag = 3, t5.payload = { element: null }, t5.callback = function() {
      In(e4, n6);
    }, t5;
  }
  __name(Mn, "Mn");
  function Wn(e4) {
    return (e4 = q(e4)).tag = 3, e4;
  }
  __name(Wn, "Wn");
  function Hn(e4, n6, t5, r6) {
    var l5 = t5.type.getDerivedStateFromError;
    if ("function" == typeof l5) {
      var a5 = r6.value;
      e4.payload = function() {
        return l5(a5);
      }, e4.callback = function() {
        Fn(n6, t5, r6);
      };
    }
    var o5 = t5.stateNode;
    null !== o5 && "function" == typeof o5.componentDidCatch && (e4.callback = function() {
      Fn(n6, t5, r6), "function" != typeof l5 && (null === Ju ? Ju = /* @__PURE__ */ new Set([this]) : Ju.add(this));
      var e5 = r6.stack;
      this.componentDidCatch(r6.value, { componentStack: null !== e5 ? e5 : "" });
    });
  }
  __name(Hn, "Hn");
  function jn(e4, n6, t5, r6) {
    n6.child = null === e4 ? Do(n6, null, t5, r6) : Uo(n6, e4.child, t5, r6);
  }
  __name(jn, "jn");
  function An(e4, n6, t5, r6, l5) {
    t5 = t5.render;
    var a5 = n6.ref;
    if ("ref" in r6) {
      var o5 = {};
      for (var u4 in r6) "ref" !== u4 && (o5[u4] = r6[u4]);
    } else o5 = r6;
    return ht(n6), r6 = ke(e4, n6, t5, o5, a5, l5), u4 = Ce(), null === e4 || lu ? (n6.flags |= 1, jn(e4, n6, r6, l5), n6.child) : (Ee(e4, n6, l5), at(e4, n6, l5));
  }
  __name(An, "An");
  function Qn(e4, n6, t5, r6, l5) {
    if (null === e4) {
      var a5 = t5.type;
      return "function" != typeof a5 || qr(a5) || void 0 !== a5.defaultProps || null !== t5.compare ? ((e4 = Jr(t5.type, null, r6, n6, n6.mode, l5)).ref = n6.ref, e4.return = n6, n6.child = e4) : (n6.tag = 15, n6.type = a5, On(e4, n6, a5, r6, l5));
    }
    if (a5 = e4.child, !ot(e4, l5)) {
      var o5 = a5.memoizedProps;
      if ((t5 = null !== (t5 = t5.compare) ? t5 : ne)(o5, r6) && e4.ref === n6.ref) return at(e4, n6, l5);
    }
    return n6.flags |= 1, (e4 = Yr(a5, r6)).ref = n6.ref, e4.return = n6, n6.child = e4;
  }
  __name(Qn, "Qn");
  function On(e4, n6, t5, r6, l5) {
    if (null !== e4) {
      var a5 = e4.memoizedProps;
      if (ne(a5, r6) && e4.ref === n6.ref) {
        if (lu = false, n6.pendingProps = r6 = a5, !ot(e4, l5)) return n6.lanes = e4.lanes, at(e4, n6, l5);
        0 != (131072 & e4.flags) && (lu = true);
      }
    }
    return qn(e4, n6, t5, r6, l5);
  }
  __name(On, "On");
  function Bn(e4, n6, t5) {
    var r6 = n6.pendingProps, l5 = r6.children, a5 = 0 != (2 & n6.stateNode._pendingVisibility), o5 = null !== e4 ? e4.memoizedState : null;
    if ($n(e4, n6), "hidden" === r6.mode || a5) {
      if (0 != (128 & n6.flags)) {
        if (r6 = null !== o5 ? o5.baseLanes | t5 : t5, null !== e4) {
          for (l5 = n6.child = e4.child, a5 = 0; null !== l5; ) a5 = a5 | l5.lanes | l5.childLanes, l5 = l5.sibling;
          n6.childLanes = a5 & ~r6;
        } else n6.childLanes = 0, n6.child = null;
        return Vn(e4, n6, r6, t5);
      }
      if (0 == (536870912 & t5)) return n6.lanes = n6.childLanes = 536870912, Vn(e4, n6, null !== o5 ? o5.baseLanes | t5 : t5, t5);
      n6.memoizedState = { baseLanes: 0, cachePool: null }, null !== e4 && wt(0, null !== o5 ? o5.cachePool : null), null !== o5 ? fe(n6, o5) : de(), he(n6);
    } else null !== o5 ? (wt(0, o5.cachePool), fe(n6, o5), ge(), n6.memoizedState = null) : (null !== e4 && wt(0, null), de(), ge());
    return jn(e4, n6, l5, t5), n6.child;
  }
  __name(Bn, "Bn");
  function Vn(e4, n6, t5, r6) {
    var l5 = kt();
    return l5 = null === l5 ? null : { parent: pu._currentValue2, pool: l5 }, n6.memoizedState = { baseLanes: t5, cachePool: l5 }, null !== e4 && wt(0, null), de(), he(n6), null !== e4 && pt(e4, n6, r6, true), null;
  }
  __name(Vn, "Vn");
  function $n(e4, n6) {
    var t5 = n6.ref;
    if (null === t5) null !== e4 && null !== e4.ref && (n6.flags |= 2097664);
    else {
      if ("function" != typeof t5 && "object" != typeof t5) throw Error(r5(284));
      null !== e4 && e4.ref === t5 || (n6.flags |= 2097664);
    }
  }
  __name($n, "$n");
  function qn(e4, n6, t5, r6, l5) {
    return ht(n6), t5 = ke(e4, n6, t5, r6, void 0, l5), r6 = Ce(), null === e4 || lu ? (n6.flags |= 1, jn(e4, n6, t5, l5), n6.child) : (Ee(e4, n6, l5), at(e4, n6, l5));
  }
  __name(qn, "qn");
  function Yn(e4, n6, t5, r6, l5, a5) {
    return ht(n6), n6.updateQueue = null, t5 = xe(n6, r6, t5, l5), we(e4), r6 = Ce(), null === e4 || lu ? (n6.flags |= 1, jn(e4, n6, t5, a5), n6.child) : (Ee(e4, n6, a5), at(e4, n6, a5));
  }
  __name(Yn, "Yn");
  function Gn(e4, n6, t5, r6, l5) {
    if (ht(n6), null === n6.stateNode) {
      var a5 = La, o5 = t5.contextType;
      "object" == typeof o5 && null !== o5 && (a5 = gt(o5)), a5 = new t5(r6, a5), n6.memoizedState = null !== a5.state && void 0 !== a5.state ? a5.state : null, a5.updater = tu, n6.stateNode = a5, a5._reactInternals = n6, (a5 = n6.stateNode).props = r6, a5.state = n6.memoizedState, a5.refs = {}, V(n6), o5 = t5.contextType, a5.context = "object" == typeof o5 && null !== o5 ? gt(o5) : La, a5.state = n6.memoizedState, "function" == typeof (o5 = t5.getDerivedStateFromProps) && (Nn(n6, t5, o5, r6), a5.state = n6.memoizedState), "function" == typeof t5.getDerivedStateFromProps || "function" == typeof a5.getSnapshotBeforeUpdate || "function" != typeof a5.UNSAFE_componentWillMount && "function" != typeof a5.componentWillMount || (o5 = a5.state, "function" == typeof a5.componentWillMount && a5.componentWillMount(), "function" == typeof a5.UNSAFE_componentWillMount && a5.UNSAFE_componentWillMount(), o5 !== a5.state && tu.enqueueReplaceState(a5, a5.state, null), X(n6, r6, a5, l5), K(), a5.state = n6.memoizedState), "function" == typeof a5.componentDidMount && (n6.flags |= 4194308), r6 = true;
    } else if (null === e4) {
      a5 = n6.stateNode;
      var u4 = n6.memoizedProps, i3 = Dn(t5, u4);
      a5.props = i3;
      var s5 = a5.context, c3 = t5.contextType;
      o5 = La, "object" == typeof c3 && null !== c3 && (o5 = gt(c3));
      var f5 = t5.getDerivedStateFromProps;
      c3 = "function" == typeof f5 || "function" == typeof a5.getSnapshotBeforeUpdate, u4 = n6.pendingProps !== u4, c3 || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (u4 || s5 !== o5) && Un(n6, a5, r6, o5), zo = false;
      var d4 = n6.memoizedState;
      a5.state = d4, X(n6, r6, a5, l5), K(), s5 = n6.memoizedState, u4 || d4 !== s5 || zo ? ("function" == typeof f5 && (Nn(n6, t5, f5, r6), s5 = n6.memoizedState), (i3 = zo || Ln(n6, t5, i3, r6, d4, s5, o5)) ? (c3 || "function" != typeof a5.UNSAFE_componentWillMount && "function" != typeof a5.componentWillMount || ("function" == typeof a5.componentWillMount && a5.componentWillMount(), "function" == typeof a5.UNSAFE_componentWillMount && a5.UNSAFE_componentWillMount()), "function" == typeof a5.componentDidMount && (n6.flags |= 4194308)) : ("function" == typeof a5.componentDidMount && (n6.flags |= 4194308), n6.memoizedProps = r6, n6.memoizedState = s5), a5.props = r6, a5.state = s5, a5.context = o5, r6 = i3) : ("function" == typeof a5.componentDidMount && (n6.flags |= 4194308), r6 = false);
    } else {
      a5 = n6.stateNode, $(e4, n6), c3 = Dn(t5, o5 = n6.memoizedProps), a5.props = c3, f5 = n6.pendingProps, d4 = a5.context, s5 = t5.contextType, i3 = La, "object" == typeof s5 && null !== s5 && (i3 = gt(s5)), (s5 = "function" == typeof (u4 = t5.getDerivedStateFromProps) || "function" == typeof a5.getSnapshotBeforeUpdate) || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (o5 !== f5 || d4 !== i3) && Un(n6, a5, r6, i3), zo = false, d4 = n6.memoizedState, a5.state = d4, X(n6, r6, a5, l5), K();
      var p4 = n6.memoizedState;
      o5 !== f5 || d4 !== p4 || zo || null !== e4 && null !== e4.dependencies && mt(e4.dependencies) ? ("function" == typeof u4 && (Nn(n6, t5, u4, r6), p4 = n6.memoizedState), (c3 = zo || Ln(n6, t5, c3, r6, d4, p4, i3) || null !== e4 && null !== e4.dependencies && mt(e4.dependencies)) ? (s5 || "function" != typeof a5.UNSAFE_componentWillUpdate && "function" != typeof a5.componentWillUpdate || ("function" == typeof a5.componentWillUpdate && a5.componentWillUpdate(r6, p4, i3), "function" == typeof a5.UNSAFE_componentWillUpdate && a5.UNSAFE_componentWillUpdate(r6, p4, i3)), "function" == typeof a5.componentDidUpdate && (n6.flags |= 4), "function" == typeof a5.getSnapshotBeforeUpdate && (n6.flags |= 1024)) : ("function" != typeof a5.componentDidUpdate || o5 === e4.memoizedProps && d4 === e4.memoizedState || (n6.flags |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || o5 === e4.memoizedProps && d4 === e4.memoizedState || (n6.flags |= 1024), n6.memoizedProps = r6, n6.memoizedState = p4), a5.props = r6, a5.state = p4, a5.context = i3, r6 = c3) : ("function" != typeof a5.componentDidUpdate || o5 === e4.memoizedProps && d4 === e4.memoizedState || (n6.flags |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || o5 === e4.memoizedProps && d4 === e4.memoizedState || (n6.flags |= 1024), r6 = false);
    }
    return a5 = r6, $n(e4, n6), r6 = 0 != (128 & n6.flags), a5 || r6 ? (a5 = n6.stateNode, t5 = r6 && "function" != typeof t5.getDerivedStateFromError ? null : a5.render(), n6.flags |= 1, null !== e4 && r6 ? (n6.child = Uo(n6, e4.child, null, l5), n6.child = Uo(n6, null, t5, l5)) : jn(e4, n6, t5, l5), n6.memoizedState = a5.state, e4 = n6.child) : e4 = at(e4, n6, l5), e4;
  }
  __name(Gn, "Gn");
  function Jn(e4) {
    return { baseLanes: e4, cachePool: xt() };
  }
  __name(Jn, "Jn");
  function Kn(e4, n6, t5) {
    return e4 = null !== e4 ? e4.childLanes & ~t5 : 0, n6 && (e4 |= Qu), e4;
  }
  __name(Kn, "Kn");
  function Xn(e4, n6, t5) {
    var l5, a5, o5, u4, i3 = n6.pendingProps, s5 = false, c3 = 0 != (128 & n6.flags);
    if ((l5 = c3) || (l5 = (null === e4 || null !== e4.memoizedState) && 0 != (2 & Ho.current)), l5 && (s5 = true, n6.flags &= -129), l5 = 0 != (32 & n6.flags), n6.flags &= -33, null === e4) return a5 = i3.children, i3 = i3.fallback, s5 ? (ge(), a5 = et({ mode: "hidden", children: a5 }, s5 = n6.mode), i3 = Kr(i3, s5, t5, null), a5.return = n6, i3.return = n6, a5.sibling = i3, n6.child = a5, (s5 = n6.child).memoizedState = Jn(t5), s5.childLanes = Kn(e4, l5, t5), n6.memoizedState = au, i3) : (me(n6), Zn(n6, a5));
    if (null !== (o5 = e4.memoizedState) && null !== (a5 = o5.dehydrated)) {
      if (c3) 256 & n6.flags ? (me(n6), n6.flags &= -257, n6 = nt(e4, n6, t5)) : null !== n6.memoizedState ? (ge(), n6.child = e4.child, n6.flags |= 128, n6 = null) : (ge(), s5 = i3.fallback, a5 = n6.mode, i3 = et({ mode: "visible", children: i3.children }, a5), (s5 = Kr(s5, a5, t5, null)).flags |= 2, i3.return = n6, s5.return = n6, i3.sibling = s5, n6.child = i3, Uo(n6, e4.child, null, t5), (i3 = n6.child).memoizedState = Jn(t5), i3.childLanes = Kn(e4, l5, t5), n6.memoizedState = au, n6 = s5);
      else if (me(n6), ka(a5)) l5 = wa(a5).digest, (i3 = Error(r5(419))).stack = "", i3.digest = l5, u4 = { value: i3, source: null, stack: null }, null === so ? so = [u4] : so.push(u4), n6 = nt(e4, n6, t5);
      else if (lu || pt(e4, n6, t5, false), l5 = 0 != (t5 & e4.childLanes), lu || l5) {
        if (null !== (l5 = Tu)) {
          if (0 != (42 & (i3 = t5 & -t5))) i3 = 1;
          else switch (i3) {
            case 2:
              i3 = 1;
              break;
            case 8:
              i3 = 4;
              break;
            case 32:
              i3 = 16;
              break;
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              i3 = 64;
              break;
            case 268435456:
              i3 = 134217728;
              break;
            default:
              i3 = 0;
          }
          if (0 !== (i3 = 0 != (i3 & (l5.suspendedLanes | t5)) ? 0 : i3) && i3 !== o5.retryLane) throw o5.retryLane = i3, D(e4, i3), hr(l5, 0, i3), ru;
        }
        Sa(a5) || Pr(), n6 = nt(e4, n6, t5);
      } else Sa(a5) ? (n6.flags |= 128, n6.child = e4.child, n6 = Br.bind(null, e4), xa(a5, n6), n6 = null) : (e4 = o5.treeContext, (n6 = Zn(n6, i3.children)).flags |= 4096);
      return n6;
    }
    return s5 ? (ge(), s5 = i3.fallback, a5 = n6.mode, c3 = (o5 = e4.child).sibling, (i3 = Yr(o5, { mode: "hidden", children: i3.children })).subtreeFlags = 31457280 & o5.subtreeFlags, null !== c3 ? s5 = Yr(c3, s5) : (s5 = Kr(s5, a5, t5, null)).flags |= 2, s5.return = n6, i3.return = n6, i3.sibling = s5, n6.child = i3, i3 = s5, s5 = n6.child, null === (a5 = e4.child.memoizedState) ? a5 = Jn(t5) : (null !== (o5 = a5.cachePool) ? (c3 = pu._currentValue2, o5 = o5.parent !== c3 ? { parent: c3, pool: c3 } : o5) : o5 = xt(), a5 = { baseLanes: a5.baseLanes | t5, cachePool: o5 }), s5.memoizedState = a5, s5.childLanes = Kn(e4, l5, t5), n6.memoizedState = au, i3) : (me(n6), e4 = (t5 = e4.child).sibling, (t5 = Yr(t5, { mode: "visible", children: i3.children })).return = n6, t5.sibling = null, null !== e4 && (null === (l5 = n6.deletions) ? (n6.deletions = [e4], n6.flags |= 16) : l5.push(e4)), n6.child = t5, n6.memoizedState = null, t5);
  }
  __name(Xn, "Xn");
  function Zn(e4, n6) {
    return (n6 = et({ mode: "visible", children: n6 }, e4.mode)).return = e4, e4.child = n6;
  }
  __name(Zn, "Zn");
  function et(e4, n6) {
    return Xr(e4, n6, 0, null);
  }
  __name(et, "et");
  function nt(e4, n6, t5) {
    return Uo(n6, e4.child, null, t5), (e4 = Zn(n6, n6.pendingProps.children)).flags |= 2, n6.memoizedState = null, e4;
  }
  __name(nt, "nt");
  function tt(e4, n6, t5) {
    e4.lanes |= n6;
    var r6 = e4.alternate;
    null !== r6 && (r6.lanes |= n6), ft(e4.return, n6, t5);
  }
  __name(tt, "tt");
  function rt(e4, n6, t5, r6, l5) {
    var a5 = e4.memoizedState;
    null === a5 ? e4.memoizedState = { isBackwards: n6, rendering: null, renderingStartTime: 0, last: r6, tail: t5, tailMode: l5 } : (a5.isBackwards = n6, a5.rendering = null, a5.renderingStartTime = 0, a5.last = r6, a5.tail = t5, a5.tailMode = l5);
  }
  __name(rt, "rt");
  function lt(e4, n6, t5) {
    var r6 = n6.pendingProps, l5 = r6.revealOrder, a5 = r6.tail;
    if (jn(e4, n6, r6.children, t5), 0 != (2 & (r6 = Ho.current))) r6 = 1 & r6 | 2, n6.flags |= 128;
    else {
      if (null !== e4 && 0 != (128 & e4.flags)) e: for (e4 = n6.child; null !== e4; ) {
        if (13 === e4.tag) null !== e4.memoizedState && tt(e4, t5, n6);
        else if (19 === e4.tag) tt(e4, t5, n6);
        else if (null !== e4.child) {
          e4.child.return = e4, e4 = e4.child;
          continue;
        }
        if (e4 === n6) break e;
        for (; null === e4.sibling; ) {
          if (null === e4.return || e4.return === n6) break e;
          e4 = e4.return;
        }
        e4.sibling.return = e4.return, e4 = e4.sibling;
      }
      r6 &= 1;
    }
    switch (p3(Ho, r6), l5) {
      case "forwards":
        for (t5 = n6.child, l5 = null; null !== t5; ) null !== (e4 = t5.alternate) && null === be(e4) && (l5 = t5), t5 = t5.sibling;
        null === (t5 = l5) ? (l5 = n6.child, n6.child = null) : (l5 = t5.sibling, t5.sibling = null), rt(n6, false, l5, t5, a5);
        break;
      case "backwards":
        for (t5 = null, l5 = n6.child, n6.child = null; null !== l5; ) {
          if (null !== (e4 = l5.alternate) && null === be(e4)) {
            n6.child = l5;
            break;
          }
          e4 = l5.sibling, l5.sibling = t5, t5 = l5, l5 = e4;
        }
        rt(n6, true, t5, null, a5);
        break;
      case "together":
        rt(n6, false, null, null, void 0);
        break;
      default:
        n6.memoizedState = null;
    }
    return n6.child;
  }
  __name(lt, "lt");
  function at(e4, n6, t5) {
    if (null !== e4 && (n6.dependencies = e4.dependencies), Hu |= n6.lanes, 0 == (t5 & n6.childLanes)) {
      if (null === e4) return null;
      if (pt(e4, n6, t5, false), 0 == (t5 & n6.childLanes)) return null;
    }
    if (null !== e4 && n6.child !== e4.child) throw Error(r5(153));
    if (null !== n6.child) {
      for (t5 = Yr(e4 = n6.child, e4.pendingProps), n6.child = t5, t5.return = n6; null !== e4.sibling; ) e4 = e4.sibling, (t5 = t5.sibling = Yr(e4, e4.pendingProps)).return = n6;
      t5.sibling = null;
    }
    return n6.child;
  }
  __name(at, "at");
  function ot(e4, n6) {
    return 0 != (e4.lanes & n6) || !(null === (e4 = e4.dependencies) || !mt(e4));
  }
  __name(ot, "ot");
  function ut(e4, n6, t5) {
    if (null !== e4) if (e4.memoizedProps !== n6.pendingProps) lu = true;
    else {
      if (!ot(e4, t5) && 0 == (128 & n6.flags)) return lu = false, function(e5, n7, t6) {
        switch (n7.tag) {
          case 3:
            P(n7, n7.stateNode.containerInfo), st(0, pu, e5.memoizedState.cache);
            break;
          case 27:
          case 5:
            R(n7);
            break;
          case 4:
            P(n7, n7.stateNode.containerInfo);
            break;
          case 10:
            st(0, n7.type, n7.memoizedProps.value);
            break;
          case 13:
            var r6 = n7.memoizedState;
            if (null !== r6) return null !== r6.dehydrated ? (me(n7), n7.flags |= 128, null) : 0 != (t6 & n7.child.childLanes) ? Xn(e5, n7, t6) : (me(n7), null !== (e5 = at(e5, n7, t6)) ? e5.sibling : null);
            me(n7);
            break;
          case 19:
            var l6 = 0 != (128 & e5.flags);
            if ((r6 = 0 != (t6 & n7.childLanes)) || (pt(e5, n7, t6, false), r6 = 0 != (t6 & n7.childLanes)), l6) {
              if (r6) return lt(e5, n7, t6);
              n7.flags |= 128;
            }
            if (null !== (l6 = n7.memoizedState) && (l6.rendering = null, l6.tail = null, l6.lastEffect = null), p3(Ho, Ho.current), r6) break;
            return null;
          case 22:
          case 23:
            return n7.lanes = 0, Bn(e5, n7, t6);
          case 24:
            st(0, pu, e5.memoizedState.cache);
        }
        return at(e5, n7, t6);
      }(e4, n6, t5);
      lu = 0 != (131072 & e4.flags);
    }
    else lu = false;
    switch (n6.lanes = 0, n6.tag) {
      case 16:
        e: {
          e4 = n6.pendingProps;
          var l5 = n6.elementType, o5 = l5._init;
          if (l5 = o5(l5._payload), n6.type = l5, "function" != typeof l5) {
            if (null != l5) {
              if ((o5 = l5.$$typeof) === bl) {
                n6.tag = 11, n6 = An(null, n6, l5, e4, t5);
                break e;
              }
              if (o5 === kl) {
                n6.tag = 14, n6 = Qn(null, n6, l5, e4, t5);
                break e;
              }
            }
            throw n6 = a4(l5) || l5, Error(r5(306, n6, ""));
          }
          qr(l5) ? (e4 = Dn(l5, e4), n6.tag = 1, n6 = Gn(null, n6, l5, e4, t5)) : (n6.tag = 0, n6 = qn(null, n6, l5, e4, t5));
        }
        return n6;
      case 0:
        return qn(e4, n6, n6.type, n6.pendingProps, t5);
      case 1:
        return Gn(e4, n6, l5 = n6.type, o5 = Dn(l5, n6.pendingProps), t5);
      case 3:
        if (P(n6, n6.stateNode.containerInfo), null === e4) throw Error(r5(387));
        var u4 = n6.pendingProps;
        l5 = (o5 = n6.memoizedState).element, $(e4, n6), X(n6, u4, null, t5);
        var i3 = n6.memoizedState;
        return u4 = i3.cache, st(0, pu, u4), u4 !== o5.cache && dt(n6, [pu], t5, true), K(), (u4 = i3.element) !== l5 ? (jn(e4, n6, u4, t5), n6 = n6.child) : n6 = at(e4, n6, t5), n6;
      case 26:
      case 27:
      case 5:
        return R(n6), o5 = n6.type, u4 = n6.pendingProps, i3 = null !== e4 ? e4.memoizedProps : null, l5 = u4.children, Wl(o5, u4) ? l5 = null : null !== i3 && Wl(o5, i3) && (n6.flags |= 32), null !== n6.memoizedState && (o5 = ke(e4, n6, ze, null, null, t5), ra._currentValue2 = o5), $n(e4, n6), jn(e4, n6, l5, t5), n6.child;
      case 6:
        return null;
      case 13:
        return Xn(e4, n6, t5);
      case 4:
        return P(n6, n6.stateNode.containerInfo), l5 = n6.pendingProps, null === e4 ? n6.child = Uo(n6, null, l5, t5) : jn(e4, n6, l5, t5), n6.child;
      case 11:
        return An(e4, n6, n6.type, n6.pendingProps, t5);
      case 7:
        return jn(e4, n6, n6.pendingProps, t5), n6.child;
      case 8:
      case 12:
        return jn(e4, n6, n6.pendingProps.children, t5), n6.child;
      case 10:
        return l5 = n6.pendingProps, st(0, n6.type, l5.value), jn(e4, n6, l5.children, t5), n6.child;
      case 9:
        return o5 = n6.type._context, l5 = n6.pendingProps.children, ht(n6), l5 = l5(o5 = gt(o5)), n6.flags |= 1, jn(e4, n6, l5, t5), n6.child;
      case 14:
        return Qn(e4, n6, n6.type, n6.pendingProps, t5);
      case 15:
        return On(e4, n6, n6.type, n6.pendingProps, t5);
      case 19:
        return lt(e4, n6, t5);
      case 22:
        return Bn(e4, n6, t5);
      case 24:
        return ht(n6), l5 = gt(pu), null === e4 ? (null === (o5 = kt()) && (o5 = Tu, u4 = vt(), o5.pooledCache = u4, u4.refCount++, null !== u4 && (o5.pooledCacheLanes |= t5), o5 = u4), n6.memoizedState = { parent: l5, cache: o5 }, V(n6), st(0, pu, o5)) : (0 != (e4.lanes & t5) && ($(e4, n6), X(n6, null, null, t5), K()), o5 = e4.memoizedState, u4 = n6.memoizedState, o5.parent !== l5 ? (o5 = { parent: l5, cache: l5 }, n6.memoizedState = o5, 0 === n6.lanes && (n6.memoizedState = n6.updateQueue.baseState = o5), st(0, pu, l5)) : (l5 = u4.cache, st(0, pu, l5), l5 !== o5.cache && dt(n6, [pu], t5, true))), jn(e4, n6, n6.pendingProps.children, t5), n6.child;
      case 29:
        throw n6.pendingProps;
    }
    throw Error(r5(156, n6.tag));
  }
  __name(ut, "ut");
  function it() {
    su = iu = uu = null;
  }
  __name(it, "it");
  function st(e4, n6, t5) {
    p3(ou, n6._currentValue2), n6._currentValue2 = t5;
  }
  __name(st, "st");
  function ct(e4) {
    var n6 = ou.current;
    e4._currentValue2 = n6, d3(ou);
  }
  __name(ct, "ct");
  function ft(e4, n6, t5) {
    for (; null !== e4; ) {
      var r6 = e4.alternate;
      if ((e4.childLanes & n6) !== n6 ? (e4.childLanes |= n6, null !== r6 && (r6.childLanes |= n6)) : null !== r6 && (r6.childLanes & n6) !== n6 && (r6.childLanes |= n6), e4 === t5) break;
      e4 = e4.return;
    }
  }
  __name(ft, "ft");
  function dt(e4, n6, t5, l5) {
    var a5 = e4.child;
    for (null !== a5 && (a5.return = e4); null !== a5; ) {
      var o5 = a5.dependencies;
      if (null !== o5) {
        var u4 = a5.child;
        o5 = o5.firstContext;
        e: for (; null !== o5; ) {
          var i3 = o5;
          o5 = a5;
          for (var s5 = 0; s5 < n6.length; s5++) if (i3.context === n6[s5]) {
            o5.lanes |= t5, null !== (i3 = o5.alternate) && (i3.lanes |= t5), ft(o5.return, t5, e4), l5 || (u4 = null);
            break e;
          }
          o5 = i3.next;
        }
      } else if (18 === a5.tag) {
        if (null === (u4 = a5.return)) throw Error(r5(341));
        u4.lanes |= t5, null !== (o5 = u4.alternate) && (o5.lanes |= t5), ft(u4, t5, e4), u4 = null;
      } else u4 = a5.child;
      if (null !== u4) u4.return = a5;
      else for (u4 = a5; null !== u4; ) {
        if (u4 === e4) {
          u4 = null;
          break;
        }
        if (null !== (a5 = u4.sibling)) {
          a5.return = u4.return, u4 = a5;
          break;
        }
        u4 = u4.return;
      }
      a5 = u4;
    }
  }
  __name(dt, "dt");
  function pt(e4, n6, t5, l5) {
    e4 = null;
    for (var a5 = n6, o5 = false; null !== a5; ) {
      if (!o5) {
        if (0 != (524288 & a5.flags)) o5 = true;
        else if (0 != (262144 & a5.flags)) break;
      }
      if (10 === a5.tag) {
        var u4 = a5.alternate;
        if (null === u4) throw Error(r5(387));
        if (null !== (u4 = u4.memoizedProps)) {
          var i3 = a5.type;
          Ja(a5.pendingProps.value, u4.value) || (null !== e4 ? e4.push(i3) : e4 = [i3]);
        }
      } else if (a5 === uo.current) {
        if (null === (u4 = a5.alternate)) throw Error(r5(387));
        u4.memoizedState.memoizedState !== a5.memoizedState.memoizedState && (null !== e4 ? e4.push(ra) : e4 = [ra]);
      }
      a5 = a5.return;
    }
    null !== e4 && dt(n6, e4, t5, l5), n6.flags |= 262144;
  }
  __name(pt, "pt");
  function mt(e4) {
    for (e4 = e4.firstContext; null !== e4; ) {
      var n6 = e4.context;
      if (!Ja(n6._currentValue2, e4.memoizedValue)) return true;
      e4 = e4.next;
    }
    return false;
  }
  __name(mt, "mt");
  function ht(e4) {
    uu = e4, su = iu = null, null !== (e4 = e4.dependencies) && (e4.firstContext = null);
  }
  __name(ht, "ht");
  function gt(e4) {
    return bt(uu, e4);
  }
  __name(gt, "gt");
  function yt(e4, n6) {
    return null === uu && ht(e4), bt(e4, n6);
  }
  __name(yt, "yt");
  function bt(e4, n6) {
    var t5 = n6._currentValue2;
    if (su !== n6) if (n6 = { context: n6, memoizedValue: t5, next: null }, null === iu) {
      if (null === e4) throw Error(r5(308));
      iu = n6, e4.dependencies = { lanes: 0, firstContext: n6 }, e4.flags |= 524288;
    } else iu = iu.next = n6;
    return t5;
  }
  __name(bt, "bt");
  function vt() {
    return { controller: new cu(), data: /* @__PURE__ */ new Map(), refCount: 0 };
  }
  __name(vt, "vt");
  function St(e4) {
    e4.refCount--, 0 === e4.refCount && fu(du, function() {
      e4.controller.abort();
    });
  }
  __name(St, "St");
  function kt() {
    var e4 = hu.current;
    return null !== e4 ? e4 : Tu.pooledCache;
  }
  __name(kt, "kt");
  function wt(e4, n6) {
    p3(hu, null === n6 ? hu.current : n6.pool);
  }
  __name(wt, "wt");
  function xt() {
    var e4 = kt();
    return null === e4 ? null : { parent: pu._currentValue2, pool: e4 };
  }
  __name(xt, "xt");
  function zt(e4) {
    e4.flags |= 4;
  }
  __name(zt, "zt");
  function Ct(e4, n6) {
    null !== n6 && (e4.flags |= 4), 16384 & e4.flags && (n6 = 22 !== e4.tag ? b3() : 536870912, e4.lanes |= n6);
  }
  __name(Ct, "Ct");
  function Et(e4, n6) {
    switch (e4.tailMode) {
      case "hidden":
        n6 = e4.tail;
        for (var t5 = null; null !== n6; ) null !== n6.alternate && (t5 = n6), n6 = n6.sibling;
        null === t5 ? e4.tail = null : t5.sibling = null;
        break;
      case "collapsed":
        t5 = e4.tail;
        for (var r6 = null; null !== t5; ) null !== t5.alternate && (r6 = t5), t5 = t5.sibling;
        null === r6 ? n6 || null === e4.tail ? e4.tail = null : e4.tail.sibling = null : r6.sibling = null;
    }
  }
  __name(Et, "Et");
  function Pt(e4) {
    var n6 = null !== e4.alternate && e4.alternate.child === e4.child, t5 = 0, r6 = 0;
    if (n6) for (var l5 = e4.child; null !== l5; ) t5 |= l5.lanes | l5.childLanes, r6 |= 31457280 & l5.subtreeFlags, r6 |= 31457280 & l5.flags, l5.return = e4, l5 = l5.sibling;
    else for (l5 = e4.child; null !== l5; ) t5 |= l5.lanes | l5.childLanes, r6 |= l5.subtreeFlags, r6 |= l5.flags, l5.return = e4, l5 = l5.sibling;
    return e4.subtreeFlags |= r6, e4.childLanes = t5, n6;
  }
  __name(Pt, "Pt");
  function _t(e4, n6, t5) {
    var l5 = n6.pendingProps;
    switch (E(n6), n6.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
      case 1:
        return Pt(n6), null;
      case 3:
        return t5 = n6.stateNode, l5 = null, null !== e4 && (l5 = e4.memoizedState.cache), n6.memoizedState.cache !== l5 && (n6.flags |= 2048), ct(pu), _(), t5.pendingContext && (t5.context = t5.pendingContext, t5.pendingContext = null), null !== e4 && null !== e4.child || null === e4 || e4.memoizedState.isDehydrated && 0 == (256 & n6.flags) || (n6.flags |= 1024, null !== so && (yr(so), so = null)), Pt(n6), null;
      case 26:
        var a5;
      case 27:
      case 5:
        if (T(n6), t5 = n6.type, null !== e4 && null != n6.stateNode) !function(e5, n7, t6, r6) {
          e5.memoizedProps !== r6 && zt(n7);
        }(e4, n6, 0, l5);
        else {
          if (!l5) {
            if (null === n6.stateNode) throw Error(r5(166));
            return Pt(n6), null;
          }
          e4 = lo.current, function(e5, n7, t6, r6) {
            for (t6 = n7.child; null !== t6; ) {
              if (5 === t6.tag || 6 === t6.tag) Fl(e5, t6.stateNode);
              else if (4 !== t6.tag && !Ra && null !== t6.child) {
                t6.child.return = t6, t6 = t6.child;
                continue;
              }
              if (t6 === n7) break;
              for (; null === t6.sibling; ) {
                if (null === t6.return || t6.return === n7) return;
                t6 = t6.return;
              }
              t6.sibling.return = t6.return, t6 = t6.sibling;
            }
          }(a5 = Il(t5, l5, oo.current, e4, n6), n6, false), n6.stateNode = a5, Ml(a5, t5, l5, e4) && zt(n6);
        }
        return Pt(n6), function(e5, n7, t6) {
          if (Kl(n7, t6)) {
            if (e5.flags |= 16777216, !Xl(n7, t6)) {
              if (!zr()) throw To = Ro, _o;
              e5.flags |= 8192;
            }
          } else e5.flags &= -16777217;
        }(n6, n6.type, n6.pendingProps), null;
      case 6:
        if (e4 && null != n6.stateNode) (t5 = e4.memoizedProps) !== l5 && zt(n6);
        else {
          if ("string" != typeof l5 && null === n6.stateNode) throw Error(r5(166));
          e4 = oo.current, t5 = lo.current, n6.stateNode = Hl(l5, e4, t5, n6);
        }
        return Pt(n6), null;
      case 13:
        if (l5 = n6.memoizedState, null === e4 || null !== e4.memoizedState && null !== e4.memoizedState.dehydrated) {
          if (a5 = false, null !== l5 && null !== l5.dehydrated) {
            if (null === e4) {
              if (!a5) throw Error(r5(318));
              throw Error(r5(344));
            }
            0 == (128 & n6.flags) && (n6.memoizedState = null), n6.flags |= 4, Pt(n6), a5 = false;
          } else null !== so && (yr(so), so = null), a5 = true;
          if (!a5) return 256 & n6.flags ? (ye(n6), n6) : (ye(n6), null);
        }
        if (ye(n6), 0 != (128 & n6.flags)) return n6.lanes = t5, n6;
        if (t5 = null !== l5, e4 = null !== e4 && null !== e4.memoizedState, t5) {
          a5 = null, null !== (l5 = n6.child).alternate && null !== l5.alternate.memoizedState && null !== l5.alternate.memoizedState.cachePool && (a5 = l5.alternate.memoizedState.cachePool.pool);
          var o5 = null;
          null !== l5.memoizedState && null !== l5.memoizedState.cachePool && (o5 = l5.memoizedState.cachePool.pool), o5 !== a5 && (l5.flags |= 2048);
        }
        return t5 !== e4 && t5 && (n6.child.flags |= 8192), Ct(n6, n6.updateQueue), Pt(n6), null;
      case 4:
        return _(), null === e4 && Vl(n6.stateNode.containerInfo), Pt(n6), null;
      case 10:
        return ct(n6.type), Pt(n6), null;
      case 19:
        if (d3(Ho), null === (a5 = n6.memoizedState)) return Pt(n6), null;
        if (l5 = 0 != (128 & n6.flags), null === (o5 = a5.rendering)) if (l5) Et(a5, false);
        else {
          if (0 !== Wu || null !== e4 && 0 != (128 & e4.flags)) for (e4 = n6.child; null !== e4; ) {
            if (null !== (o5 = be(e4))) {
              for (n6.flags |= 128, Et(a5, false), e4 = o5.updateQueue, n6.updateQueue = e4, Ct(n6, e4), n6.subtreeFlags = 0, e4 = t5, t5 = n6.child; null !== t5; ) Gr(t5, e4), t5 = t5.sibling;
              return p3(Ho, 1 & Ho.current | 2), n6.child;
            }
            e4 = e4.sibling;
          }
          null !== a5.tail && Qa() > Yu && (n6.flags |= 128, l5 = true, Et(a5, false), n6.lanes = 4194304);
        }
        else {
          if (!l5) if (null !== (e4 = be(o5))) {
            if (n6.flags |= 128, l5 = true, e4 = e4.updateQueue, n6.updateQueue = e4, Ct(n6, e4), Et(a5, true), null === a5.tail && "hidden" === a5.tailMode && !o5.alternate) return Pt(n6), null;
          } else 2 * Qa() - a5.renderingStartTime > Yu && 536870912 !== t5 && (n6.flags |= 128, l5 = true, Et(a5, false), n6.lanes = 4194304);
          a5.isBackwards ? (o5.sibling = n6.child, n6.child = o5) : (null !== (e4 = a5.last) ? e4.sibling = o5 : n6.child = o5, a5.last = o5);
        }
        return null !== a5.tail ? (n6 = a5.tail, a5.rendering = n6, a5.tail = n6.sibling, a5.renderingStartTime = Qa(), n6.sibling = null, e4 = Ho.current, p3(Ho, l5 ? 1 & e4 | 2 : 1 & e4), n6) : (Pt(n6), null);
      case 22:
      case 23:
        return ye(n6), pe(), l5 = null !== n6.memoizedState, null !== e4 ? null !== e4.memoizedState !== l5 && (n6.flags |= 8192) : l5 && (n6.flags |= 8192), l5 ? 0 != (536870912 & t5) && 0 == (128 & n6.flags) && (Pt(n6), 6 & n6.subtreeFlags && (n6.flags |= 8192)) : Pt(n6), null !== (t5 = n6.updateQueue) && Ct(n6, t5.retryQueue), t5 = null, null !== e4 && null !== e4.memoizedState && null !== e4.memoizedState.cachePool && (t5 = e4.memoizedState.cachePool.pool), l5 = null, null !== n6.memoizedState && null !== n6.memoizedState.cachePool && (l5 = n6.memoizedState.cachePool.pool), l5 !== t5 && (n6.flags |= 2048), null !== e4 && d3(hu), null;
      case 24:
        return t5 = null, null !== e4 && (t5 = e4.memoizedState.cache), n6.memoizedState.cache !== t5 && (n6.flags |= 2048), ct(pu), Pt(n6), null;
      case 25:
        return null;
    }
    throw Error(r5(156, n6.tag));
  }
  __name(_t, "_t");
  function Rt(e4, n6) {
    switch (E(n6), n6.tag) {
      case 1:
        return 65536 & (e4 = n6.flags) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 3:
        return ct(pu), _(), 0 != (65536 & (e4 = n6.flags)) && 0 == (128 & e4) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 26:
      case 27:
      case 5:
        return T(n6), null;
      case 13:
        if (ye(n6), null !== (e4 = n6.memoizedState) && null !== e4.dehydrated && null === n6.alternate) throw Error(r5(340));
        return 65536 & (e4 = n6.flags) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 19:
        return d3(Ho), null;
      case 4:
        return _(), null;
      case 10:
        return ct(n6.type), null;
      case 22:
      case 23:
        return ye(n6), pe(), null !== e4 && d3(hu), 65536 & (e4 = n6.flags) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 24:
        return ct(pu), null;
      default:
        return null;
    }
  }
  __name(Rt, "Rt");
  function Tt(e4, n6) {
    switch (E(n6), n6.tag) {
      case 3:
        ct(pu), _();
        break;
      case 26:
      case 27:
      case 5:
        T(n6);
        break;
      case 4:
        _();
        break;
      case 13:
        ye(n6);
        break;
      case 19:
        d3(Ho);
        break;
      case 10:
        ct(n6.type);
        break;
      case 22:
      case 23:
        ye(n6), pe(), null !== e4 && d3(hu);
        break;
      case 24:
        ct(pu);
    }
  }
  __name(Tt, "Tt");
  function Nt(e4, n6) {
    try {
      var t5 = n6.updateQueue, r6 = null !== t5 ? t5.lastEffect : null;
      if (null !== r6) {
        var l5 = r6.next;
        t5 = l5;
        do {
          if ((t5.tag & e4) === e4) {
            r6 = void 0;
            var a5 = t5.create, o5 = t5.inst;
            r6 = a5(), o5.destroy = r6;
          }
          t5 = t5.next;
        } while (t5 !== l5);
      }
    } catch (e5) {
      jr(n6, n6.return, e5);
    }
  }
  __name(Nt, "Nt");
  function Lt(e4, n6, t5) {
    try {
      var r6 = n6.updateQueue, l5 = null !== r6 ? r6.lastEffect : null;
      if (null !== l5) {
        var a5 = l5.next;
        r6 = a5;
        do {
          if ((r6.tag & e4) === e4) {
            var o5 = r6.inst, u4 = o5.destroy;
            if (void 0 !== u4) {
              o5.destroy = void 0, l5 = n6;
              var i3 = t5;
              try {
                u4();
              } catch (e5) {
                jr(l5, i3, e5);
              }
            }
          }
          r6 = r6.next;
        } while (r6 !== a5);
      }
    } catch (e5) {
      jr(n6, n6.return, e5);
    }
  }
  __name(Lt, "Lt");
  function Ut(e4) {
    var n6 = e4.updateQueue;
    if (null !== n6) {
      var t5 = e4.stateNode;
      try {
        ee(n6, t5);
      } catch (n7) {
        jr(e4, e4.return, n7);
      }
    }
  }
  __name(Ut, "Ut");
  function Dt(e4, n6, t5) {
    t5.props = Dn(e4.type, e4.memoizedProps), t5.state = e4.memoizedState;
    try {
      t5.componentWillUnmount();
    } catch (t6) {
      jr(e4, n6, t6);
    }
  }
  __name(Dt, "Dt");
  function It(e4, n6) {
    try {
      var t5 = e4.ref;
      if (null !== t5) {
        var r6 = e4.stateNode;
        switch (e4.tag) {
          case 26:
          case 27:
          case 5:
            var l5 = Tl(r6);
            break;
          default:
            l5 = r6;
        }
        "function" == typeof t5 ? e4.refCleanup = t5(l5) : t5.current = l5;
      }
    } catch (t6) {
      jr(e4, n6, t6);
    }
  }
  __name(It, "It");
  function Ft(e4, n6) {
    var t5 = e4.ref, r6 = e4.refCleanup;
    if (null !== t5) if ("function" == typeof r6) try {
      r6();
    } catch (t6) {
      jr(e4, n6, t6);
    } finally {
      e4.refCleanup = null, null != (e4 = e4.alternate) && (e4.refCleanup = null);
    }
    else if ("function" == typeof t5) try {
      t5(null);
    } catch (t6) {
      jr(e4, n6, t6);
    }
    else t5.current = null;
  }
  __name(Ft, "Ft");
  function Mt(e4) {
    var n6 = e4.type, t5 = e4.memoizedProps, r6 = e4.stateNode;
    try {
      ia(r6, n6, t5, e4);
    } catch (n7) {
      jr(e4, e4.return, n7);
    }
  }
  __name(Mt, "Mt");
  function Wt(e4) {
    return 5 === e4.tag || 3 === e4.tag || 4 === e4.tag;
  }
  __name(Wt, "Wt");
  function Ht(e4) {
    e: for (; ; ) {
      for (; null === e4.sibling; ) {
        if (null === e4.return || Wt(e4.return)) return null;
        e4 = e4.return;
      }
      for (e4.sibling.return = e4.return, e4 = e4.sibling; 5 !== e4.tag && 6 !== e4.tag && 18 !== e4.tag; ) {
        if (2 & e4.flags) continue e;
        if (null === e4.child || 4 === e4.tag) continue e;
        e4.child.return = e4, e4 = e4.child;
      }
      if (!(2 & e4.flags)) return e4.stateNode;
    }
  }
  __name(Ht, "Ht");
  function jt(e4, n6, t5) {
    var r6 = e4.tag;
    if (5 === r6 || 6 === r6) e4 = e4.stateNode, n6 ? fa(t5, e4, n6) : oa(t5, e4);
    else if (4 !== r6 && !Ra && null !== (e4 = e4.child)) for (jt(e4, n6, t5), e4 = e4.sibling; null !== e4; ) jt(e4, n6, t5), e4 = e4.sibling;
  }
  __name(jt, "jt");
  function At(e4, n6, t5) {
    var r6 = e4.tag;
    if (5 === r6 || 6 === r6) e4 = e4.stateNode, n6 ? ca(t5, e4, n6) : aa(t5, e4);
    else if (4 !== r6 && !Ra && null !== (e4 = e4.child)) for (At(e4, n6, t5), e4 = e4.sibling; null !== e4; ) At(e4, n6, t5), e4 = e4.sibling;
  }
  __name(At, "At");
  function Qt(e4, n6, t5) {
    var r6 = t5.flags;
    switch (t5.tag) {
      case 0:
      case 11:
      case 15:
        Kt(e4, t5), 4 & r6 && Nt(5, t5);
        break;
      case 1:
        if (Kt(e4, t5), 4 & r6) if (e4 = t5.stateNode, null === n6) try {
          e4.componentDidMount();
        } catch (e5) {
          jr(t5, t5.return, e5);
        }
        else {
          var l5 = Dn(t5.type, n6.memoizedProps);
          n6 = n6.memoizedState;
          try {
            e4.componentDidUpdate(l5, n6, e4.__reactInternalSnapshotBeforeUpdate);
          } catch (e5) {
            jr(t5, t5.return, e5);
          }
        }
        64 & r6 && Ut(t5), 512 & r6 && It(t5, t5.return);
        break;
      case 3:
        if (Kt(e4, t5), 64 & r6 && null !== (r6 = t5.updateQueue)) {
          if (e4 = null, null !== t5.child) switch (t5.child.tag) {
            case 27:
            case 5:
              e4 = Tl(t5.child.stateNode);
              break;
            case 1:
              e4 = t5.child.stateNode;
          }
          try {
            ee(r6, e4);
          } catch (e5) {
            jr(t5, t5.return, e5);
          }
        }
        break;
      case 26:
      case 27:
      case 5:
        Kt(e4, t5), null === n6 && 4 & r6 && Mt(t5), 512 & r6 && It(t5, t5.return);
        break;
      case 12:
      case 13:
      default:
        Kt(e4, t5);
        break;
      case 22:
        if (!(l5 = null !== t5.memoizedState || gu)) {
          n6 = null !== n6 && null !== n6.memoizedState || yu;
          var a5 = gu, o5 = yu;
          gu = l5, (yu = n6) && !o5 ? Zt(e4, t5, 0 != (8772 & t5.subtreeFlags)) : Kt(e4, t5), gu = a5, yu = o5;
        }
        512 & r6 && ("manual" === t5.memoizedProps.mode ? It(t5, t5.return) : Ft(t5, t5.return));
    }
  }
  __name(Qt, "Qt");
  function Ot(e4) {
    var n6 = e4.alternate;
    null !== n6 && (e4.alternate = null, Ot(n6)), e4.child = null, e4.deletions = null, e4.sibling = null, 5 === e4.tag && null !== (n6 = e4.stateNode) && Jl(n6), e4.stateNode = null, e4.return = null, e4.dependencies = null, e4.memoizedProps = null, e4.memoizedState = null, e4.pendingProps = null, e4.stateNode = null, e4.updateQueue = null;
  }
  __name(Ot, "Ot");
  function Bt(e4, n6, t5) {
    for (t5 = t5.child; null !== t5; ) Vt(e4, n6, t5), t5 = t5.sibling;
  }
  __name(Bt, "Bt");
  function Vt(e4, n6, t5) {
    switch (t5.tag) {
      case 26:
      case 27:
        var r6, l5;
      case 5:
        yu || Ft(t5, n6);
      case 6:
        if (r6 = wu, l5 = xu, wu = null, Bt(e4, n6, t5), xu = l5, null !== (wu = r6)) if (xu) try {
          pa(wu, t5.stateNode);
        } catch (e5) {
          jr(t5, n6, e5);
        }
        else try {
          da(wu, t5.stateNode);
        } catch (e5) {
          jr(t5, n6, e5);
        }
        break;
      case 18:
        null !== wu && (xu ? Ca(wu, t5.stateNode) : za(wu, t5.stateNode));
        break;
      case 4:
        r6 = wu, l5 = xu, wu = t5.stateNode.containerInfo, xu = true, Bt(e4, n6, t5), wu = r6, xu = l5;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        yu || Lt(2, t5, n6), yu || Lt(4, t5, n6), Bt(e4, n6, t5);
        break;
      case 1:
        yu || (Ft(t5, n6), "function" == typeof (r6 = t5.stateNode).componentWillUnmount && Dt(t5, n6, r6)), Bt(e4, n6, t5);
        break;
      case 21:
        Bt(e4, n6, t5);
        break;
      case 22:
        Ft(t5, n6), yu = (r6 = yu) || null !== t5.memoizedState, Bt(e4, n6, t5), yu = r6;
        break;
      default:
        Bt(e4, n6, t5);
    }
  }
  __name(Vt, "Vt");
  function $t(e4, n6) {
    var t5 = function(e5) {
      switch (e5.tag) {
        case 13:
        case 19:
          var n7 = e5.stateNode;
          return null === n7 && (n7 = e5.stateNode = new vu()), n7;
        case 22:
          return null === (n7 = (e5 = e5.stateNode)._retryCache) && (n7 = e5._retryCache = new vu()), n7;
        default:
          throw Error(r5(435, e5.tag));
      }
    }(e4);
    n6.forEach(function(n7) {
      var r6 = Vr.bind(null, e4, n7);
      t5.has(n7) || (t5.add(n7), n7.then(r6, r6));
    });
  }
  __name($t, "$t");
  function qt(e4, n6) {
    var t5 = n6.deletions;
    if (null !== t5) for (var l5 = 0; l5 < t5.length; l5++) {
      var a5 = t5[l5], o5 = e4, u4 = n6, i3 = u4;
      e: for (; null !== i3; ) {
        switch (i3.tag) {
          case 27:
          case 5:
            wu = i3.stateNode, xu = false;
            break e;
          case 3:
          case 4:
            wu = i3.stateNode.containerInfo, xu = true;
            break e;
        }
        i3 = i3.return;
      }
      if (null === wu) throw Error(r5(160));
      Vt(o5, u4, a5), wu = null, xu = false, null !== (o5 = a5.alternate) && (o5.return = null), a5.return = null;
    }
    if (13878 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) Yt(n6, e4), n6 = n6.sibling;
  }
  __name(qt, "qt");
  function Yt(e4, n6) {
    var t5 = e4.alternate, l5 = e4.flags;
    switch (e4.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        qt(n6, e4), Gt(e4), 4 & l5 && (Lt(3, e4, e4.return), Nt(3, e4), Lt(5, e4, e4.return));
        break;
      case 1:
        qt(n6, e4), Gt(e4), 512 & l5 && null !== t5 && Ft(t5, t5.return), 64 & l5 && gu && null !== (e4 = e4.updateQueue) && null !== (l5 = e4.callbacks) && (t5 = e4.shared.hiddenCallbacks, e4.shared.hiddenCallbacks = null === t5 ? l5 : t5.concat(l5));
        break;
      case 26:
        var a5;
      case 27:
        var o5;
      case 5:
        if (qt(n6, e4), Gt(e4), 512 & l5 && null !== t5 && Ft(t5, t5.return), 32 & e4.flags) {
          n6 = e4.stateNode;
          try {
            ma(n6);
          } catch (n7) {
            jr(e4, e4.return, n7);
          }
        }
        4 & l5 && null != e4.stateNode && function(e5, n7, t6) {
          try {
            sa(e5.stateNode, e5.type, t6, n7, e5);
          } catch (n8) {
            jr(e5, e5.return, n8);
          }
        }(e4, n6 = e4.memoizedProps, null !== t5 ? t5.memoizedProps : n6), 1024 & l5 && (bu = true);
        break;
      case 6:
        if (qt(n6, e4), Gt(e4), 4 & l5 && Ol) {
          if (null === e4.stateNode) throw Error(r5(162));
          l5 = e4.memoizedProps, t5 = null !== t5 ? t5.memoizedProps : l5, n6 = e4.stateNode;
          try {
            ua(n6, t5, l5);
          } catch (n7) {
            jr(e4, e4.return, n7);
          }
        }
        break;
      case 3:
        qt(n6, e4), Gt(e4), bu && (bu = false, Jt(e4));
        break;
      case 4:
      case 12:
        qt(n6, e4), Gt(e4);
        break;
      case 13:
        qt(n6, e4), Gt(e4), 8192 & e4.child.flags && null !== e4.memoizedState != (null !== t5 && null !== t5.memoizedState) && (qu = Qa()), 4 & l5 && null !== (l5 = e4.updateQueue) && (e4.updateQueue = null, $t(e4, l5));
        break;
      case 22:
        512 & l5 && null !== t5 && Ft(t5, t5.return), a5 = null !== e4.memoizedState;
        var u4 = null !== t5 && null !== t5.memoizedState, i3 = gu, s5 = yu;
        if (gu = i3 || a5, yu = s5 || u4, qt(n6, e4), yu = s5, gu = i3, Gt(e4), (n6 = e4.stateNode)._current = e4, n6._visibility &= -3, n6._visibility |= 2 & n6._pendingVisibility, 8192 & l5 && (n6._visibility = a5 ? -2 & n6._visibility : 1 | n6._visibility, a5 && (n6 = gu || yu, null === t5 || u4 || n6 || Xt(e4)), null === e4.memoizedProps || "manual" !== e4.memoizedProps.mode)) {
          e: if (t5 = null, Ol) for (n6 = e4; ; ) {
            if (5 === n6.tag || Ea || Ra) {
              if (null === t5) {
                u4 = t5 = n6;
                try {
                  o5 = u4.stateNode, a5 ? ha(o5) : ya(u4.stateNode, u4.memoizedProps);
                } catch (e5) {
                  jr(u4, u4.return, e5);
                }
              }
            } else if (6 === n6.tag) {
              if (null === t5) {
                u4 = n6;
                try {
                  var c3 = u4.stateNode;
                  a5 ? ga(c3) : ba(c3, u4.memoizedProps);
                } catch (e5) {
                  jr(u4, u4.return, e5);
                }
              }
            } else if ((22 !== n6.tag && 23 !== n6.tag || null === n6.memoizedState || n6 === e4) && null !== n6.child) {
              n6.child.return = n6, n6 = n6.child;
              continue;
            }
            if (n6 === e4) break e;
            for (; null === n6.sibling; ) {
              if (null === n6.return || n6.return === e4) break e;
              t5 === n6 && (t5 = null), n6 = n6.return;
            }
            t5 === n6 && (t5 = null), n6.sibling.return = n6.return, n6 = n6.sibling;
          }
        }
        4 & l5 && null !== (l5 = e4.updateQueue) && null !== (t5 = l5.retryQueue) && (l5.retryQueue = null, $t(e4, t5));
        break;
      case 19:
        qt(n6, e4), Gt(e4), 4 & l5 && null !== (l5 = e4.updateQueue) && (e4.updateQueue = null, $t(e4, l5));
        break;
      case 21:
        break;
      default:
        qt(n6, e4), Gt(e4);
    }
  }
  __name(Yt, "Yt");
  function Gt(e4) {
    var n6 = e4.flags;
    if (2 & n6) {
      try {
        if (Ol && (!Ra || 27 !== e4.tag)) {
          e: {
            for (var t5 = e4.return; null !== t5; ) {
              if (Wt(t5)) {
                var l5 = t5;
                break e;
              }
              t5 = t5.return;
            }
            throw Error(r5(160));
          }
          switch (l5.tag) {
            case 27:
            case 5:
              var a5 = l5.stateNode;
              32 & l5.flags && (ma(a5), l5.flags &= -33), At(e4, Ht(e4), a5);
              break;
            case 3:
            case 4:
              var o5 = l5.stateNode.containerInfo;
              jt(e4, Ht(e4), o5);
              break;
            default:
              throw Error(r5(161));
          }
        }
      } catch (n7) {
        jr(e4, e4.return, n7);
      }
      e4.flags &= -3;
    }
    4096 & n6 && (e4.flags &= -4097);
  }
  __name(Gt, "Gt");
  function Jt(e4) {
    if (1024 & e4.subtreeFlags) for (e4 = e4.child; null !== e4; ) {
      var n6 = e4;
      Jt(n6), 5 === n6.tag && 1024 & n6.flags && la(n6.stateNode), e4 = e4.sibling;
    }
  }
  __name(Jt, "Jt");
  function Kt(e4, n6) {
    if (8772 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) Qt(e4, n6.alternate, n6), n6 = n6.sibling;
  }
  __name(Kt, "Kt");
  function Xt(e4) {
    for (e4 = e4.child; null !== e4; ) {
      var n6 = e4;
      switch (n6.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Lt(4, n6, n6.return), Xt(n6);
          break;
        case 1:
          Ft(n6, n6.return);
          var t5 = n6.stateNode;
          "function" == typeof t5.componentWillUnmount && Dt(n6, n6.return, t5), Xt(n6);
          break;
        case 26:
        case 27:
        case 5:
          Ft(n6, n6.return), Xt(n6);
          break;
        case 22:
          Ft(n6, n6.return), null === n6.memoizedState && Xt(n6);
          break;
        default:
          Xt(n6);
      }
      e4 = e4.sibling;
    }
  }
  __name(Xt, "Xt");
  function Zt(e4, n6, t5) {
    for (t5 = t5 && 0 != (8772 & n6.subtreeFlags), n6 = n6.child; null !== n6; ) {
      var r6 = n6.alternate, l5 = e4, a5 = n6, o5 = a5.flags;
      switch (a5.tag) {
        case 0:
        case 11:
        case 15:
          Zt(l5, a5, t5), Nt(4, a5);
          break;
        case 1:
          if (Zt(l5, a5, t5), "function" == typeof (l5 = (r6 = a5).stateNode).componentDidMount) try {
            l5.componentDidMount();
          } catch (e5) {
            jr(r6, r6.return, e5);
          }
          if (null !== (l5 = (r6 = a5).updateQueue)) {
            var u4 = r6.stateNode;
            try {
              var i3 = l5.shared.hiddenCallbacks;
              if (null !== i3) for (l5.shared.hiddenCallbacks = null, l5 = 0; l5 < i3.length; l5++) Z(i3[l5], u4);
            } catch (e5) {
              jr(r6, r6.return, e5);
            }
          }
          t5 && 64 & o5 && Ut(a5), It(a5, a5.return);
          break;
        case 26:
        case 27:
        case 5:
          Zt(l5, a5, t5), t5 && null === r6 && 4 & o5 && Mt(a5), It(a5, a5.return);
          break;
        case 12:
        case 13:
        default:
          Zt(l5, a5, t5);
          break;
        case 22:
          null === a5.memoizedState && Zt(l5, a5, t5), It(a5, a5.return);
      }
      n6 = n6.sibling;
    }
  }
  __name(Zt, "Zt");
  function er(e4, n6) {
    var t5 = null;
    null !== e4 && null !== e4.memoizedState && null !== e4.memoizedState.cachePool && (t5 = e4.memoizedState.cachePool.pool), e4 = null, null !== n6.memoizedState && null !== n6.memoizedState.cachePool && (e4 = n6.memoizedState.cachePool.pool), e4 !== t5 && (null != e4 && e4.refCount++, null != t5 && St(t5));
  }
  __name(er, "er");
  function nr(e4, n6) {
    e4 = null, null !== n6.alternate && (e4 = n6.alternate.memoizedState.cache), (n6 = n6.memoizedState.cache) !== e4 && (n6.refCount++, null != e4 && St(e4));
  }
  __name(nr, "nr");
  function tr(e4, n6, t5, r6) {
    if (10256 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) rr(e4, n6, t5, r6), n6 = n6.sibling;
  }
  __name(tr, "tr");
  function rr(e4, n6, t5, r6) {
    var l5 = n6.flags;
    switch (n6.tag) {
      case 0:
      case 11:
      case 15:
        tr(e4, n6, t5, r6), 2048 & l5 && Nt(9, n6);
        break;
      case 3:
        tr(e4, n6, t5, r6), 2048 & l5 && (e4 = null, null !== n6.alternate && (e4 = n6.alternate.memoizedState.cache), (n6 = n6.memoizedState.cache) !== e4 && (n6.refCount++, null != e4 && St(e4)));
        break;
      case 12:
        if (2048 & l5) {
          tr(e4, n6, t5, r6), e4 = n6.stateNode;
          try {
            var a5 = n6.memoizedProps, o5 = a5.id, u4 = a5.onPostCommit;
            "function" == typeof u4 && u4(o5, null === n6.alternate ? "mount" : "update", e4.passiveEffectDuration, -0);
          } catch (e5) {
            jr(n6, n6.return, e5);
          }
        } else tr(e4, n6, t5, r6);
        break;
      case 23:
        break;
      case 22:
        a5 = n6.stateNode, null !== n6.memoizedState ? 4 & a5._visibility ? tr(e4, n6, t5, r6) : ar(e4, n6) : 4 & a5._visibility ? tr(e4, n6, t5, r6) : (a5._visibility |= 4, lr(e4, n6, t5, r6, 0 != (10256 & n6.subtreeFlags))), 2048 & l5 && er(n6.alternate, n6);
        break;
      case 24:
        tr(e4, n6, t5, r6), 2048 & l5 && nr(n6.alternate, n6);
        break;
      default:
        tr(e4, n6, t5, r6);
    }
  }
  __name(rr, "rr");
  function lr(e4, n6, t5, r6, l5) {
    for (l5 = l5 && 0 != (10256 & n6.subtreeFlags), n6 = n6.child; null !== n6; ) {
      var a5 = e4, o5 = n6, u4 = t5, i3 = r6, s5 = o5.flags;
      switch (o5.tag) {
        case 0:
        case 11:
        case 15:
          lr(a5, o5, u4, i3, l5), Nt(8, o5);
          break;
        case 23:
          break;
        case 22:
          var c3 = o5.stateNode;
          null !== o5.memoizedState ? 4 & c3._visibility ? lr(a5, o5, u4, i3, l5) : ar(a5, o5) : (c3._visibility |= 4, lr(a5, o5, u4, i3, l5)), l5 && 2048 & s5 && er(o5.alternate, o5);
          break;
        case 24:
          lr(a5, o5, u4, i3, l5), l5 && 2048 & s5 && nr(o5.alternate, o5);
          break;
        default:
          lr(a5, o5, u4, i3, l5);
      }
      n6 = n6.sibling;
    }
  }
  __name(lr, "lr");
  function ar(e4, n6) {
    if (10256 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) {
      var t5 = e4, r6 = n6, l5 = r6.flags;
      switch (r6.tag) {
        case 22:
          ar(t5, r6), 2048 & l5 && er(r6.alternate, r6);
          break;
        case 24:
          ar(t5, r6), 2048 & l5 && nr(r6.alternate, r6);
          break;
        default:
          ar(t5, r6);
      }
      n6 = n6.sibling;
    }
  }
  __name(ar, "ar");
  function or(e4) {
    if (e4.subtreeFlags & Cu) for (e4 = e4.child; null !== e4; ) ur(e4), e4 = e4.sibling;
  }
  __name(or, "or");
  function ur(e4) {
    switch (e4.tag) {
      case 26:
        or(e4), e4.flags & Cu && (null !== e4.memoizedState ? _a(zu, e4.memoizedState, e4.memoizedProps) : ea(e4.type, e4.memoizedProps));
        break;
      case 5:
        or(e4), e4.flags & Cu && ea(e4.type, e4.memoizedProps);
        break;
      case 3:
      case 4:
        var n6;
        or(e4);
        break;
      case 22:
        null === e4.memoizedState && (null !== (n6 = e4.alternate) && null !== n6.memoizedState ? (n6 = Cu, Cu = 16777216, or(e4), Cu = n6) : or(e4));
        break;
      default:
        or(e4);
    }
  }
  __name(ur, "ur");
  function ir(e4) {
    var n6 = e4.alternate;
    if (null !== n6 && null !== (e4 = n6.child)) {
      n6.child = null;
      do {
        n6 = e4.sibling, e4.sibling = null, e4 = n6;
      } while (null !== e4);
    }
  }
  __name(ir, "ir");
  function sr(e4) {
    var n6 = e4.deletions;
    if (0 != (16 & e4.flags)) {
      if (null !== n6) for (var t5 = 0; t5 < n6.length; t5++) {
        var r6 = n6[t5];
        Su = r6, dr(r6, e4);
      }
      ir(e4);
    }
    if (10256 & e4.subtreeFlags) for (e4 = e4.child; null !== e4; ) cr(e4), e4 = e4.sibling;
  }
  __name(sr, "sr");
  function cr(e4) {
    switch (e4.tag) {
      case 0:
      case 11:
      case 15:
        sr(e4), 2048 & e4.flags && Lt(9, e4, e4.return);
        break;
      case 3:
      case 12:
      default:
        sr(e4);
        break;
      case 22:
        var n6 = e4.stateNode;
        null !== e4.memoizedState && 4 & n6._visibility && (null === e4.return || 13 !== e4.return.tag) ? (n6._visibility &= -5, fr(e4)) : sr(e4);
    }
  }
  __name(cr, "cr");
  function fr(e4) {
    var n6 = e4.deletions;
    if (0 != (16 & e4.flags)) {
      if (null !== n6) for (var t5 = 0; t5 < n6.length; t5++) {
        var r6 = n6[t5];
        Su = r6, dr(r6, e4);
      }
      ir(e4);
    }
    for (e4 = e4.child; null !== e4; ) {
      switch ((n6 = e4).tag) {
        case 0:
        case 11:
        case 15:
          Lt(8, n6, n6.return), fr(n6);
          break;
        case 22:
          4 & (t5 = n6.stateNode)._visibility && (t5._visibility &= -5, fr(n6));
          break;
        default:
          fr(n6);
      }
      e4 = e4.sibling;
    }
  }
  __name(fr, "fr");
  function dr(e4, n6) {
    for (; null !== Su; ) {
      var t5 = Su;
      switch (t5.tag) {
        case 0:
        case 11:
        case 15:
          Lt(8, t5, n6);
          break;
        case 23:
        case 22:
          if (null !== t5.memoizedState && null !== t5.memoizedState.cachePool) {
            var r6 = t5.memoizedState.cachePool.pool;
            null != r6 && r6.refCount++;
          }
          break;
        case 24:
          St(t5.memoizedState.cache);
      }
      if (null !== (r6 = t5.child)) r6.return = t5, Su = r6;
      else e: for (t5 = e4; null !== Su; ) {
        var l5 = (r6 = Su).sibling, a5 = r6.return;
        if (Ot(r6), r6 === t5) {
          Su = null;
          break e;
        }
        if (null !== l5) {
          l5.return = a5, Su = l5;
          break e;
        }
        Su = a5;
      }
    }
  }
  __name(dr, "dr");
  function pr() {
    return 0 != (2 & Ru) && 0 !== Lu ? Lu & -Lu : null !== Pl.T ? 0 !== wo ? wo : O() : Yl();
  }
  __name(pr, "pr");
  function mr() {
    0 === Qu && (Qu = 0 == (536870912 & Lu) || io ? y3() : 536870912);
    var e4 = Mo.current;
    return null !== e4 && (e4.flags |= 32), Qu;
  }
  __name(mr, "mr");
  function hr(e4, n6, t5) {
    (e4 === Tu && 2 === Uu || null !== e4.cancelPendingCommit) && (wr(e4, 0), Sr(e4, Lu, Qu)), S3(e4, t5), 0 != (2 & Ru) && e4 === Tu || (e4 === Tu && (0 == (2 & Ru) && (ju |= t5), 4 === Wu && Sr(e4, Lu, Qu)), M(e4));
  }
  __name(hr, "hr");
  function gr(e4, n6, t5) {
    if (0 != (6 & Ru)) throw Error(r5(327));
    var l5 = (t5 = !t5 && 0 == (60 & n6) && 0 == (n6 & e4.expiredLanes)) ? function(e5, n7) {
      var t6 = Ru;
      Ru |= 2;
      var l6 = Cr(), a6 = Er();
      Tu === e5 && Lu === n7 || (Gu = null, Yu = Qa() + 500, wr(e5, n7));
      e: for (; ; ) try {
        if (0 !== Uu && null !== Nu) {
          n7 = Nu;
          var o6 = Du;
          n: switch (Uu) {
            case 1:
            case 6:
              Uu = 0, Du = null, Ur(e5, n7, o6);
              break;
            case 2:
              if (te(o6)) {
                Uu = 0, Du = null, Lr(n7);
                break;
              }
              n7 = /* @__PURE__ */ __name(function() {
                2 === Uu && Tu === e5 && (Uu = 7), M(e5);
              }, "n"), o6.then(n7, n7);
              break e;
            case 3:
              Uu = 7;
              break e;
            case 4:
              Uu = 5;
              break e;
            case 7:
              te(o6) ? (Uu = 0, Du = null, Lr(n7)) : (Uu = 0, Du = null, Ur(e5, n7, o6));
              break;
            case 5:
              var u5 = null;
              switch (Nu.tag) {
                case 26:
                  u5 = Nu.memoizedState;
                case 5:
                case 27:
                  var i4 = Nu, s5 = i4.type, c3 = i4.pendingProps;
                  if (u5 ? Pa(u5) : Xl(s5, c3)) {
                    Uu = 0, Du = null;
                    var f5 = i4.sibling;
                    if (null !== f5) Nu = f5;
                    else {
                      var d4 = i4.return;
                      null !== d4 ? (Nu = d4, Dr(d4)) : Nu = null;
                    }
                    break n;
                  }
              }
              Uu = 0, Du = null, Ur(e5, n7, o6);
              break;
            case 8:
              kr(), Wu = 6;
              break e;
            default:
              throw Error(r5(462));
          }
        }
        Tr();
        break;
      } catch (n8) {
        xr(e5, n8);
      }
      return it(), Pl.H = l6, Pl.A = a6, Ru = t6, null !== Nu ? 0 : (Tu = null, Lu = 0, N(), Wu);
    }(e4, n6) : _r(e4, n6);
    if (0 !== l5) for (var a5 = t5; ; ) {
      if (6 === l5) Sr(e4, n6, 0);
      else {
        if (t5 = e4.current.alternate, a5 && !vr(t5)) {
          l5 = _r(e4, n6), a5 = false;
          continue;
        }
        if (2 === l5) {
          if (a5 = n6, e4.errorRecoveryDisabledLanes & a5) var o5 = 0;
          else o5 = 0 != (o5 = -536870913 & e4.pendingLanes) ? o5 : 536870912 & o5 ? 536870912 : 0;
          if (0 !== o5) {
            n6 = o5;
            e: {
              var u4 = e4;
              l5 = Bu;
              var i3 = Bl;
              if (i3 && (wr(u4, o5).flags |= 256), 2 !== (o5 = _r(u4, o5))) {
                if (Fu && !i3) {
                  u4.errorRecoveryDisabledLanes |= a5, ju |= a5, l5 = 4;
                  break e;
                }
                a5 = Vu, Vu = l5, null !== a5 && yr(a5);
              }
              l5 = o5;
            }
            if (a5 = false, 2 !== l5) continue;
          }
        }
        if (1 === l5) {
          wr(e4, 0), Sr(e4, n6, 0);
          break;
        }
        e: {
          switch (a5 = e4, l5) {
            case 0:
            case 1:
              throw Error(r5(345));
            case 4:
              if ((4194176 & n6) === n6) {
                Sr(a5, n6, Qu);
                break e;
              }
              break;
            case 2:
              Vu = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r5(329));
          }
          if (a5.finishedWork = t5, a5.finishedLanes = n6, (62914560 & n6) === n6 && 10 < (l5 = qu + 300 - Qa())) {
            if (Sr(a5, n6, Qu), 0 !== h(a5, 0)) break e;
            a5.timeoutHandle = jl(br.bind(null, a5, t5, Vu, Gu, $u, n6, Qu, ju, Ou, Iu, 2, -0, 0), l5);
          } else br(a5, t5, Vu, Gu, $u, n6, Qu, ju, Ou, Iu, 0, -0, 0);
        }
      }
      break;
    }
    M(e4);
  }
  __name(gr, "gr");
  function yr(e4) {
    null === Vu ? Vu = e4 : Vu.push.apply(Vu, e4);
  }
  __name(yr, "yr");
  function br(e4, n6, t5, r6, l5, a5, o5, u4, i3, s5, c3, f5, d4) {
    if ((8192 & (s5 = n6.subtreeFlags) || 16785408 == (16785408 & s5)) && (Zl(), ur(n6), null !== (n6 = na()))) return e4.cancelPendingCommit = n6(Fr.bind(null, e4, t5, r6, l5, o5, u4, i3, 1, f5, d4)), void Sr(e4, a5, o5);
    Fr(e4, t5, r6, l5, o5);
  }
  __name(br, "br");
  function vr(e4) {
    for (var n6 = e4; ; ) {
      var t5 = n6.tag;
      if ((0 === t5 || 11 === t5 || 15 === t5) && 16384 & n6.flags && null !== (t5 = n6.updateQueue) && null !== (t5 = t5.stores)) for (var r6 = 0; r6 < t5.length; r6++) {
        var l5 = t5[r6], a5 = l5.getSnapshot;
        l5 = l5.value;
        try {
          if (!Ja(a5(), l5)) return false;
        } catch (e5) {
          return false;
        }
      }
      if (t5 = n6.child, 16384 & n6.subtreeFlags && null !== t5) t5.return = n6, n6 = t5;
      else {
        if (n6 === e4) break;
        for (; null === n6.sibling; ) {
          if (null === n6.return || n6.return === e4) return true;
          n6 = n6.return;
        }
        n6.sibling.return = n6.return, n6 = n6.sibling;
      }
    }
    return true;
  }
  __name(vr, "vr");
  function Sr(e4, n6, t5) {
    n6 &= ~Au, n6 &= ~ju, e4.suspendedLanes |= n6, e4.pingedLanes &= ~n6;
    for (var r6 = e4.expirationTimes, l5 = n6; 0 < l5; ) {
      var a5 = 31 - Ua(l5), o5 = 1 << a5;
      r6[a5] = -1, l5 &= ~o5;
    }
    0 !== t5 && k3(e4, t5, n6);
  }
  __name(Sr, "Sr");
  function kr() {
    if (null !== Nu) {
      if (0 === Uu) var e4 = Nu.return;
      else e4 = Nu, it(), Pe(e4), No = null, Lo = 0, e4 = Nu;
      for (; null !== e4; ) Tt(e4.alternate, e4), e4 = e4.return;
      Nu = null;
    }
  }
  __name(kr, "kr");
  function wr(e4, n6) {
    e4.finishedWork = null, e4.finishedLanes = 0;
    var t5 = e4.timeoutHandle;
    t5 !== Ql && (e4.timeoutHandle = Ql, Al(t5)), null !== (t5 = e4.cancelPendingCommit) && (e4.cancelPendingCommit = null, t5()), kr(), Tu = e4, Nu = t5 = Yr(e4.current, null), Lu = n6, Uu = 0, Du = null, Fu = Iu = false, Ou = Qu = Au = ju = Hu = Wu = 0, Vu = Bu = null, $u = false, 0 != (8 & n6) && (n6 |= 32 & n6);
    var r6 = e4.entangledLanes;
    if (0 !== r6) for (e4 = e4.entanglements, r6 &= n6; 0 < r6; ) {
      var l5 = 31 - Ua(r6), a5 = 1 << l5;
      n6 |= e4[l5], r6 &= ~a5;
    }
    return Mu = n6, N(), t5;
  }
  __name(wr, "wr");
  function xr(e4, n6) {
    Ao = null, Pl.H = Xo, n6 === Po ? (n6 = ae(), Uu = zr() && 0 == (134217727 & Hu) && 0 == (134217727 & ju) ? 2 : 3) : n6 === _o ? (n6 = ae(), Uu = 4) : Uu = n6 === ru ? 8 : null !== n6 && "object" == typeof n6 && "function" == typeof n6.then ? 6 : 1, Du = n6, null === Nu && (Wu = 1, In(e4, C(n6, e4.current)));
  }
  __name(xr, "xr");
  function zr() {
    var e4 = Mo.current;
    return null === e4 || ((4194176 & Lu) === Lu ? null === Wo : ((62914560 & Lu) === Lu || 0 != (536870912 & Lu)) && e4 === Wo);
  }
  __name(zr, "zr");
  function Cr() {
    var e4 = Pl.H;
    return Pl.H = Xo, null === e4 ? Xo : e4;
  }
  __name(Cr, "Cr");
  function Er() {
    var e4 = Pl.A;
    return Pl.A = Eu, e4;
  }
  __name(Er, "Er");
  function Pr() {
    Wu = 4, 0 == (134217727 & Hu) && 0 == (134217727 & ju) || null === Tu || Sr(Tu, Lu, Qu);
  }
  __name(Pr, "Pr");
  function _r(e4, n6) {
    var t5 = Ru;
    Ru |= 2;
    var l5 = Cr(), a5 = Er();
    Tu === e4 && Lu === n6 || (Gu = null, wr(e4, n6)), n6 = false;
    e: for (; ; ) try {
      if (0 !== Uu && null !== Nu) {
        var o5 = Nu, u4 = Du;
        switch (Uu) {
          case 8:
            kr(), Wu = 6;
            break e;
          case 3:
          case 2:
            n6 || null !== Mo.current || (n6 = true);
          default:
            Uu = 0, Du = null, Ur(e4, o5, u4);
        }
      }
      Rr();
      break;
    } catch (n7) {
      xr(e4, n7);
    }
    if (n6 && e4.shellSuspendCounter++, it(), Ru = t5, Pl.H = l5, Pl.A = a5, null !== Nu) throw Error(r5(261));
    return Tu = null, Lu = 0, N(), Wu;
  }
  __name(_r, "_r");
  function Rr() {
    for (; null !== Nu; ) Nr(Nu);
  }
  __name(Rr, "Rr");
  function Tr() {
    for (; null !== Nu && !ja(); ) Nr(Nu);
  }
  __name(Tr, "Tr");
  function Nr(e4) {
    var n6 = ut(e4.alternate, e4, Mu);
    e4.memoizedProps = e4.pendingProps, null === n6 ? Dr(e4) : Nu = n6;
  }
  __name(Nr, "Nr");
  function Lr(e4) {
    var n6 = e4, t5 = n6.alternate;
    switch (n6.tag) {
      case 15:
      case 0:
        n6 = Yn(t5, n6, n6.pendingProps, n6.type, void 0, Lu);
        break;
      case 11:
        n6 = Yn(t5, n6, n6.pendingProps, n6.type.render, n6.ref, Lu);
        break;
      case 5:
        Pe(n6);
      default:
        Tt(t5, n6), n6 = ut(t5, n6 = Nu = Gr(n6, Mu), Mu);
    }
    e4.memoizedProps = e4.pendingProps, null === n6 ? Dr(e4) : Nu = n6;
  }
  __name(Lr, "Lr");
  function Ur(e4, n6, t5) {
    it(), Pe(n6), No = null, Lo = 0;
    var l5 = n6.return;
    try {
      if (function(e5, n7, t6, l6, a5) {
        if (t6.flags |= 32768, null !== l6 && "object" == typeof l6 && "function" == typeof l6.then) {
          if (null !== (n7 = t6.alternate) && pt(n7, t6, a5, true), null !== (t6 = Mo.current)) {
            switch (t6.tag) {
              case 13:
                return null === Wo ? Pr() : null === t6.alternate && 0 === Wu && (Wu = 3), t6.flags &= -257, t6.flags |= 65536, t6.lanes = a5, l6 === Ro ? t6.flags |= 16384 : (null === (n7 = t6.updateQueue) ? t6.updateQueue = /* @__PURE__ */ new Set([l6]) : n7.add(l6), Ar(e5, l6, a5)), false;
              case 22:
                return t6.flags |= 65536, l6 === Ro ? t6.flags |= 16384 : (null === (n7 = t6.updateQueue) ? (n7 = { transitions: null, markerInstances: null, retryQueue: /* @__PURE__ */ new Set([l6]) }, t6.updateQueue = n7) : null === (t6 = n7.retryQueue) ? n7.retryQueue = /* @__PURE__ */ new Set([l6]) : t6.add(l6), Ar(e5, l6, a5)), false;
            }
            throw Error(r5(435, t6.tag));
          }
          return Ar(e5, l6, a5), Pr(), false;
        }
        var o5 = Error(r5(520), { cause: l6 });
        if (o5 = C(o5, t6), null === Bu ? Bu = [o5] : Bu.push(o5), 4 !== Wu && (Wu = 2), null === n7) return true;
        l6 = C(l6, t6), t6 = n7;
        do {
          switch (t6.tag) {
            case 3:
              return t6.flags |= 65536, e5 = a5 & -a5, t6.lanes |= e5, J(t6, e5 = Mn(t6.stateNode, l6, e5)), false;
            case 1:
              if (n7 = t6.type, o5 = t6.stateNode, 0 == (128 & t6.flags) && ("function" == typeof n7.getDerivedStateFromError || null !== o5 && "function" == typeof o5.componentDidCatch && (null === Ju || !Ju.has(o5)))) return t6.flags |= 65536, a5 &= -a5, t6.lanes |= a5, Hn(a5 = Wn(a5), e5, t6, l6), J(t6, a5), false;
          }
          t6 = t6.return;
        } while (null !== t6);
        return false;
      }(e4, l5, n6, t5, Lu)) return Wu = 1, In(e4, C(t5, e4.current)), void (Nu = null);
    } catch (n7) {
      if (null !== l5) throw Nu = l5, n7;
      return Wu = 1, In(e4, C(t5, e4.current)), void (Nu = null);
    }
    32768 & n6.flags ? Ir(n6, true) : Dr(n6);
  }
  __name(Ur, "Ur");
  function Dr(e4) {
    var n6 = e4;
    do {
      if (0 != (32768 & n6.flags)) return void Ir(n6, Iu);
      e4 = n6.return;
      var t5 = _t(n6.alternate, n6, Mu);
      if (null !== t5) return void (Nu = t5);
      if (null !== (n6 = n6.sibling)) return void (Nu = n6);
      Nu = n6 = e4;
    } while (null !== n6);
    0 === Wu && (Wu = 5);
  }
  __name(Dr, "Dr");
  function Ir(e4, n6) {
    do {
      var t5 = Rt(e4.alternate, e4);
      if (null !== t5) return t5.flags &= 32767, void (Nu = t5);
      if (null !== (t5 = e4.return) && (t5.flags |= 32768, t5.subtreeFlags = 0, t5.deletions = null), !n6 && null !== (e4 = e4.sibling)) return void (Nu = e4);
      Nu = e4 = t5;
    } while (null !== e4);
    Wu = 6, Nu = null;
  }
  __name(Ir, "Ir");
  function Fr(e4, n6, t5, l5, a5, o5, u4, i3, s5, c3) {
    var f5 = Pl.T, d4 = ql();
    try {
      $l(2), Pl.T = null, function(e5, n7, t6, l6, a6, o6) {
        do {
          Wr();
        } while (null !== Xu);
        if (0 != (6 & Ru)) throw Error(r5(327));
        var u5 = e5.finishedWork;
        if (l6 = e5.finishedLanes, null === u5) return null;
        if (e5.finishedWork = null, e5.finishedLanes = 0, u5 === e5.current) throw Error(r5(177));
        e5.callbackNode = null, e5.callbackPriority = 0, e5.cancelPendingCommit = null;
        var i4 = u5.lanes | u5.childLanes;
        if (function(e6, n8, t7, r6) {
          var l7 = e6.pendingLanes;
          e6.pendingLanes = t7, e6.suspendedLanes = 0, e6.pingedLanes = 0, e6.warmLanes = 0, e6.expiredLanes &= t7, e6.entangledLanes &= t7, e6.errorRecoveryDisabledLanes &= t7, e6.shellSuspendCounter = 0, n8 = e6.entanglements;
          var a7 = e6.expirationTimes, o7 = e6.hiddenUpdates;
          for (t7 = l7 & ~t7; 0 < t7; ) {
            var u6 = 31 - Ua(t7);
            l7 = 1 << u6, n8[u6] = 0, a7[u6] = -1;
            var i5 = o7[u6];
            if (null !== i5) for (o7[u6] = null, u6 = 0; u6 < i5.length; u6++) {
              var s7 = i5[u6];
              null !== s7 && (s7.lane &= -536870913);
            }
            t7 &= ~l7;
          }
          0 !== r6 && k3(e6, r6, 0);
        }(e5, l6, i4 |= po, o6), e5 === Tu && (Nu = Tu = null, Lu = 0), 0 == (10256 & u5.subtreeFlags) && 0 == (10256 & u5.flags) || Ku || (Ku = true, ei = i4, ni = t6, Wa(Va, function() {
          return Wr(), null;
        })), t6 = 0 != (15990 & u5.flags), 0 != (15990 & u5.subtreeFlags) || t6) {
          t6 = Pl.T, Pl.T = null, o6 = ql(), $l(2);
          var s6 = Ru;
          Ru |= 4, function(e6, n8) {
            for (Ul(e6.containerInfo), Su = n8; null !== Su; ) if (n8 = (e6 = Su).child, 0 != (1028 & e6.subtreeFlags) && null !== n8) n8.return = e6, Su = n8;
            else for (; null !== Su; ) {
              var t7 = (e6 = Su).alternate;
              switch (n8 = e6.flags, e6.tag) {
                case 0:
                case 11:
                case 15:
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                case 1:
                  if (0 != (1024 & n8) && null !== t7) {
                    n8 = void 0;
                    var l7 = e6, a7 = t7.memoizedProps;
                    t7 = t7.memoizedState;
                    var o7 = l7.stateNode;
                    try {
                      var u6 = Dn(l7.type, a7, (l7.elementType, l7.type));
                      n8 = o7.getSnapshotBeforeUpdate(u6, t7), o7.__reactInternalSnapshotBeforeUpdate = n8;
                    } catch (e7) {
                      jr(l7, l7.return, e7);
                    }
                  }
                  break;
                case 3:
                  0 != (1024 & n8) && Ol && va(e6.stateNode.containerInfo);
                  break;
                default:
                  if (0 != (1024 & n8)) throw Error(r5(163));
              }
              if (null !== (n8 = e6.sibling)) {
                n8.return = e6.return, Su = n8;
                break;
              }
              Su = e6.return;
            }
            u6 = ku, ku = false;
          }(e5, u5), Yt(u5, e5), Dl(e5.containerInfo), e5.current = u5, Qt(e5, u5.alternate, u5), Aa(), Ru = s6, $l(o6), Pl.T = t6;
        } else e5.current = u5;
        if (Ku ? (Ku = false, Xu = e5, Zu = l6) : Mr(e5, i4), 0 === (i4 = e5.pendingLanes) && (Ju = null), u5.stateNode, M(e5), null !== n7) for (a6 = e5.onRecoverableError, u5 = 0; u5 < n7.length; u5++) a6((i4 = n7[u5]).value, { componentStack: i4.stack });
        0 != (3 & Zu) && Wr(), i4 = e5.pendingLanes, 0 != (4194218 & l6) && 0 != (42 & i4) ? e5 === ri ? ti++ : (ti = 0, ri = e5) : ti = 0, W(0);
      }(e4, n6, t5, l5, d4, a5);
    } finally {
      Pl.T = f5, $l(d4);
    }
  }
  __name(Fr, "Fr");
  function Mr(e4, n6) {
    0 == (e4.pooledCacheLanes &= n6) && null != (n6 = e4.pooledCache) && (e4.pooledCache = null, St(n6));
  }
  __name(Mr, "Mr");
  function Wr() {
    if (null !== Xu) {
      var e4 = Xu, n6 = ei;
      ei = 0;
      var t5 = x(Zu), l5 = 32 > t5 ? 32 : t5;
      t5 = Pl.T;
      var a5 = ql();
      try {
        if ($l(l5), Pl.T = null, null === Xu) var o5 = false;
        else {
          l5 = ni, ni = null;
          var u4 = Xu, i3 = Zu;
          if (Xu = null, Zu = 0, 0 != (6 & Ru)) throw Error(r5(331));
          var s5 = Ru;
          Ru |= 4, cr(u4.current), rr(u4, u4.current, i3, l5), Ru = s5, W(0), Ga && Ga.onPostCommitFiberRoot, o5 = true;
        }
        return o5;
      } finally {
        $l(a5), Pl.T = t5, Mr(e4, n6);
      }
    }
    return false;
  }
  __name(Wr, "Wr");
  function Hr(e4, n6, t5) {
    n6 = C(t5, n6), null !== (e4 = Y(e4, n6 = Mn(e4.stateNode, n6, 2), 2)) && (S3(e4, 2), M(e4));
  }
  __name(Hr, "Hr");
  function jr(e4, n6, t5) {
    if (3 === e4.tag) Hr(e4, e4, t5);
    else for (; null !== n6; ) {
      if (3 === n6.tag) {
        Hr(n6, e4, t5);
        break;
      }
      if (1 === n6.tag) {
        var r6 = n6.stateNode;
        if ("function" == typeof n6.type.getDerivedStateFromError || "function" == typeof r6.componentDidCatch && (null === Ju || !Ju.has(r6))) {
          e4 = C(t5, e4), null !== (r6 = Y(n6, t5 = Wn(2), 2)) && (Hn(t5, r6, n6, e4), S3(r6, 2), M(r6));
          break;
        }
      }
      n6 = n6.return;
    }
  }
  __name(jr, "jr");
  function Ar(e4, n6, t5) {
    var r6 = e4.pingCache;
    if (null === r6) {
      r6 = e4.pingCache = new _u();
      var l5 = /* @__PURE__ */ new Set();
      r6.set(n6, l5);
    } else void 0 === (l5 = r6.get(n6)) && (l5 = /* @__PURE__ */ new Set(), r6.set(n6, l5));
    l5.has(t5) || (Fu = true, l5.add(t5), e4 = Qr.bind(null, e4, n6, t5), n6.then(e4, e4));
  }
  __name(Ar, "Ar");
  function Qr(e4, n6, t5) {
    var r6 = e4.pingCache;
    null !== r6 && r6.delete(n6), e4.pingedLanes |= e4.suspendedLanes & t5, e4.warmLanes &= ~t5, Tu === e4 && (Lu & t5) === t5 && (4 === Wu || 3 === Wu && (62914560 & Lu) === Lu && 300 > Qa() - qu ? 0 == (2 & Ru) && wr(e4, 0) : Au |= t5, Ou === Lu && (Ou = 0)), M(e4);
  }
  __name(Qr, "Qr");
  function Or(e4, n6) {
    0 === n6 && (n6 = b3()), null !== (e4 = D(e4, n6)) && (S3(e4, n6), M(e4));
  }
  __name(Or, "Or");
  function Br(e4) {
    var n6 = e4.memoizedState, t5 = 0;
    null !== n6 && (t5 = n6.retryLane), Or(e4, t5);
  }
  __name(Br, "Br");
  function Vr(e4, n6) {
    var t5 = 0;
    switch (e4.tag) {
      case 13:
        var l5 = e4.stateNode, a5 = e4.memoizedState;
        null !== a5 && (t5 = a5.retryLane);
        break;
      case 19:
        l5 = e4.stateNode;
        break;
      case 22:
        l5 = e4.stateNode._retryCache;
        break;
      default:
        throw Error(r5(314));
    }
    null !== l5 && l5.delete(n6), Or(e4, t5);
  }
  __name(Vr, "Vr");
  function $r(e4, n6, t5, r6) {
    this.tag = e4, this.key = t5, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = n6, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r6, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  __name($r, "$r");
  function qr(e4) {
    return !(!(e4 = e4.prototype) || !e4.isReactComponent);
  }
  __name(qr, "qr");
  function Yr(e4, n6) {
    var r6 = e4.alternate;
    return null === r6 ? ((r6 = t4(e4.tag, n6, e4.key, e4.mode)).elementType = e4.elementType, r6.type = e4.type, r6.stateNode = e4.stateNode, r6.alternate = e4, e4.alternate = r6) : (r6.pendingProps = n6, r6.type = e4.type, r6.flags = 0, r6.subtreeFlags = 0, r6.deletions = null), r6.flags = 31457280 & e4.flags, r6.childLanes = e4.childLanes, r6.lanes = e4.lanes, r6.child = e4.child, r6.memoizedProps = e4.memoizedProps, r6.memoizedState = e4.memoizedState, r6.updateQueue = e4.updateQueue, n6 = e4.dependencies, r6.dependencies = null === n6 ? null : { lanes: n6.lanes, firstContext: n6.firstContext }, r6.sibling = e4.sibling, r6.index = e4.index, r6.ref = e4.ref, r6.refCleanup = e4.refCleanup, r6;
  }
  __name(Yr, "Yr");
  function Gr(e4, n6) {
    e4.flags &= 31457282;
    var t5 = e4.alternate;
    return null === t5 ? (e4.childLanes = 0, e4.lanes = n6, e4.child = null, e4.subtreeFlags = 0, e4.memoizedProps = null, e4.memoizedState = null, e4.updateQueue = null, e4.dependencies = null, e4.stateNode = null) : (e4.childLanes = t5.childLanes, e4.lanes = t5.lanes, e4.child = t5.child, e4.subtreeFlags = 0, e4.deletions = null, e4.memoizedProps = t5.memoizedProps, e4.memoizedState = t5.memoizedState, e4.updateQueue = t5.updateQueue, e4.type = t5.type, n6 = t5.dependencies, e4.dependencies = null === n6 ? null : { lanes: n6.lanes, firstContext: n6.firstContext }), e4;
  }
  __name(Gr, "Gr");
  function Jr(e4, n6, l5, a5, o5, u4) {
    var i3 = 0;
    if (a5 = e4, "function" == typeof e4) qr(e4) && (i3 = 1);
    else if ("string" == typeof e4) i3 = 5;
    else e: switch (e4) {
      case dl:
        return Kr(l5.children, o5, u4, n6);
      case pl:
        i3 = 8, o5 |= 24;
        break;
      case ml:
        return (e4 = t4(12, l5, n6, 2 | o5)).elementType = ml, e4.lanes = u4, e4;
      case vl:
        return (e4 = t4(13, l5, n6, o5)).elementType = vl, e4.lanes = u4, e4;
      case Sl:
        return (e4 = t4(19, l5, n6, o5)).elementType = Sl, e4.lanes = u4, e4;
      case xl:
        return Xr(l5, o5, u4, n6);
      default:
        if ("object" == typeof e4 && null !== e4) switch (e4.$$typeof) {
          case hl:
          case yl:
            i3 = 10;
            break e;
          case gl:
            i3 = 9;
            break e;
          case bl:
            i3 = 11;
            break e;
          case kl:
            i3 = 14;
            break e;
          case wl:
            i3 = 16, a5 = null;
            break e;
        }
        i3 = 29, l5 = Error(r5(130, null === e4 ? "null" : typeof e4, "")), a5 = null;
    }
    return (n6 = t4(i3, l5, n6, o5)).elementType = e4, n6.type = a5, n6.lanes = u4, n6;
  }
  __name(Jr, "Jr");
  function Kr(e4, n6, r6, l5) {
    return (e4 = t4(7, e4, l5, n6)).lanes = r6, e4;
  }
  __name(Kr, "Kr");
  function Xr(e4, n6, l5, a5) {
    (e4 = t4(22, e4, a5, n6)).elementType = xl, e4.lanes = l5;
    var o5 = { _visibility: 1, _pendingVisibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null, _current: null, detach: /* @__PURE__ */ __name(function() {
      var e5 = o5._current;
      if (null === e5) throw Error(r5(456));
      if (0 == (2 & o5._pendingVisibility)) {
        var n7 = D(e5, 2);
        null !== n7 && (o5._pendingVisibility |= 2, hr(n7, 0, 2));
      }
    }, "detach"), attach: /* @__PURE__ */ __name(function() {
      var e5 = o5._current;
      if (null === e5) throw Error(r5(456));
      if (0 != (2 & o5._pendingVisibility)) {
        var n7 = D(e5, 2);
        null !== n7 && (o5._pendingVisibility &= -3, hr(n7, 0, 2));
      }
    }, "attach") };
    return e4.stateNode = o5, e4;
  }
  __name(Xr, "Xr");
  function Zr(e4, n6, r6) {
    return (e4 = t4(6, e4, null, n6)).lanes = r6, e4;
  }
  __name(Zr, "Zr");
  function el(e4, n6, r6) {
    return (n6 = t4(4, null !== e4.children ? e4.children : [], e4.key, n6)).lanes = r6, n6.stateNode = { containerInfo: e4.containerInfo, pendingChildren: null, implementation: e4.implementation }, n6;
  }
  __name(el, "el");
  function nl(e4, n6, t5, r6, l5, a5, o5, u4) {
    this.tag = 1, this.containerInfo = e4, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Ql, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = v3(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = v3(0), this.hiddenUpdates = v3(null), this.identifierPrefix = r6, this.onUncaughtError = l5, this.onCaughtError = a5, this.onRecoverableError = o5, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = u4, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  __name(nl, "nl");
  function tl(e4, n6, t5, r6, l5, a5) {
    l5 = function(e5) {
      return e5 ? e5 = La : La;
    }(l5), null === r6.context ? r6.context = l5 : r6.pendingContext = l5, (r6 = q(n6)).payload = { element: t5 }, null !== (a5 = void 0 === a5 ? null : a5) && (r6.callback = a5), null !== (t5 = Y(e4, r6, n6)) && (hr(t5, 0, n6), G2(t5, e4, n6));
  }
  __name(tl, "tl");
  var rl, ll, al = {}, ol = import_react.default, ul = u, il = Object.assign, sl = Symbol.for("react.element"), cl = Symbol.for("react.transitional.element"), fl = Symbol.for("react.portal"), dl = Symbol.for("react.fragment"), pl = Symbol.for("react.strict_mode"), ml = Symbol.for("react.profiler"), hl = Symbol.for("react.provider"), gl = Symbol.for("react.consumer"), yl = Symbol.for("react.context"), bl = Symbol.for("react.forward_ref"), vl = Symbol.for("react.suspense"), Sl = Symbol.for("react.suspense_list"), kl = Symbol.for("react.memo"), wl = Symbol.for("react.lazy"), xl = Symbol.for("react.offscreen"), zl = Symbol.for("react.memo_cache_sentinel"), Cl = Symbol.iterator, El = Symbol.for("react.client.reference"), Pl = ol.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, _l = false, Rl = Array.isArray, Tl = n5.getPublicInstance, Nl = n5.getRootHostContext, Ll = n5.getChildHostContext, Ul = n5.prepareForCommit, Dl = n5.resetAfterCommit, Il = n5.createInstance, Fl = n5.appendInitialChild, Ml = n5.finalizeInitialChildren, Wl = n5.shouldSetTextContent, Hl = n5.createTextInstance, jl = null, Al = null, Ql = n5.noTimeout, Ol = true, Bl = null, Vl = null, $l = n5.setCurrentUpdatePriority, ql = n5.getCurrentUpdatePriority, Yl = n5.resolveUpdatePriority;
  n5.resolveEventType, n5.resolveEventTimeStamp;
  var Gl = n5.shouldAttemptEagerTransition, Jl = n5.detachDeletedInstance;
  n5.requestPostPaintCallback;
  var Kl = n5.maySuspendCommit, Xl = null, Zl = null, ea = null, na = null, ta = null, ra = null, la = null, aa = n5.appendChild, oa = n5.appendChildToContainer, ua = n5.commitTextUpdate, ia = null, sa = n5.commitUpdate, ca = n5.insertBefore, fa = null, da = n5.removeChild, pa = n5.removeChildFromContainer, ma = n5.resetTextContent, ha = null, ga = null, ya = null, ba = null, va = n5.clearContainer, Sa = null, ka = null, wa = null, xa = null, za = null, Ca = null, Ea = null, Pa = null, _a = null, Ra = null, Ta = [], Na = -1, La = {}, Ua = Math.clz32 ? Math.clz32 : function(e4) {
    return 0 == (e4 >>>= 0) ? 32 : 31 - (Da(e4) / Ia | 0) | 0;
  }, Da = Math.log, Ia = Math.LN2, Fa = 128, Ma = 4194304, Wa = ul.unstable_scheduleCallback, Ha = ul.unstable_cancelCallback, ja = ul.unstable_shouldYield, Aa = ul.unstable_requestPaint, Qa = ul.unstable_now, Oa = ul.unstable_ImmediatePriority, Ba = ul.unstable_UserBlockingPriority, Va = ul.unstable_NormalPriority, $a = ul.unstable_IdlePriority, qa = ul.log, Ya = ul.unstable_setDisableYieldValue, Ga = null, Ja = "function" == typeof Object.is ? Object.is : function(e4, n6) {
    return e4 === n6 && (0 !== e4 || 1 / e4 == 1 / n6) || e4 != e4 && n6 != n6;
  }, Ka = /* @__PURE__ */ new WeakMap(), Xa = [], Za = 0, eo = null, no = [], to = 0, ro = null, lo = f4(null), ao = f4(null), oo = f4(null), uo = f4(null), io = false, so = null;
  Error(r5(519));
  var co = [], fo = 0, po = 0, mo = null, ho = null, go = false, yo = false, bo = false, vo = 0, So = null, ko = 0, wo = 0, xo = null, zo = false, Co = false, Eo = Object.prototype.hasOwnProperty, Po = Error(r5(460)), _o = Error(r5(474)), Ro = { then: /* @__PURE__ */ __name(function() {
  }, "then") }, To = null, No = null, Lo = 0, Uo = ce(true), Do = ce(false), Io = f4(null), Fo = f4(0), Mo = f4(null), Wo = null, Ho = f4(0), jo = 0, Ao = null, Qo = null, Oo = null, Bo = false, Vo = false, $o = false, qo = 0, Yo = 0, Go = null, Jo = 0, Ko = /* @__PURE__ */ __name(function() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }, "Ko"), Xo = { readContext: gt, use: Ne, useCallback: ve, useContext: ve, useEffect: ve, useImperativeHandle: ve, useLayoutEffect: ve, useInsertionEffect: ve, useMemo: ve, useReducer: ve, useRef: ve, useState: ve, useDebugValue: ve, useDeferredValue: ve, useTransition: ve, useSyncExternalStore: ve, useId: ve };
  Xo.useCacheRefresh = ve, Xo.useMemoCache = ve, Xo.useHostTransitionStatus = ve, Xo.useFormState = ve, Xo.useActionState = ve, Xo.useOptimistic = ve;
  var Zo = { readContext: gt, use: Ne, useCallback: /* @__PURE__ */ __name(function(e4, n6) {
    return _e().memoizedState = [e4, void 0 === n6 ? null : n6], e4;
  }, "useCallback"), useContext: gt, useEffect: un, useImperativeHandle: /* @__PURE__ */ __name(function(e4, n6, t5) {
    t5 = null != t5 ? t5.concat([e4]) : null, an(4194308, 4, dn.bind(null, n6, e4), t5);
  }, "useImperativeHandle"), useLayoutEffect: /* @__PURE__ */ __name(function(e4, n6) {
    return an(4194308, 4, e4, n6);
  }, "useLayoutEffect"), useInsertionEffect: /* @__PURE__ */ __name(function(e4, n6) {
    an(4, 2, e4, n6);
  }, "useInsertionEffect"), useMemo: /* @__PURE__ */ __name(function(e4, n6) {
    var t5 = _e();
    n6 = void 0 === n6 ? null : n6;
    var r6 = e4();
    if ($o) {
      z(true);
      try {
        e4();
      } finally {
        z(false);
      }
    }
    return t5.memoizedState = [r6, n6], r6;
  }, "useMemo"), useReducer: /* @__PURE__ */ __name(function(e4, n6, t5) {
    var r6 = _e();
    if (void 0 !== t5) {
      var l5 = t5(n6);
      if ($o) {
        z(true);
        try {
          t5(n6);
        } finally {
          z(false);
        }
      }
    } else l5 = n6;
    return r6.memoizedState = r6.baseState = l5, e4 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: e4, lastRenderedState: l5 }, r6.queue = e4, e4 = e4.dispatch = zn.bind(null, Ao, e4), [r6.memoizedState, e4];
  }, "useReducer"), useRef: /* @__PURE__ */ __name(function(e4) {
    return e4 = { current: e4 }, _e().memoizedState = e4;
  }, "useRef"), useState: /* @__PURE__ */ __name(function(e4) {
    var n6 = (e4 = Oe(e4)).queue, t5 = Cn.bind(null, Ao, n6);
    return n6.dispatch = t5, [e4.memoizedState, t5];
  }, "useState"), useDebugValue: mn, useDeferredValue: /* @__PURE__ */ __name(function(e4, n6) {
    return yn(_e(), e4, n6);
  }, "useDeferredValue"), useTransition: /* @__PURE__ */ __name(function() {
    var e4 = Oe(false);
    return e4 = vn.bind(null, Ao, e4.queue, true, false), _e().memoizedState = e4, [false, e4];
  }, "useTransition"), useSyncExternalStore: /* @__PURE__ */ __name(function(e4, n6, t5) {
    var l5 = Ao, a5 = _e();
    if (t5 = n6(), null === Tu) throw Error(r5(349));
    0 != (60 & Lu) || We(l5, n6, t5), a5.memoizedState = t5;
    var o5 = { value: t5, getSnapshot: n6 };
    return a5.queue = o5, un(je.bind(null, l5, o5, e4), [e4]), l5.flags |= 2048, rn(9, He.bind(null, l5, o5, t5, n6), { destroy: void 0 }, null), t5;
  }, "useSyncExternalStore"), useId: /* @__PURE__ */ __name(function() {
    var e4 = _e(), n6 = Tu.identifierPrefix;
    return n6 = ":" + n6 + "r" + (Jo++).toString(32) + ":", e4.memoizedState = n6;
  }, "useId"), useCacheRefresh: /* @__PURE__ */ __name(function() {
    return _e().memoizedState = xn.bind(null, Ao);
  }, "useCacheRefresh") };
  Zo.useMemoCache = Le, Zo.useHostTransitionStatus = Sn, Zo.useFormState = Xe, Zo.useActionState = Xe, Zo.useOptimistic = function(e4) {
    var n6 = _e();
    n6.memoizedState = n6.baseState = e4;
    var t5 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null };
    return n6.queue = t5, n6 = Pn.bind(null, Ao, true, t5), t5.dispatch = n6, [e4, n6];
  };
  var eu = { readContext: gt, use: Ne, useCallback: hn, useContext: gt, useEffect: sn, useImperativeHandle: pn, useInsertionEffect: cn, useLayoutEffect: fn, useMemo: gn, useReducer: De, useRef: ln, useState: /* @__PURE__ */ __name(function() {
    return De(Ue);
  }, "useState"), useDebugValue: mn, useDeferredValue: /* @__PURE__ */ __name(function(e4, n6) {
    return bn(Re(), Qo.memoizedState, e4, n6);
  }, "useDeferredValue"), useTransition: /* @__PURE__ */ __name(function() {
    var e4 = De(Ue)[0], n6 = Re().memoizedState;
    return ["boolean" == typeof e4 ? e4 : Te(e4), n6];
  }, "useTransition"), useSyncExternalStore: Me, useId: kn };
  eu.useCacheRefresh = wn, eu.useMemoCache = Le, eu.useHostTransitionStatus = Sn, eu.useFormState = Ze, eu.useActionState = Ze, eu.useOptimistic = function(e4, n6) {
    return Be(Re(), 0, e4, n6);
  };
  var nu = { readContext: gt, use: Ne, useCallback: hn, useContext: gt, useEffect: sn, useImperativeHandle: pn, useInsertionEffect: cn, useLayoutEffect: fn, useMemo: gn, useReducer: Fe, useRef: ln, useState: /* @__PURE__ */ __name(function() {
    return Fe(Ue);
  }, "useState"), useDebugValue: mn, useDeferredValue: /* @__PURE__ */ __name(function(e4, n6) {
    var t5 = Re();
    return null === Qo ? yn(t5, e4, n6) : bn(t5, Qo.memoizedState, e4, n6);
  }, "useDeferredValue"), useTransition: /* @__PURE__ */ __name(function() {
    var e4 = Fe(Ue)[0], n6 = Re().memoizedState;
    return ["boolean" == typeof e4 ? e4 : Te(e4), n6];
  }, "useTransition"), useSyncExternalStore: Me, useId: kn };
  nu.useCacheRefresh = wn, nu.useMemoCache = Le, nu.useHostTransitionStatus = Sn, nu.useFormState = tn, nu.useActionState = tn, nu.useOptimistic = function(e4, n6) {
    var t5 = Re();
    return null !== Qo ? Be(t5, 0, e4, n6) : (t5.baseState = e4, [e4, t5.queue.dispatch]);
  };
  var tu = { isMounted: /* @__PURE__ */ __name(function(e4) {
    return !!(e4 = e4._reactInternals) && function(e5) {
      var n6 = e5, t5 = e5;
      if (e5.alternate) for (; n6.return; ) n6 = n6.return;
      else {
        e5 = n6;
        do {
          0 != (4098 & (n6 = e5).flags) && (t5 = n6.return), e5 = n6.return;
        } while (e5);
      }
      return 3 === n6.tag ? t5 : null;
    }(e4) === e4;
  }, "isMounted"), enqueueSetState: /* @__PURE__ */ __name(function(e4, n6, t5) {
    e4 = e4._reactInternals;
    var r6 = pr(), l5 = q(r6);
    l5.payload = n6, null != t5 && (l5.callback = t5), null !== (n6 = Y(e4, l5, r6)) && (hr(n6, 0, r6), G2(n6, e4, r6));
  }, "enqueueSetState"), enqueueReplaceState: /* @__PURE__ */ __name(function(e4, n6, t5) {
    e4 = e4._reactInternals;
    var r6 = pr(), l5 = q(r6);
    l5.tag = 1, l5.payload = n6, null != t5 && (l5.callback = t5), null !== (n6 = Y(e4, l5, r6)) && (hr(n6, 0, r6), G2(n6, e4, r6));
  }, "enqueueReplaceState"), enqueueForceUpdate: /* @__PURE__ */ __name(function(e4, n6) {
    e4 = e4._reactInternals;
    var t5 = pr(), r6 = q(t5);
    r6.tag = 2, null != n6 && (r6.callback = n6), null !== (n6 = Y(e4, r6, t5)) && (hr(n6, 0, t5), G2(n6, e4, t5));
  }, "enqueueForceUpdate") };
  "function" == typeof reportError && reportError;
  var ru = Error(r5(461)), lu = false, au = { dehydrated: null, treeContext: null, retryLane: 0 }, ou = f4(null), uu = null, iu = null, su = null, cu = "undefined" != typeof AbortController ? AbortController : function() {
    var e4 = [], n6 = this.signal = { aborted: false, addEventListener: /* @__PURE__ */ __name(function(n7, t5) {
      e4.push(t5);
    }, "addEventListener") };
    this.abort = function() {
      n6.aborted = true, e4.forEach(function(e5) {
        return e5();
      });
    };
  }, fu = ul.unstable_scheduleCallback, du = ul.unstable_NormalPriority, pu = { $$typeof: yl, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }, mu = Pl.S;
  Pl.S = function(e4, n6) {
    "object" == typeof n6 && null !== n6 && "function" == typeof n6.then && function(e5, n7) {
      if (null === So) {
        var t5 = So = [];
        ko = 0, wo = O(), xo = { status: "pending", value: void 0, then: /* @__PURE__ */ __name(function(e6) {
          t5.push(e6);
        }, "then") };
      }
      ko++, n7.then(B, B);
    }(0, n6), null !== mu && mu(e4, n6);
  };
  var hu = f4(null), gu = false, yu = false, bu = false, vu = "function" == typeof WeakSet ? WeakSet : Set, Su = null, ku = false, wu = null, xu = false, zu = null, Cu = 8192, Eu = { getCacheForType: /* @__PURE__ */ __name(function(e4) {
    var n6 = gt(pu), t5 = n6.data.get(e4);
    return void 0 === t5 && (t5 = e4(), n6.data.set(e4, t5)), t5;
  }, "getCacheForType") };
  if ("function" == typeof Symbol && Symbol.for) {
    var Pu = Symbol.for;
    Pu("selector.component"), Pu("selector.has_pseudo_class"), Pu("selector.role"), Pu("selector.test_id"), Pu("selector.text");
  }
  var _u = "function" == typeof WeakMap ? WeakMap : Map, Ru = 0, Tu = null, Nu = null, Lu = 0, Uu = 0, Du = null, Iu = false, Fu = false, Mu = 0, Wu = 0, Hu = 0, ju = 0, Au = 0, Qu = 0, Ou = 0, Bu = null, Vu = null, $u = false, qu = 0, Yu = 1 / 0, Gu = null, Ju = null, Ku = false, Xu = null, Zu = 0, ei = 0, ni = null, ti = 0, ri = null;
  return al.createContainer = function(e4, n6, r6, l5, a5, o5, u4, i3, s5, c3) {
    return function(e5, n7, r7, l6, a6, o6, u5, i4, s6, c4, f5, d4) {
      return e5 = new nl(e5, n7, r7, u5, i4, s6, c4, null), n7 = 1, true === o6 && (n7 |= 24), o6 = t4(3, null, null, n7), e5.current = o6, o6.stateNode = e5, (n7 = vt()).refCount++, e5.pooledCache = n7, n7.refCount++, o6.memoizedState = { element: l6, isDehydrated: r7, cache: n7 }, V(o6), e5;
    }(e4, n6, false, null, 0, l5, o5, u4, i3, s5);
  }, al.flushSyncWork = function() {
    return 0 != (6 & Ru) || (W(0), false);
  }, al.updateContainer = function(e4, n6, t5, r6) {
    var l5 = n6.current, a5 = pr();
    return tl(l5, a5, e4, n6, t5, r6), a5;
  }, al.updateContainerSync = function(e4, n6, t5, r6) {
    return 0 === n6.tag && Wr(), tl(n6.current, 2, e4, n6, t5, r6), 2;
  }, al;
}, s.exports.default = s.exports, Object.defineProperty(s.exports, "__esModule", { value: true })), o.exports) : a.exports = function() {
  return i || (i = 1, n5 = c, false), c.exports;
  var n5;
}();
var f;
var d = t(a.exports);
var p = { exports: {} };
var m = {};
true ? p.exports = (f || (f = 1, m.ConcurrentRoot = 1, m.ContinuousEventPriority = 8, m.DefaultEventPriority = 32, m.DiscreteEventPriority = 2, m.IdleEventPriority = 268435456, m.LegacyRoot = 0, m.NoEventPriority = 0), m) : p.exports = (h || (h = 1, false), g);
var y = p.exports;
var b = /* @__PURE__ */ __name((e4, n5) => {
  const t4 = Object.keys(e4), r5 = Object.keys(n5);
  if (t4.length !== r5.length) return false;
  for (let r6 = 0; r6 < t4.length; r6 += 1) {
    const l4 = t4[r6];
    if ("render" === l4 && !e4[l4] != !n5[l4]) return false;
    if ("children" !== l4 && e4[l4] !== n5[l4]) {
      if ("object" == typeof e4[l4] && "object" == typeof n5[l4] && b(e4[l4], n5[l4])) continue;
      return false;
    }
    if ("children" === l4 && ("string" == typeof e4[l4] || "string" == typeof n5[l4])) return e4[l4] === n5[l4];
  }
  return true;
}, "b");
var v = {};
var S = console.error;
var k = /* @__PURE__ */ __name(({ appendChild: e4, appendChildToContainer: n5, commitTextUpdate: t4, commitUpdate: r5, createInstance: l4, createTextInstance: a4, insertBefore: o4, removeChild: u4, removeChildFromContainer: i2, resetAfterCommit: s4 }) => {
  const c2 = d({ appendChild: e4, appendChildToContainer: n5, appendInitialChild: e4, createInstance: l4, createTextInstance: a4, insertBefore: o4, commitUpdate: /* @__PURE__ */ __name((e5, n6, t5, l5) => {
    b(t5, l5) || r5(e5, null, n6, t5, l5);
  }, "commitUpdate"), commitTextUpdate: t4, removeChild: u4, removeChildFromContainer: i2, resetAfterCommit: s4, noTimeout: -1, shouldSetTextContent: /* @__PURE__ */ __name(() => false, "shouldSetTextContent"), finalizeInitialChildren: /* @__PURE__ */ __name(() => false, "finalizeInitialChildren"), getPublicInstance: /* @__PURE__ */ __name((e5) => e5, "getPublicInstance"), getRootHostContext: /* @__PURE__ */ __name(() => v, "getRootHostContext"), getChildHostContext: /* @__PURE__ */ __name(() => v, "getChildHostContext"), prepareForCommit() {
  }, clearContainer() {
  }, resetTextContent() {
  }, getCurrentUpdatePriority: /* @__PURE__ */ __name(() => y.DefaultEventPriority, "getCurrentUpdatePriority"), maySuspendCommit: /* @__PURE__ */ __name(() => false, "maySuspendCommit"), requestPostPaintCallback: /* @__PURE__ */ __name(() => {
  }, "requestPostPaintCallback"), resolveUpdatePriority: /* @__PURE__ */ __name(() => y.DefaultEventPriority, "resolveUpdatePriority"), setCurrentUpdatePriority: /* @__PURE__ */ __name(() => {
  }, "setCurrentUpdatePriority"), shouldAttemptEagerTransition: /* @__PURE__ */ __name(() => false, "shouldAttemptEagerTransition"), detachDeletedInstance: /* @__PURE__ */ __name(() => {
  }, "detachDeletedInstance") });
  return { createContainer: /* @__PURE__ */ __name((e5) => c2.createContainer(e5, y.ConcurrentRoot, null, false, null, "", S, S, S, null), "createContainer"), updateContainer: /* @__PURE__ */ __name((e5, n6, t5, r6) => {
    c2.updateContainerSync(e5, n6, t5, r6), c2.flushSyncWork();
  }, "updateContainer") };
}, "k");

// ../../node_modules/.pnpm/@react-pdf+reconciler@2.0.0_react@19.2.0/node_modules/@react-pdf/reconciler/lib/reconciler-33.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_react2 = __toESM(require_react(), 1);
var n2 = __toESM(require_scheduler(), 1);
function t2(e4) {
  return e4 && e4.__esModule && Object.prototype.hasOwnProperty.call(e4, "default") ? e4.default : e4;
}
__name(t2, "t");
function r3(e4) {
  if (e4.__esModule) return e4;
  var n5 = e4.default;
  if ("function" == typeof n5) {
    var t4 = /* @__PURE__ */ __name(function e5() {
      return this instanceof e5 ? Reflect.construct(n5, arguments, this.constructor) : n5.apply(this, arguments);
    }, "e");
    t4.prototype = n5.prototype;
  } else t4 = {};
  return Object.defineProperty(t4, "__esModule", { value: true }), Object.keys(e4).forEach(function(n6) {
    var r5 = Object.getOwnPropertyDescriptor(e4, n6);
    Object.defineProperty(t4, n6, r5.get ? r5 : { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return e4[n6];
    }, "get") });
  }), t4;
}
__name(r3, "r");
var l2;
var a2 = { exports: {} };
var o2 = { exports: {} };
var u2 = r3(n2);
var s2;
true ? a2.exports = (l2 || (l2 = 1, (s2 = o2).exports = function(n5) {
  function t4(e4, n6, t5, r6) {
    return new tl(e4, n6, t5, r6);
  }
  __name(t4, "t");
  function r5(e4) {
    var n6 = "https://react.dev/errors/" + e4;
    if (1 < arguments.length) {
      n6 += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var t5 = 2; t5 < arguments.length; t5++) n6 += "&args[]=" + encodeURIComponent(arguments[t5]);
    }
    return "Minified React error #" + e4 + "; visit " + n6 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  __name(r5, "r");
  function l4(e4) {
    return null === e4 || "object" != typeof e4 ? null : "function" == typeof (e4 = Nl && e4[Nl] || e4["@@iterator"]) ? e4 : null;
  }
  __name(l4, "l");
  function a4(e4) {
    if (null == e4) return null;
    if ("function" == typeof e4) return e4.$$typeof === Ll ? null : e4.displayName || e4.name || null;
    if ("string" == typeof e4) return e4;
    switch (e4) {
      case vl:
        return "Fragment";
      case kl:
        return "Profiler";
      case Sl:
        return "StrictMode";
      case El:
        return "Suspense";
      case Cl:
        return "SuspenseList";
      case Tl:
        return "Activity";
    }
    if ("object" == typeof e4) switch (e4.$$typeof) {
      case bl:
        return "Portal";
      case zl:
        return e4.displayName || "Context";
      case wl:
        return (e4._context.displayName || "Context") + ".Consumer";
      case xl:
        var n6 = e4.render;
        return (e4 = e4.displayName) || (e4 = "" !== (e4 = n6.displayName || n6.name || "") ? "ForwardRef(" + e4 + ")" : "ForwardRef"), e4;
      case Pl:
        return null !== (n6 = e4.displayName || null) ? n6 : a4(e4.type) || "Memo";
      case _l:
        n6 = e4._payload, e4 = e4._init;
        try {
          return a4(e4(n6));
        } catch (e5) {
        }
    }
    return null;
  }
  __name(a4, "a");
  function o4(e4) {
    return { current: e4 };
  }
  __name(o4, "o");
  function i2(e4) {
    0 > Ma || (e4.current = Oa[Ma], Oa[Ma] = null, Ma--);
  }
  __name(i2, "i");
  function s4(e4, n6) {
    Ma++, Oa[Ma] = e4.current, e4.current = n6;
  }
  __name(s4, "s");
  function c2(e4) {
    var n6 = 42 & e4;
    if (0 !== n6) return n6;
    switch (e4 & -e4) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return 261888 & e4;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return 3932160 & e4;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return 62914560 & e4;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return e4;
    }
  }
  __name(c2, "c");
  function d3(e4, n6, t5) {
    var r6 = e4.pendingLanes;
    if (0 === r6) return 0;
    var l5 = 0, a5 = e4.suspendedLanes, o5 = e4.pingedLanes;
    e4 = e4.warmLanes;
    var u4 = 134217727 & r6;
    return 0 !== u4 ? 0 != (r6 = u4 & ~a5) ? l5 = c2(r6) : 0 != (o5 &= u4) ? l5 = c2(o5) : t5 || 0 != (t5 = u4 & ~e4) && (l5 = c2(t5)) : 0 != (u4 = r6 & ~a5) ? l5 = c2(u4) : 0 !== o5 ? l5 = c2(o5) : t5 || 0 != (t5 = r6 & ~e4) && (l5 = c2(t5)), 0 === l5 ? 0 : 0 !== n6 && n6 !== l5 && 0 == (n6 & a5) && ((a5 = l5 & -l5) >= (t5 = n6 & -n6) || 32 === a5 && 0 != (4194048 & t5)) ? n6 : l5;
  }
  __name(d3, "d");
  function f4(e4, n6) {
    return 0 == (e4.pendingLanes & ~(e4.suspendedLanes & ~e4.pingedLanes) & n6);
  }
  __name(f4, "f");
  function p3(e4, n6) {
    switch (e4) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return n6 + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return n6 + 5e3;
      default:
        return -1;
    }
  }
  __name(p3, "p");
  function m3() {
    var e4 = Ya;
    return 0 == (62914560 & (Ya <<= 1)) && (Ya = 4194304), e4;
  }
  __name(m3, "m");
  function h(e4) {
    for (var n6 = [], t5 = 0; 31 > t5; t5++) n6.push(e4);
    return n6;
  }
  __name(h, "h");
  function g(e4, n6) {
    e4.pendingLanes |= n6, 268435456 !== n6 && (e4.suspendedLanes = 0, e4.pingedLanes = 0, e4.warmLanes = 0);
  }
  __name(g, "g");
  function y3(e4, n6, t5) {
    e4.pendingLanes |= n6, e4.suspendedLanes &= ~n6;
    var r6 = 31 - Qa(n6);
    e4.entangledLanes |= n6, e4.entanglements[r6] = 1073741824 | e4.entanglements[r6] | 261930 & t5;
  }
  __name(y3, "y");
  function b3(e4, n6) {
    var t5 = e4.entangledLanes |= n6;
    for (e4 = e4.entanglements; t5; ) {
      var r6 = 31 - Qa(t5), l5 = 1 << r6;
      l5 & n6 | e4[r6] & n6 && (e4[r6] |= n6), t5 &= ~l5;
    }
  }
  __name(b3, "b");
  function v3(e4, n6) {
    var t5 = n6 & -n6;
    return 0 != ((t5 = 0 != (42 & t5) ? 1 : function(e5) {
      switch (e5) {
        case 2:
          e5 = 1;
          break;
        case 8:
          e5 = 4;
          break;
        case 32:
          e5 = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          e5 = 128;
          break;
        case 268435456:
          e5 = 134217728;
          break;
        default:
          e5 = 0;
      }
      return e5;
    }(t5)) & (e4.suspendedLanes | n6)) ? 0 : t5;
  }
  __name(v3, "v");
  function S3(e4) {
    return 2 < (e4 &= -e4) ? 8 < e4 ? 0 != (134217727 & e4) ? 32 : 268435456 : 8 : 2;
  }
  __name(S3, "S");
  function k3(e4) {
    "function" == typeof lo && ao(e4);
  }
  __name(k3, "k");
  function w(e4) {
    if (void 0 === io) try {
      throw Error();
    } catch (e5) {
      var n6 = e5.stack.trim().match(/\n( *(at )?)/);
      io = n6 && n6[1] || "", so = -1 < e5.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < e5.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
    return "\n" + io + e4 + so;
  }
  __name(w, "w");
  function z(e4, n6) {
    if (!e4 || fo) return "";
    fo = true;
    var t5 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var r6 = { DetermineComponentFrameRoot: /* @__PURE__ */ __name(function() {
        try {
          if (n6) {
            var t6 = /* @__PURE__ */ __name(function() {
              throw Error();
            }, "t");
            if (Object.defineProperty(t6.prototype, "props", { set: /* @__PURE__ */ __name(function() {
              throw Error();
            }, "set") }), "object" == typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(t6, []);
              } catch (e5) {
                var r7 = e5;
              }
              Reflect.construct(e4, [], t6);
            } else {
              try {
                t6.call();
              } catch (e5) {
                r7 = e5;
              }
              e4.call(t6.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (e5) {
              r7 = e5;
            }
            (t6 = e4()) && "function" == typeof t6.catch && t6.catch(function() {
            });
          }
        } catch (e5) {
          if (e5 && r7 && "string" == typeof e5.stack) return [e5.stack, r7.stack];
        }
        return [null, null];
      }, "DetermineComponentFrameRoot") };
      r6.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var l5 = Object.getOwnPropertyDescriptor(r6.DetermineComponentFrameRoot, "name");
      l5 && l5.configurable && Object.defineProperty(r6.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
      var a5 = r6.DetermineComponentFrameRoot(), o5 = a5[0], u4 = a5[1];
      if (o5 && u4) {
        var i3 = o5.split("\n"), s5 = u4.split("\n");
        for (l5 = r6 = 0; r6 < i3.length && !i3[r6].includes("DetermineComponentFrameRoot"); ) r6++;
        for (; l5 < s5.length && !s5[l5].includes("DetermineComponentFrameRoot"); ) l5++;
        if (r6 === i3.length || l5 === s5.length) for (r6 = i3.length - 1, l5 = s5.length - 1; 1 <= r6 && 0 <= l5 && i3[r6] !== s5[l5]; ) l5--;
        for (; 1 <= r6 && 0 <= l5; r6--, l5--) if (i3[r6] !== s5[l5]) {
          if (1 !== r6 || 1 !== l5) do {
            if (r6--, 0 > --l5 || i3[r6] !== s5[l5]) {
              var c3 = "\n" + i3[r6].replace(" at new ", " at ");
              return e4.displayName && c3.includes("<anonymous>") && (c3 = c3.replace("<anonymous>", e4.displayName)), c3;
            }
          } while (1 <= r6 && 0 <= l5);
          break;
        }
      }
    } finally {
      fo = false, Error.prepareStackTrace = t5;
    }
    return (t5 = e4 ? e4.displayName || e4.name : "") ? w(t5) : "";
  }
  __name(z, "z");
  function x(e4, n6) {
    switch (e4.tag) {
      case 26:
      case 27:
      case 5:
        return w(e4.type);
      case 16:
        return w("Lazy");
      case 13:
        return e4.child !== n6 && null !== n6 ? w("Suspense Fallback") : w("Suspense");
      case 19:
        return w("SuspenseList");
      case 0:
      case 15:
        return z(e4.type, false);
      case 11:
        return z(e4.type.render, false);
      case 1:
        return z(e4.type, true);
      case 31:
        return w("Activity");
      default:
        return "";
    }
  }
  __name(x, "x");
  function E(e4) {
    try {
      var n6 = "", t5 = null;
      do {
        n6 += x(e4, t5), t5 = e4, e4 = e4.return;
      } while (e4);
      return n6;
    } catch (e5) {
      return "\nError generating stack: " + e5.message + "\n" + e5.stack;
    }
  }
  __name(E, "E");
  function C(e4, n6) {
    if ("object" == typeof e4 && null !== e4) {
      var t5 = po.get(e4);
      return void 0 !== t5 ? t5 : (n6 = { value: e4, source: n6, stack: E(n6) }, po.set(e4, n6), n6);
    }
    return { value: e4, source: n6, stack: E(n6) };
  }
  __name(C, "C");
  function P(e4) {
    for (; e4 === go; ) go = mo[--ho], mo[ho] = null, mo[--ho], mo[ho] = null;
    for (; e4 === vo; ) vo = yo[--bo], yo[bo] = null, yo[--bo], yo[bo] = null, yo[--bo], yo[bo] = null;
  }
  __name(P, "P");
  function _(e4, n6) {
    s4(wo, n6), s4(ko, e4), s4(So, null), e4 = Fl(n6), i2(So), s4(So, e4);
  }
  __name(_, "_");
  function T() {
    i2(So), i2(ko), i2(wo);
  }
  __name(T, "T");
  function R(e4) {
    null !== e4.memoizedState && s4(zo, e4);
    var n6 = So.current, t5 = jl(n6, e4.type);
    n6 !== t5 && (s4(ko, e4), s4(So, t5));
  }
  __name(R, "R");
  function N(e4) {
    ko.current === e4 && (i2(So), i2(ko)), zo.current === e4 && (i2(zo), ca._currentValue2 = sa);
  }
  __name(N, "N");
  function L() {
    var e4 = Eo;
    return null !== e4 && (null === li ? li = e4 : li.push.apply(li, e4), Eo = null), e4;
  }
  __name(L, "L");
  function U(e4, n6, t5) {
    s4(Co, n6._currentValue2), n6._currentValue2 = t5;
  }
  __name(U, "U");
  function D(e4) {
    var n6 = Co.current;
    e4._currentValue2 = n6, i2(Co);
  }
  __name(D, "D");
  function I(e4, n6, t5) {
    for (; null !== e4; ) {
      var r6 = e4.alternate;
      if ((e4.childLanes & n6) !== n6 ? (e4.childLanes |= n6, null !== r6 && (r6.childLanes |= n6)) : null !== r6 && (r6.childLanes & n6) !== n6 && (r6.childLanes |= n6), e4 === t5) break;
      e4 = e4.return;
    }
  }
  __name(I, "I");
  function F(e4, n6, t5, l5) {
    var a5 = e4.child;
    for (null !== a5 && (a5.return = e4); null !== a5; ) {
      var o5 = a5.dependencies;
      if (null !== o5) {
        var u4 = a5.child;
        o5 = o5.firstContext;
        e: for (; null !== o5; ) {
          var i3 = o5;
          o5 = a5;
          for (var s5 = 0; s5 < n6.length; s5++) if (i3.context === n6[s5]) {
            o5.lanes |= t5, null !== (i3 = o5.alternate) && (i3.lanes |= t5), I(o5.return, t5, e4), l5 || (u4 = null);
            break e;
          }
          o5 = i3.next;
        }
      } else if (18 === a5.tag) {
        if (null === (u4 = a5.return)) throw Error(r5(341));
        u4.lanes |= t5, null !== (o5 = u4.alternate) && (o5.lanes |= t5), I(u4, t5, e4), u4 = null;
      } else u4 = a5.child;
      if (null !== u4) u4.return = a5;
      else for (u4 = a5; null !== u4; ) {
        if (u4 === e4) {
          u4 = null;
          break;
        }
        if (null !== (a5 = u4.sibling)) {
          a5.return = u4.return, u4 = a5;
          break;
        }
        u4 = u4.return;
      }
      a5 = u4;
    }
  }
  __name(F, "F");
  function j(e4, n6, t5, l5) {
    e4 = null;
    for (var a5 = n6, o5 = false; null !== a5; ) {
      if (!o5) {
        if (0 != (524288 & a5.flags)) o5 = true;
        else if (0 != (262144 & a5.flags)) break;
      }
      if (10 === a5.tag) {
        var u4 = a5.alternate;
        if (null === u4) throw Error(r5(387));
        if (null !== (u4 = u4.memoizedProps)) {
          var i3 = a5.type;
          uo(a5.pendingProps.value, u4.value) || (null !== e4 ? e4.push(i3) : e4 = [i3]);
        }
      } else if (a5 === zo.current) {
        if (null === (u4 = a5.alternate)) throw Error(r5(387));
        u4.memoizedState.memoizedState !== a5.memoizedState.memoizedState && (null !== e4 ? e4.push(ca) : e4 = [ca]);
      }
      a5 = a5.return;
    }
    null !== e4 && F(n6, e4, t5, l5), n6.flags |= 262144;
  }
  __name(j, "j");
  function A(e4) {
    for (e4 = e4.firstContext; null !== e4; ) {
      var n6 = e4.context;
      if (!uo(n6._currentValue2, e4.memoizedValue)) return true;
      e4 = e4.next;
    }
    return false;
  }
  __name(A, "A");
  function H(e4) {
    Po = e4, _o = null, null !== (e4 = e4.dependencies) && (e4.firstContext = null);
  }
  __name(H, "H");
  function O(e4) {
    return W(Po, e4);
  }
  __name(O, "O");
  function M(e4, n6) {
    return null === Po && H(e4), W(e4, n6);
  }
  __name(M, "M");
  function W(e4, n6) {
    var t5 = n6._currentValue2;
    if (n6 = { context: n6, memoizedValue: t5, next: null }, null === _o) {
      if (null === e4) throw Error(r5(308));
      _o = n6, e4.dependencies = { lanes: 0, firstContext: n6 }, e4.flags |= 524288;
    } else _o = _o.next = n6;
    return t5;
  }
  __name(W, "W");
  function Q() {
    return { controller: new To(), data: /* @__PURE__ */ new Map(), refCount: 0 };
  }
  __name(Q, "Q");
  function B(e4) {
    e4.refCount--, 0 === e4.refCount && Ro(No, function() {
      e4.controller.abort();
    });
  }
  __name(B, "B");
  function $() {
  }
  __name($, "$");
  function V(e4) {
    e4 !== Do && null === e4.next && (null === Do ? Uo = Do = e4 : Do = Do.next = e4), Fo = true, Io || (Io = true, Ga(eo, Y));
  }
  __name(V, "V");
  function q(e4, n6) {
    if (!jo && Fo) {
      jo = true;
      do {
        for (var t5 = false, r6 = Uo; null !== r6; ) {
          if (0 !== e4) {
            var l5 = r6.pendingLanes;
            if (0 === l5) var a5 = 0;
            else {
              var o5 = r6.suspendedLanes, u4 = r6.pingedLanes;
              a5 = (1 << 31 - Qa(42 | e4) + 1) - 1, a5 = 201326741 & (a5 &= l5 & ~(o5 & ~u4)) ? 201326741 & a5 | 1 : a5 ? 2 | a5 : 0;
            }
            0 !== a5 && (t5 = true, K(r6, a5));
          } else a5 = Bu, 0 == (3 & (a5 = d3(r6, r6 === Wu ? a5 : 0, null !== r6.cancelPendingCommit || r6.timeoutHandle !== ql))) || f4(r6, a5) || (t5 = true, K(r6, a5));
          r6 = r6.next;
        }
      } while (t5);
      jo = false;
    }
  }
  __name(q, "q");
  function Y() {
    !function() {
      Fo = Io = false;
      var e4 = 0;
      0 !== Ao && ea() && (e4 = Ao);
      for (var n6 = Za(), t5 = null, r6 = Uo; null !== r6; ) {
        var l5 = r6.next, a5 = G2(r6, n6);
        0 === a5 ? (r6.next = null, null === t5 ? Uo = l5 : t5.next = l5, null === l5 && (Do = t5)) : (t5 = r6, (0 !== e4 || 0 != (3 & a5)) && (Fo = true)), r6 = l5;
      }
      0 !== di && 5 !== di || q(e4), 0 !== Ao && (Ao = 0);
    }();
  }
  __name(Y, "Y");
  function G2(e4, n6) {
    for (var t5 = e4.suspendedLanes, r6 = e4.pingedLanes, l5 = e4.expirationTimes, a5 = -62914561 & e4.pendingLanes; 0 < a5; ) {
      var o5 = 31 - Qa(a5), u4 = 1 << o5, i3 = l5[o5];
      -1 === i3 ? 0 != (u4 & t5) && 0 == (u4 & r6) || (l5[o5] = p3(u4, n6)) : i3 <= n6 && (e4.expiredLanes |= u4), a5 &= ~u4;
    }
    if (t5 = Bu, t5 = d3(e4, e4 === (n6 = Wu) ? t5 : 0, null !== e4.cancelPendingCommit || e4.timeoutHandle !== ql), r6 = e4.callbackNode, 0 === t5 || e4 === n6 && (2 === $u || 9 === $u) || null !== e4.cancelPendingCommit) return null !== r6 && null !== r6 && Ja(r6), e4.callbackNode = null, e4.callbackPriority = 0;
    if (0 == (3 & t5) || f4(e4, t5)) {
      if ((n6 = t5 & -t5) === e4.callbackPriority) return n6;
      switch (null !== r6 && Ja(r6), S3(t5)) {
        case 2:
        case 8:
          t5 = no;
          break;
        case 32:
        default:
          t5 = to;
          break;
        case 268435456:
          t5 = ro;
      }
      return r6 = J.bind(null, e4), t5 = Ga(t5, r6), e4.callbackPriority = n6, e4.callbackNode = t5, n6;
    }
    return null !== r6 && null !== r6 && Ja(r6), e4.callbackPriority = 2, e4.callbackNode = null, 2;
  }
  __name(G2, "G");
  function J(e4, n6) {
    if (0 !== di && 5 !== di) return e4.callbackNode = null, e4.callbackPriority = 0, null;
    var t5 = e4.callbackNode;
    if (qr() && e4.callbackNode !== t5) return null;
    var r6 = Bu;
    return 0 === (r6 = d3(e4, e4 === Wu ? r6 : 0, null !== e4.cancelPendingCommit || e4.timeoutHandle !== ql)) ? null : (xr(e4, r6, n6), G2(e4, Za()), null != e4.callbackNode && e4.callbackNode === t5 ? J.bind(null, e4) : null);
  }
  __name(J, "J");
  function K(e4, n6) {
    if (qr()) return null;
    xr(e4, n6, true);
  }
  __name(K, "K");
  function X() {
    if (0 === Ao) {
      var e4 = Mo;
      0 === e4 && (e4 = Va, 0 == (261888 & (Va <<= 1)) && (Va = 256)), Ao = e4;
    }
    return Ao;
  }
  __name(X, "X");
  function Z() {
    if (0 == --Oo && null !== Ho) {
      null !== Wo && (Wo.status = "fulfilled");
      var e4 = Ho;
      Ho = null, Mo = 0, Wo = null;
      for (var n6 = 0; n6 < e4.length; n6++) (0, e4[n6])();
    }
  }
  __name(Z, "Z");
  function ee() {
    var e4 = Bo.current;
    return null !== e4 ? e4 : Wu.pooledCache;
  }
  __name(ee, "ee");
  function ne(e4, n6) {
    s4(Bo, null === n6 ? Bo.current : n6.pool);
  }
  __name(ne, "ne");
  function te() {
    var e4 = ee();
    return null === e4 ? null : { parent: Lo._currentValue2, pool: e4 };
  }
  __name(te, "te");
  function re(e4, n6) {
    if (uo(e4, n6)) return true;
    if ("object" != typeof e4 || null === e4 || "object" != typeof n6 || null === n6) return false;
    var t5 = Object.keys(e4), r6 = Object.keys(n6);
    if (t5.length !== r6.length) return false;
    for (r6 = 0; r6 < t5.length; r6++) {
      var l5 = t5[r6];
      if (!co.call(n6, l5) || !uo(e4[l5], n6[l5])) return false;
    }
    return true;
  }
  __name(re, "re");
  function le(e4) {
    return "fulfilled" === (e4 = e4.status) || "rejected" === e4;
  }
  __name(le, "le");
  function ae(e4, n6, t5) {
    switch (void 0 === (t5 = e4[t5]) ? e4.push(n6) : t5 !== n6 && (n6.then($, $), n6 = t5), n6.status) {
      case "fulfilled":
        return n6.value;
      case "rejected":
        throw ie(e4 = n6.reason), e4;
      default:
        if ("string" == typeof n6.status) n6.then($, $);
        else {
          if (null !== (e4 = Wu) && 100 < e4.shellSuspendCounter) throw Error(r5(482));
          (e4 = n6).status = "pending", e4.then(function(e5) {
            if ("pending" === n6.status) {
              var t6 = n6;
              t6.status = "fulfilled", t6.value = e5;
            }
          }, function(e5) {
            if ("pending" === n6.status) {
              var t6 = n6;
              t6.status = "rejected", t6.reason = e5;
            }
          });
        }
        switch (n6.status) {
          case "fulfilled":
            return n6.value;
          case "rejected":
            throw ie(e4 = n6.reason), e4;
        }
        throw Go = n6, $o;
    }
  }
  __name(ae, "ae");
  function oe(e4) {
    try {
      return (0, e4._init)(e4._payload);
    } catch (e5) {
      if (null !== e5 && "object" == typeof e5 && "function" == typeof e5.then) throw Go = e5, $o;
      throw e5;
    }
  }
  __name(oe, "oe");
  function ue() {
    if (null === Go) throw Error(r5(459));
    var e4 = Go;
    return Go = null, e4;
  }
  __name(ue, "ue");
  function ie(e4) {
    if (e4 === $o || e4 === qo) throw Error(r5(483));
  }
  __name(ie, "ie");
  function se(e4) {
    var n6 = Ko;
    return Ko += 1, null === Jo && (Jo = []), ae(Jo, e4, n6);
  }
  __name(se, "se");
  function ce(e4, n6) {
    n6 = n6.props.ref, e4.ref = void 0 !== n6 ? n6 : null;
  }
  __name(ce, "ce");
  function de(e4, n6) {
    if (n6.$$typeof === gl) throw Error(r5(525));
    throw e4 = Object.prototype.toString.call(n6), Error(r5(31, "[object Object]" === e4 ? "object with keys {" + Object.keys(n6).join(", ") + "}" : e4));
  }
  __name(de, "de");
  function fe(e4) {
    function n6(n7, t5) {
      if (e4) {
        var r6 = n7.deletions;
        null === r6 ? (n7.deletions = [t5], n7.flags |= 16) : r6.push(t5);
      }
    }
    __name(n6, "n");
    function a5(t5, r6) {
      if (!e4) return null;
      for (; null !== r6; ) n6(t5, r6), r6 = r6.sibling;
      return null;
    }
    __name(a5, "a");
    function o5(e5) {
      for (var n7 = /* @__PURE__ */ new Map(); null !== e5; ) null !== e5.key ? n7.set(e5.key, e5) : n7.set(e5.index, e5), e5 = e5.sibling;
      return n7;
    }
    __name(o5, "o");
    function u4(e5, n7) {
      return (e5 = ll(e5, n7)).index = 0, e5.sibling = null, e5;
    }
    __name(u4, "u");
    function i3(n7, t5, r6) {
      return n7.index = r6, e4 ? null !== (r6 = n7.alternate) ? (r6 = r6.index) < t5 ? (n7.flags |= 67108866, t5) : r6 : (n7.flags |= 67108866, t5) : (n7.flags |= 1048576, t5);
    }
    __name(i3, "i");
    function s5(n7) {
      return e4 && null === n7.alternate && (n7.flags |= 67108866), n7;
    }
    __name(s5, "s");
    function c3(e5, n7, t5, r6) {
      return null === n7 || 6 !== n7.tag ? ((n7 = il(t5, e5.mode, r6)).return = e5, n7) : ((n7 = u4(n7, t5)).return = e5, n7);
    }
    __name(c3, "c");
    function d4(e5, n7, t5, r6) {
      var l5 = t5.type;
      return l5 === vl ? p4(e5, n7, t5.props.children, r6, t5.key) : null !== n7 && (n7.elementType === l5 || "object" == typeof l5 && null !== l5 && l5.$$typeof === _l && oe(l5) === n7.type) ? (ce(n7 = u4(n7, t5.props), t5), n7.return = e5, n7) : (ce(n7 = ol(t5.type, t5.key, t5.props, null, e5.mode, r6), t5), n7.return = e5, n7);
    }
    __name(d4, "d");
    function f5(e5, n7, t5, r6) {
      return null === n7 || 4 !== n7.tag || n7.stateNode.containerInfo !== t5.containerInfo || n7.stateNode.implementation !== t5.implementation ? ((n7 = sl(t5, e5.mode, r6)).return = e5, n7) : ((n7 = u4(n7, t5.children || [])).return = e5, n7);
    }
    __name(f5, "f");
    function p4(e5, n7, t5, r6, l5) {
      return null === n7 || 7 !== n7.tag ? ((n7 = ul(t5, e5.mode, r6, l5)).return = e5, n7) : ((n7 = u4(n7, t5)).return = e5, n7);
    }
    __name(p4, "p");
    function m4(e5, n7, t5) {
      if ("string" == typeof n7 && "" !== n7 || "number" == typeof n7 || "bigint" == typeof n7) return (n7 = il("" + n7, e5.mode, t5)).return = e5, n7;
      if ("object" == typeof n7 && null !== n7) {
        switch (n7.$$typeof) {
          case yl:
            return ce(t5 = ol(n7.type, n7.key, n7.props, null, e5.mode, t5), n7), t5.return = e5, t5;
          case bl:
            return (n7 = sl(n7, e5.mode, t5)).return = e5, n7;
          case _l:
            return m4(e5, n7 = oe(n7), t5);
        }
        if (Ul(n7) || l4(n7)) return (n7 = ul(n7, e5.mode, t5, null)).return = e5, n7;
        if ("function" == typeof n7.then) return m4(e5, se(n7), t5);
        if (n7.$$typeof === zl) return m4(e5, M(e5, n7), t5);
        de(e5, n7);
      }
      return null;
    }
    __name(m4, "m");
    function h2(e5, n7, t5, r6) {
      var a6 = null !== n7 ? n7.key : null;
      if ("string" == typeof t5 && "" !== t5 || "number" == typeof t5 || "bigint" == typeof t5) return null !== a6 ? null : c3(e5, n7, "" + t5, r6);
      if ("object" == typeof t5 && null !== t5) {
        switch (t5.$$typeof) {
          case yl:
            return t5.key === a6 ? d4(e5, n7, t5, r6) : null;
          case bl:
            return t5.key === a6 ? f5(e5, n7, t5, r6) : null;
          case _l:
            return h2(e5, n7, t5 = oe(t5), r6);
        }
        if (Ul(t5) || l4(t5)) return null !== a6 ? null : p4(e5, n7, t5, r6, null);
        if ("function" == typeof t5.then) return h2(e5, n7, se(t5), r6);
        if (t5.$$typeof === zl) return h2(e5, n7, M(e5, t5), r6);
        de(e5, t5);
      }
      return null;
    }
    __name(h2, "h");
    function g2(e5, n7, t5, r6, a6) {
      if ("string" == typeof r6 && "" !== r6 || "number" == typeof r6 || "bigint" == typeof r6) return c3(n7, e5 = e5.get(t5) || null, "" + r6, a6);
      if ("object" == typeof r6 && null !== r6) {
        switch (r6.$$typeof) {
          case yl:
            return d4(n7, e5 = e5.get(null === r6.key ? t5 : r6.key) || null, r6, a6);
          case bl:
            return f5(n7, e5 = e5.get(null === r6.key ? t5 : r6.key) || null, r6, a6);
          case _l:
            return g2(e5, n7, t5, r6 = oe(r6), a6);
        }
        if (Ul(r6) || l4(r6)) return p4(n7, e5 = e5.get(t5) || null, r6, a6, null);
        if ("function" == typeof r6.then) return g2(e5, n7, t5, se(r6), a6);
        if (r6.$$typeof === zl) return g2(e5, n7, t5, M(n7, r6), a6);
        de(n7, r6);
      }
      return null;
    }
    __name(g2, "g");
    function y4(t5, c4, d5, f6) {
      if ("object" == typeof d5 && null !== d5 && d5.type === vl && null === d5.key && (d5 = d5.props.children), "object" == typeof d5 && null !== d5) {
        switch (d5.$$typeof) {
          case yl:
            e: {
              for (var p5 = d5.key; null !== c4; ) {
                if (c4.key === p5) {
                  if ((p5 = d5.type) === vl) {
                    if (7 === c4.tag) {
                      a5(t5, c4.sibling), (f6 = u4(c4, d5.props.children)).return = t5, t5 = f6;
                      break e;
                    }
                  } else if (c4.elementType === p5 || "object" == typeof p5 && null !== p5 && p5.$$typeof === _l && oe(p5) === c4.type) {
                    a5(t5, c4.sibling), ce(f6 = u4(c4, d5.props), d5), f6.return = t5, t5 = f6;
                    break e;
                  }
                  a5(t5, c4);
                  break;
                }
                n6(t5, c4), c4 = c4.sibling;
              }
              d5.type === vl ? ((f6 = ul(d5.props.children, t5.mode, f6, d5.key)).return = t5, t5 = f6) : (ce(f6 = ol(d5.type, d5.key, d5.props, null, t5.mode, f6), d5), f6.return = t5, t5 = f6);
            }
            return s5(t5);
          case bl:
            e: {
              for (p5 = d5.key; null !== c4; ) {
                if (c4.key === p5) {
                  if (4 === c4.tag && c4.stateNode.containerInfo === d5.containerInfo && c4.stateNode.implementation === d5.implementation) {
                    a5(t5, c4.sibling), (f6 = u4(c4, d5.children || [])).return = t5, t5 = f6;
                    break e;
                  }
                  a5(t5, c4);
                  break;
                }
                n6(t5, c4), c4 = c4.sibling;
              }
              (f6 = sl(d5, t5.mode, f6)).return = t5, t5 = f6;
            }
            return s5(t5);
          case _l:
            return y4(t5, c4, d5 = oe(d5), f6);
        }
        if (Ul(d5)) return function(t6, r6, l5, u5) {
          for (var s6 = null, c5 = null, d6 = r6, f7 = r6 = 0, p6 = null; null !== d6 && f7 < l5.length; f7++) {
            d6.index > f7 ? (p6 = d6, d6 = null) : p6 = d6.sibling;
            var y5 = h2(t6, d6, l5[f7], u5);
            if (null === y5) {
              null === d6 && (d6 = p6);
              break;
            }
            e4 && d6 && null === y5.alternate && n6(t6, d6), r6 = i3(y5, r6, f7), null === c5 ? s6 = y5 : c5.sibling = y5, c5 = y5, d6 = p6;
          }
          if (f7 === l5.length) return a5(t6, d6), s6;
          if (null === d6) {
            for (; f7 < l5.length; f7++) null !== (d6 = m4(t6, l5[f7], u5)) && (r6 = i3(d6, r6, f7), null === c5 ? s6 = d6 : c5.sibling = d6, c5 = d6);
            return s6;
          }
          for (d6 = o5(d6); f7 < l5.length; f7++) null !== (p6 = g2(d6, t6, f7, l5[f7], u5)) && (e4 && null !== p6.alternate && d6.delete(null === p6.key ? f7 : p6.key), r6 = i3(p6, r6, f7), null === c5 ? s6 = p6 : c5.sibling = p6, c5 = p6);
          return e4 && d6.forEach(function(e5) {
            return n6(t6, e5);
          }), s6;
        }(t5, c4, d5, f6);
        if (l4(d5)) {
          if ("function" != typeof (p5 = l4(d5))) throw Error(r5(150));
          return function(t6, l5, u5, s6) {
            if (null == u5) throw Error(r5(151));
            for (var c5 = null, d6 = null, f7 = l5, p6 = l5 = 0, y5 = null, b4 = u5.next(); null !== f7 && !b4.done; p6++, b4 = u5.next()) {
              f7.index > p6 ? (y5 = f7, f7 = null) : y5 = f7.sibling;
              var v4 = h2(t6, f7, b4.value, s6);
              if (null === v4) {
                null === f7 && (f7 = y5);
                break;
              }
              e4 && f7 && null === v4.alternate && n6(t6, f7), l5 = i3(v4, l5, p6), null === d6 ? c5 = v4 : d6.sibling = v4, d6 = v4, f7 = y5;
            }
            if (b4.done) return a5(t6, f7), c5;
            if (null === f7) {
              for (; !b4.done; p6++, b4 = u5.next()) null !== (b4 = m4(t6, b4.value, s6)) && (l5 = i3(b4, l5, p6), null === d6 ? c5 = b4 : d6.sibling = b4, d6 = b4);
              return c5;
            }
            for (f7 = o5(f7); !b4.done; p6++, b4 = u5.next()) null !== (b4 = g2(f7, t6, p6, b4.value, s6)) && (e4 && null !== b4.alternate && f7.delete(null === b4.key ? p6 : b4.key), l5 = i3(b4, l5, p6), null === d6 ? c5 = b4 : d6.sibling = b4, d6 = b4);
            return e4 && f7.forEach(function(e5) {
              return n6(t6, e5);
            }), c5;
          }(t5, c4, d5 = p5.call(d5), f6);
        }
        if ("function" == typeof d5.then) return y4(t5, c4, se(d5), f6);
        if (d5.$$typeof === zl) return y4(t5, c4, M(t5, d5), f6);
        de(t5, d5);
      }
      return "string" == typeof d5 && "" !== d5 || "number" == typeof d5 || "bigint" == typeof d5 ? (d5 = "" + d5, null !== c4 && 6 === c4.tag ? (a5(t5, c4.sibling), (f6 = u4(c4, d5)).return = t5, t5 = f6) : (a5(t5, c4), (f6 = il(d5, t5.mode, f6)).return = t5, t5 = f6), s5(t5)) : a5(t5, c4);
    }
    __name(y4, "y");
    return function(e5, n7, r6, l5) {
      try {
        Ko = 0;
        var a6 = y4(e5, n7, r6, l5);
        return Jo = null, a6;
      } catch (n8) {
        if (n8 === $o || n8 === qo) throw n8;
        var o6 = t4(29, n8, null, e5.mode);
        return o6.lanes = l5, o6.return = e5, o6;
      }
    };
  }
  __name(fe, "fe");
  function pe() {
    for (var e4 = nu, n6 = tu = nu = 0; n6 < e4; ) {
      var t5 = eu[n6];
      eu[n6++] = null;
      var r6 = eu[n6];
      eu[n6++] = null;
      var l5 = eu[n6];
      eu[n6++] = null;
      var a5 = eu[n6];
      if (eu[n6++] = null, null !== r6 && null !== l5) {
        var o5 = r6.pending;
        null === o5 ? l5.next = l5 : (l5.next = o5.next, o5.next = l5), r6.pending = l5;
      }
      0 !== a5 && ye(t5, l5, a5);
    }
  }
  __name(pe, "pe");
  function me(e4, n6, t5, r6) {
    eu[nu++] = e4, eu[nu++] = n6, eu[nu++] = t5, eu[nu++] = r6, tu |= r6, e4.lanes |= r6, null !== (e4 = e4.alternate) && (e4.lanes |= r6);
  }
  __name(me, "me");
  function he(e4, n6, t5, r6) {
    return me(e4, n6, t5, r6), be(e4);
  }
  __name(he, "he");
  function ge(e4, n6) {
    return me(e4, null, null, n6), be(e4);
  }
  __name(ge, "ge");
  function ye(e4, n6, t5) {
    e4.lanes |= t5;
    var r6 = e4.alternate;
    null !== r6 && (r6.lanes |= t5);
    for (var l5 = false, a5 = e4.return; null !== a5; ) a5.childLanes |= t5, null !== (r6 = a5.alternate) && (r6.childLanes |= t5), 22 === a5.tag && (null === (e4 = a5.stateNode) || 1 & e4._visibility || (l5 = true)), e4 = a5, a5 = a5.return;
    return 3 === e4.tag ? (a5 = e4.stateNode, l5 && null !== n6 && (l5 = 31 - Qa(t5), null === (r6 = (e4 = a5.hiddenUpdates)[l5]) ? e4[l5] = [n6] : r6.push(n6), n6.lane = 536870912 | t5), a5) : null;
  }
  __name(ye, "ye");
  function be(e4) {
    if (50 < bi) throw bi = 0, vi = null, Error(r5(185));
    for (var n6 = e4.return; null !== n6; ) n6 = (e4 = n6).return;
    return 3 === e4.tag ? e4.stateNode : null;
  }
  __name(be, "be");
  function ve(e4) {
    e4.updateQueue = { baseState: e4.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null };
  }
  __name(ve, "ve");
  function Se(e4, n6) {
    e4 = e4.updateQueue, n6.updateQueue === e4 && (n6.updateQueue = { baseState: e4.baseState, firstBaseUpdate: e4.firstBaseUpdate, lastBaseUpdate: e4.lastBaseUpdate, shared: e4.shared, callbacks: null });
  }
  __name(Se, "Se");
  function ke(e4) {
    return { lane: e4, tag: 0, payload: null, callback: null, next: null };
  }
  __name(ke, "ke");
  function we(e4, n6, t5) {
    var r6 = e4.updateQueue;
    if (null === r6) return null;
    if (r6 = r6.shared, 0 != (2 & Mu)) {
      var l5 = r6.pending;
      return null === l5 ? n6.next = n6 : (n6.next = l5.next, l5.next = n6), r6.pending = n6, n6 = be(e4), ye(e4, null, t5), n6;
    }
    return me(e4, r6, n6, t5), be(e4);
  }
  __name(we, "we");
  function ze(e4, n6, t5) {
    if (null !== (n6 = n6.updateQueue) && (n6 = n6.shared, 0 != (4194048 & t5))) {
      var r6 = n6.lanes;
      t5 |= r6 &= e4.pendingLanes, n6.lanes = t5, b3(e4, t5);
    }
  }
  __name(ze, "ze");
  function xe(e4, n6) {
    var t5 = e4.updateQueue, r6 = e4.alternate;
    if (null !== r6 && t5 === (r6 = r6.updateQueue)) {
      var l5 = null, a5 = null;
      if (null !== (t5 = t5.firstBaseUpdate)) {
        do {
          var o5 = { lane: t5.lane, tag: t5.tag, payload: t5.payload, callback: null, next: null };
          null === a5 ? l5 = a5 = o5 : a5 = a5.next = o5, t5 = t5.next;
        } while (null !== t5);
        null === a5 ? l5 = a5 = n6 : a5 = a5.next = n6;
      } else l5 = a5 = n6;
      return t5 = { baseState: r6.baseState, firstBaseUpdate: l5, lastBaseUpdate: a5, shared: r6.shared, callbacks: r6.callbacks }, void (e4.updateQueue = t5);
    }
    null === (e4 = t5.lastBaseUpdate) ? t5.firstBaseUpdate = n6 : e4.next = n6, t5.lastBaseUpdate = n6;
  }
  __name(xe, "xe");
  function Ee() {
    if (lu && null !== Wo) throw Wo;
  }
  __name(Ee, "Ee");
  function Ce(e4, n6, t5, r6) {
    lu = false;
    var l5 = e4.updateQueue;
    ru = false;
    var a5 = l5.firstBaseUpdate, o5 = l5.lastBaseUpdate, u4 = l5.shared.pending;
    if (null !== u4) {
      l5.shared.pending = null;
      var i3 = u4, s5 = i3.next;
      i3.next = null, null === o5 ? a5 = s5 : o5.next = s5, o5 = i3;
      var c3 = e4.alternate;
      null !== c3 && (u4 = (c3 = c3.updateQueue).lastBaseUpdate) !== o5 && (null === u4 ? c3.firstBaseUpdate = s5 : u4.next = s5, c3.lastBaseUpdate = i3);
    }
    if (null !== a5) {
      var d4 = l5.baseState;
      for (o5 = 0, c3 = s5 = i3 = null, u4 = a5; ; ) {
        var f5 = -536870913 & u4.lane, p4 = f5 !== u4.lane;
        if (p4 ? (Bu & f5) === f5 : (r6 & f5) === f5) {
          0 !== f5 && f5 === Mo && (lu = true), null !== c3 && (c3 = c3.next = { lane: 0, tag: u4.tag, payload: u4.payload, callback: null, next: null });
          e: {
            var m4 = e4, h2 = u4;
            f5 = n6;
            var g2 = t5;
            switch (h2.tag) {
              case 1:
                if ("function" == typeof (m4 = h2.payload)) {
                  d4 = m4.call(g2, d4, f5);
                  break e;
                }
                d4 = m4;
                break e;
              case 3:
                m4.flags = -65537 & m4.flags | 128;
              case 0:
                if (null == (f5 = "function" == typeof (m4 = h2.payload) ? m4.call(g2, d4, f5) : m4)) break e;
                d4 = hl({}, d4, f5);
                break e;
              case 2:
                ru = true;
            }
          }
          null !== (f5 = u4.callback) && (e4.flags |= 64, p4 && (e4.flags |= 8192), null === (p4 = l5.callbacks) ? l5.callbacks = [f5] : p4.push(f5));
        } else p4 = { lane: f5, tag: u4.tag, payload: u4.payload, callback: u4.callback, next: null }, null === c3 ? (s5 = c3 = p4, i3 = d4) : c3 = c3.next = p4, o5 |= f5;
        if (null === (u4 = u4.next)) {
          if (null === (u4 = l5.shared.pending)) break;
          u4 = (p4 = u4).next, p4.next = null, l5.lastBaseUpdate = p4, l5.shared.pending = null;
        }
      }
      null === c3 && (i3 = d4), l5.baseState = i3, l5.firstBaseUpdate = s5, l5.lastBaseUpdate = c3, null === a5 && (l5.shared.lanes = 0), Xu |= o5, e4.lanes = o5, e4.memoizedState = d4;
    }
  }
  __name(Ce, "Ce");
  function Pe(e4, n6) {
    if ("function" != typeof e4) throw Error(r5(191, e4));
    e4.call(n6);
  }
  __name(Pe, "Pe");
  function _e(e4, n6) {
    var t5 = e4.callbacks;
    if (null !== t5) for (e4.callbacks = null, e4 = 0; e4 < t5.length; e4++) Pe(t5[e4], n6);
  }
  __name(_e, "_e");
  function Te(e4, n6) {
    s4(ou, e4 = Ju), s4(au, n6), Ju = e4 | n6.baseLanes;
  }
  __name(Te, "Te");
  function Re() {
    s4(ou, Ju), s4(au, au.current);
  }
  __name(Re, "Re");
  function Ne() {
    Ju = ou.current, i2(au), i2(ou);
  }
  __name(Ne, "Ne");
  function Le(e4) {
    var n6 = e4.alternate;
    s4(su, 1 & su.current), s4(uu, e4), null === iu && (null === n6 || null !== au.current || null !== n6.memoizedState) && (iu = e4);
  }
  __name(Le, "Le");
  function Ue(e4) {
    s4(su, su.current), s4(uu, e4), null === iu && (iu = e4);
  }
  __name(Ue, "Ue");
  function De(e4) {
    22 === e4.tag ? (s4(su, su.current), s4(uu, e4), null === iu && (iu = e4)) : Ie();
  }
  __name(De, "De");
  function Ie() {
    s4(su, su.current), s4(uu, uu.current);
  }
  __name(Ie, "Ie");
  function Fe(e4) {
    i2(uu), iu === e4 && (iu = null), i2(su);
  }
  __name(Fe, "Fe");
  function je(e4) {
    for (var n6 = e4; null !== n6; ) {
      if (13 === n6.tag) {
        var t5 = n6.memoizedState;
        if (null !== t5 && (null === (t5 = t5.dehydrated) || Pa(t5) || _a(t5))) return n6;
      } else if (19 !== n6.tag || "forwards" !== n6.memoizedProps.revealOrder && "backwards" !== n6.memoizedProps.revealOrder && "unstable_legacy-backwards" !== n6.memoizedProps.revealOrder && "together" !== n6.memoizedProps.revealOrder) {
        if (null !== n6.child) {
          n6.child.return = n6, n6 = n6.child;
          continue;
        }
      } else if (0 != (128 & n6.flags)) return n6;
      if (n6 === e4) break;
      for (; null === n6.sibling; ) {
        if (null === n6.return || n6.return === e4) return null;
        n6 = n6.return;
      }
      n6.sibling.return = n6.return, n6 = n6.sibling;
    }
    return null;
  }
  __name(je, "je");
  function Ae() {
    throw Error(r5(321));
  }
  __name(Ae, "Ae");
  function He(e4, n6) {
    if (null === n6) return false;
    for (var t5 = 0; t5 < n6.length && t5 < e4.length; t5++) if (!uo(e4[t5], n6[t5])) return false;
    return true;
  }
  __name(He, "He");
  function Oe(e4, n6, t5, r6, l5, a5) {
    return cu = a5, du = n6, n6.memoizedState = null, n6.updateQueue = null, n6.lanes = 0, Dl.H = null === e4 || null === e4.memoizedState ? wu : zu, gu = false, a5 = t5(r6, l5), gu = false, hu && (a5 = We(n6, t5, r6, l5)), Me(e4), a5;
  }
  __name(Oe, "Oe");
  function Me(e4) {
    Dl.H = ku;
    var n6 = null !== fu && null !== fu.next;
    if (cu = 0, pu = fu = du = null, mu = false, bu = 0, vu = null, n6) throw Error(r5(300));
    null === e4 || Pu || null !== (e4 = e4.dependencies) && A(e4) && (Pu = true);
  }
  __name(Me, "Me");
  function We(e4, n6, t5, l5) {
    du = e4;
    var a5 = 0;
    do {
      if (hu && (vu = null), bu = 0, hu = false, 25 <= a5) throw Error(r5(301));
      if (a5 += 1, pu = fu = null, null != e4.updateQueue) {
        var o5 = e4.updateQueue;
        o5.lastEffect = null, o5.events = null, o5.stores = null, null != o5.memoCache && (o5.memoCache.index = 0);
      }
      Dl.H = xu, o5 = n6(t5, l5);
    } while (hu);
    return o5;
  }
  __name(We, "We");
  function Qe() {
    var e4 = Dl.H, n6 = e4.useState()[0];
    return n6 = "function" == typeof n6.then ? Ge(n6) : n6, e4 = e4.useState()[0], (null !== fu ? fu.memoizedState : null) !== e4 && (du.flags |= 1024), n6;
  }
  __name(Qe, "Qe");
  function Be() {
    var e4 = 0 !== yu;
    return yu = 0, e4;
  }
  __name(Be, "Be");
  function $e(e4, n6, t5) {
    n6.updateQueue = e4.updateQueue, n6.flags &= -2053, e4.lanes &= ~t5;
  }
  __name($e, "$e");
  function Ve(e4) {
    if (mu) {
      for (e4 = e4.memoizedState; null !== e4; ) {
        var n6 = e4.queue;
        null !== n6 && (n6.pending = null), e4 = e4.next;
      }
      mu = false;
    }
    cu = 0, pu = fu = du = null, hu = false, bu = yu = 0, vu = null;
  }
  __name(Ve, "Ve");
  function qe() {
    var e4 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return null === pu ? du.memoizedState = pu = e4 : pu = pu.next = e4, pu;
  }
  __name(qe, "qe");
  function Ye() {
    if (null === fu) {
      var e4 = du.alternate;
      e4 = null !== e4 ? e4.memoizedState : null;
    } else e4 = fu.next;
    var n6 = null === pu ? du.memoizedState : pu.next;
    if (null !== n6) pu = n6, fu = e4;
    else {
      if (null === e4) {
        if (null === du.alternate) throw Error(r5(467));
        throw Error(r5(310));
      }
      e4 = { memoizedState: (fu = e4).memoizedState, baseState: fu.baseState, baseQueue: fu.baseQueue, queue: fu.queue, next: null }, null === pu ? du.memoizedState = pu = e4 : pu = pu.next = e4;
    }
    return pu;
  }
  __name(Ye, "Ye");
  function Ge(e4) {
    var n6 = bu;
    return bu += 1, null === vu && (vu = []), e4 = ae(vu, e4, n6), n6 = du, null === (null === pu ? n6.memoizedState : pu.next) && (n6 = n6.alternate, Dl.H = null === n6 || null === n6.memoizedState ? wu : zu), e4;
  }
  __name(Ge, "Ge");
  function Je(e4) {
    if (null !== e4 && "object" == typeof e4) {
      if ("function" == typeof e4.then) return Ge(e4);
      if (e4.$$typeof === zl) return O(e4);
    }
    throw Error(r5(438, String(e4)));
  }
  __name(Je, "Je");
  function Ke(e4) {
    var n6 = null, t5 = du.updateQueue;
    if (null !== t5 && (n6 = t5.memoCache), null == n6) {
      var r6 = du.alternate;
      null !== r6 && null !== (r6 = r6.updateQueue) && null != (r6 = r6.memoCache) && (n6 = { data: r6.data.map(function(e5) {
        return e5.slice();
      }), index: 0 });
    }
    if (null == n6 && (n6 = { data: [], index: 0 }), null === t5 && (t5 = { lastEffect: null, events: null, stores: null, memoCache: null }, du.updateQueue = t5), t5.memoCache = n6, void 0 === (t5 = n6.data[n6.index])) for (t5 = n6.data[n6.index] = Array(e4), r6 = 0; r6 < e4; r6++) t5[r6] = Rl;
    return n6.index++, t5;
  }
  __name(Ke, "Ke");
  function Xe(e4, n6) {
    return "function" == typeof n6 ? n6(e4) : n6;
  }
  __name(Xe, "Xe");
  function Ze(e4) {
    return en(Ye(), fu, e4);
  }
  __name(Ze, "Ze");
  function en(e4, n6, t5) {
    var l5 = e4.queue;
    if (null === l5) throw Error(r5(311));
    l5.lastRenderedReducer = t5;
    var a5 = e4.baseQueue, o5 = l5.pending;
    if (null !== o5) {
      if (null !== a5) {
        var u4 = a5.next;
        a5.next = o5.next, o5.next = u4;
      }
      n6.baseQueue = a5 = o5, l5.pending = null;
    }
    if (o5 = e4.baseState, null === a5) e4.memoizedState = o5;
    else {
      var i3 = u4 = null, s5 = null, c3 = n6 = a5.next, d4 = false;
      do {
        var f5 = -536870913 & c3.lane;
        if (f5 !== c3.lane ? (Bu & f5) === f5 : (cu & f5) === f5) {
          var p4 = c3.revertLane;
          if (0 === p4) null !== s5 && (s5 = s5.next = { lane: 0, revertLane: 0, gesture: null, action: c3.action, hasEagerState: c3.hasEagerState, eagerState: c3.eagerState, next: null }), f5 === Mo && (d4 = true);
          else {
            if ((cu & p4) === p4) {
              c3 = c3.next, p4 === Mo && (d4 = true);
              continue;
            }
            f5 = { lane: 0, revertLane: c3.revertLane, gesture: null, action: c3.action, hasEagerState: c3.hasEagerState, eagerState: c3.eagerState, next: null }, null === s5 ? (i3 = s5 = f5, u4 = o5) : s5 = s5.next = f5, du.lanes |= p4, Xu |= p4;
          }
          f5 = c3.action, gu && t5(o5, f5), o5 = c3.hasEagerState ? c3.eagerState : t5(o5, f5);
        } else p4 = { lane: f5, revertLane: c3.revertLane, gesture: c3.gesture, action: c3.action, hasEagerState: c3.hasEagerState, eagerState: c3.eagerState, next: null }, null === s5 ? (i3 = s5 = p4, u4 = o5) : s5 = s5.next = p4, du.lanes |= f5, Xu |= f5;
        c3 = c3.next;
      } while (null !== c3 && c3 !== n6);
      if (null === s5 ? u4 = o5 : s5.next = i3, !uo(o5, e4.memoizedState) && (Pu = true, d4 && null !== (t5 = Wo))) throw t5;
      e4.memoizedState = o5, e4.baseState = u4, e4.baseQueue = s5, l5.lastRenderedState = o5;
    }
    return null === a5 && (l5.lanes = 0), [e4.memoizedState, l5.dispatch];
  }
  __name(en, "en");
  function nn(e4) {
    var n6 = Ye(), t5 = n6.queue;
    if (null === t5) throw Error(r5(311));
    t5.lastRenderedReducer = e4;
    var l5 = t5.dispatch, a5 = t5.pending, o5 = n6.memoizedState;
    if (null !== a5) {
      t5.pending = null;
      var u4 = a5 = a5.next;
      do {
        o5 = e4(o5, u4.action), u4 = u4.next;
      } while (u4 !== a5);
      uo(o5, n6.memoizedState) || (Pu = true), n6.memoizedState = o5, null === n6.baseQueue && (n6.baseState = o5), t5.lastRenderedState = o5;
    }
    return [o5, l5];
  }
  __name(nn, "nn");
  function tn(e4, n6, t5) {
    var l5 = du, a5 = Ye();
    t5 = n6();
    var o5 = !uo((fu || a5).memoizedState, t5);
    if (o5 && (a5.memoizedState = t5, Pu = true), a5 = a5.queue, _n(an.bind(null, l5, a5, e4), [e4]), a5.getSnapshot !== n6 || o5 || null !== pu && 1 & pu.memoizedState.tag) {
      if (l5.flags |= 2048, zn(9, { destroy: void 0 }, ln.bind(null, l5, a5, t5, n6), null), null === Wu) throw Error(r5(349));
      0 != (127 & cu) || rn(l5, n6, t5);
    }
    return t5;
  }
  __name(tn, "tn");
  function rn(e4, n6, t5) {
    e4.flags |= 16384, e4 = { getSnapshot: n6, value: t5 }, null === (n6 = du.updateQueue) ? (n6 = { lastEffect: null, events: null, stores: null, memoCache: null }, du.updateQueue = n6, n6.stores = [e4]) : null === (t5 = n6.stores) ? n6.stores = [e4] : t5.push(e4);
  }
  __name(rn, "rn");
  function ln(e4, n6, t5, r6) {
    n6.value = t5, n6.getSnapshot = r6, on4(n6) && un(e4);
  }
  __name(ln, "ln");
  function an(e4, n6, t5) {
    return t5(function() {
      on4(n6) && un(e4);
    });
  }
  __name(an, "an");
  function on4(e4) {
    var n6 = e4.getSnapshot;
    e4 = e4.value;
    try {
      var t5 = n6();
      return !uo(e4, t5);
    } catch (e5) {
      return true;
    }
  }
  __name(on4, "on");
  function un(e4) {
    var n6 = ge(e4, 2);
    null !== n6 && zr(n6, 0, 2);
  }
  __name(un, "un");
  function sn(e4) {
    var n6 = qe();
    if ("function" == typeof e4) {
      var t5 = e4;
      if (e4 = t5(), gu) {
        k3(true);
        try {
          t5();
        } finally {
          k3(false);
        }
      }
    }
    return n6.memoizedState = n6.baseState = e4, n6.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Xe, lastRenderedState: e4 }, n6;
  }
  __name(sn, "sn");
  function cn(e4, n6, t5, r6) {
    return e4.baseState = t5, en(e4, fu, "function" == typeof r6 ? r6 : Xe);
  }
  __name(cn, "cn");
  function dn(e4, n6, t5, l5, a5) {
    if (Yn(e4)) throw Error(r5(485));
    if (null !== (e4 = n6.action)) {
      var o5 = { payload: a5, action: e4, next: null, isTransition: true, status: "pending", value: null, reason: null, listeners: [], then: /* @__PURE__ */ __name(function(e5) {
        o5.listeners.push(e5);
      }, "then") };
      null !== Dl.T ? t5(true) : o5.isTransition = false, l5(o5), null === (t5 = n6.pending) ? (o5.next = n6.pending = o5, fn(n6, o5)) : (o5.next = t5.next, n6.pending = t5.next = o5);
    }
  }
  __name(dn, "dn");
  function fn(e4, n6) {
    var t5 = n6.action, r6 = n6.payload, l5 = e4.state;
    if (n6.isTransition) {
      var a5 = Dl.T, o5 = {};
      Dl.T = o5;
      try {
        var u4 = t5(l5, r6), i3 = Dl.S;
        null !== i3 && i3(o5, u4), pn(e4, n6, u4);
      } catch (t6) {
        hn(e4, n6, t6);
      } finally {
        null !== a5 && null !== o5.types && (a5.types = o5.types), Dl.T = a5;
      }
    } else try {
      pn(e4, n6, a5 = t5(l5, r6));
    } catch (t6) {
      hn(e4, n6, t6);
    }
  }
  __name(fn, "fn");
  function pn(e4, n6, t5) {
    null !== t5 && "object" == typeof t5 && "function" == typeof t5.then ? t5.then(function(t6) {
      mn(e4, n6, t6);
    }, function(t6) {
      return hn(e4, n6, t6);
    }) : mn(e4, n6, t5);
  }
  __name(pn, "pn");
  function mn(e4, n6, t5) {
    n6.status = "fulfilled", n6.value = t5, gn(n6), e4.state = t5, null !== (n6 = e4.pending) && ((t5 = n6.next) === n6 ? e4.pending = null : (t5 = t5.next, n6.next = t5, fn(e4, t5)));
  }
  __name(mn, "mn");
  function hn(e4, n6, t5) {
    var r6 = e4.pending;
    if (e4.pending = null, null !== r6) {
      r6 = r6.next;
      do {
        n6.status = "rejected", n6.reason = t5, gn(n6), n6 = n6.next;
      } while (n6 !== r6);
    }
    e4.action = null;
  }
  __name(hn, "hn");
  function gn(e4) {
    e4 = e4.listeners;
    for (var n6 = 0; n6 < e4.length; n6++) (0, e4[n6])();
  }
  __name(gn, "gn");
  function yn(e4, n6) {
    return n6;
  }
  __name(yn, "yn");
  function bn(e4, n6) {
    var t5, r6, l5;
    (t5 = qe()).memoizedState = t5.baseState = n6, r6 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: yn, lastRenderedState: n6 }, t5.queue = r6, t5 = $n.bind(null, du, r6), r6.dispatch = t5, r6 = sn(false);
    var a5 = qn.bind(null, du, false, r6.queue);
    return l5 = { state: n6, dispatch: null, action: e4, pending: null }, (r6 = qe()).queue = l5, t5 = dn.bind(null, du, l5, a5, t5), l5.dispatch = t5, r6.memoizedState = e4, [n6, t5, false];
  }
  __name(bn, "bn");
  function vn(e4) {
    return Sn(Ye(), fu, e4);
  }
  __name(vn, "vn");
  function Sn(e4, n6, t5) {
    if (n6 = en(e4, n6, yn)[0], e4 = Ze(Xe)[0], "object" == typeof n6 && null !== n6 && "function" == typeof n6.then) try {
      var r6 = Ge(n6);
    } catch (e5) {
      if (e5 === $o) throw qo;
      throw e5;
    }
    else r6 = n6;
    var l5 = (n6 = Ye()).queue, a5 = l5.dispatch;
    return t5 !== n6.memoizedState && (du.flags |= 2048, zn(9, { destroy: void 0 }, kn.bind(null, l5, t5), null)), [r6, a5, e4];
  }
  __name(Sn, "Sn");
  function kn(e4, n6) {
    e4.action = n6;
  }
  __name(kn, "kn");
  function wn(e4) {
    var n6 = Ye(), t5 = fu;
    if (null !== t5) return Sn(n6, t5, e4);
    Ye(), n6 = n6.memoizedState;
    var r6 = (t5 = Ye()).queue.dispatch;
    return t5.memoizedState = e4, [n6, r6, false];
  }
  __name(wn, "wn");
  function zn(e4, n6, t5, r6) {
    return e4 = { tag: e4, create: t5, deps: r6, inst: n6, next: null }, null === (n6 = du.updateQueue) && (n6 = { lastEffect: null, events: null, stores: null, memoCache: null }, du.updateQueue = n6), null === (t5 = n6.lastEffect) ? n6.lastEffect = e4.next = e4 : (r6 = t5.next, t5.next = e4, e4.next = r6, n6.lastEffect = e4), e4;
  }
  __name(zn, "zn");
  function xn() {
    return Ye().memoizedState;
  }
  __name(xn, "xn");
  function En(e4, n6, t5, r6) {
    var l5 = qe();
    du.flags |= e4, l5.memoizedState = zn(1 | n6, { destroy: void 0 }, t5, void 0 === r6 ? null : r6);
  }
  __name(En, "En");
  function Cn(e4, n6, t5, r6) {
    var l5 = Ye();
    r6 = void 0 === r6 ? null : r6;
    var a5 = l5.memoizedState.inst;
    null !== fu && null !== r6 && He(r6, fu.memoizedState.deps) ? l5.memoizedState = zn(n6, a5, t5, r6) : (du.flags |= e4, l5.memoizedState = zn(1 | n6, a5, t5, r6));
  }
  __name(Cn, "Cn");
  function Pn(e4, n6) {
    En(8390656, 8, e4, n6);
  }
  __name(Pn, "Pn");
  function _n(e4, n6) {
    Cn(2048, 8, e4, n6);
  }
  __name(_n, "_n");
  function Tn(e4) {
    var n6 = Ye().memoizedState;
    return function(e5) {
      du.flags |= 4;
      var n7 = du.updateQueue;
      if (null === n7) n7 = { lastEffect: null, events: null, stores: null, memoCache: null }, du.updateQueue = n7, n7.events = [e5];
      else {
        var t5 = n7.events;
        null === t5 ? n7.events = [e5] : t5.push(e5);
      }
    }({ ref: n6, nextImpl: e4 }), function() {
      if (0 != (2 & Mu)) throw Error(r5(440));
      return n6.impl.apply(void 0, arguments);
    };
  }
  __name(Tn, "Tn");
  function Rn(e4, n6) {
    return Cn(4, 2, e4, n6);
  }
  __name(Rn, "Rn");
  function Nn(e4, n6) {
    return Cn(4, 4, e4, n6);
  }
  __name(Nn, "Nn");
  function Ln(e4, n6) {
    if ("function" == typeof n6) {
      e4 = e4();
      var t5 = n6(e4);
      return function() {
        "function" == typeof t5 ? t5() : n6(null);
      };
    }
    if (null != n6) return e4 = e4(), n6.current = e4, function() {
      n6.current = null;
    };
  }
  __name(Ln, "Ln");
  function Un(e4, n6, t5) {
    t5 = null != t5 ? t5.concat([e4]) : null, Cn(4, 4, Ln.bind(null, n6, e4), t5);
  }
  __name(Un, "Un");
  function Dn() {
  }
  __name(Dn, "Dn");
  function In(e4, n6) {
    var t5 = Ye();
    n6 = void 0 === n6 ? null : n6;
    var r6 = t5.memoizedState;
    return null !== n6 && He(n6, r6[1]) ? r6[0] : (t5.memoizedState = [e4, n6], e4);
  }
  __name(In, "In");
  function Fn(e4, n6) {
    var t5 = Ye();
    n6 = void 0 === n6 ? null : n6;
    var r6 = t5.memoizedState;
    if (null !== n6 && He(n6, r6[1])) return r6[0];
    if (r6 = e4(), gu) {
      k3(true);
      try {
        e4();
      } finally {
        k3(false);
      }
    }
    return t5.memoizedState = [r6, n6], r6;
  }
  __name(Fn, "Fn");
  function jn(e4, n6, t5) {
    return void 0 === t5 || 0 != (1073741824 & cu) && 0 == (261930 & Bu) ? e4.memoizedState = n6 : (e4.memoizedState = t5, e4 = wr(), du.lanes |= e4, Xu |= e4, t5);
  }
  __name(jn, "jn");
  function An(e4, n6, t5, r6) {
    return uo(t5, n6) ? t5 : null !== au.current ? (e4 = jn(e4, t5, r6), uo(e4, n6) || (Pu = true), e4) : 0 == (42 & cu) || 0 != (1073741824 & cu) && 0 == (261930 & Bu) ? (Pu = true, e4.memoizedState = t5) : (e4 = wr(), du.lanes |= e4, Xu |= e4, n6);
  }
  __name(An, "An");
  function Hn(e4, n6, t5, r6, l5) {
    var a5 = Xl();
    Kl(0 !== a5 && 8 > a5 ? a5 : 8);
    var o5, u4, i3, s5 = Dl.T, c3 = {};
    Dl.T = c3, qn(e4, false, n6, t5);
    try {
      var d4 = l5(), f5 = Dl.S;
      null !== f5 && f5(c3, d4), null !== d4 && "object" == typeof d4 && "function" == typeof d4.then ? Vn(e4, n6, (o5 = r6, u4 = [], i3 = { status: "pending", value: null, reason: null, then: /* @__PURE__ */ __name(function(e5) {
        u4.push(e5);
      }, "then") }, d4.then(function() {
        i3.status = "fulfilled", i3.value = o5;
        for (var e5 = 0; e5 < u4.length; e5++) (0, u4[e5])(o5);
      }, function(e5) {
        for (i3.status = "rejected", i3.reason = e5, e5 = 0; e5 < u4.length; e5++) (0, u4[e5])(void 0);
      }), i3), kr()) : Vn(e4, n6, r6, kr());
    } catch (t6) {
      Vn(e4, n6, { then: /* @__PURE__ */ __name(function() {
      }, "then"), status: "rejected", reason: t6 }, kr());
    } finally {
      Kl(a5), null !== s5 && null !== c3.types && (s5.types = c3.types), Dl.T = s5;
    }
  }
  __name(Hn, "Hn");
  function On() {
    return O(ca);
  }
  __name(On, "On");
  function Mn() {
    return Ye().memoizedState;
  }
  __name(Mn, "Mn");
  function Wn() {
    return Ye().memoizedState;
  }
  __name(Wn, "Wn");
  function Qn(e4) {
    for (var n6 = e4.return; null !== n6; ) {
      switch (n6.tag) {
        case 24:
        case 3:
          var t5 = kr(), r6 = we(n6, e4 = ke(t5), t5);
          return null !== r6 && (zr(r6, 0, t5), ze(r6, n6, t5)), n6 = { cache: Q() }, void (e4.payload = n6);
      }
      n6 = n6.return;
    }
  }
  __name(Qn, "Qn");
  function Bn(e4, n6, t5) {
    var r6 = kr();
    t5 = { lane: r6, revertLane: 0, gesture: null, action: t5, hasEagerState: false, eagerState: null, next: null }, Yn(e4) ? Gn(n6, t5) : null !== (t5 = he(e4, n6, t5, r6)) && (zr(t5, 0, r6), Jn(t5, n6, r6));
  }
  __name(Bn, "Bn");
  function $n(e4, n6, t5) {
    Vn(e4, n6, t5, kr());
  }
  __name($n, "$n");
  function Vn(e4, n6, t5, r6) {
    var l5 = { lane: r6, revertLane: 0, gesture: null, action: t5, hasEagerState: false, eagerState: null, next: null };
    if (Yn(e4)) Gn(n6, l5);
    else {
      var a5 = e4.alternate;
      if (0 === e4.lanes && (null === a5 || 0 === a5.lanes) && null !== (a5 = n6.lastRenderedReducer)) try {
        var o5 = n6.lastRenderedState, u4 = a5(o5, t5);
        if (l5.hasEagerState = true, l5.eagerState = u4, uo(u4, o5)) return me(e4, n6, l5, 0), null === Wu && pe(), false;
      } catch (e5) {
      }
      if (null !== (t5 = he(e4, n6, l5, r6))) return zr(t5, 0, r6), Jn(t5, n6, r6), true;
    }
    return false;
  }
  __name(Vn, "Vn");
  function qn(e4, n6, t5, l5) {
    if (l5 = { lane: 2, revertLane: X(), gesture: null, action: l5, hasEagerState: false, eagerState: null, next: null }, Yn(e4)) {
      if (n6) throw Error(r5(479));
    } else null !== (n6 = he(e4, t5, l5, 2)) && zr(n6, 0, 2);
  }
  __name(qn, "qn");
  function Yn(e4) {
    var n6 = e4.alternate;
    return e4 === du || null !== n6 && n6 === du;
  }
  __name(Yn, "Yn");
  function Gn(e4, n6) {
    hu = mu = true;
    var t5 = e4.pending;
    null === t5 ? n6.next = n6 : (n6.next = t5.next, t5.next = n6), e4.pending = n6;
  }
  __name(Gn, "Gn");
  function Jn(e4, n6, t5) {
    if (0 != (4194048 & t5)) {
      var r6 = n6.lanes;
      t5 |= r6 &= e4.pendingLanes, n6.lanes = t5, b3(e4, t5);
    }
  }
  __name(Jn, "Jn");
  function Kn(e4, n6, t5, r6) {
    t5 = null == (t5 = t5(r6, n6 = e4.memoizedState)) ? n6 : hl({}, n6, t5), e4.memoizedState = t5, 0 === e4.lanes && (e4.updateQueue.baseState = t5);
  }
  __name(Kn, "Kn");
  function Xn(e4, n6, t5, r6, l5, a5, o5) {
    return "function" == typeof (e4 = e4.stateNode).shouldComponentUpdate ? e4.shouldComponentUpdate(r6, a5, o5) : !(n6.prototype && n6.prototype.isPureReactComponent && re(t5, r6) && re(l5, a5));
  }
  __name(Xn, "Xn");
  function Zn(e4, n6, t5, r6) {
    e4 = n6.state, "function" == typeof n6.componentWillReceiveProps && n6.componentWillReceiveProps(t5, r6), "function" == typeof n6.UNSAFE_componentWillReceiveProps && n6.UNSAFE_componentWillReceiveProps(t5, r6), n6.state !== e4 && Eu.enqueueReplaceState(n6, n6.state, null);
  }
  __name(Zn, "Zn");
  function et(e4, n6) {
    var t5 = n6;
    if ("ref" in n6) for (var r6 in t5 = {}, n6) "ref" !== r6 && (t5[r6] = n6[r6]);
    if (e4 = e4.defaultProps) for (var l5 in t5 === n6 && (t5 = hl({}, t5)), e4) void 0 === t5[l5] && (t5[l5] = e4[l5]);
    return t5;
  }
  __name(et, "et");
  function nt(e4, n6) {
    try {
      (0, e4.onUncaughtError)(n6.value, { componentStack: n6.stack });
    } catch (e5) {
      setTimeout(function() {
        throw e5;
      });
    }
  }
  __name(nt, "nt");
  function tt(e4, n6, t5) {
    try {
      (0, e4.onCaughtError)(t5.value, { componentStack: t5.stack, errorBoundary: 1 === n6.tag ? n6.stateNode : null });
    } catch (e5) {
      setTimeout(function() {
        throw e5;
      });
    }
  }
  __name(tt, "tt");
  function rt(e4, n6, t5) {
    return (t5 = ke(t5)).tag = 3, t5.payload = { element: null }, t5.callback = function() {
      nt(e4, n6);
    }, t5;
  }
  __name(rt, "rt");
  function lt(e4) {
    return (e4 = ke(e4)).tag = 3, e4;
  }
  __name(lt, "lt");
  function at(e4, n6, t5, r6) {
    var l5 = t5.type.getDerivedStateFromError;
    if ("function" == typeof l5) {
      var a5 = r6.value;
      e4.payload = function() {
        return l5(a5);
      }, e4.callback = function() {
        tt(n6, t5, r6);
      };
    }
    var o5 = t5.stateNode;
    null !== o5 && "function" == typeof o5.componentDidCatch && (e4.callback = function() {
      tt(n6, t5, r6), "function" != typeof l5 && (null === ci ? ci = /* @__PURE__ */ new Set([this]) : ci.add(this));
      var e5 = r6.stack;
      this.componentDidCatch(r6.value, { componentStack: null !== e5 ? e5 : "" });
    });
  }
  __name(at, "at");
  function ot(e4, n6, t5, r6) {
    n6.child = null === e4 ? Zo(n6, null, t5, r6) : Xo(n6, e4.child, t5, r6);
  }
  __name(ot, "ot");
  function ut(e4, n6, t5, r6, l5) {
    t5 = t5.render;
    var a5 = n6.ref;
    if ("ref" in r6) {
      var o5 = {};
      for (var u4 in r6) "ref" !== u4 && (o5[u4] = r6[u4]);
    } else o5 = r6;
    return H(n6), r6 = Oe(e4, n6, t5, o5, a5, l5), u4 = Be(), null === e4 || Pu ? (n6.flags |= 1, ot(e4, n6, r6, l5), n6.child) : ($e(e4, n6, l5), _t(e4, n6, l5));
  }
  __name(ut, "ut");
  function it(e4, n6, t5, r6, l5) {
    if (null === e4) {
      var a5 = t5.type;
      return "function" != typeof a5 || rl(a5) || void 0 !== a5.defaultProps || null !== t5.compare ? ((e4 = ol(t5.type, null, r6, n6, n6.mode, l5)).ref = n6.ref, e4.return = n6, n6.child = e4) : (n6.tag = 15, n6.type = a5, st(e4, n6, a5, r6, l5));
    }
    if (a5 = e4.child, !Tt(e4, l5)) {
      var o5 = a5.memoizedProps;
      if ((t5 = null !== (t5 = t5.compare) ? t5 : re)(o5, r6) && e4.ref === n6.ref) return _t(e4, n6, l5);
    }
    return n6.flags |= 1, (e4 = ll(a5, r6)).ref = n6.ref, e4.return = n6, n6.child = e4;
  }
  __name(it, "it");
  function st(e4, n6, t5, r6, l5) {
    if (null !== e4) {
      var a5 = e4.memoizedProps;
      if (re(a5, r6) && e4.ref === n6.ref) {
        if (Pu = false, n6.pendingProps = r6 = a5, !Tt(e4, l5)) return n6.lanes = e4.lanes, _t(e4, n6, l5);
        0 != (131072 & e4.flags) && (Pu = true);
      }
    }
    return gt(e4, n6, t5, r6, l5);
  }
  __name(st, "st");
  function ct(e4, n6, t5, r6) {
    var l5 = r6.children, a5 = null !== e4 ? e4.memoizedState : null;
    if (null === e4 && null === n6.stateNode && (n6.stateNode = { _visibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null }), "hidden" === r6.mode) {
      if (0 != (128 & n6.flags)) {
        if (a5 = null !== a5 ? a5.baseLanes | t5 : t5, null !== e4) {
          for (r6 = n6.child = e4.child, l5 = 0; null !== r6; ) l5 = l5 | r6.lanes | r6.childLanes, r6 = r6.sibling;
          r6 = l5 & ~a5;
        } else r6 = 0, n6.child = null;
        return ft(e4, n6, a5, t5, r6);
      }
      if (0 == (536870912 & t5)) return r6 = n6.lanes = 536870912, ft(e4, n6, null !== a5 ? a5.baseLanes | t5 : t5, t5, r6);
      n6.memoizedState = { baseLanes: 0, cachePool: null }, null !== e4 && ne(0, null !== a5 ? a5.cachePool : null), null !== a5 ? Te(n6, a5) : Re(), De(n6);
    } else null !== a5 ? (ne(0, a5.cachePool), Te(n6, a5), Ie(), n6.memoizedState = null) : (null !== e4 && ne(0, null), Re(), Ie());
    return ot(e4, n6, l5, t5), n6.child;
  }
  __name(ct, "ct");
  function dt(e4, n6) {
    return null !== e4 && 22 === e4.tag || null !== n6.stateNode || (n6.stateNode = { _visibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null }), n6.sibling;
  }
  __name(dt, "dt");
  function ft(e4, n6, t5, r6, l5) {
    var a5 = ee();
    return a5 = null === a5 ? null : { parent: Lo._currentValue2, pool: a5 }, n6.memoizedState = { baseLanes: t5, cachePool: a5 }, null !== e4 && ne(0, null), Re(), De(n6), null !== e4 && j(e4, n6, r6, true), n6.childLanes = l5, null;
  }
  __name(ft, "ft");
  function pt(e4, n6) {
    return (n6 = zt({ mode: n6.mode, children: n6.children }, e4.mode)).ref = e4.ref, e4.child = n6, n6.return = e4, n6;
  }
  __name(pt, "pt");
  function mt(e4, n6, t5) {
    return Xo(n6, e4.child, null, t5), (e4 = pt(n6, n6.pendingProps)).flags |= 2, Fe(n6), n6.memoizedState = null, e4;
  }
  __name(mt, "mt");
  function ht(e4, n6) {
    var t5 = n6.ref;
    if (null === t5) null !== e4 && null !== e4.ref && (n6.flags |= 4194816);
    else {
      if ("function" != typeof t5 && "object" != typeof t5) throw Error(r5(284));
      null !== e4 && e4.ref === t5 || (n6.flags |= 4194816);
    }
  }
  __name(ht, "ht");
  function gt(e4, n6, t5, r6, l5) {
    return H(n6), t5 = Oe(e4, n6, t5, r6, void 0, l5), r6 = Be(), null === e4 || Pu ? (n6.flags |= 1, ot(e4, n6, t5, l5), n6.child) : ($e(e4, n6, l5), _t(e4, n6, l5));
  }
  __name(gt, "gt");
  function yt(e4, n6, t5, r6, l5, a5) {
    return H(n6), n6.updateQueue = null, t5 = We(n6, r6, t5, l5), Me(e4), r6 = Be(), null === e4 || Pu ? (n6.flags |= 1, ot(e4, n6, t5, a5), n6.child) : ($e(e4, n6, a5), _t(e4, n6, a5));
  }
  __name(yt, "yt");
  function bt(e4, n6, t5, r6, l5) {
    if (H(n6), null === n6.stateNode) {
      var a5 = Wa, o5 = t5.contextType;
      "object" == typeof o5 && null !== o5 && (a5 = O(o5)), a5 = new t5(r6, a5), n6.memoizedState = null !== a5.state && void 0 !== a5.state ? a5.state : null, a5.updater = Eu, n6.stateNode = a5, a5._reactInternals = n6, (a5 = n6.stateNode).props = r6, a5.state = n6.memoizedState, a5.refs = {}, ve(n6), o5 = t5.contextType, a5.context = "object" == typeof o5 && null !== o5 ? O(o5) : Wa, a5.state = n6.memoizedState, "function" == typeof (o5 = t5.getDerivedStateFromProps) && (Kn(n6, t5, o5, r6), a5.state = n6.memoizedState), "function" == typeof t5.getDerivedStateFromProps || "function" == typeof a5.getSnapshotBeforeUpdate || "function" != typeof a5.UNSAFE_componentWillMount && "function" != typeof a5.componentWillMount || (o5 = a5.state, "function" == typeof a5.componentWillMount && a5.componentWillMount(), "function" == typeof a5.UNSAFE_componentWillMount && a5.UNSAFE_componentWillMount(), o5 !== a5.state && Eu.enqueueReplaceState(a5, a5.state, null), Ce(n6, r6, a5, l5), Ee(), a5.state = n6.memoizedState), "function" == typeof a5.componentDidMount && (n6.flags |= 4194308), r6 = true;
    } else if (null === e4) {
      a5 = n6.stateNode;
      var u4 = n6.memoizedProps, i3 = et(t5, u4);
      a5.props = i3;
      var s5 = a5.context, c3 = t5.contextType;
      o5 = Wa, "object" == typeof c3 && null !== c3 && (o5 = O(c3));
      var d4 = t5.getDerivedStateFromProps;
      c3 = "function" == typeof d4 || "function" == typeof a5.getSnapshotBeforeUpdate, u4 = n6.pendingProps !== u4, c3 || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (u4 || s5 !== o5) && Zn(n6, a5, r6, o5), ru = false;
      var f5 = n6.memoizedState;
      a5.state = f5, Ce(n6, r6, a5, l5), Ee(), s5 = n6.memoizedState, u4 || f5 !== s5 || ru ? ("function" == typeof d4 && (Kn(n6, t5, d4, r6), s5 = n6.memoizedState), (i3 = ru || Xn(n6, t5, i3, r6, f5, s5, o5)) ? (c3 || "function" != typeof a5.UNSAFE_componentWillMount && "function" != typeof a5.componentWillMount || ("function" == typeof a5.componentWillMount && a5.componentWillMount(), "function" == typeof a5.UNSAFE_componentWillMount && a5.UNSAFE_componentWillMount()), "function" == typeof a5.componentDidMount && (n6.flags |= 4194308)) : ("function" == typeof a5.componentDidMount && (n6.flags |= 4194308), n6.memoizedProps = r6, n6.memoizedState = s5), a5.props = r6, a5.state = s5, a5.context = o5, r6 = i3) : ("function" == typeof a5.componentDidMount && (n6.flags |= 4194308), r6 = false);
    } else {
      a5 = n6.stateNode, Se(e4, n6), c3 = et(t5, o5 = n6.memoizedProps), a5.props = c3, d4 = n6.pendingProps, f5 = a5.context, s5 = t5.contextType, i3 = Wa, "object" == typeof s5 && null !== s5 && (i3 = O(s5)), (s5 = "function" == typeof (u4 = t5.getDerivedStateFromProps) || "function" == typeof a5.getSnapshotBeforeUpdate) || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (o5 !== d4 || f5 !== i3) && Zn(n6, a5, r6, i3), ru = false, f5 = n6.memoizedState, a5.state = f5, Ce(n6, r6, a5, l5), Ee();
      var p4 = n6.memoizedState;
      o5 !== d4 || f5 !== p4 || ru || null !== e4 && null !== e4.dependencies && A(e4.dependencies) ? ("function" == typeof u4 && (Kn(n6, t5, u4, r6), p4 = n6.memoizedState), (c3 = ru || Xn(n6, t5, c3, r6, f5, p4, i3) || null !== e4 && null !== e4.dependencies && A(e4.dependencies)) ? (s5 || "function" != typeof a5.UNSAFE_componentWillUpdate && "function" != typeof a5.componentWillUpdate || ("function" == typeof a5.componentWillUpdate && a5.componentWillUpdate(r6, p4, i3), "function" == typeof a5.UNSAFE_componentWillUpdate && a5.UNSAFE_componentWillUpdate(r6, p4, i3)), "function" == typeof a5.componentDidUpdate && (n6.flags |= 4), "function" == typeof a5.getSnapshotBeforeUpdate && (n6.flags |= 1024)) : ("function" != typeof a5.componentDidUpdate || o5 === e4.memoizedProps && f5 === e4.memoizedState || (n6.flags |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || o5 === e4.memoizedProps && f5 === e4.memoizedState || (n6.flags |= 1024), n6.memoizedProps = r6, n6.memoizedState = p4), a5.props = r6, a5.state = p4, a5.context = i3, r6 = c3) : ("function" != typeof a5.componentDidUpdate || o5 === e4.memoizedProps && f5 === e4.memoizedState || (n6.flags |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || o5 === e4.memoizedProps && f5 === e4.memoizedState || (n6.flags |= 1024), r6 = false);
    }
    return a5 = r6, ht(e4, n6), r6 = 0 != (128 & n6.flags), a5 || r6 ? (a5 = n6.stateNode, t5 = r6 && "function" != typeof t5.getDerivedStateFromError ? null : a5.render(), n6.flags |= 1, null !== e4 && r6 ? (n6.child = Xo(n6, e4.child, null, l5), n6.child = Xo(n6, null, t5, l5)) : ot(e4, n6, t5, l5), n6.memoizedState = a5.state, e4 = n6.child) : e4 = _t(e4, n6, l5), e4;
  }
  __name(bt, "bt");
  function vt(e4) {
    return { baseLanes: e4, cachePool: te() };
  }
  __name(vt, "vt");
  function St(e4, n6, t5) {
    return e4 = null !== e4 ? e4.childLanes & ~t5 : 0, n6 && (e4 |= ni), e4;
  }
  __name(St, "St");
  function kt(e4, n6, t5) {
    var l5, a5 = n6.pendingProps, o5 = false, u4 = 0 != (128 & n6.flags);
    if ((l5 = u4) || (l5 = (null === e4 || null !== e4.memoizedState) && 0 != (2 & su.current)), l5 && (o5 = true, n6.flags &= -129), l5 = 0 != (32 & n6.flags), n6.flags &= -33, null === e4) {
      var i3 = a5.children;
      return a5 = a5.fallback, o5 ? (Ie(), i3 = zt({ mode: "hidden", children: i3 }, o5 = n6.mode), a5 = ul(a5, o5, t5, null), i3.return = n6, a5.return = n6, i3.sibling = a5, n6.child = i3, (a5 = n6.child).memoizedState = vt(t5), a5.childLanes = St(e4, l5, t5), n6.memoizedState = _u, dt(null, a5)) : (Le(n6), wt(n6, i3));
    }
    var s5, c3 = e4.memoizedState;
    if (null !== c3 && null !== (i3 = c3.dehydrated)) {
      if (u4) 256 & n6.flags ? (Le(n6), n6.flags &= -257, n6 = xt(e4, n6, t5)) : null !== n6.memoizedState ? (Ie(), n6.child = e4.child, n6.flags |= 128, n6 = null) : (Ie(), i3 = a5.fallback, o5 = n6.mode, a5 = zt({ mode: "visible", children: a5.children }, o5), (i3 = ul(i3, o5, t5, null)).flags |= 2, a5.return = n6, i3.return = n6, a5.sibling = i3, n6.child = a5, Xo(n6, e4.child, null, t5), (a5 = n6.child).memoizedState = vt(t5), a5.childLanes = St(e4, l5, t5), n6.memoizedState = _u, n6 = dt(null, a5));
      else if (Le(n6), _a(i3)) l5 = Ta(i3).digest, (a5 = Error(r5(419))).stack = "", a5.digest = l5, s5 = { value: a5, source: null, stack: null }, null === Eo ? Eo = [s5] : Eo.push(s5), n6 = xt(e4, n6, t5);
      else if (Pu || j(e4, n6, t5, false), l5 = 0 != (t5 & e4.childLanes), Pu || l5) {
        if (null !== (l5 = Wu) && 0 !== (a5 = v3(l5, t5)) && a5 !== c3.retryLane) throw c3.retryLane = a5, ge(e4, a5), zr(l5, 0, a5), Cu;
        Pa(i3) || Ur(), n6 = xt(e4, n6, t5);
      } else Pa(i3) ? (n6.flags |= 192, n6.child = e4.child, n6 = null) : (e4 = c3.treeContext, (n6 = wt(n6, a5.children)).flags |= 4096);
      return n6;
    }
    return o5 ? (Ie(), i3 = a5.fallback, o5 = n6.mode, u4 = (c3 = e4.child).sibling, (a5 = ll(c3, { mode: "hidden", children: a5.children })).subtreeFlags = 65011712 & c3.subtreeFlags, null !== u4 ? i3 = ll(u4, i3) : (i3 = ul(i3, o5, t5, null)).flags |= 2, i3.return = n6, a5.return = n6, a5.sibling = i3, n6.child = a5, dt(null, a5), a5 = n6.child, null === (i3 = e4.child.memoizedState) ? i3 = vt(t5) : (null !== (o5 = i3.cachePool) ? (c3 = Lo._currentValue2, o5 = o5.parent !== c3 ? { parent: c3, pool: c3 } : o5) : o5 = te(), i3 = { baseLanes: i3.baseLanes | t5, cachePool: o5 }), a5.memoizedState = i3, a5.childLanes = St(e4, l5, t5), n6.memoizedState = _u, dt(e4.child, a5)) : (Le(n6), e4 = (t5 = e4.child).sibling, (t5 = ll(t5, { mode: "visible", children: a5.children })).return = n6, t5.sibling = null, null !== e4 && (null === (l5 = n6.deletions) ? (n6.deletions = [e4], n6.flags |= 16) : l5.push(e4)), n6.child = t5, n6.memoizedState = null, t5);
  }
  __name(kt, "kt");
  function wt(e4, n6) {
    return (n6 = zt({ mode: "visible", children: n6 }, e4.mode)).return = e4, e4.child = n6;
  }
  __name(wt, "wt");
  function zt(e4, n6) {
    return (e4 = t4(22, e4, null, n6)).lanes = 0, e4;
  }
  __name(zt, "zt");
  function xt(e4, n6, t5) {
    return Xo(n6, e4.child, null, t5), (e4 = wt(n6, n6.pendingProps.children)).flags |= 2, n6.memoizedState = null, e4;
  }
  __name(xt, "xt");
  function Et(e4, n6, t5) {
    e4.lanes |= n6;
    var r6 = e4.alternate;
    null !== r6 && (r6.lanes |= n6), I(e4.return, n6, t5);
  }
  __name(Et, "Et");
  function Ct(e4, n6, t5, r6, l5, a5) {
    var o5 = e4.memoizedState;
    null === o5 ? e4.memoizedState = { isBackwards: n6, rendering: null, renderingStartTime: 0, last: r6, tail: t5, tailMode: l5, treeForkCount: a5 } : (o5.isBackwards = n6, o5.rendering = null, o5.renderingStartTime = 0, o5.last = r6, o5.tail = t5, o5.tailMode = l5, o5.treeForkCount = a5);
  }
  __name(Ct, "Ct");
  function Pt(e4, n6, t5) {
    var r6 = n6.pendingProps, l5 = r6.revealOrder, a5 = r6.tail;
    r6 = r6.children;
    var o5 = su.current, u4 = 0 != (2 & o5);
    if (u4 ? (o5 = 1 & o5 | 2, n6.flags |= 128) : o5 &= 1, s4(su, o5), ot(e4, n6, r6, t5), r6 = 0, !u4 && null !== e4 && 0 != (128 & e4.flags)) e: for (e4 = n6.child; null !== e4; ) {
      if (13 === e4.tag) null !== e4.memoizedState && Et(e4, t5, n6);
      else if (19 === e4.tag) Et(e4, t5, n6);
      else if (null !== e4.child) {
        e4.child.return = e4, e4 = e4.child;
        continue;
      }
      if (e4 === n6) break e;
      for (; null === e4.sibling; ) {
        if (null === e4.return || e4.return === n6) break e;
        e4 = e4.return;
      }
      e4.sibling.return = e4.return, e4 = e4.sibling;
    }
    switch (l5) {
      case "forwards":
        for (t5 = n6.child, l5 = null; null !== t5; ) null !== (e4 = t5.alternate) && null === je(e4) && (l5 = t5), t5 = t5.sibling;
        null === (t5 = l5) ? (l5 = n6.child, n6.child = null) : (l5 = t5.sibling, t5.sibling = null), Ct(n6, false, l5, t5, a5, r6);
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (t5 = null, l5 = n6.child, n6.child = null; null !== l5; ) {
          if (null !== (e4 = l5.alternate) && null === je(e4)) {
            n6.child = l5;
            break;
          }
          e4 = l5.sibling, l5.sibling = t5, t5 = l5, l5 = e4;
        }
        Ct(n6, true, t5, null, a5, r6);
        break;
      case "together":
        Ct(n6, false, null, null, void 0, r6);
        break;
      default:
        n6.memoizedState = null;
    }
    return n6.child;
  }
  __name(Pt, "Pt");
  function _t(e4, n6, t5) {
    if (null !== e4 && (n6.dependencies = e4.dependencies), Xu |= n6.lanes, 0 == (t5 & n6.childLanes)) {
      if (null === e4) return null;
      if (j(e4, n6, t5, false), 0 == (t5 & n6.childLanes)) return null;
    }
    if (null !== e4 && n6.child !== e4.child) throw Error(r5(153));
    if (null !== n6.child) {
      for (t5 = ll(e4 = n6.child, e4.pendingProps), n6.child = t5, t5.return = n6; null !== e4.sibling; ) e4 = e4.sibling, (t5 = t5.sibling = ll(e4, e4.pendingProps)).return = n6;
      t5.sibling = null;
    }
    return n6.child;
  }
  __name(_t, "_t");
  function Tt(e4, n6) {
    return 0 != (e4.lanes & n6) || !(null === (e4 = e4.dependencies) || !A(e4));
  }
  __name(Tt, "Tt");
  function Rt(e4, n6, t5) {
    if (null !== e4) if (e4.memoizedProps !== n6.pendingProps) Pu = true;
    else {
      if (!Tt(e4, t5) && 0 == (128 & n6.flags)) return Pu = false, function(e5, n7, t6) {
        switch (n7.tag) {
          case 3:
            _(n7, n7.stateNode.containerInfo), U(0, Lo, e5.memoizedState.cache);
            break;
          case 27:
          case 5:
            R(n7);
            break;
          case 4:
            _(n7, n7.stateNode.containerInfo);
            break;
          case 10:
            U(0, n7.type, n7.memoizedProps.value);
            break;
          case 31:
            if (null !== n7.memoizedState) return n7.flags |= 128, Ue(n7), null;
            break;
          case 13:
            var r6 = n7.memoizedState;
            if (null !== r6) return null !== r6.dehydrated ? (Le(n7), n7.flags |= 128, null) : 0 != (t6 & n7.child.childLanes) ? kt(e5, n7, t6) : (Le(n7), null !== (e5 = _t(e5, n7, t6)) ? e5.sibling : null);
            Le(n7);
            break;
          case 19:
            var l6 = 0 != (128 & e5.flags);
            if ((r6 = 0 != (t6 & n7.childLanes)) || (j(e5, n7, t6, false), r6 = 0 != (t6 & n7.childLanes)), l6) {
              if (r6) return Pt(e5, n7, t6);
              n7.flags |= 128;
            }
            if (null !== (l6 = n7.memoizedState) && (l6.rendering = null, l6.tail = null, l6.lastEffect = null), s4(su, su.current), r6) break;
            return null;
          case 22:
            return n7.lanes = 0, ct(e5, n7, t6, n7.pendingProps);
          case 24:
            U(0, Lo, e5.memoizedState.cache);
        }
        return _t(e5, n7, t6);
      }(e4, n6, t5);
      Pu = 0 != (131072 & e4.flags);
    }
    else Pu = false;
    switch (n6.lanes = 0, n6.tag) {
      case 16:
        e: {
          var l5 = n6.pendingProps;
          if (e4 = oe(n6.elementType), n6.type = e4, "function" != typeof e4) {
            if (null != e4) {
              var o5 = e4.$$typeof;
              if (o5 === xl) {
                n6.tag = 11, n6 = ut(null, n6, e4, l5, t5);
                break e;
              }
              if (o5 === Pl) {
                n6.tag = 14, n6 = it(null, n6, e4, l5, t5);
                break e;
              }
            }
            throw n6 = a4(e4) || e4, Error(r5(306, n6, ""));
          }
          rl(e4) ? (l5 = et(e4, l5), n6.tag = 1, n6 = bt(null, n6, e4, l5, t5)) : (n6.tag = 0, n6 = gt(null, n6, e4, l5, t5));
        }
        return n6;
      case 0:
        return gt(e4, n6, n6.type, n6.pendingProps, t5);
      case 1:
        return bt(e4, n6, l5 = n6.type, o5 = et(l5, n6.pendingProps), t5);
      case 3:
        if (_(n6, n6.stateNode.containerInfo), null === e4) throw Error(r5(387));
        var u4 = n6.pendingProps;
        l5 = (o5 = n6.memoizedState).element, Se(e4, n6), Ce(n6, u4, null, t5);
        var i3 = n6.memoizedState;
        return u4 = i3.cache, U(0, Lo, u4), u4 !== o5.cache && F(n6, [Lo], t5, true), Ee(), (u4 = i3.element) !== l5 ? (ot(e4, n6, u4, t5), n6 = n6.child) : n6 = _t(e4, n6, t5), n6;
      case 26:
      case 27:
      case 5:
        return R(n6), o5 = n6.type, u4 = n6.pendingProps, i3 = null !== e4 ? e4.memoizedProps : null, l5 = u4.children, Ql(o5, u4) ? l5 = null : null !== i3 && Ql(o5, i3) && (n6.flags |= 32), null !== n6.memoizedState && (o5 = Oe(e4, n6, Qe, null, null, t5), ca._currentValue2 = o5), ht(e4, n6), ot(e4, n6, l5, t5), n6.child;
      case 6:
        return null;
      case 13:
        return kt(e4, n6, t5);
      case 4:
        return _(n6, n6.stateNode.containerInfo), l5 = n6.pendingProps, null === e4 ? n6.child = Xo(n6, null, l5, t5) : ot(e4, n6, l5, t5), n6.child;
      case 11:
        return ut(e4, n6, n6.type, n6.pendingProps, t5);
      case 7:
        return ot(e4, n6, n6.pendingProps, t5), n6.child;
      case 8:
      case 12:
        return ot(e4, n6, n6.pendingProps.children, t5), n6.child;
      case 10:
        return l5 = n6.pendingProps, U(0, n6.type, l5.value), ot(e4, n6, l5.children, t5), n6.child;
      case 9:
        return o5 = n6.type._context, l5 = n6.pendingProps.children, H(n6), l5 = l5(o5 = O(o5)), n6.flags |= 1, ot(e4, n6, l5, t5), n6.child;
      case 14:
        return it(e4, n6, n6.type, n6.pendingProps, t5);
      case 15:
        return st(e4, n6, n6.type, n6.pendingProps, t5);
      case 19:
        return Pt(e4, n6, t5);
      case 31:
        return function(e5, n7, t6) {
          var l6 = n7.pendingProps, a5 = 0 != (128 & n7.flags);
          if (n7.flags &= -129, null === e5) return pt(n7, l6);
          var o6 = e5.memoizedState;
          if (null !== o6) {
            var u5 = o6.dehydrated;
            if (Ue(n7), a5) if (256 & n7.flags) n7.flags &= -257, n7 = mt(e5, n7, t6);
            else {
              if (null === n7.memoizedState) throw Error(r5(558));
              n7.child = e5.child, n7.flags |= 128, n7 = null;
            }
            else if (Pu || j(e5, n7, t6, false), a5 = 0 != (t6 & e5.childLanes), Pu || a5) {
              if (null !== (l6 = Wu) && 0 !== (u5 = v3(l6, t6)) && u5 !== o6.retryLane) throw o6.retryLane = u5, ge(e5, u5), zr(l6, 0, u5), Cu;
              Ur(), n7 = mt(e5, n7, t6);
            } else e5 = o6.treeContext, (n7 = pt(n7, l6)).flags |= 4096;
            return n7;
          }
          return (e5 = ll(e5.child, { mode: l6.mode, children: l6.children })).ref = n7.ref, n7.child = e5, e5.return = n7, e5;
        }(e4, n6, t5);
      case 22:
        return ct(e4, n6, t5, n6.pendingProps);
      case 24:
        return H(n6), l5 = O(Lo), null === e4 ? (null === (o5 = ee()) && (o5 = Wu, u4 = Q(), o5.pooledCache = u4, u4.refCount++, null !== u4 && (o5.pooledCacheLanes |= t5), o5 = u4), n6.memoizedState = { parent: l5, cache: o5 }, ve(n6), U(0, Lo, o5)) : (0 != (e4.lanes & t5) && (Se(e4, n6), Ce(n6, null, null, t5), Ee()), o5 = e4.memoizedState, u4 = n6.memoizedState, o5.parent !== l5 ? (o5 = { parent: l5, cache: l5 }, n6.memoizedState = o5, 0 === n6.lanes && (n6.memoizedState = n6.updateQueue.baseState = o5), U(0, Lo, l5)) : (l5 = u4.cache, U(0, Lo, l5), l5 !== o5.cache && F(n6, [Lo], t5, true))), ot(e4, n6, n6.pendingProps.children, t5), n6.child;
      case 29:
        throw n6.pendingProps;
    }
    throw Error(r5(156, n6.tag));
  }
  __name(Rt, "Rt");
  function Nt(e4) {
    e4.flags |= 4;
  }
  __name(Nt, "Nt");
  function Lt(e4, n6, t5, r6, l5) {
    if (0 != (32 & e4.mode) && (null === t5 ? ta(n6, r6) : ra(n6, t5, r6))) {
      if (e4.flags |= 16777216, (335544128 & l5) === l5 || la(n6, r6)) if (aa(e4.stateNode, n6, r6)) e4.flags |= 8192;
      else {
        if (null !== (a5 = uu.current) && ((4194048 & Bu) === Bu ? null !== iu : (62914560 & Bu) !== Bu && 0 == (536870912 & Bu) || a5 !== iu)) throw Go = Yo, Vo;
        e4.flags |= 8192;
      }
    } else e4.flags &= -16777217;
    var a5;
  }
  __name(Lt, "Lt");
  function Ut(e4, n6) {
    null !== n6 && (e4.flags |= 4), 16384 & e4.flags && (n6 = 22 !== e4.tag ? m3() : 536870912, e4.lanes |= n6, ti |= n6);
  }
  __name(Ut, "Ut");
  function Dt(e4, n6) {
    switch (e4.tailMode) {
      case "hidden":
        n6 = e4.tail;
        for (var t5 = null; null !== n6; ) null !== n6.alternate && (t5 = n6), n6 = n6.sibling;
        null === t5 ? e4.tail = null : t5.sibling = null;
        break;
      case "collapsed":
        t5 = e4.tail;
        for (var r6 = null; null !== t5; ) null !== t5.alternate && (r6 = t5), t5 = t5.sibling;
        null === r6 ? n6 || null === e4.tail ? e4.tail = null : e4.tail.sibling = null : r6.sibling = null;
    }
  }
  __name(Dt, "Dt");
  function It(e4) {
    var n6 = null !== e4.alternate && e4.alternate.child === e4.child, t5 = 0, r6 = 0;
    if (n6) for (var l5 = e4.child; null !== l5; ) t5 |= l5.lanes | l5.childLanes, r6 |= 65011712 & l5.subtreeFlags, r6 |= 65011712 & l5.flags, l5.return = e4, l5 = l5.sibling;
    else for (l5 = e4.child; null !== l5; ) t5 |= l5.lanes | l5.childLanes, r6 |= l5.subtreeFlags, r6 |= l5.flags, l5.return = e4, l5 = l5.sibling;
    return e4.subtreeFlags |= r6, e4.childLanes = t5, n6;
  }
  __name(It, "It");
  function Ft(e4, n6, t5) {
    var l5 = n6.pendingProps;
    switch (P(n6), n6.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
      case 1:
        return It(n6), null;
      case 3:
        return t5 = n6.stateNode, l5 = null, null !== e4 && (l5 = e4.memoizedState.cache), n6.memoizedState.cache !== l5 && (n6.flags |= 2048), D(Lo), T(), t5.pendingContext && (t5.context = t5.pendingContext, t5.pendingContext = null), null !== e4 && null !== e4.child || null === e4 || e4.memoizedState.isDehydrated && 0 == (256 & n6.flags) || (n6.flags |= 1024, L()), It(n6), null;
      case 26:
        var a5, o5;
      case 27:
      case 5:
        if (N(n6), a5 = n6.type, null !== e4 && null != n6.stateNode) !function(e5, n7, t6, r6) {
          e5.memoizedProps !== r6 && Nt(n7);
        }(e4, n6, 0, l5);
        else {
          if (!l5) {
            if (null === n6.stateNode) throw Error(r5(166));
            return It(n6), null;
          }
          o5 = So.current;
          var u4 = Ol(a5, l5, wo.current, o5, n6);
          !function(e5, n7, t6, r6) {
            for (t6 = n7.child; null !== t6; ) {
              if (5 === t6.tag || 6 === t6.tag) Ml(e5, t6.stateNode);
              else if (4 !== t6.tag && !Ha && null !== t6.child) {
                t6.child.return = t6, t6 = t6.child;
                continue;
              }
              if (t6 === n7) break;
              for (; null === t6.sibling; ) {
                if (null === t6.return || t6.return === n7) return;
                t6 = t6.return;
              }
              t6.sibling.return = t6.return, t6 = t6.sibling;
            }
          }(u4, n6, false), n6.stateNode = u4, Wl(u4, a5, l5, o5) && Nt(n6);
        }
        return It(n6), Lt(n6, n6.type, null === e4 ? null : e4.memoizedProps, n6.pendingProps, t5), null;
      case 6:
        if (e4 && null != n6.stateNode) (t5 = e4.memoizedProps) !== l5 && Nt(n6);
        else {
          if ("string" != typeof l5 && null === n6.stateNode) throw Error(r5(166));
          e4 = wo.current, t5 = So.current, n6.stateNode = Bl(l5, e4, t5, n6);
        }
        return It(n6), null;
      case 31:
        if (t5 = n6.memoizedState, null === e4 || null !== e4.memoizedState) {
          if (l5 = false, null !== t5) {
            if (null === e4) {
              if (!l5) throw Error(r5(318));
              throw Error(r5(556));
            }
            0 == (128 & n6.flags) && (n6.memoizedState = null), n6.flags |= 4, It(n6), e4 = false;
          } else t5 = L(), null !== e4 && null !== e4.memoizedState && (e4.memoizedState.hydrationErrors = t5), e4 = true;
          if (!e4) return 256 & n6.flags ? (Fe(n6), n6) : (Fe(n6), null);
          if (0 != (128 & n6.flags)) throw Error(r5(558));
        }
        return It(n6), null;
      case 13:
        if (l5 = n6.memoizedState, null === e4 || null !== e4.memoizedState && null !== e4.memoizedState.dehydrated) {
          if (a5 = false, null !== l5 && null !== l5.dehydrated) {
            if (null === e4) {
              if (!a5) throw Error(r5(318));
              throw Error(r5(344));
            }
            0 == (128 & n6.flags) && (n6.memoizedState = null), n6.flags |= 4, It(n6), a5 = false;
          } else a5 = L(), null !== e4 && null !== e4.memoizedState && (e4.memoizedState.hydrationErrors = a5), a5 = true;
          if (!a5) return 256 & n6.flags ? (Fe(n6), n6) : (Fe(n6), null);
        }
        return Fe(n6), 0 != (128 & n6.flags) ? (n6.lanes = t5, n6) : (t5 = null !== l5, e4 = null !== e4 && null !== e4.memoizedState, t5 && (a5 = null, null !== (l5 = n6.child).alternate && null !== l5.alternate.memoizedState && null !== l5.alternate.memoizedState.cachePool && (a5 = l5.alternate.memoizedState.cachePool.pool), o5 = null, null !== l5.memoizedState && null !== l5.memoizedState.cachePool && (o5 = l5.memoizedState.cachePool.pool), o5 !== a5 && (l5.flags |= 2048)), t5 !== e4 && t5 && (n6.child.flags |= 8192), Ut(n6, n6.updateQueue), It(n6), null);
      case 4:
        return T(), null === e4 && Jl(n6.stateNode.containerInfo), It(n6), null;
      case 10:
        return D(n6.type), It(n6), null;
      case 19:
        if (i2(su), null === (l5 = n6.memoizedState)) return It(n6), null;
        if (a5 = 0 != (128 & n6.flags), null === (o5 = l5.rendering)) if (a5) Dt(l5, false);
        else {
          if (0 !== Ku || null !== e4 && 0 != (128 & e4.flags)) for (e4 = n6.child; null !== e4; ) {
            if (null !== (o5 = je(e4))) {
              for (n6.flags |= 128, Dt(l5, false), e4 = o5.updateQueue, n6.updateQueue = e4, Ut(n6, e4), n6.subtreeFlags = 0, e4 = t5, t5 = n6.child; null !== t5; ) al(t5, e4), t5 = t5.sibling;
              return s4(su, 1 & su.current | 2), n6.child;
            }
            e4 = e4.sibling;
          }
          null !== l5.tail && Za() > ii && (n6.flags |= 128, a5 = true, Dt(l5, false), n6.lanes = 4194304);
        }
        else {
          if (!a5) if (null !== (e4 = je(o5))) {
            if (n6.flags |= 128, a5 = true, e4 = e4.updateQueue, n6.updateQueue = e4, Ut(n6, e4), Dt(l5, true), null === l5.tail && "hidden" === l5.tailMode && !o5.alternate) return It(n6), null;
          } else 2 * Za() - l5.renderingStartTime > ii && 536870912 !== t5 && (n6.flags |= 128, a5 = true, Dt(l5, false), n6.lanes = 4194304);
          l5.isBackwards ? (o5.sibling = n6.child, n6.child = o5) : (null !== (e4 = l5.last) ? e4.sibling = o5 : n6.child = o5, l5.last = o5);
        }
        return null !== l5.tail ? (e4 = l5.tail, l5.rendering = e4, l5.tail = e4.sibling, l5.renderingStartTime = Za(), e4.sibling = null, t5 = su.current, s4(su, a5 ? 1 & t5 | 2 : 1 & t5), e4) : (It(n6), null);
      case 22:
      case 23:
        return Fe(n6), Ne(), l5 = null !== n6.memoizedState, null !== e4 ? null !== e4.memoizedState !== l5 && (n6.flags |= 8192) : l5 && (n6.flags |= 8192), l5 ? 0 != (536870912 & t5) && 0 == (128 & n6.flags) && (It(n6), 6 & n6.subtreeFlags && (n6.flags |= 8192)) : It(n6), null !== (t5 = n6.updateQueue) && Ut(n6, t5.retryQueue), t5 = null, null !== e4 && null !== e4.memoizedState && null !== e4.memoizedState.cachePool && (t5 = e4.memoizedState.cachePool.pool), l5 = null, null !== n6.memoizedState && null !== n6.memoizedState.cachePool && (l5 = n6.memoizedState.cachePool.pool), l5 !== t5 && (n6.flags |= 2048), null !== e4 && i2(Bo), null;
      case 24:
        return t5 = null, null !== e4 && (t5 = e4.memoizedState.cache), n6.memoizedState.cache !== t5 && (n6.flags |= 2048), D(Lo), It(n6), null;
      case 25:
      case 30:
        return null;
    }
    throw Error(r5(156, n6.tag));
  }
  __name(Ft, "Ft");
  function jt(e4, n6) {
    switch (P(n6), n6.tag) {
      case 1:
        return 65536 & (e4 = n6.flags) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 3:
        return D(Lo), T(), 0 != (65536 & (e4 = n6.flags)) && 0 == (128 & e4) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 26:
      case 27:
      case 5:
        return N(n6), null;
      case 31:
        if (null !== n6.memoizedState && (Fe(n6), null === n6.alternate)) throw Error(r5(340));
        return 65536 & (e4 = n6.flags) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 13:
        if (Fe(n6), null !== (e4 = n6.memoizedState) && null !== e4.dehydrated && null === n6.alternate) throw Error(r5(340));
        return 65536 & (e4 = n6.flags) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 19:
        return i2(su), null;
      case 4:
        return T(), null;
      case 10:
        return D(n6.type), null;
      case 22:
      case 23:
        return Fe(n6), Ne(), null !== e4 && i2(Bo), 65536 & (e4 = n6.flags) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 24:
        return D(Lo), null;
      default:
        return null;
    }
  }
  __name(jt, "jt");
  function At(e4, n6) {
    switch (P(n6), n6.tag) {
      case 3:
        D(Lo), T();
        break;
      case 26:
      case 27:
      case 5:
        N(n6);
        break;
      case 4:
        T();
        break;
      case 31:
        null !== n6.memoizedState && Fe(n6);
        break;
      case 13:
        Fe(n6);
        break;
      case 19:
        i2(su);
        break;
      case 10:
        D(n6.type);
        break;
      case 22:
      case 23:
        Fe(n6), Ne(), null !== e4 && i2(Bo);
        break;
      case 24:
        D(Lo);
    }
  }
  __name(At, "At");
  function Ht(e4, n6) {
    try {
      var t5 = n6.updateQueue, r6 = null !== t5 ? t5.lastEffect : null;
      if (null !== r6) {
        var l5 = r6.next;
        t5 = l5;
        do {
          if ((t5.tag & e4) === e4) {
            r6 = void 0;
            var a5 = t5.create, o5 = t5.inst;
            r6 = a5(), o5.destroy = r6;
          }
          t5 = t5.next;
        } while (t5 !== l5);
      }
    } catch (e5) {
      Jr(n6, n6.return, e5);
    }
  }
  __name(Ht, "Ht");
  function Ot(e4, n6, t5) {
    try {
      var r6 = n6.updateQueue, l5 = null !== r6 ? r6.lastEffect : null;
      if (null !== l5) {
        var a5 = l5.next;
        r6 = a5;
        do {
          if ((r6.tag & e4) === e4) {
            var o5 = r6.inst, u4 = o5.destroy;
            if (void 0 !== u4) {
              o5.destroy = void 0, l5 = n6;
              var i3 = t5, s5 = u4;
              try {
                s5();
              } catch (e5) {
                Jr(l5, i3, e5);
              }
            }
          }
          r6 = r6.next;
        } while (r6 !== a5);
      }
    } catch (e5) {
      Jr(n6, n6.return, e5);
    }
  }
  __name(Ot, "Ot");
  function Mt(e4) {
    var n6 = e4.updateQueue;
    if (null !== n6) {
      var t5 = e4.stateNode;
      try {
        _e(n6, t5);
      } catch (n7) {
        Jr(e4, e4.return, n7);
      }
    }
  }
  __name(Mt, "Mt");
  function Wt(e4, n6, t5) {
    t5.props = et(e4.type, e4.memoizedProps), t5.state = e4.memoizedState;
    try {
      t5.componentWillUnmount();
    } catch (t6) {
      Jr(e4, n6, t6);
    }
  }
  __name(Wt, "Wt");
  function Qt(e4, n6) {
    try {
      var t5 = e4.ref;
      if (null !== t5) {
        switch (e4.tag) {
          case 26:
          case 27:
          case 5:
            var r6 = Il(e4.stateNode);
            break;
          default:
            r6 = e4.stateNode;
        }
        "function" == typeof t5 ? e4.refCleanup = t5(r6) : t5.current = r6;
      }
    } catch (t6) {
      Jr(e4, n6, t6);
    }
  }
  __name(Qt, "Qt");
  function Bt(e4, n6) {
    var t5 = e4.ref, r6 = e4.refCleanup;
    if (null !== t5) if ("function" == typeof r6) try {
      r6();
    } catch (t6) {
      Jr(e4, n6, t6);
    } finally {
      e4.refCleanup = null, null != (e4 = e4.alternate) && (e4.refCleanup = null);
    }
    else if ("function" == typeof t5) try {
      t5(null);
    } catch (t6) {
      Jr(e4, n6, t6);
    }
    else t5.current = null;
  }
  __name(Bt, "Bt");
  function $t(e4) {
    var n6 = e4.type, t5 = e4.memoizedProps, r6 = e4.stateNode;
    try {
      ha(r6, n6, t5, e4);
    } catch (n7) {
      Jr(e4, e4.return, n7);
    }
  }
  __name($t, "$t");
  function Vt(e4) {
    return 5 === e4.tag || 3 === e4.tag || 4 === e4.tag;
  }
  __name(Vt, "Vt");
  function qt(e4) {
    e: for (; ; ) {
      for (; null === e4.sibling; ) {
        if (null === e4.return || Vt(e4.return)) return null;
        e4 = e4.return;
      }
      for (e4.sibling.return = e4.return, e4 = e4.sibling; 5 !== e4.tag && 6 !== e4.tag && 18 !== e4.tag; ) {
        if (2 & e4.flags) continue e;
        if (null === e4.child || 4 === e4.tag) continue e;
        e4.child.return = e4, e4 = e4.child;
      }
      if (!(2 & e4.flags)) return e4.stateNode;
    }
  }
  __name(qt, "qt");
  function Yt(e4, n6, t5) {
    var r6 = e4.tag;
    if (5 === r6 || 6 === r6) e4 = e4.stateNode, n6 ? ba(t5, e4, n6) : pa(t5, e4);
    else if (4 !== r6 && null !== (e4 = e4.child)) for (Yt(e4, n6, t5), e4 = e4.sibling; null !== e4; ) Yt(e4, n6, t5), e4 = e4.sibling;
  }
  __name(Yt, "Yt");
  function Gt(e4, n6, t5) {
    var r6 = e4.tag;
    if (5 === r6 || 6 === r6) e4 = e4.stateNode, n6 ? ya(t5, e4, n6) : fa(t5, e4);
    else if (4 !== r6 && null !== (e4 = e4.child)) for (Gt(e4, n6, t5), e4 = e4.sibling; null !== e4; ) Gt(e4, n6, t5), e4 = e4.sibling;
  }
  __name(Gt, "Gt");
  function Jt(e4, n6, t5) {
    var r6 = t5.flags;
    switch (t5.tag) {
      case 0:
      case 11:
      case 15:
        ar(e4, t5), 4 & r6 && Ht(5, t5);
        break;
      case 1:
        if (ar(e4, t5), 4 & r6) if (e4 = t5.stateNode, null === n6) try {
          e4.componentDidMount();
        } catch (e5) {
          Jr(t5, t5.return, e5);
        }
        else {
          var l5 = et(t5.type, n6.memoizedProps);
          n6 = n6.memoizedState;
          try {
            e4.componentDidUpdate(l5, n6, e4.__reactInternalSnapshotBeforeUpdate);
          } catch (e5) {
            Jr(t5, t5.return, e5);
          }
        }
        64 & r6 && Mt(t5), 512 & r6 && Qt(t5, t5.return);
        break;
      case 3:
        if (ar(e4, t5), 64 & r6 && null !== (r6 = t5.updateQueue)) {
          if (e4 = null, null !== t5.child) switch (t5.child.tag) {
            case 27:
            case 5:
              e4 = Il(t5.child.stateNode);
              break;
            case 1:
              e4 = t5.child.stateNode;
          }
          try {
            _e(r6, e4);
          } catch (e5) {
            Jr(t5, t5.return, e5);
          }
        }
        break;
      case 27:
      case 26:
      case 5:
        if (ar(e4, t5), null === n6) {
          if (4 & r6) $t(t5);
          else if (64 & r6) {
            e4 = t5.type, n6 = t5.memoizedProps, l5 = t5.stateNode;
            try {
              Na(l5, e4, n6, t5);
            } catch (e5) {
              Jr(t5, t5.return, e5);
            }
          }
        }
        512 & r6 && Qt(t5, t5.return);
        break;
      case 12:
      case 31:
      default:
        ar(e4, t5);
        break;
      case 13:
        ar(e4, t5), 64 & r6 && null !== (r6 = t5.memoizedState) && null !== (r6 = r6.dehydrated) && (t5 = el.bind(null, t5), Ra(r6, t5));
        break;
      case 22:
        if (!(r6 = null !== t5.memoizedState || Tu)) {
          n6 = null !== n6 && null !== n6.memoizedState || Ru, l5 = Tu;
          var a5 = Ru;
          Tu = r6, (Ru = n6) && !a5 ? ur(e4, t5, 0 != (8772 & t5.subtreeFlags)) : ar(e4, t5), Tu = l5, Ru = a5;
        }
      case 30:
    }
  }
  __name(Jt, "Jt");
  function Kt(e4) {
    var n6 = e4.alternate;
    null !== n6 && (e4.alternate = null, Kt(n6)), e4.child = null, e4.deletions = null, e4.sibling = null, 5 === e4.tag && null !== (n6 = e4.stateNode) && na(n6), e4.stateNode = null, e4.return = null, e4.dependencies = null, e4.memoizedProps = null, e4.memoizedState = null, e4.pendingProps = null, e4.stateNode = null, e4.updateQueue = null;
  }
  __name(Kt, "Kt");
  function Xt(e4, n6, t5) {
    for (t5 = t5.child; null !== t5; ) Zt(e4, n6, t5), t5 = t5.sibling;
  }
  __name(Xt, "Xt");
  function Zt(e4, n6, t5) {
    switch (t5.tag) {
      case 26:
      case 27:
        var r6, l5;
      case 5:
        Ru || Bt(t5, n6);
      case 6:
        if (r6 = Du, l5 = Iu, Du = null, Xt(e4, n6, t5), Iu = l5, null !== (Du = r6)) if (Iu) try {
          Sa(Du, t5.stateNode);
        } catch (e5) {
          Jr(t5, n6, e5);
        }
        else try {
          va(Du, t5.stateNode);
        } catch (e5) {
          Jr(t5, n6, e5);
        }
        break;
      case 18:
        null !== Du && (Iu ? Ua(Du, t5.stateNode) : La(Du, t5.stateNode));
        break;
      case 4:
        r6 = Du, l5 = Iu, Du = t5.stateNode.containerInfo, Iu = true, Xt(e4, n6, t5), Du = r6, Iu = l5;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        Ot(2, t5, n6), Ru || Ot(4, t5, n6), Xt(e4, n6, t5);
        break;
      case 1:
        Ru || (Bt(t5, n6), "function" == typeof (r6 = t5.stateNode).componentWillUnmount && Wt(t5, n6, r6)), Xt(e4, n6, t5);
        break;
      case 21:
        Xt(e4, n6, t5);
        break;
      case 22:
        Ru = (r6 = Ru) || null !== t5.memoizedState, Xt(e4, n6, t5), Ru = r6;
        break;
      default:
        Xt(e4, n6, t5);
    }
  }
  __name(Zt, "Zt");
  function er(e4, n6) {
    var t5 = function(e5) {
      switch (e5.tag) {
        case 31:
        case 13:
        case 19:
          var n7 = e5.stateNode;
          return null === n7 && (n7 = e5.stateNode = new Lu()), n7;
        case 22:
          return null === (n7 = (e5 = e5.stateNode)._retryCache) && (n7 = e5._retryCache = new Lu()), n7;
        default:
          throw Error(r5(435, e5.tag));
      }
    }(e4);
    n6.forEach(function(n7) {
      if (!t5.has(n7)) {
        t5.add(n7);
        var r6 = nl.bind(null, e4, n7);
        n7.then(r6, r6);
      }
    });
  }
  __name(er, "er");
  function nr(e4, n6) {
    var t5 = n6.deletions;
    if (null !== t5) for (var l5 = 0; l5 < t5.length; l5++) {
      var a5 = t5[l5], o5 = e4, u4 = n6, i3 = u4;
      e: for (; null !== i3; ) {
        switch (i3.tag) {
          case 27:
          case 5:
            Du = i3.stateNode, Iu = false;
            break e;
          case 3:
          case 4:
            Du = i3.stateNode.containerInfo, Iu = true;
            break e;
        }
        i3 = i3.return;
      }
      if (null === Du) throw Error(r5(160));
      Zt(o5, u4, a5), Du = null, Iu = false, null !== (o5 = a5.alternate) && (o5.return = null), a5.return = null;
    }
    if (13886 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) tr(n6, e4), n6 = n6.sibling;
  }
  __name(nr, "nr");
  function tr(e4, n6) {
    var t5 = e4.alternate, l5 = e4.flags;
    switch (e4.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        nr(n6, e4), rr(e4), 4 & l5 && (Ot(3, e4, e4.return), Ht(3, e4), Ot(5, e4, e4.return));
        break;
      case 1:
        nr(n6, e4), rr(e4), 512 & l5 && (Ru || null === t5 || Bt(t5, t5.return)), 64 & l5 && Tu && null !== (e4 = e4.updateQueue) && null !== (l5 = e4.callbacks) && (t5 = e4.shared.hiddenCallbacks, e4.shared.hiddenCallbacks = null === t5 ? l5 : t5.concat(l5));
        break;
      case 26:
        var a5, o5;
      case 27:
      case 5:
        if (nr(n6, e4), rr(e4), 512 & l5 && (Ru || null === t5 || Bt(t5, t5.return)), 32 & e4.flags) {
          a5 = e4.stateNode;
          try {
            ka(a5);
          } catch (n7) {
            Jr(e4, e4.return, n7);
          }
        }
        4 & l5 && null != e4.stateNode && function(e5, n7, t6) {
          try {
            ga(e5.stateNode, e5.type, t6, n7, e5);
          } catch (n8) {
            Jr(e5, e5.return, n8);
          }
        }(e4, a5 = e4.memoizedProps, null !== t5 ? t5.memoizedProps : a5), 1024 & l5 && (Nu = true);
        break;
      case 6:
        if (nr(n6, e4), rr(e4), 4 & l5 && Yl) {
          if (null === e4.stateNode) throw Error(r5(162));
          l5 = e4.memoizedProps, t5 = null !== t5 ? t5.memoizedProps : l5, a5 = e4.stateNode;
          try {
            ma(a5, t5, l5);
          } catch (n7) {
            Jr(e4, e4.return, n7);
          }
        }
        break;
      case 3:
        nr(n6, e4), rr(e4), Nu && (Nu = false, lr(e4));
        break;
      case 4:
      case 12:
        nr(n6, e4), rr(e4);
        break;
      case 31:
        nr(n6, e4), rr(e4), 4 & l5 && null !== (l5 = e4.updateQueue) && (e4.updateQueue = null, er(e4, l5));
        break;
      case 13:
        nr(n6, e4), rr(e4), 8192 & e4.child.flags && null !== e4.memoizedState != (null !== t5 && null !== t5.memoizedState) && (oi = Za()), 4 & l5 && null !== (l5 = e4.updateQueue) && (e4.updateQueue = null, er(e4, l5));
        break;
      case 22:
        a5 = null !== e4.memoizedState;
        var u4 = null !== t5 && null !== t5.memoizedState, i3 = Tu, s5 = Ru;
        if (Tu = i3 || a5, Ru = s5 || u4, nr(n6, e4), Ru = s5, Tu = i3, rr(e4), 8192 & l5 && ((n6 = e4.stateNode)._visibility = a5 ? -2 & n6._visibility : 1 | n6._visibility, a5 && (null === t5 || u4 || Tu || Ru || or(e4)), Yl)) {
          e: if (t5 = null, Yl) for (n6 = e4; ; ) {
            if (5 === n6.tag || Fa) {
              if (null === t5) {
                u4 = t5 = n6;
                try {
                  o5 = u4.stateNode, a5 ? wa(o5) : xa(u4.stateNode, u4.memoizedProps);
                } catch (e5) {
                  Jr(u4, u4.return, e5);
                }
              }
            } else if (6 === n6.tag) {
              if (null === t5) {
                u4 = n6;
                try {
                  var c3 = u4.stateNode;
                  a5 ? za(c3) : Ea(c3, u4.memoizedProps);
                } catch (e5) {
                  Jr(u4, u4.return, e5);
                }
              }
            } else if (18 === n6.tag) {
              if (null === t5) {
                u4 = n6;
                try {
                  var d4 = u4.stateNode;
                  a5 ? Da(d4) : Ia(u4.stateNode);
                } catch (e5) {
                  Jr(u4, u4.return, e5);
                }
              }
            } else if ((22 !== n6.tag && 23 !== n6.tag || null === n6.memoizedState || n6 === e4) && null !== n6.child) {
              n6.child.return = n6, n6 = n6.child;
              continue;
            }
            if (n6 === e4) break e;
            for (; null === n6.sibling; ) {
              if (null === n6.return || n6.return === e4) break e;
              t5 === n6 && (t5 = null), n6 = n6.return;
            }
            t5 === n6 && (t5 = null), n6.sibling.return = n6.return, n6 = n6.sibling;
          }
        }
        4 & l5 && null !== (l5 = e4.updateQueue) && null !== (t5 = l5.retryQueue) && (l5.retryQueue = null, er(e4, t5));
        break;
      case 19:
        nr(n6, e4), rr(e4), 4 & l5 && null !== (l5 = e4.updateQueue) && (e4.updateQueue = null, er(e4, l5));
        break;
      case 30:
      case 21:
        break;
      default:
        nr(n6, e4), rr(e4);
    }
  }
  __name(tr, "tr");
  function rr(e4) {
    var n6 = e4.flags;
    if (2 & n6) {
      try {
        for (var t5, l5 = e4.return; null !== l5; ) {
          if (Vt(l5)) {
            t5 = l5;
            break;
          }
          l5 = l5.return;
        }
        if (Yl) {
          if (null == t5) throw Error(r5(160));
          switch (t5.tag) {
            case 27:
            case 5:
              var a5 = t5.stateNode;
              32 & t5.flags && (ka(a5), t5.flags &= -33), Gt(e4, qt(e4), a5);
              break;
            case 3:
            case 4:
              var o5 = t5.stateNode.containerInfo;
              Yt(e4, qt(e4), o5);
              break;
            default:
              throw Error(r5(161));
          }
        }
      } catch (n7) {
        Jr(e4, e4.return, n7);
      }
      e4.flags &= -3;
    }
    4096 & n6 && (e4.flags &= -4097);
  }
  __name(rr, "rr");
  function lr(e4) {
    if (1024 & e4.subtreeFlags) for (e4 = e4.child; null !== e4; ) {
      var n6 = e4;
      lr(n6), 5 === n6.tag && 1024 & n6.flags && da(n6.stateNode), e4 = e4.sibling;
    }
  }
  __name(lr, "lr");
  function ar(e4, n6) {
    if (8772 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) Jt(e4, n6.alternate, n6), n6 = n6.sibling;
  }
  __name(ar, "ar");
  function or(e4) {
    for (e4 = e4.child; null !== e4; ) {
      var n6 = e4;
      switch (n6.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ot(4, n6, n6.return), or(n6);
          break;
        case 1:
          Bt(n6, n6.return);
          var t5 = n6.stateNode;
          "function" == typeof t5.componentWillUnmount && Wt(n6, n6.return, t5), or(n6);
          break;
        case 27:
        case 26:
        case 5:
          Bt(n6, n6.return), or(n6);
          break;
        case 22:
          null === n6.memoizedState && or(n6);
          break;
        default:
          or(n6);
      }
      e4 = e4.sibling;
    }
  }
  __name(or, "or");
  function ur(e4, n6, t5) {
    for (t5 = t5 && 0 != (8772 & n6.subtreeFlags), n6 = n6.child; null !== n6; ) {
      var r6 = n6.alternate, l5 = e4, a5 = n6, o5 = a5.flags;
      switch (a5.tag) {
        case 0:
        case 11:
        case 15:
          ur(l5, a5, t5), Ht(4, a5);
          break;
        case 1:
          if (ur(l5, a5, t5), "function" == typeof (l5 = (r6 = a5).stateNode).componentDidMount) try {
            l5.componentDidMount();
          } catch (e5) {
            Jr(r6, r6.return, e5);
          }
          if (null !== (l5 = (r6 = a5).updateQueue)) {
            var u4 = r6.stateNode;
            try {
              var i3 = l5.shared.hiddenCallbacks;
              if (null !== i3) for (l5.shared.hiddenCallbacks = null, l5 = 0; l5 < i3.length; l5++) Pe(i3[l5], u4);
            } catch (e5) {
              Jr(r6, r6.return, e5);
            }
          }
          t5 && 64 & o5 && Mt(a5), Qt(a5, a5.return);
          break;
        case 27:
        case 26:
        case 5:
          ur(l5, a5, t5), t5 && null === r6 && 4 & o5 && $t(a5), Qt(a5, a5.return);
          break;
        case 12:
        case 31:
        case 13:
        default:
          ur(l5, a5, t5);
          break;
        case 22:
          null === a5.memoizedState && ur(l5, a5, t5), Qt(a5, a5.return);
        case 30:
      }
      n6 = n6.sibling;
    }
  }
  __name(ur, "ur");
  function ir(e4, n6) {
    var t5 = null;
    null !== e4 && null !== e4.memoizedState && null !== e4.memoizedState.cachePool && (t5 = e4.memoizedState.cachePool.pool), e4 = null, null !== n6.memoizedState && null !== n6.memoizedState.cachePool && (e4 = n6.memoizedState.cachePool.pool), e4 !== t5 && (null != e4 && e4.refCount++, null != t5 && B(t5));
  }
  __name(ir, "ir");
  function sr(e4, n6) {
    e4 = null, null !== n6.alternate && (e4 = n6.alternate.memoizedState.cache), (n6 = n6.memoizedState.cache) !== e4 && (n6.refCount++, null != e4 && B(e4));
  }
  __name(sr, "sr");
  function cr(e4, n6, t5, r6) {
    if (10256 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) dr(e4, n6, t5, r6), n6 = n6.sibling;
  }
  __name(cr, "cr");
  function dr(e4, n6, t5, r6) {
    var l5 = n6.flags;
    switch (n6.tag) {
      case 0:
      case 11:
      case 15:
        cr(e4, n6, t5, r6), 2048 & l5 && Ht(9, n6);
        break;
      case 1:
      case 31:
      case 13:
      default:
        cr(e4, n6, t5, r6);
        break;
      case 3:
        cr(e4, n6, t5, r6), 2048 & l5 && (e4 = null, null !== n6.alternate && (e4 = n6.alternate.memoizedState.cache), (n6 = n6.memoizedState.cache) !== e4 && (n6.refCount++, null != e4 && B(e4)));
        break;
      case 12:
        if (2048 & l5) {
          cr(e4, n6, t5, r6), e4 = n6.stateNode;
          try {
            var a5 = n6.memoizedProps, o5 = a5.id, u4 = a5.onPostCommit;
            "function" == typeof u4 && u4(o5, null === n6.alternate ? "mount" : "update", e4.passiveEffectDuration, -0);
          } catch (e5) {
            Jr(n6, n6.return, e5);
          }
        } else cr(e4, n6, t5, r6);
        break;
      case 23:
        break;
      case 22:
        a5 = n6.stateNode, o5 = n6.alternate, null !== n6.memoizedState ? 2 & a5._visibility ? cr(e4, n6, t5, r6) : pr(e4, n6) : 2 & a5._visibility ? cr(e4, n6, t5, r6) : (a5._visibility |= 2, fr(e4, n6, t5, r6, 0 != (10256 & n6.subtreeFlags) || false)), 2048 & l5 && ir(o5, n6);
        break;
      case 24:
        cr(e4, n6, t5, r6), 2048 & l5 && sr(n6.alternate, n6);
    }
  }
  __name(dr, "dr");
  function fr(e4, n6, t5, r6, l5) {
    for (l5 = l5 && (0 != (10256 & n6.subtreeFlags) || false), n6 = n6.child; null !== n6; ) {
      var a5 = e4, o5 = n6, u4 = t5, i3 = r6, s5 = o5.flags;
      switch (o5.tag) {
        case 0:
        case 11:
        case 15:
          fr(a5, o5, u4, i3, l5), Ht(8, o5);
          break;
        case 23:
          break;
        case 22:
          var c3 = o5.stateNode;
          null !== o5.memoizedState ? 2 & c3._visibility ? fr(a5, o5, u4, i3, l5) : pr(a5, o5) : (c3._visibility |= 2, fr(a5, o5, u4, i3, l5)), l5 && 2048 & s5 && ir(o5.alternate, o5);
          break;
        case 24:
          fr(a5, o5, u4, i3, l5), l5 && 2048 & s5 && sr(o5.alternate, o5);
          break;
        default:
          fr(a5, o5, u4, i3, l5);
      }
      n6 = n6.sibling;
    }
  }
  __name(fr, "fr");
  function pr(e4, n6) {
    if (10256 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) {
      var t5 = e4, r6 = n6, l5 = r6.flags;
      switch (r6.tag) {
        case 22:
          pr(t5, r6), 2048 & l5 && ir(r6.alternate, r6);
          break;
        case 24:
          pr(t5, r6), 2048 & l5 && sr(r6.alternate, r6);
          break;
        default:
          pr(t5, r6);
      }
      n6 = n6.sibling;
    }
  }
  __name(pr, "pr");
  function mr(e4, n6, t5) {
    if (e4.subtreeFlags & ju) for (e4 = e4.child; null !== e4; ) hr(e4, n6, t5), e4 = e4.sibling;
  }
  __name(mr, "mr");
  function hr(e4, n6, t5) {
    switch (e4.tag) {
      case 26:
        if (mr(e4, n6, t5), e4.flags & ju) if (null !== e4.memoizedState) Aa(t5, Fu, e4.memoizedState, e4.memoizedProps);
        else {
          var r6 = e4.stateNode, l5 = e4.type;
          e4 = e4.memoizedProps, ((335544128 & n6) === n6 || la(l5, e4)) && ua(t5, r6, l5, e4);
        }
        break;
      case 5:
        mr(e4, n6, t5), e4.flags & ju && (r6 = e4.stateNode, l5 = e4.type, e4 = e4.memoizedProps, ((335544128 & n6) === n6 || la(l5, e4)) && ua(t5, r6, l5, e4));
        break;
      case 3:
      case 4:
      default:
        mr(e4, n6, t5);
        break;
      case 22:
        null === e4.memoizedState && (null !== (r6 = e4.alternate) && null !== r6.memoizedState ? (r6 = ju, ju = 16777216, mr(e4, n6, t5), ju = r6) : mr(e4, n6, t5));
    }
  }
  __name(hr, "hr");
  function gr(e4) {
    var n6 = e4.alternate;
    if (null !== n6 && null !== (e4 = n6.child)) {
      n6.child = null;
      do {
        n6 = e4.sibling, e4.sibling = null, e4 = n6;
      } while (null !== e4);
    }
  }
  __name(gr, "gr");
  function yr(e4) {
    var n6 = e4.deletions;
    if (0 != (16 & e4.flags)) {
      if (null !== n6) for (var t5 = 0; t5 < n6.length; t5++) {
        var r6 = n6[t5];
        Uu = r6, Sr(r6, e4);
      }
      gr(e4);
    }
    if (10256 & e4.subtreeFlags) for (e4 = e4.child; null !== e4; ) br(e4), e4 = e4.sibling;
  }
  __name(yr, "yr");
  function br(e4) {
    switch (e4.tag) {
      case 0:
      case 11:
      case 15:
        yr(e4), 2048 & e4.flags && Ot(9, e4, e4.return);
        break;
      case 3:
      case 12:
      default:
        yr(e4);
        break;
      case 22:
        var n6 = e4.stateNode;
        null !== e4.memoizedState && 2 & n6._visibility && (null === e4.return || 13 !== e4.return.tag) ? (n6._visibility &= -3, vr(e4)) : yr(e4);
    }
  }
  __name(br, "br");
  function vr(e4) {
    var n6 = e4.deletions;
    if (0 != (16 & e4.flags)) {
      if (null !== n6) for (var t5 = 0; t5 < n6.length; t5++) {
        var r6 = n6[t5];
        Uu = r6, Sr(r6, e4);
      }
      gr(e4);
    }
    for (e4 = e4.child; null !== e4; ) {
      switch ((n6 = e4).tag) {
        case 0:
        case 11:
        case 15:
          Ot(8, n6, n6.return), vr(n6);
          break;
        case 22:
          2 & (t5 = n6.stateNode)._visibility && (t5._visibility &= -3, vr(n6));
          break;
        default:
          vr(n6);
      }
      e4 = e4.sibling;
    }
  }
  __name(vr, "vr");
  function Sr(e4, n6) {
    for (; null !== Uu; ) {
      var t5 = Uu;
      switch (t5.tag) {
        case 0:
        case 11:
        case 15:
          Ot(8, t5, n6);
          break;
        case 23:
        case 22:
          if (null !== t5.memoizedState && null !== t5.memoizedState.cachePool) {
            var r6 = t5.memoizedState.cachePool.pool;
            null != r6 && r6.refCount++;
          }
          break;
        case 24:
          B(t5.memoizedState.cache);
      }
      if (null !== (r6 = t5.child)) r6.return = t5, Uu = r6;
      else e: for (t5 = e4; null !== Uu; ) {
        var l5 = (r6 = Uu).sibling, a5 = r6.return;
        if (Kt(r6), r6 === t5) {
          Uu = null;
          break e;
        }
        if (null !== l5) {
          l5.return = a5, Uu = l5;
          break e;
        }
        Uu = a5;
      }
    }
  }
  __name(Sr, "Sr");
  function kr() {
    return 0 != (2 & Mu) && 0 !== Bu ? Bu & -Bu : null !== Dl.T ? X() : Zl();
  }
  __name(kr, "kr");
  function wr() {
    if (0 === ni) if (0 == (536870912 & Bu) || xo) {
      var e4 = qa;
      0 == (3932160 & (qa <<= 1)) && (qa = 262144), ni = e4;
    } else ni = 536870912;
    return null !== (e4 = uu.current) && (e4.flags |= 32), ni;
  }
  __name(wr, "wr");
  function zr(e4, n6, t5) {
    (e4 !== Wu || 2 !== $u && 9 !== $u) && null === e4.cancelPendingCommit || (Tr(e4, 0), Pr(e4, Bu, ni, false)), g(e4, t5), 0 != (2 & Mu) && e4 === Wu || (e4 === Wu && (0 == (2 & Mu) && (Zu |= t5), 4 === Ku && Pr(e4, Bu, ni, false)), V(e4));
  }
  __name(zr, "zr");
  function xr(e4, n6, t5) {
    if (0 != (6 & Mu)) throw Error(r5(327));
    for (var l5 = !t5 && 0 == (127 & n6) && 0 == (n6 & e4.expiredLanes) || f4(e4, n6), a5 = l5 ? function(e5, n7) {
      var t6 = Mu;
      Mu |= 2;
      var l6 = Nr(), a6 = Lr();
      Wu !== e5 || Bu !== n7 ? (si = null, ii = Za() + 500, Tr(e5, n7)) : Yu = f4(e5, n7);
      e: for (; ; ) try {
        if (0 !== $u && null !== Qu) {
          n7 = Qu;
          var o6 = Vu;
          n: switch ($u) {
            case 1:
              $u = 0, Vu = null, Hr(e5, n7, o6, 1);
              break;
            case 2:
            case 9:
              if (le(o6)) {
                $u = 0, Vu = null, Ar(n7);
                break;
              }
              n7 = /* @__PURE__ */ __name(function() {
                2 !== $u && 9 !== $u || Wu !== e5 || ($u = 7), V(e5);
              }, "n"), o6.then(n7, n7);
              break e;
            case 3:
              $u = 7;
              break e;
            case 4:
              $u = 5;
              break e;
            case 7:
              le(o6) ? ($u = 0, Vu = null, Ar(n7)) : ($u = 0, Vu = null, Hr(e5, n7, o6, 7));
              break;
            case 5:
              var u5 = null;
              switch (Qu.tag) {
                case 26:
                  u5 = Qu.memoizedState;
                case 5:
                case 27:
                  var i4 = Qu, s6 = i4.type, c3 = i4.pendingProps;
                  if (u5 ? ja(u5) : aa(i4.stateNode, s6, c3)) {
                    $u = 0, Vu = null;
                    var d4 = i4.sibling;
                    if (null !== d4) Qu = d4;
                    else {
                      var p4 = i4.return;
                      null !== p4 ? (Qu = p4, Or(p4)) : Qu = null;
                    }
                    break n;
                  }
              }
              $u = 0, Vu = null, Hr(e5, n7, o6, 5);
              break;
            case 6:
              $u = 0, Vu = null, Hr(e5, n7, o6, 6);
              break;
            case 8:
              _r(), Ku = 6;
              break e;
            default:
              throw Error(r5(462));
          }
        }
        Fr();
        break;
      } catch (n8) {
        Rr(e5, n8);
      }
      return _o = Po = null, Dl.H = l6, Dl.A = a6, Mu = t6, null !== Qu ? 0 : (Wu = null, Bu = 0, pe(), Ku);
    }(e4, n6) : Dr(e4, n6, true), o5 = l5; ; ) {
      if (0 === a5) {
        Yu && !l5 && Pr(e4, n6, 0, false);
        break;
      }
      if (t5 = e4.current.alternate, !o5 || Cr(t5)) {
        if (2 === a5) {
          if (o5 = n6, e4.errorRecoveryDisabledLanes & o5) var u4 = 0;
          else u4 = 0 != (u4 = -536870913 & e4.pendingLanes) ? u4 : 536870912 & u4 ? 536870912 : 0;
          if (0 !== u4) {
            n6 = u4;
            e: {
              var i3 = e4;
              a5 = ri;
              var s5 = Gl;
              if (s5 && (Tr(i3, u4).flags |= 256), 2 !== (u4 = Dr(i3, u4, false))) {
                if (Gu && !s5) {
                  i3.errorRecoveryDisabledLanes |= o5, Zu |= o5, a5 = 4;
                  break e;
                }
                o5 = li, li = a5, null !== o5 && (null === li ? li = o5 : li.push.apply(li, o5));
              }
              a5 = u4;
            }
            if (o5 = false, 2 !== a5) continue;
          }
        }
        if (1 === a5) {
          Tr(e4, 0), Pr(e4, n6, 0, true);
          break;
        }
        e: {
          switch (l5 = e4, o5 = a5) {
            case 0:
            case 1:
              throw Error(r5(345));
            case 4:
              if ((4194048 & n6) !== n6) break;
            case 6:
              Pr(l5, n6, ni, !qu);
              break e;
            case 2:
              li = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r5(329));
          }
          if ((62914560 & n6) === n6 && 10 < (a5 = oi + 300 - Za())) {
            if (Pr(l5, n6, ni, !qu), 0 !== d3(l5, 0, true)) break e;
            mi = n6, l5.timeoutHandle = $l(Er.bind(null, l5, t5, li, si, ai, n6, ni, Zu, ti, qu, o5, "Throttled", -0, 0), a5);
          } else Er(l5, t5, li, si, ai, n6, ni, Zu, ti, qu, o5, null, -0, 0);
        }
        break;
      }
      a5 = Dr(e4, n6, false), o5 = false;
    }
    V(e4);
  }
  __name(xr, "xr");
  function Er(e4, n6, t5, r6, l5, a5, o5, u4, i3, s5, c3, d4, f5, p4) {
    if (e4.timeoutHandle = ql, 8192 & (d4 = n6.subtreeFlags) || 16785408 == (16785408 & d4)) {
      hr(n6, a5, d4 = oa());
      var m4 = (62914560 & a5) === a5 ? oi - Za() : (4194048 & a5) === a5 ? ui - Za() : 0;
      if (null !== (m4 = ia(d4, m4))) return mi = a5, e4.cancelPendingCommit = m4(Wr.bind(null, e4, n6, a5, t5, r6, l5, o5, u4, i3, c3, d4, null, f5, p4)), void Pr(e4, a5, o5, !s5);
    }
    Wr(e4, n6, a5, t5, r6, l5, o5, u4, i3);
  }
  __name(Er, "Er");
  function Cr(e4) {
    for (var n6 = e4; ; ) {
      var t5 = n6.tag;
      if ((0 === t5 || 11 === t5 || 15 === t5) && 16384 & n6.flags && null !== (t5 = n6.updateQueue) && null !== (t5 = t5.stores)) for (var r6 = 0; r6 < t5.length; r6++) {
        var l5 = t5[r6], a5 = l5.getSnapshot;
        l5 = l5.value;
        try {
          if (!uo(a5(), l5)) return false;
        } catch (e5) {
          return false;
        }
      }
      if (t5 = n6.child, 16384 & n6.subtreeFlags && null !== t5) t5.return = n6, n6 = t5;
      else {
        if (n6 === e4) break;
        for (; null === n6.sibling; ) {
          if (null === n6.return || n6.return === e4) return true;
          n6 = n6.return;
        }
        n6.sibling.return = n6.return, n6 = n6.sibling;
      }
    }
    return true;
  }
  __name(Cr, "Cr");
  function Pr(e4, n6, t5, r6) {
    n6 &= ~ei, n6 &= ~Zu, e4.suspendedLanes |= n6, e4.pingedLanes &= ~n6, r6 && (e4.warmLanes |= n6), r6 = e4.expirationTimes;
    for (var l5 = n6; 0 < l5; ) {
      var a5 = 31 - Qa(l5), o5 = 1 << a5;
      r6[a5] = -1, l5 &= ~o5;
    }
    0 !== t5 && y3(e4, t5, n6);
  }
  __name(Pr, "Pr");
  function _r() {
    if (null !== Qu) {
      if (0 === $u) var e4 = Qu.return;
      else _o = Po = null, Ve(e4 = Qu), Jo = null, Ko = 0, e4 = Qu;
      for (; null !== e4; ) At(e4.alternate, e4), e4 = e4.return;
      Qu = null;
    }
  }
  __name(_r, "_r");
  function Tr(e4, n6) {
    var t5 = e4.timeoutHandle;
    t5 !== ql && (e4.timeoutHandle = ql, Vl(t5)), null !== (t5 = e4.cancelPendingCommit) && (e4.cancelPendingCommit = null, t5()), mi = 0, _r(), Wu = e4, Qu = t5 = ll(e4.current, null), Bu = n6, $u = 0, Vu = null, qu = false, Yu = f4(e4, n6), Gu = false, ti = ni = ei = Zu = Xu = Ku = 0, li = ri = null, ai = false, 0 != (8 & n6) && (n6 |= 32 & n6);
    var r6 = e4.entangledLanes;
    if (0 !== r6) for (e4 = e4.entanglements, r6 &= n6; 0 < r6; ) {
      var l5 = 31 - Qa(r6), a5 = 1 << l5;
      n6 |= e4[l5], r6 &= ~a5;
    }
    return Ju = n6, pe(), t5;
  }
  __name(Tr, "Tr");
  function Rr(e4, n6) {
    du = null, Dl.H = ku, n6 === $o || n6 === qo ? (n6 = ue(), $u = 3) : n6 === Vo ? (n6 = ue(), $u = 4) : $u = n6 === Cu ? 8 : null !== n6 && "object" == typeof n6 && "function" == typeof n6.then ? 6 : 1, Vu = n6, null === Qu && (Ku = 1, nt(e4, C(n6, e4.current)));
  }
  __name(Rr, "Rr");
  function Nr() {
    var e4 = Dl.H;
    return Dl.H = ku, null === e4 ? ku : e4;
  }
  __name(Nr, "Nr");
  function Lr() {
    var e4 = Dl.A;
    return Dl.A = Au, e4;
  }
  __name(Lr, "Lr");
  function Ur() {
    Ku = 4, qu || (4194048 & Bu) !== Bu && null !== uu.current || (Yu = true), 0 == (134217727 & Xu) && 0 == (134217727 & Zu) || null === Wu || Pr(Wu, Bu, ni, false);
  }
  __name(Ur, "Ur");
  function Dr(e4, n6, t5) {
    var r6 = Mu;
    Mu |= 2;
    var l5 = Nr(), a5 = Lr();
    Wu === e4 && Bu === n6 || (si = null, Tr(e4, n6)), n6 = false;
    var o5 = Ku;
    e: for (; ; ) try {
      if (0 !== $u && null !== Qu) {
        var u4 = Qu, i3 = Vu;
        switch ($u) {
          case 8:
            _r(), o5 = 6;
            break e;
          case 3:
          case 2:
          case 9:
          case 6:
            null === uu.current && (n6 = true);
            var s5 = $u;
            if ($u = 0, Vu = null, Hr(e4, u4, i3, s5), t5 && Yu) {
              o5 = 0;
              break e;
            }
            break;
          default:
            s5 = $u, $u = 0, Vu = null, Hr(e4, u4, i3, s5);
        }
      }
      Ir(), o5 = Ku;
      break;
    } catch (n7) {
      Rr(e4, n7);
    }
    return n6 && e4.shellSuspendCounter++, _o = Po = null, Mu = r6, Dl.H = l5, Dl.A = a5, null === Qu && (Wu = null, Bu = 0, pe()), o5;
  }
  __name(Dr, "Dr");
  function Ir() {
    for (; null !== Qu; ) jr(Qu);
  }
  __name(Ir, "Ir");
  function Fr() {
    for (; null !== Qu && !Ka(); ) jr(Qu);
  }
  __name(Fr, "Fr");
  function jr(e4) {
    var n6 = Rt(e4.alternate, e4, Ju);
    e4.memoizedProps = e4.pendingProps, null === n6 ? Or(e4) : Qu = n6;
  }
  __name(jr, "jr");
  function Ar(e4) {
    var n6 = e4, t5 = n6.alternate;
    switch (n6.tag) {
      case 15:
      case 0:
        n6 = yt(t5, n6, n6.pendingProps, n6.type, void 0, Bu);
        break;
      case 11:
        n6 = yt(t5, n6, n6.pendingProps, n6.type.render, n6.ref, Bu);
        break;
      case 5:
        Ve(n6);
      default:
        At(t5, n6), n6 = Rt(t5, n6 = Qu = al(n6, Ju), Ju);
    }
    e4.memoizedProps = e4.pendingProps, null === n6 ? Or(e4) : Qu = n6;
  }
  __name(Ar, "Ar");
  function Hr(e4, n6, t5, l5) {
    _o = Po = null, Ve(n6), Jo = null, Ko = 0;
    var a5 = n6.return;
    try {
      if (function(e5, n7, t6, l6, a6) {
        if (t6.flags |= 32768, null !== l6 && "object" == typeof l6 && "function" == typeof l6.then) {
          if (null !== (n7 = t6.alternate) && j(n7, t6, a6, true), null !== (t6 = uu.current)) {
            switch (t6.tag) {
              case 31:
              case 13:
                return null === iu ? Ur() : null === t6.alternate && 0 === Ku && (Ku = 3), t6.flags &= -257, t6.flags |= 65536, t6.lanes = a6, l6 === Yo ? t6.flags |= 16384 : (null === (n7 = t6.updateQueue) ? t6.updateQueue = /* @__PURE__ */ new Set([l6]) : n7.add(l6), Kr(e5, l6, a6)), false;
              case 22:
                return t6.flags |= 65536, l6 === Yo ? t6.flags |= 16384 : (null === (n7 = t6.updateQueue) ? (n7 = { transitions: null, markerInstances: null, retryQueue: /* @__PURE__ */ new Set([l6]) }, t6.updateQueue = n7) : null === (t6 = n7.retryQueue) ? n7.retryQueue = /* @__PURE__ */ new Set([l6]) : t6.add(l6), Kr(e5, l6, a6)), false;
            }
            throw Error(r5(435, t6.tag));
          }
          return Kr(e5, l6, a6), Ur(), false;
        }
        var o5 = Error(r5(520), { cause: l6 });
        if (o5 = C(o5, t6), null === ri ? ri = [o5] : ri.push(o5), 4 !== Ku && (Ku = 2), null === n7) return true;
        l6 = C(l6, t6), t6 = n7;
        do {
          switch (t6.tag) {
            case 3:
              return t6.flags |= 65536, e5 = a6 & -a6, t6.lanes |= e5, xe(t6, e5 = rt(t6.stateNode, l6, e5)), false;
            case 1:
              if (n7 = t6.type, o5 = t6.stateNode, 0 == (128 & t6.flags) && ("function" == typeof n7.getDerivedStateFromError || null !== o5 && "function" == typeof o5.componentDidCatch && (null === ci || !ci.has(o5)))) return t6.flags |= 65536, a6 &= -a6, t6.lanes |= a6, at(a6 = lt(a6), e5, t6, l6), xe(t6, a6), false;
          }
          t6 = t6.return;
        } while (null !== t6);
        return false;
      }(e4, a5, n6, t5, Bu)) return Ku = 1, nt(e4, C(t5, e4.current)), void (Qu = null);
    } catch (n7) {
      if (null !== a5) throw Qu = a5, n7;
      return Ku = 1, nt(e4, C(t5, e4.current)), void (Qu = null);
    }
    32768 & n6.flags ? (1 === l5 ? e4 = true : Yu || 0 != (536870912 & Bu) ? e4 = false : (qu = e4 = true, (2 === l5 || 9 === l5 || 3 === l5 || 6 === l5) && null !== (l5 = uu.current) && 13 === l5.tag && (l5.flags |= 16384)), Mr(n6, e4)) : Or(n6);
  }
  __name(Hr, "Hr");
  function Or(e4) {
    var n6 = e4;
    do {
      if (0 != (32768 & n6.flags)) return void Mr(n6, qu);
      e4 = n6.return;
      var t5 = Ft(n6.alternate, n6, Ju);
      if (null !== t5) return void (Qu = t5);
      if (null !== (n6 = n6.sibling)) return void (Qu = n6);
      Qu = n6 = e4;
    } while (null !== n6);
    0 === Ku && (Ku = 5);
  }
  __name(Or, "Or");
  function Mr(e4, n6) {
    do {
      var t5 = jt(e4.alternate, e4);
      if (null !== t5) return t5.flags &= 32767, void (Qu = t5);
      if (null !== (t5 = e4.return) && (t5.flags |= 32768, t5.subtreeFlags = 0, t5.deletions = null), !n6 && null !== (e4 = e4.sibling)) return void (Qu = e4);
      Qu = e4 = t5;
    } while (null !== e4);
    Ku = 6, Qu = null;
  }
  __name(Mr, "Mr");
  function Wr(e4, n6, t5, l5, a5, o5, u4, i3, s5) {
    e4.cancelPendingCommit = null;
    do {
      qr();
    } while (0 !== di);
    if (0 != (6 & Mu)) throw Error(r5(327));
    if (null !== n6) {
      if (n6 === e4.current) throw Error(r5(177));
      if (o5 = n6.lanes | n6.childLanes, function(e5, n7, t6, r6, l6, a6) {
        var o6 = e5.pendingLanes;
        e5.pendingLanes = t6, e5.suspendedLanes = 0, e5.pingedLanes = 0, e5.warmLanes = 0, e5.expiredLanes &= t6, e5.entangledLanes &= t6, e5.errorRecoveryDisabledLanes &= t6, e5.shellSuspendCounter = 0;
        var u5 = e5.entanglements, i4 = e5.expirationTimes, s6 = e5.hiddenUpdates;
        for (t6 = o6 & ~t6; 0 < t6; ) {
          var c3 = 31 - Qa(t6), d4 = 1 << c3;
          u5[c3] = 0, i4[c3] = -1;
          var f5 = s6[c3];
          if (null !== f5) for (s6[c3] = null, c3 = 0; c3 < f5.length; c3++) {
            var p4 = f5[c3];
            null !== p4 && (p4.lane &= -536870913);
          }
          t6 &= ~d4;
        }
        0 !== r6 && y3(e5, r6, 0), 0 !== a6 && 0 === l6 && 0 !== e5.tag && (e5.suspendedLanes |= a6 & ~(o6 & ~n7));
      }(e4, t5, o5 |= tu, u4, i3, s5), e4 === Wu && (Qu = Wu = null, Bu = 0), pi = n6, fi = e4, mi = t5, hi = o5, gi = a5, yi = l5, 0 != (10256 & n6.subtreeFlags) || 0 != (10256 & n6.flags) ? (e4.callbackNode = null, e4.callbackPriority = 0, Ga(to, function() {
        return Yr(), null;
      })) : (e4.callbackNode = null, e4.callbackPriority = 0), l5 = 0 != (13878 & n6.flags), 0 != (13878 & n6.subtreeFlags) || l5) {
        l5 = Dl.T, Dl.T = null, a5 = Xl(), Kl(2), u4 = Mu, Mu |= 4;
        try {
          !function(e5, n7) {
            for (Al(e5.containerInfo), Uu = n7; null !== Uu; ) if (n7 = (e5 = Uu).child, 0 != (1028 & e5.subtreeFlags) && null !== n7) n7.return = e5, Uu = n7;
            else for (; null !== Uu; ) {
              var t6 = (e5 = Uu).alternate;
              switch (n7 = e5.flags, e5.tag) {
                case 0:
                  if (0 != (4 & n7) && null !== (n7 = null !== (n7 = e5.updateQueue) ? n7.events : null)) for (var l6 = 0; l6 < n7.length; l6++) {
                    var a6 = n7[l6];
                    a6.ref.impl = a6.nextImpl;
                  }
                  break;
                case 11:
                case 15:
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                case 1:
                  if (0 != (1024 & n7) && null !== t6) {
                    n7 = void 0, l6 = e5, a6 = t6.memoizedProps, t6 = t6.memoizedState;
                    var o6 = l6.stateNode;
                    try {
                      var u5 = et(l6.type, a6);
                      n7 = o6.getSnapshotBeforeUpdate(u5, t6), o6.__reactInternalSnapshotBeforeUpdate = n7;
                    } catch (e6) {
                      Jr(l6, l6.return, e6);
                    }
                  }
                  break;
                case 3:
                  0 != (1024 & n7) && Yl && Ca(e5.stateNode.containerInfo);
                  break;
                default:
                  if (0 != (1024 & n7)) throw Error(r5(163));
              }
              if (null !== (n7 = e5.sibling)) {
                n7.return = e5.return, Uu = n7;
                break;
              }
              Uu = e5.return;
            }
          }(e4, n6);
        } finally {
          Mu = u4, Kl(a5), Dl.T = l5;
        }
      }
      di = 1, Qr(), Br(), $r();
    }
  }
  __name(Wr, "Wr");
  function Qr() {
    if (1 === di) {
      di = 0;
      var e4 = fi, n6 = pi, t5 = 0 != (13878 & n6.flags);
      if (0 != (13878 & n6.subtreeFlags) || t5) {
        t5 = Dl.T, Dl.T = null;
        var r6 = Xl();
        Kl(2);
        var l5 = Mu;
        Mu |= 4;
        try {
          tr(n6, e4), Hl(e4.containerInfo);
        } finally {
          Mu = l5, Kl(r6), Dl.T = t5;
        }
      }
      e4.current = n6, di = 2;
    }
  }
  __name(Qr, "Qr");
  function Br() {
    if (2 === di) {
      di = 0;
      var e4 = fi, n6 = pi, t5 = 0 != (8772 & n6.flags);
      if (0 != (8772 & n6.subtreeFlags) || t5) {
        t5 = Dl.T, Dl.T = null;
        var r6 = Xl();
        Kl(2);
        var l5 = Mu;
        Mu |= 4;
        try {
          Jt(e4, n6.alternate, n6);
        } finally {
          Mu = l5, Kl(r6), Dl.T = t5;
        }
      }
      di = 3;
    }
  }
  __name(Br, "Br");
  function $r() {
    if (4 === di || 3 === di) {
      di = 0, Xa();
      var e4 = fi, n6 = pi, t5 = mi, r6 = yi;
      0 != (10256 & n6.subtreeFlags) || 0 != (10256 & n6.flags) ? di = 5 : (di = 0, pi = fi = null, Vr(e4, e4.pendingLanes));
      var l5 = e4.pendingLanes;
      if (0 === l5 && (ci = null), S3(t5), n6 = n6.stateNode, null !== r6) {
        n6 = Dl.T, l5 = Xl(), Kl(2), Dl.T = null;
        try {
          for (var a5 = e4.onRecoverableError, o5 = 0; o5 < r6.length; o5++) {
            var u4 = r6[o5];
            a5(u4.value, { componentStack: u4.stack });
          }
        } finally {
          Dl.T = n6, Kl(l5);
        }
      }
      0 != (3 & mi) && qr(), V(e4), l5 = e4.pendingLanes, 0 != (261930 & t5) && 0 != (42 & l5) ? e4 === vi ? bi++ : (bi = 0, vi = e4) : bi = 0, q(0);
    }
  }
  __name($r, "$r");
  function Vr(e4, n6) {
    0 == (e4.pooledCacheLanes &= n6) && null != (n6 = e4.pooledCache) && (e4.pooledCache = null, B(n6));
  }
  __name(Vr, "Vr");
  function qr() {
    return Qr(), Br(), $r(), Yr();
  }
  __name(qr, "qr");
  function Yr() {
    if (5 !== di) return false;
    var e4 = fi, n6 = hi;
    hi = 0;
    var t5 = S3(mi), l5 = 32 > t5 ? 32 : t5;
    t5 = Dl.T;
    var a5 = Xl();
    try {
      Kl(l5), Dl.T = null, l5 = gi, gi = null;
      var o5 = fi, u4 = mi;
      if (di = 0, pi = fi = null, mi = 0, 0 != (6 & Mu)) throw Error(r5(331));
      var i3 = Mu;
      return Mu |= 4, br(o5.current), dr(o5, o5.current, u4, l5), Mu = i3, q(0), oo && oo.onPostCommitFiberRoot, true;
    } finally {
      Kl(a5), Dl.T = t5, Vr(e4, n6);
    }
  }
  __name(Yr, "Yr");
  function Gr(e4, n6, t5) {
    n6 = C(t5, n6), null !== (e4 = we(e4, n6 = rt(e4.stateNode, n6, 2), 2)) && (g(e4, 2), V(e4));
  }
  __name(Gr, "Gr");
  function Jr(e4, n6, t5) {
    if (3 === e4.tag) Gr(e4, e4, t5);
    else for (; null !== n6; ) {
      if (3 === n6.tag) {
        Gr(n6, e4, t5);
        break;
      }
      if (1 === n6.tag) {
        var r6 = n6.stateNode;
        if ("function" == typeof n6.type.getDerivedStateFromError || "function" == typeof r6.componentDidCatch && (null === ci || !ci.has(r6))) {
          e4 = C(t5, e4), null !== (r6 = we(n6, t5 = lt(2), 2)) && (at(t5, r6, n6, e4), g(r6, 2), V(r6));
          break;
        }
      }
      n6 = n6.return;
    }
  }
  __name(Jr, "Jr");
  function Kr(e4, n6, t5) {
    var r6 = e4.pingCache;
    if (null === r6) {
      r6 = e4.pingCache = new Ou();
      var l5 = /* @__PURE__ */ new Set();
      r6.set(n6, l5);
    } else void 0 === (l5 = r6.get(n6)) && (l5 = /* @__PURE__ */ new Set(), r6.set(n6, l5));
    l5.has(t5) || (Gu = true, l5.add(t5), e4 = Xr.bind(null, e4, n6, t5), n6.then(e4, e4));
  }
  __name(Kr, "Kr");
  function Xr(e4, n6, t5) {
    var r6 = e4.pingCache;
    null !== r6 && r6.delete(n6), e4.pingedLanes |= e4.suspendedLanes & t5, e4.warmLanes &= ~t5, Wu === e4 && (Bu & t5) === t5 && (4 === Ku || 3 === Ku && (62914560 & Bu) === Bu && 300 > Za() - oi ? 0 == (2 & Mu) && Tr(e4, 0) : ei |= t5, ti === Bu && (ti = 0)), V(e4);
  }
  __name(Xr, "Xr");
  function Zr(e4, n6) {
    0 === n6 && (n6 = m3()), null !== (e4 = ge(e4, n6)) && (g(e4, n6), V(e4));
  }
  __name(Zr, "Zr");
  function el(e4) {
    var n6 = e4.memoizedState, t5 = 0;
    null !== n6 && (t5 = n6.retryLane), Zr(e4, t5);
  }
  __name(el, "el");
  function nl(e4, n6) {
    var t5 = 0;
    switch (e4.tag) {
      case 31:
      case 13:
        var l5 = e4.stateNode, a5 = e4.memoizedState;
        null !== a5 && (t5 = a5.retryLane);
        break;
      case 19:
        l5 = e4.stateNode;
        break;
      case 22:
        l5 = e4.stateNode._retryCache;
        break;
      default:
        throw Error(r5(314));
    }
    null !== l5 && l5.delete(n6), Zr(e4, t5);
  }
  __name(nl, "nl");
  function tl(e4, n6, t5, r6) {
    this.tag = e4, this.key = t5, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = n6, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r6, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  __name(tl, "tl");
  function rl(e4) {
    return !(!(e4 = e4.prototype) || !e4.isReactComponent);
  }
  __name(rl, "rl");
  function ll(e4, n6) {
    var r6 = e4.alternate;
    return null === r6 ? ((r6 = t4(e4.tag, n6, e4.key, e4.mode)).elementType = e4.elementType, r6.type = e4.type, r6.stateNode = e4.stateNode, r6.alternate = e4, e4.alternate = r6) : (r6.pendingProps = n6, r6.type = e4.type, r6.flags = 0, r6.subtreeFlags = 0, r6.deletions = null), r6.flags = 65011712 & e4.flags, r6.childLanes = e4.childLanes, r6.lanes = e4.lanes, r6.child = e4.child, r6.memoizedProps = e4.memoizedProps, r6.memoizedState = e4.memoizedState, r6.updateQueue = e4.updateQueue, n6 = e4.dependencies, r6.dependencies = null === n6 ? null : { lanes: n6.lanes, firstContext: n6.firstContext }, r6.sibling = e4.sibling, r6.index = e4.index, r6.ref = e4.ref, r6.refCleanup = e4.refCleanup, r6;
  }
  __name(ll, "ll");
  function al(e4, n6) {
    e4.flags &= 65011714;
    var t5 = e4.alternate;
    return null === t5 ? (e4.childLanes = 0, e4.lanes = n6, e4.child = null, e4.subtreeFlags = 0, e4.memoizedProps = null, e4.memoizedState = null, e4.updateQueue = null, e4.dependencies = null, e4.stateNode = null) : (e4.childLanes = t5.childLanes, e4.lanes = t5.lanes, e4.child = t5.child, e4.subtreeFlags = 0, e4.deletions = null, e4.memoizedProps = t5.memoizedProps, e4.memoizedState = t5.memoizedState, e4.updateQueue = t5.updateQueue, e4.type = t5.type, n6 = t5.dependencies, e4.dependencies = null === n6 ? null : { lanes: n6.lanes, firstContext: n6.firstContext }), e4;
  }
  __name(al, "al");
  function ol(e4, n6, l5, a5, o5, u4) {
    var i3 = 0;
    if (a5 = e4, "function" == typeof e4) rl(e4) && (i3 = 1);
    else if ("string" == typeof e4) i3 = 5;
    else e: switch (e4) {
      case Tl:
        return (e4 = t4(31, l5, n6, o5)).elementType = Tl, e4.lanes = u4, e4;
      case vl:
        return ul(l5.children, o5, u4, n6);
      case Sl:
        i3 = 8, o5 |= 24;
        break;
      case kl:
        return (e4 = t4(12, l5, n6, 2 | o5)).elementType = kl, e4.lanes = u4, e4;
      case El:
        return (e4 = t4(13, l5, n6, o5)).elementType = El, e4.lanes = u4, e4;
      case Cl:
        return (e4 = t4(19, l5, n6, o5)).elementType = Cl, e4.lanes = u4, e4;
      default:
        if ("object" == typeof e4 && null !== e4) switch (e4.$$typeof) {
          case zl:
            i3 = 10;
            break e;
          case wl:
            i3 = 9;
            break e;
          case xl:
            i3 = 11;
            break e;
          case Pl:
            i3 = 14;
            break e;
          case _l:
            i3 = 16, a5 = null;
            break e;
        }
        i3 = 29, l5 = Error(r5(130, null === e4 ? "null" : typeof e4, "")), a5 = null;
    }
    return (n6 = t4(i3, l5, n6, o5)).elementType = e4, n6.type = a5, n6.lanes = u4, n6;
  }
  __name(ol, "ol");
  function ul(e4, n6, r6, l5) {
    return (e4 = t4(7, e4, l5, n6)).lanes = r6, e4;
  }
  __name(ul, "ul");
  function il(e4, n6, r6) {
    return (e4 = t4(6, e4, null, n6)).lanes = r6, e4;
  }
  __name(il, "il");
  function sl(e4, n6, r6) {
    return (n6 = t4(4, null !== e4.children ? e4.children : [], e4.key, n6)).lanes = r6, n6.stateNode = { containerInfo: e4.containerInfo, pendingChildren: null, implementation: e4.implementation }, n6;
  }
  __name(sl, "sl");
  function cl(e4, n6, t5, r6, l5, a5, o5, u4, i3) {
    this.tag = 1, this.containerInfo = e4, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = ql, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = h(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = h(0), this.hiddenUpdates = h(null), this.identifierPrefix = r6, this.onUncaughtError = l5, this.onCaughtError = a5, this.onRecoverableError = o5, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = i3, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  __name(cl, "cl");
  function dl(e4, n6, t5, r6, l5, a5) {
    l5 = function(e5) {
      return e5 ? e5 = Wa : Wa;
    }(l5), null === r6.context ? r6.context = l5 : r6.pendingContext = l5, (r6 = ke(n6)).payload = { element: t5 }, null !== (a5 = void 0 === a5 ? null : a5) && (r6.callback = a5), null !== (t5 = we(e4, r6, n6)) && (zr(t5, 0, n6), ze(t5, e4, n6));
  }
  __name(dl, "dl");
  var fl = {}, pl = import_react2.default, ml = u2, hl = Object.assign, gl = Symbol.for("react.element"), yl = Symbol.for("react.transitional.element"), bl = Symbol.for("react.portal"), vl = Symbol.for("react.fragment"), Sl = Symbol.for("react.strict_mode"), kl = Symbol.for("react.profiler"), wl = Symbol.for("react.consumer"), zl = Symbol.for("react.context"), xl = Symbol.for("react.forward_ref"), El = Symbol.for("react.suspense"), Cl = Symbol.for("react.suspense_list"), Pl = Symbol.for("react.memo"), _l = Symbol.for("react.lazy"), Tl = Symbol.for("react.activity"), Rl = Symbol.for("react.memo_cache_sentinel"), Nl = Symbol.iterator, Ll = Symbol.for("react.client.reference"), Ul = Array.isArray, Dl = pl.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Il = n5.getPublicInstance, Fl = n5.getRootHostContext, jl = n5.getChildHostContext, Al = n5.prepareForCommit, Hl = n5.resetAfterCommit, Ol = n5.createInstance, Ml = n5.appendInitialChild, Wl = n5.finalizeInitialChildren, Ql = n5.shouldSetTextContent, Bl = n5.createTextInstance, $l = null, Vl = null, ql = n5.noTimeout, Yl = true, Gl = null, Jl = null, Kl = n5.setCurrentUpdatePriority, Xl = n5.getCurrentUpdatePriority, Zl = n5.resolveUpdatePriority;
  n5.trackSchedulerEvent, n5.resolveEventType, n5.resolveEventTimeStamp;
  var ea = n5.shouldAttemptEagerTransition, na = n5.detachDeletedInstance;
  n5.requestPostPaintCallback;
  var ta = n5.maySuspendCommit, ra = null, la = null, aa = null, oa = null, ua = null, ia = null, sa = null, ca = null, da = null, fa = n5.appendChild, pa = n5.appendChildToContainer, ma = n5.commitTextUpdate, ha = null, ga = n5.commitUpdate, ya = n5.insertBefore, ba = null, va = n5.removeChild, Sa = n5.removeChildFromContainer, ka = n5.resetTextContent, wa = null, za = null, xa = null, Ea = null, Ca = n5.clearContainer, Pa = null, _a = null, Ta = null, Ra = null, Na = null, La = null, Ua = null, Da = null, Ia = null, Fa = null, ja = null, Aa = null, Ha = null, Oa = [], Ma = -1, Wa = {}, Qa = Math.clz32 ? Math.clz32 : function(e4) {
    return 0 == (e4 >>>= 0) ? 32 : 31 - (Ba(e4) / $a | 0) | 0;
  }, Ba = Math.log, $a = Math.LN2, Va = 256, qa = 262144, Ya = 4194304, Ga = ml.unstable_scheduleCallback, Ja = ml.unstable_cancelCallback, Ka = ml.unstable_shouldYield, Xa = ml.unstable_requestPaint, Za = ml.unstable_now, eo = ml.unstable_ImmediatePriority, no = ml.unstable_UserBlockingPriority, to = ml.unstable_NormalPriority, ro = ml.unstable_IdlePriority, lo = ml.log, ao = ml.unstable_setDisableYieldValue, oo = null, uo = "function" == typeof Object.is ? Object.is : function(e4, n6) {
    return e4 === n6 && (0 !== e4 || 1 / e4 == 1 / n6) || e4 != e4 && n6 != n6;
  };
  "function" == typeof reportError && reportError;
  var io, so, co = Object.prototype.hasOwnProperty, fo = false, po = /* @__PURE__ */ new WeakMap(), mo = [], ho = 0, go = null, yo = [], bo = 0, vo = null, So = o4(null), ko = o4(null), wo = o4(null), zo = o4(null), xo = false, Eo = null;
  Error(r5(519));
  var Co = o4(null), Po = null, _o = null, To = "undefined" != typeof AbortController ? AbortController : function() {
    var e4 = [], n6 = this.signal = { aborted: false, addEventListener: /* @__PURE__ */ __name(function(n7, t5) {
      e4.push(t5);
    }, "addEventListener") };
    this.abort = function() {
      n6.aborted = true, e4.forEach(function(e5) {
        return e5();
      });
    };
  }, Ro = ml.unstable_scheduleCallback, No = ml.unstable_NormalPriority, Lo = { $$typeof: zl, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }, Uo = null, Do = null, Io = false, Fo = false, jo = false, Ao = 0, Ho = null, Oo = 0, Mo = 0, Wo = null, Qo = Dl.S;
  Dl.S = function(e4, n6) {
    ui = Za(), "object" == typeof n6 && null !== n6 && "function" == typeof n6.then && function(e5, n7) {
      if (null === Ho) {
        var t5 = Ho = [];
        Oo = 0, Mo = X(), Wo = { status: "pending", value: void 0, then: /* @__PURE__ */ __name(function(e6) {
          t5.push(e6);
        }, "then") };
      }
      Oo++, n7.then(Z, Z);
    }(0, n6), null !== Qo && Qo(e4, n6);
  };
  var Bo = o4(null), $o = Error(r5(460)), Vo = Error(r5(474)), qo = Error(r5(542)), Yo = { then: /* @__PURE__ */ __name(function() {
  }, "then") }, Go = null, Jo = null, Ko = 0, Xo = fe(true), Zo = fe(false), eu = [], nu = 0, tu = 0, ru = false, lu = false, au = o4(null), ou = o4(0), uu = o4(null), iu = null, su = o4(0), cu = 0, du = null, fu = null, pu = null, mu = false, hu = false, gu = false, yu = 0, bu = 0, vu = null, Su = 0, ku = { readContext: O, use: Je, useCallback: Ae, useContext: Ae, useEffect: Ae, useImperativeHandle: Ae, useLayoutEffect: Ae, useInsertionEffect: Ae, useMemo: Ae, useReducer: Ae, useRef: Ae, useState: Ae, useDebugValue: Ae, useDeferredValue: Ae, useTransition: Ae, useSyncExternalStore: Ae, useId: Ae, useHostTransitionStatus: Ae, useFormState: Ae, useActionState: Ae, useOptimistic: Ae, useMemoCache: Ae, useCacheRefresh: Ae };
  ku.useEffectEvent = Ae;
  var wu = { readContext: O, use: Je, useCallback: /* @__PURE__ */ __name(function(e4, n6) {
    return qe().memoizedState = [e4, void 0 === n6 ? null : n6], e4;
  }, "useCallback"), useContext: O, useEffect: Pn, useImperativeHandle: /* @__PURE__ */ __name(function(e4, n6, t5) {
    t5 = null != t5 ? t5.concat([e4]) : null, En(4194308, 4, Ln.bind(null, n6, e4), t5);
  }, "useImperativeHandle"), useLayoutEffect: /* @__PURE__ */ __name(function(e4, n6) {
    return En(4194308, 4, e4, n6);
  }, "useLayoutEffect"), useInsertionEffect: /* @__PURE__ */ __name(function(e4, n6) {
    En(4, 2, e4, n6);
  }, "useInsertionEffect"), useMemo: /* @__PURE__ */ __name(function(e4, n6) {
    var t5 = qe();
    n6 = void 0 === n6 ? null : n6;
    var r6 = e4();
    if (gu) {
      k3(true);
      try {
        e4();
      } finally {
        k3(false);
      }
    }
    return t5.memoizedState = [r6, n6], r6;
  }, "useMemo"), useReducer: /* @__PURE__ */ __name(function(e4, n6, t5) {
    var r6 = qe();
    if (void 0 !== t5) {
      var l5 = t5(n6);
      if (gu) {
        k3(true);
        try {
          t5(n6);
        } finally {
          k3(false);
        }
      }
    } else l5 = n6;
    return r6.memoizedState = r6.baseState = l5, e4 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: e4, lastRenderedState: l5 }, r6.queue = e4, e4 = e4.dispatch = Bn.bind(null, du, e4), [r6.memoizedState, e4];
  }, "useReducer"), useRef: /* @__PURE__ */ __name(function(e4) {
    return e4 = { current: e4 }, qe().memoizedState = e4;
  }, "useRef"), useState: /* @__PURE__ */ __name(function(e4) {
    var n6 = (e4 = sn(e4)).queue, t5 = $n.bind(null, du, n6);
    return n6.dispatch = t5, [e4.memoizedState, t5];
  }, "useState"), useDebugValue: Dn, useDeferredValue: /* @__PURE__ */ __name(function(e4, n6) {
    return jn(qe(), e4, n6);
  }, "useDeferredValue"), useTransition: /* @__PURE__ */ __name(function() {
    var e4 = sn(false);
    return e4 = Hn.bind(null, du, e4.queue, true, false), qe().memoizedState = e4, [false, e4];
  }, "useTransition"), useSyncExternalStore: /* @__PURE__ */ __name(function(e4, n6, t5) {
    var l5 = du, a5 = qe();
    if (t5 = n6(), null === Wu) throw Error(r5(349));
    0 != (127 & Bu) || rn(l5, n6, t5), a5.memoizedState = t5;
    var o5 = { value: t5, getSnapshot: n6 };
    return a5.queue = o5, Pn(an.bind(null, l5, o5, e4), [e4]), l5.flags |= 2048, zn(9, { destroy: void 0 }, ln.bind(null, l5, o5, t5, n6), null), t5;
  }, "useSyncExternalStore"), useId: /* @__PURE__ */ __name(function() {
    var e4 = qe(), n6 = Wu.identifierPrefix;
    return n6 = "_" + n6 + "r_" + (Su++).toString(32) + "_", e4.memoizedState = n6;
  }, "useId"), useHostTransitionStatus: On, useFormState: bn, useActionState: bn, useOptimistic: /* @__PURE__ */ __name(function(e4) {
    var n6 = qe();
    n6.memoizedState = n6.baseState = e4;
    var t5 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null };
    return n6.queue = t5, n6 = qn.bind(null, du, true, t5), t5.dispatch = n6, [e4, n6];
  }, "useOptimistic"), useMemoCache: Ke, useCacheRefresh: /* @__PURE__ */ __name(function() {
    return qe().memoizedState = Qn.bind(null, du);
  }, "useCacheRefresh"), useEffectEvent: /* @__PURE__ */ __name(function(e4) {
    var n6 = qe(), t5 = { impl: e4 };
    return n6.memoizedState = t5, function() {
      if (0 != (2 & Mu)) throw Error(r5(440));
      return t5.impl.apply(void 0, arguments);
    };
  }, "useEffectEvent") }, zu = { readContext: O, use: Je, useCallback: In, useContext: O, useEffect: _n, useImperativeHandle: Un, useInsertionEffect: Rn, useLayoutEffect: Nn, useMemo: Fn, useReducer: Ze, useRef: xn, useState: /* @__PURE__ */ __name(function() {
    return Ze(Xe);
  }, "useState"), useDebugValue: Dn, useDeferredValue: /* @__PURE__ */ __name(function(e4, n6) {
    return An(Ye(), fu.memoizedState, e4, n6);
  }, "useDeferredValue"), useTransition: /* @__PURE__ */ __name(function() {
    var e4 = Ze(Xe)[0], n6 = Ye().memoizedState;
    return ["boolean" == typeof e4 ? e4 : Ge(e4), n6];
  }, "useTransition"), useSyncExternalStore: tn, useId: Mn, useHostTransitionStatus: On, useFormState: vn, useActionState: vn, useOptimistic: /* @__PURE__ */ __name(function(e4, n6) {
    return cn(Ye(), 0, e4, n6);
  }, "useOptimistic"), useMemoCache: Ke, useCacheRefresh: Wn };
  zu.useEffectEvent = Tn;
  var xu = { readContext: O, use: Je, useCallback: In, useContext: O, useEffect: _n, useImperativeHandle: Un, useInsertionEffect: Rn, useLayoutEffect: Nn, useMemo: Fn, useReducer: nn, useRef: xn, useState: /* @__PURE__ */ __name(function() {
    return nn(Xe);
  }, "useState"), useDebugValue: Dn, useDeferredValue: /* @__PURE__ */ __name(function(e4, n6) {
    var t5 = Ye();
    return null === fu ? jn(t5, e4, n6) : An(t5, fu.memoizedState, e4, n6);
  }, "useDeferredValue"), useTransition: /* @__PURE__ */ __name(function() {
    var e4 = nn(Xe)[0], n6 = Ye().memoizedState;
    return ["boolean" == typeof e4 ? e4 : Ge(e4), n6];
  }, "useTransition"), useSyncExternalStore: tn, useId: Mn, useHostTransitionStatus: On, useFormState: wn, useActionState: wn, useOptimistic: /* @__PURE__ */ __name(function(e4, n6) {
    var t5 = Ye();
    return null !== fu ? cn(t5, 0, e4, n6) : (t5.baseState = e4, [e4, t5.queue.dispatch]);
  }, "useOptimistic"), useMemoCache: Ke, useCacheRefresh: Wn };
  xu.useEffectEvent = Tn;
  var Eu = { enqueueSetState: /* @__PURE__ */ __name(function(e4, n6, t5) {
    e4 = e4._reactInternals;
    var r6 = kr(), l5 = ke(r6);
    l5.payload = n6, null != t5 && (l5.callback = t5), null !== (n6 = we(e4, l5, r6)) && (zr(n6, 0, r6), ze(n6, e4, r6));
  }, "enqueueSetState"), enqueueReplaceState: /* @__PURE__ */ __name(function(e4, n6, t5) {
    e4 = e4._reactInternals;
    var r6 = kr(), l5 = ke(r6);
    l5.tag = 1, l5.payload = n6, null != t5 && (l5.callback = t5), null !== (n6 = we(e4, l5, r6)) && (zr(n6, 0, r6), ze(n6, e4, r6));
  }, "enqueueReplaceState"), enqueueForceUpdate: /* @__PURE__ */ __name(function(e4, n6) {
    e4 = e4._reactInternals;
    var t5 = kr(), r6 = ke(t5);
    r6.tag = 2, null != n6 && (r6.callback = n6), null !== (n6 = we(e4, r6, t5)) && (zr(n6, 0, t5), ze(n6, e4, t5));
  }, "enqueueForceUpdate") }, Cu = Error(r5(461)), Pu = false, _u = { dehydrated: null, treeContext: null, retryLane: 0, hydrationErrors: null }, Tu = false, Ru = false, Nu = false, Lu = "function" == typeof WeakSet ? WeakSet : Set, Uu = null, Du = null, Iu = false, Fu = null, ju = 8192, Au = { getCacheForType: /* @__PURE__ */ __name(function(e4) {
    var n6 = O(Lo), t5 = n6.data.get(e4);
    return void 0 === t5 && (t5 = e4(), n6.data.set(e4, t5)), t5;
  }, "getCacheForType"), cacheSignal: /* @__PURE__ */ __name(function() {
    return O(Lo).controller.signal;
  }, "cacheSignal") };
  if ("function" == typeof Symbol && Symbol.for) {
    var Hu = Symbol.for;
    Hu("selector.component"), Hu("selector.has_pseudo_class"), Hu("selector.role"), Hu("selector.test_id"), Hu("selector.text");
  }
  var Ou = "function" == typeof WeakMap ? WeakMap : Map, Mu = 0, Wu = null, Qu = null, Bu = 0, $u = 0, Vu = null, qu = false, Yu = false, Gu = false, Ju = 0, Ku = 0, Xu = 0, Zu = 0, ei = 0, ni = 0, ti = 0, ri = null, li = null, ai = false, oi = 0, ui = 0, ii = 1 / 0, si = null, ci = null, di = 0, fi = null, pi = null, mi = 0, hi = 0, gi = null, yi = null, bi = 0, vi = null;
  return fl.createContainer = function(e4, n6, r6, l5, a5, o5, u4, i3, s5, c3) {
    return function(e5, n7, r7, l6, a6, o6, u5, i4, s6, c4, d4, f5) {
      return e5 = new cl(e5, n7, r7, u5, s6, c4, d4, f5, null), n7 = 1, true === o6 && (n7 |= 24), o6 = t4(3, null, null, n7), e5.current = o6, o6.stateNode = e5, (n7 = Q()).refCount++, e5.pooledCache = n7, n7.refCount++, o6.memoizedState = { element: l6, isDehydrated: r7, cache: n7 }, ve(o6), e5;
    }(e4, n6, false, null, 0, l5, o5, 0, u4, i3, s5, c3);
  }, fl.flushSyncWork = function() {
    return 0 != (6 & Mu) || (q(0), false);
  }, fl.updateContainer = function(e4, n6, t5, r6) {
    var l5 = n6.current, a5 = kr();
    return dl(l5, a5, e4, n6, t5, r6), a5;
  }, fl.updateContainerSync = function(e4, n6, t5, r6) {
    return dl(n6.current, 2, e4, n6, t5, r6), 2;
  }, fl;
}, s2.exports.default = s2.exports, Object.defineProperty(s2.exports, "__esModule", { value: true })), o2.exports) : a2.exports = function() {
  return i || (i = 1, n5 = c, false), c.exports;
  var n5;
}();
var d2;
var f2 = t2(a2.exports);
var p2 = { exports: {} };
var m2 = {};
true ? p2.exports = (d2 || (d2 = 1, m2.ConcurrentRoot = 1, m2.ContinuousEventPriority = 8, m2.DefaultEventPriority = 32, m2.DiscreteEventPriority = 2, m2.IdleEventPriority = 268435456, m2.LegacyRoot = 0, m2.NoEventPriority = 0), m2) : p2.exports = (h || (h = 1, false), g);
var y2 = p2.exports;
var b2 = /* @__PURE__ */ __name((e4, n5) => {
  const t4 = Object.keys(e4), r5 = Object.keys(n5);
  if (t4.length !== r5.length) return false;
  for (let r6 = 0; r6 < t4.length; r6 += 1) {
    const l4 = t4[r6];
    if ("render" === l4 && !e4[l4] != !n5[l4]) return false;
    if ("children" !== l4 && e4[l4] !== n5[l4]) {
      if ("object" == typeof e4[l4] && "object" == typeof n5[l4] && b2(e4[l4], n5[l4])) continue;
      return false;
    }
    if ("children" === l4 && ("string" == typeof e4[l4] || "string" == typeof n5[l4])) return e4[l4] === n5[l4];
  }
  return true;
}, "b");
var v2 = {};
var S2 = console.error;
var k2 = /* @__PURE__ */ __name(({ appendChild: e4, appendChildToContainer: n5, commitTextUpdate: t4, commitUpdate: r5, createInstance: l4, createTextInstance: a4, insertBefore: o4, removeChild: u4, removeChildFromContainer: i2, resetAfterCommit: s4 }) => {
  const c2 = f2({ appendChild: e4, appendChildToContainer: n5, appendInitialChild: e4, createInstance: l4, createTextInstance: a4, insertBefore: o4, commitUpdate: /* @__PURE__ */ __name((e5, n6, t5, l5) => {
    b2(t5, l5) || r5(e5, null, n6, t5, l5);
  }, "commitUpdate"), commitTextUpdate: t4, removeChild: u4, removeChildFromContainer: i2, resetAfterCommit: s4, noTimeout: -1, shouldSetTextContent: /* @__PURE__ */ __name(() => false, "shouldSetTextContent"), finalizeInitialChildren: /* @__PURE__ */ __name(() => false, "finalizeInitialChildren"), getPublicInstance: /* @__PURE__ */ __name((e5) => e5, "getPublicInstance"), getRootHostContext: /* @__PURE__ */ __name(() => v2, "getRootHostContext"), getChildHostContext: /* @__PURE__ */ __name(() => v2, "getChildHostContext"), prepareForCommit() {
  }, clearContainer() {
  }, resetTextContent() {
  }, getCurrentUpdatePriority: /* @__PURE__ */ __name(() => y2.DefaultEventPriority, "getCurrentUpdatePriority"), maySuspendCommit: /* @__PURE__ */ __name(() => false, "maySuspendCommit"), requestPostPaintCallback: /* @__PURE__ */ __name(() => {
  }, "requestPostPaintCallback"), resolveUpdatePriority: /* @__PURE__ */ __name(() => y2.DefaultEventPriority, "resolveUpdatePriority"), setCurrentUpdatePriority: /* @__PURE__ */ __name(() => {
  }, "setCurrentUpdatePriority"), shouldAttemptEagerTransition: /* @__PURE__ */ __name(() => false, "shouldAttemptEagerTransition"), detachDeletedInstance: /* @__PURE__ */ __name(() => {
  }, "detachDeletedInstance"), resolveEventTimeStamp: /* @__PURE__ */ __name(() => {
  }, "resolveEventTimeStamp"), resolveEventType: /* @__PURE__ */ __name(() => {
  }, "resolveEventType"), trackSchedulerEvent: /* @__PURE__ */ __name(() => {
  }, "trackSchedulerEvent") });
  return { createContainer: /* @__PURE__ */ __name((e5) => c2.createContainer(e5, y2.ConcurrentRoot, null, false, null, "", S2, S2, S2, () => {
  }, null), "createContainer"), updateContainer: /* @__PURE__ */ __name((e5, n6, t5, r6) => {
    c2.updateContainerSync(e5, n6, t5, r6), c2.flushSyncWork();
  }, "updateContainer") };
}, "k");

// ../../node_modules/.pnpm/@react-pdf+reconciler@2.0.0_react@19.2.0/node_modules/@react-pdf/reconciler/lib/reconciler-23.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_object_assign = __toESM(require_object_assign(), 1);
var import_react3 = __toESM(require_react(), 1);
var n3 = __toESM(require_scheduler(), 1);
function r4(e4) {
  return e4 && e4.__esModule && Object.prototype.hasOwnProperty.call(e4, "default") ? e4.default : e4;
}
__name(r4, "r");
function l3(e4) {
  if (e4.__esModule) return e4;
  var t4 = e4.default;
  if ("function" == typeof t4) {
    var n5 = /* @__PURE__ */ __name(function e5() {
      return this instanceof e5 ? Reflect.construct(t4, arguments, this.constructor) : t4.apply(this, arguments);
    }, "e");
    n5.prototype = t4.prototype;
  } else n5 = {};
  return Object.defineProperty(n5, "__esModule", { value: true }), Object.keys(e4).forEach(function(t5) {
    var r5 = Object.getOwnPropertyDescriptor(e4, t5);
    Object.defineProperty(n5, t5, r5.get ? r5 : { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return e4[t5];
    }, "get") });
  }), n5;
}
__name(l3, "l");
var i;
var a3 = { exports: {} };
var u3 = l3(n3);
/** @license React v0.23.0
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(i = a3).exports = /* @__PURE__ */ __name(function n4(r5) {
  var l4 = import_object_assign.default, a4 = import_react3.default, o4 = u3;
  function f4(e4) {
    for (var t4 = "https://reactjs.org/docs/error-decoder.html?invariant=" + e4, n5 = 1; n5 < arguments.length; n5++) t4 += "&args[]=" + encodeURIComponent(arguments[n5]);
    return "Minified React error #" + e4 + "; visit " + t4 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  __name(f4, "f");
  var c2 = a4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  c2.hasOwnProperty("ReactCurrentDispatcher") || (c2.ReactCurrentDispatcher = { current: null }), c2.hasOwnProperty("ReactCurrentBatchConfig") || (c2.ReactCurrentBatchConfig = { suspense: null });
  var s4 = "function" == typeof Symbol && Symbol.for, d3 = s4 ? Symbol.for("react.element") : 60103, p3 = s4 ? Symbol.for("react.portal") : 60106, m3 = s4 ? Symbol.for("react.fragment") : 60107, h = s4 ? Symbol.for("react.strict_mode") : 60108, g = s4 ? Symbol.for("react.profiler") : 60114, b3 = s4 ? Symbol.for("react.provider") : 60109, y3 = s4 ? Symbol.for("react.context") : 60110, v3 = s4 ? Symbol.for("react.concurrent_mode") : 60111, T = s4 ? Symbol.for("react.forward_ref") : 60112, x = s4 ? Symbol.for("react.suspense") : 60113, E = s4 ? Symbol.for("react.suspense_list") : 60120, k3 = s4 ? Symbol.for("react.memo") : 60115, S3 = s4 ? Symbol.for("react.lazy") : 60116, C = "function" == typeof Symbol && Symbol.iterator;
  function w(e4) {
    return null === e4 || "object" != typeof e4 ? null : "function" == typeof (e4 = C && e4[C] || e4["@@iterator"]) ? e4 : null;
  }
  __name(w, "w");
  function z(e4) {
    if (null == e4) return null;
    if ("function" == typeof e4) return e4.displayName || e4.name || null;
    if ("string" == typeof e4) return e4;
    switch (e4) {
      case m3:
        return "Fragment";
      case p3:
        return "Portal";
      case g:
        return "Profiler";
      case h:
        return "StrictMode";
      case x:
        return "Suspense";
      case E:
        return "SuspenseList";
    }
    if ("object" == typeof e4) switch (e4.$$typeof) {
      case y3:
        return "Context.Consumer";
      case b3:
        return "Context.Provider";
      case T:
        var t4 = e4.render;
        return t4 = t4.displayName || t4.name || "", e4.displayName || ("" !== t4 ? "ForwardRef(" + t4 + ")" : "ForwardRef");
      case k3:
        return z(e4.type);
      case S3:
        if (e4 = 1 === e4._status ? e4._result : null) return z(e4);
    }
    return null;
  }
  __name(z, "z");
  function P(e4) {
    var t4 = e4, n5 = e4;
    if (e4.alternate) for (; t4.return; ) t4 = t4.return;
    else {
      e4 = t4;
      do {
        0 != (1026 & (t4 = e4).effectTag) && (n5 = t4.return), e4 = t4.return;
      } while (e4);
    }
    return 3 === t4.tag ? n5 : null;
  }
  __name(P, "P");
  function _(e4) {
    if (P(e4) !== e4) throw Error(f4(188));
  }
  __name(_, "_");
  function N(e4) {
    var t4 = e4.alternate;
    if (!t4) {
      if (null === (t4 = P(e4))) throw Error(f4(188));
      return t4 !== e4 ? null : e4;
    }
    for (var n5 = e4, r6 = t4; ; ) {
      var l5 = n5.return;
      if (null === l5) break;
      var i2 = l5.alternate;
      if (null === i2) {
        if (null !== (r6 = l5.return)) {
          n5 = r6;
          continue;
        }
        break;
      }
      if (l5.child === i2.child) {
        for (i2 = l5.child; i2; ) {
          if (i2 === n5) return _(l5), e4;
          if (i2 === r6) return _(l5), t4;
          i2 = i2.sibling;
        }
        throw Error(f4(188));
      }
      if (n5.return !== r6.return) n5 = l5, r6 = i2;
      else {
        for (var a5 = false, u4 = l5.child; u4; ) {
          if (u4 === n5) {
            a5 = true, n5 = l5, r6 = i2;
            break;
          }
          if (u4 === r6) {
            a5 = true, r6 = l5, n5 = i2;
            break;
          }
          u4 = u4.sibling;
        }
        if (!a5) {
          for (u4 = i2.child; u4; ) {
            if (u4 === n5) {
              a5 = true, n5 = i2, r6 = l5;
              break;
            }
            if (u4 === r6) {
              a5 = true, r6 = i2, n5 = l5;
              break;
            }
            u4 = u4.sibling;
          }
          if (!a5) throw Error(f4(189));
        }
      }
      if (n5.alternate !== r6) throw Error(f4(190));
    }
    if (3 !== n5.tag) throw Error(f4(188));
    return n5.stateNode.current === n5 ? e4 : t4;
  }
  __name(N, "N");
  function U(e4) {
    if (!(e4 = N(e4))) return null;
    for (var t4 = e4; ; ) {
      if (5 === t4.tag || 6 === t4.tag) return t4;
      if (t4.child) t4.child.return = t4, t4 = t4.child;
      else {
        if (t4 === e4) break;
        for (; !t4.sibling; ) {
          if (!t4.return || t4.return === e4) return null;
          t4 = t4.return;
        }
        t4.sibling.return = t4.return, t4 = t4.sibling;
      }
    }
    return null;
  }
  __name(U, "U");
  var R = r5.getPublicInstance, I = r5.getRootHostContext, M = r5.getChildHostContext, F = r5.prepareForCommit, Q = r5.resetAfterCommit, D = r5.createInstance, W = r5.appendInitialChild, j = r5.finalizeInitialChildren, O = r5.prepareUpdate, B = r5.shouldSetTextContent, H = r5.createTextInstance, A = null, L = null, $ = r5.noTimeout, q = true, V = null, K = r5.appendChild, G2 = r5.appendChildToContainer, Y = r5.commitTextUpdate, J = null, X = r5.commitUpdate, Z = r5.insertBefore, ee = null, te = r5.removeChild, ne = r5.removeChildFromContainer, re = r5.resetTextContent, le = null, ie = null, ae = null, ue = null, oe = null, fe = null, ce = /^(.*)[\\\/]/;
  function se(e4) {
    var t4 = "";
    do {
      e: switch (e4.tag) {
        case 3:
        case 4:
        case 6:
        case 7:
        case 10:
        case 9:
          var n5 = "";
          break e;
        default:
          var r6 = e4._debugOwner, l5 = e4._debugSource, i2 = z(e4.type);
          n5 = null, r6 && (n5 = z(r6.type)), r6 = i2, i2 = "", l5 ? i2 = " (at " + l5.fileName.replace(ce, "") + ":" + l5.lineNumber + ")" : n5 && (i2 = " (created by " + n5 + ")"), n5 = "\n    in " + (r6 || "Unknown") + i2;
      }
      t4 += n5, e4 = e4.return;
    } while (e4);
    return t4;
  }
  __name(se, "se");
  var de = [], pe = -1;
  function me(e4) {
    0 > pe || (e4.current = de[pe], de[pe] = null, pe--);
  }
  __name(me, "me");
  function he(e4, t4) {
    pe++, de[pe] = e4.current, e4.current = t4;
  }
  __name(he, "he");
  var ge = {}, be = { current: ge }, ye = { current: false }, ve = ge;
  function Te(e4, t4) {
    var n5 = e4.type.contextTypes;
    if (!n5) return ge;
    var r6 = e4.stateNode;
    if (r6 && r6.__reactInternalMemoizedUnmaskedChildContext === t4) return r6.__reactInternalMemoizedMaskedChildContext;
    var l5, i2 = {};
    for (l5 in n5) i2[l5] = t4[l5];
    return r6 && ((e4 = e4.stateNode).__reactInternalMemoizedUnmaskedChildContext = t4, e4.__reactInternalMemoizedMaskedChildContext = i2), i2;
  }
  __name(Te, "Te");
  function xe(e4) {
    return null != (e4 = e4.childContextTypes);
  }
  __name(xe, "xe");
  function Ee(e4) {
    me(ye), me(be);
  }
  __name(Ee, "Ee");
  function ke(e4) {
    me(ye), me(be);
  }
  __name(ke, "ke");
  function Se(e4, t4, n5) {
    if (be.current !== ge) throw Error(f4(168));
    he(be, t4), he(ye, n5);
  }
  __name(Se, "Se");
  function Ce(e4, t4, n5) {
    var r6 = e4.stateNode;
    if (e4 = t4.childContextTypes, "function" != typeof r6.getChildContext) return n5;
    for (var i2 in r6 = r6.getChildContext()) if (!(i2 in e4)) throw Error(f4(108, z(t4) || "Unknown", i2));
    return l4({}, n5, {}, r6);
  }
  __name(Ce, "Ce");
  function we(e4) {
    var t4 = e4.stateNode;
    return t4 = t4 && t4.__reactInternalMemoizedMergedChildContext || ge, ve = be.current, he(be, t4), he(ye, ye.current), true;
  }
  __name(we, "we");
  function ze(e4, t4, n5) {
    var r6 = e4.stateNode;
    if (!r6) throw Error(f4(169));
    n5 ? (t4 = Ce(e4, t4, ve), r6.__reactInternalMemoizedMergedChildContext = t4, me(ye), me(be), he(be, t4)) : me(ye), he(ye, n5);
  }
  __name(ze, "ze");
  var Pe = o4.unstable_runWithPriority, _e = o4.unstable_scheduleCallback, Ne = o4.unstable_cancelCallback, Ue = o4.unstable_shouldYield, Re = o4.unstable_requestPaint, Ie = o4.unstable_now, Me = o4.unstable_getCurrentPriorityLevel, Fe = o4.unstable_ImmediatePriority, Qe = o4.unstable_UserBlockingPriority, De = o4.unstable_NormalPriority, We = o4.unstable_LowPriority, je = o4.unstable_IdlePriority, Oe = {}, Be = void 0 !== Re ? Re : function() {
  }, He = null, Ae = null, Le = false, $e = Ie(), qe = 1e4 > $e ? Ie : function() {
    return Ie() - $e;
  };
  function Ve() {
    switch (Me()) {
      case Fe:
        return 99;
      case Qe:
        return 98;
      case De:
        return 97;
      case We:
        return 96;
      case je:
        return 95;
      default:
        throw Error(f4(332));
    }
  }
  __name(Ve, "Ve");
  function Ke(e4) {
    switch (e4) {
      case 99:
        return Fe;
      case 98:
        return Qe;
      case 97:
        return De;
      case 96:
        return We;
      case 95:
        return je;
      default:
        throw Error(f4(332));
    }
  }
  __name(Ke, "Ke");
  function Ge(e4, t4) {
    return e4 = Ke(e4), Pe(e4, t4);
  }
  __name(Ge, "Ge");
  function Ye(e4, t4, n5) {
    return e4 = Ke(e4), _e(e4, t4, n5);
  }
  __name(Ye, "Ye");
  function Je(e4) {
    return null === He ? (He = [e4], Ae = _e(Fe, Ze)) : He.push(e4), Oe;
  }
  __name(Je, "Je");
  function Xe() {
    if (null !== Ae) {
      var e4 = Ae;
      Ae = null, Ne(e4);
    }
    Ze();
  }
  __name(Xe, "Xe");
  function Ze() {
    if (!Le && null !== He) {
      Le = true;
      var e4 = 0;
      try {
        var t4 = He;
        Ge(99, function() {
          for (; e4 < t4.length; e4++) {
            var n5 = t4[e4];
            do {
              n5 = n5(true);
            } while (null !== n5);
          }
        }), He = null;
      } catch (t5) {
        throw null !== He && (He = He.slice(e4 + 1)), _e(Fe, Xe), t5;
      } finally {
        Le = false;
      }
    }
  }
  __name(Ze, "Ze");
  var et = 3;
  function tt(e4, t4, n5) {
    return 1073741821 - (1 + ((1073741821 - e4 + t4 / 10) / (n5 /= 10) | 0)) * n5;
  }
  __name(tt, "tt");
  var nt = "function" == typeof Object.is ? Object.is : function(e4, t4) {
    return e4 === t4 && (0 !== e4 || 1 / e4 == 1 / t4) || e4 != e4 && t4 != t4;
  }, rt = Object.prototype.hasOwnProperty;
  function lt(e4, t4) {
    if (nt(e4, t4)) return true;
    if ("object" != typeof e4 || null === e4 || "object" != typeof t4 || null === t4) return false;
    var n5 = Object.keys(e4), r6 = Object.keys(t4);
    if (n5.length !== r6.length) return false;
    for (r6 = 0; r6 < n5.length; r6++) if (!rt.call(t4, n5[r6]) || !nt(e4[n5[r6]], t4[n5[r6]])) return false;
    return true;
  }
  __name(lt, "lt");
  function it(e4, t4) {
    if (e4 && e4.defaultProps) for (var n5 in t4 = l4({}, t4), e4 = e4.defaultProps) void 0 === t4[n5] && (t4[n5] = e4[n5]);
    return t4;
  }
  __name(it, "it");
  var at = { current: null }, ut = null, ot = null, ft = null;
  function ct() {
    ft = ot = ut = null;
  }
  __name(ct, "ct");
  function st(e4, t4) {
    var n5 = e4.type._context;
    he(at, n5._currentValue2), n5._currentValue2 = t4;
  }
  __name(st, "st");
  function dt(e4) {
    var t4 = at.current;
    me(at), (e4 = e4.type._context)._currentValue2 = t4;
  }
  __name(dt, "dt");
  function pt(e4, t4) {
    for (; null !== e4; ) {
      var n5 = e4.alternate;
      if (e4.childExpirationTime < t4) e4.childExpirationTime = t4, null !== n5 && n5.childExpirationTime < t4 && (n5.childExpirationTime = t4);
      else {
        if (!(null !== n5 && n5.childExpirationTime < t4)) break;
        n5.childExpirationTime = t4;
      }
      e4 = e4.return;
    }
  }
  __name(pt, "pt");
  function mt(e4, t4) {
    ut = e4, ft = ot = null, null !== (e4 = e4.dependencies) && null !== e4.firstContext && (e4.expirationTime >= t4 && (On = true), e4.firstContext = null);
  }
  __name(mt, "mt");
  function ht(e4, t4) {
    if (ft !== e4 && false !== t4 && 0 !== t4) if ("number" == typeof t4 && 1073741823 !== t4 || (ft = e4, t4 = 1073741823), t4 = { context: e4, observedBits: t4, next: null }, null === ot) {
      if (null === ut) throw Error(f4(308));
      ot = t4, ut.dependencies = { expirationTime: 0, firstContext: t4, responders: null };
    } else ot = ot.next = t4;
    return e4._currentValue2;
  }
  __name(ht, "ht");
  var gt = false;
  function bt(e4) {
    return { baseState: e4, firstUpdate: null, lastUpdate: null, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null };
  }
  __name(bt, "bt");
  function yt(e4) {
    return { baseState: e4.baseState, firstUpdate: e4.firstUpdate, lastUpdate: e4.lastUpdate, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null };
  }
  __name(yt, "yt");
  function vt(e4, t4) {
    return { expirationTime: e4, suspenseConfig: t4, tag: 0, payload: null, callback: null, next: null, nextEffect: null };
  }
  __name(vt, "vt");
  function Tt(e4, t4) {
    null === e4.lastUpdate ? e4.firstUpdate = e4.lastUpdate = t4 : (e4.lastUpdate.next = t4, e4.lastUpdate = t4);
  }
  __name(Tt, "Tt");
  function xt(e4, t4) {
    var n5 = e4.alternate;
    if (null === n5) {
      var r6 = e4.updateQueue, l5 = null;
      null === r6 && (r6 = e4.updateQueue = bt(e4.memoizedState));
    } else r6 = e4.updateQueue, l5 = n5.updateQueue, null === r6 ? null === l5 ? (r6 = e4.updateQueue = bt(e4.memoizedState), l5 = n5.updateQueue = bt(n5.memoizedState)) : r6 = e4.updateQueue = yt(l5) : null === l5 && (l5 = n5.updateQueue = yt(r6));
    null === l5 || r6 === l5 ? Tt(r6, t4) : null === r6.lastUpdate || null === l5.lastUpdate ? (Tt(r6, t4), Tt(l5, t4)) : (Tt(r6, t4), l5.lastUpdate = t4);
  }
  __name(xt, "xt");
  function Et(e4, t4) {
    var n5 = e4.updateQueue;
    null === (n5 = null === n5 ? e4.updateQueue = bt(e4.memoizedState) : kt(e4, n5)).lastCapturedUpdate ? n5.firstCapturedUpdate = n5.lastCapturedUpdate = t4 : (n5.lastCapturedUpdate.next = t4, n5.lastCapturedUpdate = t4);
  }
  __name(Et, "Et");
  function kt(e4, t4) {
    var n5 = e4.alternate;
    return null !== n5 && t4 === n5.updateQueue && (t4 = e4.updateQueue = yt(t4)), t4;
  }
  __name(kt, "kt");
  function St(e4, t4, n5, r6, i2, a5) {
    switch (n5.tag) {
      case 1:
        return "function" == typeof (e4 = n5.payload) ? e4.call(a5, r6, i2) : e4;
      case 3:
        e4.effectTag = -4097 & e4.effectTag | 64;
      case 0:
        if (null == (i2 = "function" == typeof (e4 = n5.payload) ? e4.call(a5, r6, i2) : e4)) break;
        return l4({}, r6, i2);
      case 2:
        gt = true;
    }
    return r6;
  }
  __name(St, "St");
  function Ct(e4, t4, n5, r6, l5) {
    gt = false;
    for (var i2 = (t4 = kt(e4, t4)).baseState, a5 = null, u4 = 0, o5 = t4.firstUpdate, f5 = i2; null !== o5; ) {
      var c3 = o5.expirationTime;
      c3 < l5 ? (null === a5 && (a5 = o5, i2 = f5), u4 < c3 && (u4 = c3)) : (El(c3, o5.suspenseConfig), f5 = St(e4, 0, o5, f5, n5, r6), null !== o5.callback && (e4.effectTag |= 32, o5.nextEffect = null, null === t4.lastEffect ? t4.firstEffect = t4.lastEffect = o5 : (t4.lastEffect.nextEffect = o5, t4.lastEffect = o5))), o5 = o5.next;
    }
    for (c3 = null, o5 = t4.firstCapturedUpdate; null !== o5; ) {
      var s5 = o5.expirationTime;
      s5 < l5 ? (null === c3 && (c3 = o5, null === a5 && (i2 = f5)), u4 < s5 && (u4 = s5)) : (f5 = St(e4, 0, o5, f5, n5, r6), null !== o5.callback && (e4.effectTag |= 32, o5.nextEffect = null, null === t4.lastCapturedEffect ? t4.firstCapturedEffect = t4.lastCapturedEffect = o5 : (t4.lastCapturedEffect.nextEffect = o5, t4.lastCapturedEffect = o5))), o5 = o5.next;
    }
    null === a5 && (t4.lastUpdate = null), null === c3 ? t4.lastCapturedUpdate = null : e4.effectTag |= 32, null === a5 && null === c3 && (i2 = f5), t4.baseState = i2, t4.firstUpdate = a5, t4.firstCapturedUpdate = c3, kl(u4), e4.expirationTime = u4, e4.memoizedState = f5;
  }
  __name(Ct, "Ct");
  function wt(e4, t4, n5) {
    null !== t4.firstCapturedUpdate && (null !== t4.lastUpdate && (t4.lastUpdate.next = t4.firstCapturedUpdate, t4.lastUpdate = t4.lastCapturedUpdate), t4.firstCapturedUpdate = t4.lastCapturedUpdate = null), zt(t4.firstEffect, n5), t4.firstEffect = t4.lastEffect = null, zt(t4.firstCapturedEffect, n5), t4.firstCapturedEffect = t4.lastCapturedEffect = null;
  }
  __name(wt, "wt");
  function zt(e4, t4) {
    for (; null !== e4; ) {
      var n5 = e4.callback;
      if (null !== n5) {
        e4.callback = null;
        var r6 = t4;
        if ("function" != typeof n5) throw Error(f4(191, n5));
        n5.call(r6);
      }
      e4 = e4.nextEffect;
    }
  }
  __name(zt, "zt");
  var Pt = c2.ReactCurrentBatchConfig, _t = new a4.Component().refs;
  function Nt(e4, t4, n5, r6) {
    n5 = null == (n5 = n5(r6, t4 = e4.memoizedState)) ? t4 : l4({}, t4, n5), e4.memoizedState = n5, null !== (r6 = e4.updateQueue) && 0 === e4.expirationTime && (r6.baseState = n5);
  }
  __name(Nt, "Nt");
  var Ut = { isMounted: /* @__PURE__ */ __name(function(e4) {
    return !!(e4 = e4._reactInternalFiber) && P(e4) === e4;
  }, "isMounted"), enqueueSetState: /* @__PURE__ */ __name(function(e4, t4, n5) {
    e4 = e4._reactInternalFiber;
    var r6 = cl(), l5 = Pt.suspense;
    (l5 = vt(r6 = sl(r6, e4, l5), l5)).payload = t4, null != n5 && (l5.callback = n5), xt(e4, l5), dl(e4, r6);
  }, "enqueueSetState"), enqueueReplaceState: /* @__PURE__ */ __name(function(e4, t4, n5) {
    e4 = e4._reactInternalFiber;
    var r6 = cl(), l5 = Pt.suspense;
    (l5 = vt(r6 = sl(r6, e4, l5), l5)).tag = 1, l5.payload = t4, null != n5 && (l5.callback = n5), xt(e4, l5), dl(e4, r6);
  }, "enqueueReplaceState"), enqueueForceUpdate: /* @__PURE__ */ __name(function(e4, t4) {
    e4 = e4._reactInternalFiber;
    var n5 = cl(), r6 = Pt.suspense;
    (r6 = vt(n5 = sl(n5, e4, r6), r6)).tag = 2, null != t4 && (r6.callback = t4), xt(e4, r6), dl(e4, n5);
  }, "enqueueForceUpdate") };
  function Rt(e4, t4, n5, r6, l5, i2, a5) {
    return "function" == typeof (e4 = e4.stateNode).shouldComponentUpdate ? e4.shouldComponentUpdate(r6, i2, a5) : !(t4.prototype && t4.prototype.isPureReactComponent && lt(n5, r6) && lt(l5, i2));
  }
  __name(Rt, "Rt");
  function It(e4, t4, n5) {
    var r6 = false, l5 = ge, i2 = t4.contextType;
    return "object" == typeof i2 && null !== i2 ? i2 = ht(i2) : (l5 = xe(t4) ? ve : be.current, i2 = (r6 = null != (r6 = t4.contextTypes)) ? Te(e4, l5) : ge), t4 = new t4(n5, i2), e4.memoizedState = null !== t4.state && void 0 !== t4.state ? t4.state : null, t4.updater = Ut, e4.stateNode = t4, t4._reactInternalFiber = e4, r6 && ((e4 = e4.stateNode).__reactInternalMemoizedUnmaskedChildContext = l5, e4.__reactInternalMemoizedMaskedChildContext = i2), t4;
  }
  __name(It, "It");
  function Mt(e4, t4, n5, r6) {
    e4 = t4.state, "function" == typeof t4.componentWillReceiveProps && t4.componentWillReceiveProps(n5, r6), "function" == typeof t4.UNSAFE_componentWillReceiveProps && t4.UNSAFE_componentWillReceiveProps(n5, r6), t4.state !== e4 && Ut.enqueueReplaceState(t4, t4.state, null);
  }
  __name(Mt, "Mt");
  function Ft(e4, t4, n5, r6) {
    var l5 = e4.stateNode;
    l5.props = n5, l5.state = e4.memoizedState, l5.refs = _t;
    var i2 = t4.contextType;
    "object" == typeof i2 && null !== i2 ? l5.context = ht(i2) : (i2 = xe(t4) ? ve : be.current, l5.context = Te(e4, i2)), null !== (i2 = e4.updateQueue) && (Ct(e4, i2, n5, l5, r6), l5.state = e4.memoizedState), "function" == typeof (i2 = t4.getDerivedStateFromProps) && (Nt(e4, t4, i2, n5), l5.state = e4.memoizedState), "function" == typeof t4.getDerivedStateFromProps || "function" == typeof l5.getSnapshotBeforeUpdate || "function" != typeof l5.UNSAFE_componentWillMount && "function" != typeof l5.componentWillMount || (t4 = l5.state, "function" == typeof l5.componentWillMount && l5.componentWillMount(), "function" == typeof l5.UNSAFE_componentWillMount && l5.UNSAFE_componentWillMount(), t4 !== l5.state && Ut.enqueueReplaceState(l5, l5.state, null), null !== (i2 = e4.updateQueue) && (Ct(e4, i2, n5, l5, r6), l5.state = e4.memoizedState)), "function" == typeof l5.componentDidMount && (e4.effectTag |= 4);
  }
  __name(Ft, "Ft");
  var Qt = Array.isArray;
  function Dt(e4, t4, n5) {
    if (null !== (e4 = n5.ref) && "function" != typeof e4 && "object" != typeof e4) {
      if (n5._owner) {
        if (n5 = n5._owner) {
          if (1 !== n5.tag) throw Error(f4(309));
          var r6 = n5.stateNode;
        }
        if (!r6) throw Error(f4(147, e4));
        var l5 = "" + e4;
        return null !== t4 && null !== t4.ref && "function" == typeof t4.ref && t4.ref._stringRef === l5 ? t4.ref : (t4 = /* @__PURE__ */ __name(function(e5) {
          var t5 = r6.refs;
          t5 === _t && (t5 = r6.refs = {}), null === e5 ? delete t5[l5] : t5[l5] = e5;
        }, "t"), t4._stringRef = l5, t4);
      }
      if ("string" != typeof e4) throw Error(f4(284));
      if (!n5._owner) throw Error(f4(290, e4));
    }
    return e4;
  }
  __name(Dt, "Dt");
  function Wt(e4, t4) {
    if ("textarea" !== e4.type) throw Error(f4(31, "[object Object]" === Object.prototype.toString.call(t4) ? "object with keys {" + Object.keys(t4).join(", ") + "}" : t4, ""));
  }
  __name(Wt, "Wt");
  function jt(e4) {
    function t4(t5, n6) {
      if (e4) {
        var r7 = t5.lastEffect;
        null !== r7 ? (r7.nextEffect = n6, t5.lastEffect = n6) : t5.firstEffect = t5.lastEffect = n6, n6.nextEffect = null, n6.effectTag = 8;
      }
    }
    __name(t4, "t");
    function n5(n6, r7) {
      if (!e4) return null;
      for (; null !== r7; ) t4(n6, r7), r7 = r7.sibling;
      return null;
    }
    __name(n5, "n");
    function r6(e5, t5) {
      for (e5 = /* @__PURE__ */ new Map(); null !== t5; ) null !== t5.key ? e5.set(t5.key, t5) : e5.set(t5.index, t5), t5 = t5.sibling;
      return e5;
    }
    __name(r6, "r");
    function l5(e5, t5, n6) {
      return (e5 = Al(e5, t5)).index = 0, e5.sibling = null, e5;
    }
    __name(l5, "l");
    function i2(t5, n6, r7) {
      return t5.index = r7, e4 ? null !== (r7 = t5.alternate) ? (r7 = r7.index) < n6 ? (t5.effectTag = 2, n6) : r7 : (t5.effectTag = 2, n6) : n6;
    }
    __name(i2, "i");
    function a5(t5) {
      return e4 && null === t5.alternate && (t5.effectTag = 2), t5;
    }
    __name(a5, "a");
    function u4(e5, t5, n6, r7) {
      return null === t5 || 6 !== t5.tag ? ((t5 = ql(n6, e5.mode, r7)).return = e5, t5) : ((t5 = l5(t5, n6)).return = e5, t5);
    }
    __name(u4, "u");
    function o5(e5, t5, n6, r7) {
      return null !== t5 && t5.elementType === n6.type ? ((r7 = l5(t5, n6.props)).ref = Dt(e5, t5, n6), r7.return = e5, r7) : ((r7 = Ll(n6.type, n6.key, n6.props, null, e5.mode, r7)).ref = Dt(e5, t5, n6), r7.return = e5, r7);
    }
    __name(o5, "o");
    function c3(e5, t5, n6, r7) {
      return null === t5 || 4 !== t5.tag || t5.stateNode.containerInfo !== n6.containerInfo || t5.stateNode.implementation !== n6.implementation ? ((t5 = Vl(n6, e5.mode, r7)).return = e5, t5) : ((t5 = l5(t5, n6.children || [])).return = e5, t5);
    }
    __name(c3, "c");
    function s5(e5, t5, n6, r7, i3) {
      return null === t5 || 7 !== t5.tag ? ((t5 = $l(n6, e5.mode, r7, i3)).return = e5, t5) : ((t5 = l5(t5, n6)).return = e5, t5);
    }
    __name(s5, "s");
    function h2(e5, t5, n6) {
      if ("string" == typeof t5 || "number" == typeof t5) return (t5 = ql("" + t5, e5.mode, n6)).return = e5, t5;
      if ("object" == typeof t5 && null !== t5) {
        switch (t5.$$typeof) {
          case d3:
            return (n6 = Ll(t5.type, t5.key, t5.props, null, e5.mode, n6)).ref = Dt(e5, null, t5), n6.return = e5, n6;
          case p3:
            return (t5 = Vl(t5, e5.mode, n6)).return = e5, t5;
        }
        if (Qt(t5) || w(t5)) return (t5 = $l(t5, e5.mode, n6, null)).return = e5, t5;
        Wt(e5, t5);
      }
      return null;
    }
    __name(h2, "h");
    function g2(e5, t5, n6, r7) {
      var l6 = null !== t5 ? t5.key : null;
      if ("string" == typeof n6 || "number" == typeof n6) return null !== l6 ? null : u4(e5, t5, "" + n6, r7);
      if ("object" == typeof n6 && null !== n6) {
        switch (n6.$$typeof) {
          case d3:
            return n6.key === l6 ? n6.type === m3 ? s5(e5, t5, n6.props.children, r7, l6) : o5(e5, t5, n6, r7) : null;
          case p3:
            return n6.key === l6 ? c3(e5, t5, n6, r7) : null;
        }
        if (Qt(n6) || w(n6)) return null !== l6 ? null : s5(e5, t5, n6, r7, null);
        Wt(e5, n6);
      }
      return null;
    }
    __name(g2, "g");
    function b4(e5, t5, n6, r7, l6) {
      if ("string" == typeof r7 || "number" == typeof r7) return u4(t5, e5 = e5.get(n6) || null, "" + r7, l6);
      if ("object" == typeof r7 && null !== r7) {
        switch (r7.$$typeof) {
          case d3:
            return e5 = e5.get(null === r7.key ? n6 : r7.key) || null, r7.type === m3 ? s5(t5, e5, r7.props.children, l6, r7.key) : o5(t5, e5, r7, l6);
          case p3:
            return c3(t5, e5 = e5.get(null === r7.key ? n6 : r7.key) || null, r7, l6);
        }
        if (Qt(r7) || w(r7)) return s5(t5, e5 = e5.get(n6) || null, r7, l6, null);
        Wt(t5, r7);
      }
      return null;
    }
    __name(b4, "b");
    function y4(l6, a6, u5, o6) {
      for (var f5 = null, c4 = null, s6 = a6, d4 = a6 = 0, p4 = null; null !== s6 && d4 < u5.length; d4++) {
        s6.index > d4 ? (p4 = s6, s6 = null) : p4 = s6.sibling;
        var m4 = g2(l6, s6, u5[d4], o6);
        if (null === m4) {
          null === s6 && (s6 = p4);
          break;
        }
        e4 && s6 && null === m4.alternate && t4(l6, s6), a6 = i2(m4, a6, d4), null === c4 ? f5 = m4 : c4.sibling = m4, c4 = m4, s6 = p4;
      }
      if (d4 === u5.length) return n5(l6, s6), f5;
      if (null === s6) {
        for (; d4 < u5.length; d4++) null !== (s6 = h2(l6, u5[d4], o6)) && (a6 = i2(s6, a6, d4), null === c4 ? f5 = s6 : c4.sibling = s6, c4 = s6);
        return f5;
      }
      for (s6 = r6(l6, s6); d4 < u5.length; d4++) null !== (p4 = b4(s6, l6, d4, u5[d4], o6)) && (e4 && null !== p4.alternate && s6.delete(null === p4.key ? d4 : p4.key), a6 = i2(p4, a6, d4), null === c4 ? f5 = p4 : c4.sibling = p4, c4 = p4);
      return e4 && s6.forEach(function(e5) {
        return t4(l6, e5);
      }), f5;
    }
    __name(y4, "y");
    function v4(l6, a6, u5, o6) {
      var c4 = w(u5);
      if ("function" != typeof c4) throw Error(f4(150));
      if (null == (u5 = c4.call(u5))) throw Error(f4(151));
      for (var s6 = c4 = null, d4 = a6, p4 = a6 = 0, m4 = null, y5 = u5.next(); null !== d4 && !y5.done; p4++, y5 = u5.next()) {
        d4.index > p4 ? (m4 = d4, d4 = null) : m4 = d4.sibling;
        var v5 = g2(l6, d4, y5.value, o6);
        if (null === v5) {
          null === d4 && (d4 = m4);
          break;
        }
        e4 && d4 && null === v5.alternate && t4(l6, d4), a6 = i2(v5, a6, p4), null === s6 ? c4 = v5 : s6.sibling = v5, s6 = v5, d4 = m4;
      }
      if (y5.done) return n5(l6, d4), c4;
      if (null === d4) {
        for (; !y5.done; p4++, y5 = u5.next()) null !== (y5 = h2(l6, y5.value, o6)) && (a6 = i2(y5, a6, p4), null === s6 ? c4 = y5 : s6.sibling = y5, s6 = y5);
        return c4;
      }
      for (d4 = r6(l6, d4); !y5.done; p4++, y5 = u5.next()) null !== (y5 = b4(d4, l6, p4, y5.value, o6)) && (e4 && null !== y5.alternate && d4.delete(null === y5.key ? p4 : y5.key), a6 = i2(y5, a6, p4), null === s6 ? c4 = y5 : s6.sibling = y5, s6 = y5);
      return e4 && d4.forEach(function(e5) {
        return t4(l6, e5);
      }), c4;
    }
    __name(v4, "v");
    return function(e5, r7, i3, u5) {
      var o6 = "object" == typeof i3 && null !== i3 && i3.type === m3 && null === i3.key;
      o6 && (i3 = i3.props.children);
      var c4 = "object" == typeof i3 && null !== i3;
      if (c4) switch (i3.$$typeof) {
        case d3:
          e: {
            for (c4 = i3.key, o6 = r7; null !== o6; ) {
              if (o6.key === c4) {
                if (7 === o6.tag ? i3.type === m3 : o6.elementType === i3.type) {
                  n5(e5, o6.sibling), (r7 = l5(o6, i3.type === m3 ? i3.props.children : i3.props)).ref = Dt(e5, o6, i3), r7.return = e5, e5 = r7;
                  break e;
                }
                n5(e5, o6);
                break;
              }
              t4(e5, o6), o6 = o6.sibling;
            }
            i3.type === m3 ? ((r7 = $l(i3.props.children, e5.mode, u5, i3.key)).return = e5, e5 = r7) : ((u5 = Ll(i3.type, i3.key, i3.props, null, e5.mode, u5)).ref = Dt(e5, r7, i3), u5.return = e5, e5 = u5);
          }
          return a5(e5);
        case p3:
          e: {
            for (o6 = i3.key; null !== r7; ) {
              if (r7.key === o6) {
                if (4 === r7.tag && r7.stateNode.containerInfo === i3.containerInfo && r7.stateNode.implementation === i3.implementation) {
                  n5(e5, r7.sibling), (r7 = l5(r7, i3.children || [])).return = e5, e5 = r7;
                  break e;
                }
                n5(e5, r7);
                break;
              }
              t4(e5, r7), r7 = r7.sibling;
            }
            (r7 = Vl(i3, e5.mode, u5)).return = e5, e5 = r7;
          }
          return a5(e5);
      }
      if ("string" == typeof i3 || "number" == typeof i3) return i3 = "" + i3, null !== r7 && 6 === r7.tag ? (n5(e5, r7.sibling), (r7 = l5(r7, i3)).return = e5, e5 = r7) : (n5(e5, r7), (r7 = ql(i3, e5.mode, u5)).return = e5, e5 = r7), a5(e5);
      if (Qt(i3)) return y4(e5, r7, i3, u5);
      if (w(i3)) return v4(e5, r7, i3, u5);
      if (c4 && Wt(e5, i3), void 0 === i3 && !o6) switch (e5.tag) {
        case 1:
        case 0:
          throw e5 = e5.type, Error(f4(152, e5.displayName || e5.name || "Component"));
      }
      return n5(e5, r7);
    };
  }
  __name(jt, "jt");
  var Ot = jt(true), Bt = jt(false), Ht = {}, At = { current: Ht }, Lt = { current: Ht }, $t = { current: Ht };
  function qt(e4) {
    if (e4 === Ht) throw Error(f4(174));
    return e4;
  }
  __name(qt, "qt");
  function Vt(e4, t4) {
    he($t, t4), he(Lt, e4), he(At, Ht), t4 = I(t4), me(At), he(At, t4);
  }
  __name(Vt, "Vt");
  function Kt(e4) {
    me(At), me(Lt), me($t);
  }
  __name(Kt, "Kt");
  function Gt(e4) {
    var t4 = qt($t.current), n5 = qt(At.current);
    n5 !== (t4 = M(n5, e4.type, t4)) && (he(Lt, e4), he(At, t4));
  }
  __name(Gt, "Gt");
  function Yt(e4) {
    Lt.current === e4 && (me(At), me(Lt));
  }
  __name(Yt, "Yt");
  var Jt = { current: 0 };
  function Xt(e4) {
    for (var t4 = e4; null !== t4; ) {
      if (13 === t4.tag) {
        var n5 = t4.memoizedState;
        if (null !== n5 && (null === (n5 = n5.dehydrated) || oe(n5) || fe(n5))) return t4;
      } else if (19 === t4.tag && void 0 !== t4.memoizedProps.revealOrder) {
        if (0 != (64 & t4.effectTag)) return t4;
      } else if (null !== t4.child) {
        t4.child.return = t4, t4 = t4.child;
        continue;
      }
      if (t4 === e4) break;
      for (; null === t4.sibling; ) {
        if (null === t4.return || t4.return === e4) return null;
        t4 = t4.return;
      }
      t4.sibling.return = t4.return, t4 = t4.sibling;
    }
    return null;
  }
  __name(Xt, "Xt");
  function Zt(e4, t4) {
    return { responder: e4, props: t4 };
  }
  __name(Zt, "Zt");
  var en = c2.ReactCurrentDispatcher, tn = c2.ReactCurrentBatchConfig, nn = 0, rn = null, ln = null, an = null, un = null, on4 = null, fn = null, cn = 0, sn = null, dn = 0, pn = false, mn = null, hn = 0;
  function gn() {
    throw Error(f4(321));
  }
  __name(gn, "gn");
  function bn(e4, t4) {
    if (null === t4) return false;
    for (var n5 = 0; n5 < t4.length && n5 < e4.length; n5++) if (!nt(e4[n5], t4[n5])) return false;
    return true;
  }
  __name(bn, "bn");
  function yn(e4, t4, n5, r6, l5, i2) {
    if (nn = i2, rn = t4, an = null !== e4 ? e4.memoizedState : null, en.current = null === an ? Dn : Wn, t4 = n5(r6, l5), pn) {
      do {
        pn = false, hn += 1, an = null !== e4 ? e4.memoizedState : null, fn = un, sn = on4 = ln = null, en.current = Wn, t4 = n5(r6, l5);
      } while (pn);
      mn = null, hn = 0;
    }
    if (en.current = Qn, (e4 = rn).memoizedState = un, e4.expirationTime = cn, e4.updateQueue = sn, e4.effectTag |= dn, e4 = null !== ln && null !== ln.next, nn = 0, fn = on4 = un = an = ln = rn = null, cn = 0, sn = null, dn = 0, e4) throw Error(f4(300));
    return t4;
  }
  __name(yn, "yn");
  function vn() {
    en.current = Qn, nn = 0, fn = on4 = un = an = ln = rn = null, cn = 0, sn = null, dn = 0, pn = false, mn = null, hn = 0;
  }
  __name(vn, "vn");
  function Tn() {
    var e4 = { memoizedState: null, baseState: null, queue: null, baseUpdate: null, next: null };
    return null === on4 ? un = on4 = e4 : on4 = on4.next = e4, on4;
  }
  __name(Tn, "Tn");
  function xn() {
    if (null !== fn) fn = (on4 = fn).next, an = null !== (ln = an) ? ln.next : null;
    else {
      if (null === an) throw Error(f4(310));
      var e4 = { memoizedState: (ln = an).memoizedState, baseState: ln.baseState, queue: ln.queue, baseUpdate: ln.baseUpdate, next: null };
      on4 = null === on4 ? un = e4 : on4.next = e4, an = ln.next;
    }
    return on4;
  }
  __name(xn, "xn");
  function En(e4, t4) {
    return "function" == typeof t4 ? t4(e4) : t4;
  }
  __name(En, "En");
  function kn(e4) {
    var t4 = xn(), n5 = t4.queue;
    if (null === n5) throw Error(f4(311));
    if (n5.lastRenderedReducer = e4, 0 < hn) {
      var r6 = n5.dispatch;
      if (null !== mn) {
        var l5 = mn.get(n5);
        if (void 0 !== l5) {
          mn.delete(n5);
          var i2 = t4.memoizedState;
          do {
            i2 = e4(i2, l5.action), l5 = l5.next;
          } while (null !== l5);
          return nt(i2, t4.memoizedState) || (On = true), t4.memoizedState = i2, t4.baseUpdate === n5.last && (t4.baseState = i2), n5.lastRenderedState = i2, [i2, r6];
        }
      }
      return [t4.memoizedState, r6];
    }
    r6 = n5.last;
    var a5 = t4.baseUpdate;
    if (i2 = t4.baseState, null !== a5 ? (null !== r6 && (r6.next = null), r6 = a5.next) : r6 = null !== r6 ? r6.next : null, null !== r6) {
      var u4 = l5 = null, o5 = r6, c3 = false;
      do {
        var s5 = o5.expirationTime;
        s5 < nn ? (c3 || (c3 = true, u4 = a5, l5 = i2), s5 > cn && kl(cn = s5)) : (El(s5, o5.suspenseConfig), i2 = o5.eagerReducer === e4 ? o5.eagerState : e4(i2, o5.action)), a5 = o5, o5 = o5.next;
      } while (null !== o5 && o5 !== r6);
      c3 || (u4 = a5, l5 = i2), nt(i2, t4.memoizedState) || (On = true), t4.memoizedState = i2, t4.baseUpdate = u4, t4.baseState = l5, n5.lastRenderedState = i2;
    }
    return [t4.memoizedState, n5.dispatch];
  }
  __name(kn, "kn");
  function Sn(e4) {
    var t4 = Tn();
    return "function" == typeof e4 && (e4 = e4()), t4.memoizedState = t4.baseState = e4, e4 = (e4 = t4.queue = { last: null, dispatch: null, lastRenderedReducer: En, lastRenderedState: e4 }).dispatch = Fn.bind(null, rn, e4), [t4.memoizedState, e4];
  }
  __name(Sn, "Sn");
  function Cn(e4) {
    return kn(En);
  }
  __name(Cn, "Cn");
  function wn(e4, t4, n5, r6) {
    return e4 = { tag: e4, create: t4, destroy: n5, deps: r6, next: null }, null === sn ? (sn = { lastEffect: null }).lastEffect = e4.next = e4 : null === (t4 = sn.lastEffect) ? sn.lastEffect = e4.next = e4 : (n5 = t4.next, t4.next = e4, e4.next = n5, sn.lastEffect = e4), e4;
  }
  __name(wn, "wn");
  function zn(e4, t4, n5, r6) {
    var l5 = Tn();
    dn |= e4, l5.memoizedState = wn(t4, n5, void 0, void 0 === r6 ? null : r6);
  }
  __name(zn, "zn");
  function Pn(e4, t4, n5, r6) {
    var l5 = xn();
    r6 = void 0 === r6 ? null : r6;
    var i2 = void 0;
    if (null !== ln) {
      var a5 = ln.memoizedState;
      if (i2 = a5.destroy, null !== r6 && bn(r6, a5.deps)) return void wn(0, n5, i2, r6);
    }
    dn |= e4, l5.memoizedState = wn(t4, n5, i2, r6);
  }
  __name(Pn, "Pn");
  function _n(e4, t4) {
    return zn(516, 192, e4, t4);
  }
  __name(_n, "_n");
  function Nn(e4, t4) {
    return Pn(516, 192, e4, t4);
  }
  __name(Nn, "Nn");
  function Un(e4, t4) {
    return "function" == typeof t4 ? (e4 = e4(), t4(e4), function() {
      t4(null);
    }) : null != t4 ? (e4 = e4(), t4.current = e4, function() {
      t4.current = null;
    }) : void 0;
  }
  __name(Un, "Un");
  function Rn() {
  }
  __name(Rn, "Rn");
  function In(e4, t4) {
    return Tn().memoizedState = [e4, void 0 === t4 ? null : t4], e4;
  }
  __name(In, "In");
  function Mn(e4, t4) {
    var n5 = xn();
    t4 = void 0 === t4 ? null : t4;
    var r6 = n5.memoizedState;
    return null !== r6 && null !== t4 && bn(t4, r6[1]) ? r6[0] : (n5.memoizedState = [e4, t4], e4);
  }
  __name(Mn, "Mn");
  function Fn(e4, t4, n5) {
    if (!(25 > hn)) throw Error(f4(301));
    var r6 = e4.alternate;
    if (e4 === rn || null !== r6 && r6 === rn) if (pn = true, e4 = { expirationTime: nn, suspenseConfig: null, action: n5, eagerReducer: null, eagerState: null, next: null }, null === mn && (mn = /* @__PURE__ */ new Map()), void 0 === (n5 = mn.get(t4))) mn.set(t4, e4);
    else {
      for (t4 = n5; null !== t4.next; ) t4 = t4.next;
      t4.next = e4;
    }
    else {
      var l5 = cl(), i2 = Pt.suspense;
      i2 = { expirationTime: l5 = sl(l5, e4, i2), suspenseConfig: i2, action: n5, eagerReducer: null, eagerState: null, next: null };
      var a5 = t4.last;
      if (null === a5) i2.next = i2;
      else {
        var u4 = a5.next;
        null !== u4 && (i2.next = u4), a5.next = i2;
      }
      if (t4.last = i2, 0 === e4.expirationTime && (null === r6 || 0 === r6.expirationTime) && null !== (r6 = t4.lastRenderedReducer)) try {
        var o5 = t4.lastRenderedState, c3 = r6(o5, n5);
        if (i2.eagerReducer = r6, i2.eagerState = c3, nt(c3, o5)) return;
      } catch (e5) {
      }
      dl(e4, l5);
    }
  }
  __name(Fn, "Fn");
  var Qn = { readContext: ht, useCallback: gn, useContext: gn, useEffect: gn, useImperativeHandle: gn, useLayoutEffect: gn, useMemo: gn, useReducer: gn, useRef: gn, useState: gn, useDebugValue: gn, useResponder: gn, useDeferredValue: gn, useTransition: gn }, Dn = { readContext: ht, useCallback: In, useContext: ht, useEffect: _n, useImperativeHandle: /* @__PURE__ */ __name(function(e4, t4, n5) {
    return n5 = null != n5 ? n5.concat([e4]) : null, zn(4, 36, Un.bind(null, t4, e4), n5);
  }, "useImperativeHandle"), useLayoutEffect: /* @__PURE__ */ __name(function(e4, t4) {
    return zn(4, 36, e4, t4);
  }, "useLayoutEffect"), useMemo: /* @__PURE__ */ __name(function(e4, t4) {
    var n5 = Tn();
    return t4 = void 0 === t4 ? null : t4, e4 = e4(), n5.memoizedState = [e4, t4], e4;
  }, "useMemo"), useReducer: /* @__PURE__ */ __name(function(e4, t4, n5) {
    var r6 = Tn();
    return t4 = void 0 !== n5 ? n5(t4) : t4, r6.memoizedState = r6.baseState = t4, e4 = (e4 = r6.queue = { last: null, dispatch: null, lastRenderedReducer: e4, lastRenderedState: t4 }).dispatch = Fn.bind(null, rn, e4), [r6.memoizedState, e4];
  }, "useReducer"), useRef: /* @__PURE__ */ __name(function(e4) {
    return e4 = { current: e4 }, Tn().memoizedState = e4;
  }, "useRef"), useState: Sn, useDebugValue: Rn, useResponder: Zt, useDeferredValue: /* @__PURE__ */ __name(function(e4, t4) {
    var n5 = Sn(e4), r6 = n5[0], l5 = n5[1];
    return _n(function() {
      o4.unstable_next(function() {
        var n6 = tn.suspense;
        tn.suspense = void 0 === t4 ? null : t4;
        try {
          l5(e4);
        } finally {
          tn.suspense = n6;
        }
      });
    }, [e4, t4]), r6;
  }, "useDeferredValue"), useTransition: /* @__PURE__ */ __name(function(e4) {
    var t4 = Sn(false), n5 = t4[0], r6 = t4[1];
    return [In(function(t5) {
      r6(true), o4.unstable_next(function() {
        var n6 = tn.suspense;
        tn.suspense = void 0 === e4 ? null : e4;
        try {
          r6(false), t5();
        } finally {
          tn.suspense = n6;
        }
      });
    }, [e4, n5]), n5];
  }, "useTransition") }, Wn = { readContext: ht, useCallback: Mn, useContext: ht, useEffect: Nn, useImperativeHandle: /* @__PURE__ */ __name(function(e4, t4, n5) {
    return n5 = null != n5 ? n5.concat([e4]) : null, Pn(4, 36, Un.bind(null, t4, e4), n5);
  }, "useImperativeHandle"), useLayoutEffect: /* @__PURE__ */ __name(function(e4, t4) {
    return Pn(4, 36, e4, t4);
  }, "useLayoutEffect"), useMemo: /* @__PURE__ */ __name(function(e4, t4) {
    var n5 = xn();
    t4 = void 0 === t4 ? null : t4;
    var r6 = n5.memoizedState;
    return null !== r6 && null !== t4 && bn(t4, r6[1]) ? r6[0] : (e4 = e4(), n5.memoizedState = [e4, t4], e4);
  }, "useMemo"), useReducer: kn, useRef: /* @__PURE__ */ __name(function() {
    return xn().memoizedState;
  }, "useRef"), useState: Cn, useDebugValue: Rn, useResponder: Zt, useDeferredValue: /* @__PURE__ */ __name(function(e4, t4) {
    var n5 = Cn(), r6 = n5[0], l5 = n5[1];
    return Nn(function() {
      o4.unstable_next(function() {
        var n6 = tn.suspense;
        tn.suspense = void 0 === t4 ? null : t4;
        try {
          l5(e4);
        } finally {
          tn.suspense = n6;
        }
      });
    }, [e4, t4]), r6;
  }, "useDeferredValue"), useTransition: /* @__PURE__ */ __name(function(e4) {
    var t4 = Cn(), n5 = t4[0], r6 = t4[1];
    return [Mn(function(t5) {
      r6(true), o4.unstable_next(function() {
        var n6 = tn.suspense;
        tn.suspense = void 0 === e4 ? null : e4;
        try {
          r6(false), t5();
        } finally {
          tn.suspense = n6;
        }
      });
    }, [e4, n5]), n5];
  }, "useTransition") }, jn = c2.ReactCurrentOwner, On = false;
  function Bn(e4, t4, n5, r6) {
    t4.child = null === e4 ? Bt(t4, null, n5, r6) : Ot(t4, e4.child, n5, r6);
  }
  __name(Bn, "Bn");
  function Hn(e4, t4, n5, r6, l5) {
    n5 = n5.render;
    var i2 = t4.ref;
    return mt(t4, l5), r6 = yn(e4, t4, n5, r6, i2, l5), null === e4 || On ? (t4.effectTag |= 1, Bn(e4, t4, r6, l5), t4.child) : (t4.updateQueue = e4.updateQueue, t4.effectTag &= -517, e4.expirationTime <= l5 && (e4.expirationTime = 0), ir(e4, t4, l5));
  }
  __name(Hn, "Hn");
  function An(e4, t4, n5, r6, l5, i2) {
    if (null === e4) {
      var a5 = n5.type;
      return "function" != typeof a5 || Hl(a5) || void 0 !== a5.defaultProps || null !== n5.compare || void 0 !== n5.defaultProps ? ((e4 = Ll(n5.type, null, r6, null, t4.mode, i2)).ref = t4.ref, e4.return = t4, t4.child = e4) : (t4.tag = 15, t4.type = a5, Ln(e4, t4, a5, r6, l5, i2));
    }
    return a5 = e4.child, l5 < i2 && (l5 = a5.memoizedProps, (n5 = null !== (n5 = n5.compare) ? n5 : lt)(l5, r6) && e4.ref === t4.ref) ? ir(e4, t4, i2) : (t4.effectTag |= 1, (e4 = Al(a5, r6)).ref = t4.ref, e4.return = t4, t4.child = e4);
  }
  __name(An, "An");
  function Ln(e4, t4, n5, r6, l5, i2) {
    return null !== e4 && lt(e4.memoizedProps, r6) && e4.ref === t4.ref && (On = false, l5 < i2) ? ir(e4, t4, i2) : qn(e4, t4, n5, r6, i2);
  }
  __name(Ln, "Ln");
  function $n(e4, t4) {
    var n5 = t4.ref;
    (null === e4 && null !== n5 || null !== e4 && e4.ref !== n5) && (t4.effectTag |= 128);
  }
  __name($n, "$n");
  function qn(e4, t4, n5, r6, l5) {
    var i2 = xe(n5) ? ve : be.current;
    return i2 = Te(t4, i2), mt(t4, l5), n5 = yn(e4, t4, n5, r6, i2, l5), null === e4 || On ? (t4.effectTag |= 1, Bn(e4, t4, n5, l5), t4.child) : (t4.updateQueue = e4.updateQueue, t4.effectTag &= -517, e4.expirationTime <= l5 && (e4.expirationTime = 0), ir(e4, t4, l5));
  }
  __name(qn, "qn");
  function Vn(e4, t4, n5, r6, l5) {
    if (xe(n5)) {
      var i2 = true;
      we(t4);
    } else i2 = false;
    if (mt(t4, l5), null === t4.stateNode) null !== e4 && (e4.alternate = null, t4.alternate = null, t4.effectTag |= 2), It(t4, n5, r6), Ft(t4, n5, r6, l5), r6 = true;
    else if (null === e4) {
      var a5 = t4.stateNode, u4 = t4.memoizedProps;
      a5.props = u4;
      var o5 = a5.context, f5 = n5.contextType;
      f5 = "object" == typeof f5 && null !== f5 ? ht(f5) : Te(t4, f5 = xe(n5) ? ve : be.current);
      var c3 = n5.getDerivedStateFromProps, s5 = "function" == typeof c3 || "function" == typeof a5.getSnapshotBeforeUpdate;
      s5 || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (u4 !== r6 || o5 !== f5) && Mt(t4, a5, r6, f5), gt = false;
      var d4 = t4.memoizedState;
      o5 = a5.state = d4;
      var p4 = t4.updateQueue;
      null !== p4 && (Ct(t4, p4, r6, a5, l5), o5 = t4.memoizedState), u4 !== r6 || d4 !== o5 || ye.current || gt ? ("function" == typeof c3 && (Nt(t4, n5, c3, r6), o5 = t4.memoizedState), (u4 = gt || Rt(t4, n5, u4, r6, d4, o5, f5)) ? (s5 || "function" != typeof a5.UNSAFE_componentWillMount && "function" != typeof a5.componentWillMount || ("function" == typeof a5.componentWillMount && a5.componentWillMount(), "function" == typeof a5.UNSAFE_componentWillMount && a5.UNSAFE_componentWillMount()), "function" == typeof a5.componentDidMount && (t4.effectTag |= 4)) : ("function" == typeof a5.componentDidMount && (t4.effectTag |= 4), t4.memoizedProps = r6, t4.memoizedState = o5), a5.props = r6, a5.state = o5, a5.context = f5, r6 = u4) : ("function" == typeof a5.componentDidMount && (t4.effectTag |= 4), r6 = false);
    } else a5 = t4.stateNode, u4 = t4.memoizedProps, a5.props = t4.type === t4.elementType ? u4 : it(t4.type, u4), o5 = a5.context, f5 = "object" == typeof (f5 = n5.contextType) && null !== f5 ? ht(f5) : Te(t4, f5 = xe(n5) ? ve : be.current), (s5 = "function" == typeof (c3 = n5.getDerivedStateFromProps) || "function" == typeof a5.getSnapshotBeforeUpdate) || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (u4 !== r6 || o5 !== f5) && Mt(t4, a5, r6, f5), gt = false, o5 = t4.memoizedState, d4 = a5.state = o5, null !== (p4 = t4.updateQueue) && (Ct(t4, p4, r6, a5, l5), d4 = t4.memoizedState), u4 !== r6 || o5 !== d4 || ye.current || gt ? ("function" == typeof c3 && (Nt(t4, n5, c3, r6), d4 = t4.memoizedState), (c3 = gt || Rt(t4, n5, u4, r6, o5, d4, f5)) ? (s5 || "function" != typeof a5.UNSAFE_componentWillUpdate && "function" != typeof a5.componentWillUpdate || ("function" == typeof a5.componentWillUpdate && a5.componentWillUpdate(r6, d4, f5), "function" == typeof a5.UNSAFE_componentWillUpdate && a5.UNSAFE_componentWillUpdate(r6, d4, f5)), "function" == typeof a5.componentDidUpdate && (t4.effectTag |= 4), "function" == typeof a5.getSnapshotBeforeUpdate && (t4.effectTag |= 256)) : ("function" != typeof a5.componentDidUpdate || u4 === e4.memoizedProps && o5 === e4.memoizedState || (t4.effectTag |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || u4 === e4.memoizedProps && o5 === e4.memoizedState || (t4.effectTag |= 256), t4.memoizedProps = r6, t4.memoizedState = d4), a5.props = r6, a5.state = d4, a5.context = f5, r6 = c3) : ("function" != typeof a5.componentDidUpdate || u4 === e4.memoizedProps && o5 === e4.memoizedState || (t4.effectTag |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || u4 === e4.memoizedProps && o5 === e4.memoizedState || (t4.effectTag |= 256), r6 = false);
    return Kn(e4, t4, n5, r6, i2, l5);
  }
  __name(Vn, "Vn");
  function Kn(e4, t4, n5, r6, l5, i2) {
    $n(e4, t4);
    var a5 = 0 != (64 & t4.effectTag);
    if (!r6 && !a5) return l5 && ze(t4, n5, false), ir(e4, t4, i2);
    r6 = t4.stateNode, jn.current = t4;
    var u4 = a5 && "function" != typeof n5.getDerivedStateFromError ? null : r6.render();
    return t4.effectTag |= 1, null !== e4 && a5 ? (t4.child = Ot(t4, e4.child, null, i2), t4.child = Ot(t4, null, u4, i2)) : Bn(e4, t4, u4, i2), t4.memoizedState = r6.state, l5 && ze(t4, n5, true), t4.child;
  }
  __name(Kn, "Kn");
  function Gn(e4) {
    var t4 = e4.stateNode;
    t4.pendingContext ? Se(0, t4.pendingContext, t4.pendingContext !== t4.context) : t4.context && Se(0, t4.context, false), Vt(e4, t4.containerInfo);
  }
  __name(Gn, "Gn");
  var Yn, Jn, Xn, Zn, er = { dehydrated: null, retryTime: 0 };
  function tr(e4, t4, n5) {
    var r6, l5 = t4.mode, i2 = t4.pendingProps, a5 = Jt.current, u4 = false;
    if ((r6 = 0 != (64 & t4.effectTag)) || (r6 = 0 != (2 & a5) && (null === e4 || null !== e4.memoizedState)), r6 ? (u4 = true, t4.effectTag &= -65) : null !== e4 && null === e4.memoizedState || void 0 === i2.fallback || true === i2.unstable_avoidThisFallback || (a5 |= 1), he(Jt, 1 & a5), null === e4) {
      if (i2.fallback, u4) {
        if (u4 = i2.fallback, (i2 = $l(null, l5, 0, null)).return = t4, 0 == (2 & t4.mode)) for (e4 = null !== t4.memoizedState ? t4.child.child : t4.child, i2.child = e4; null !== e4; ) e4.return = i2, e4 = e4.sibling;
        return (n5 = $l(u4, l5, n5, null)).return = t4, i2.sibling = n5, t4.memoizedState = er, t4.child = i2, n5;
      }
      return l5 = i2.children, t4.memoizedState = null, t4.child = Bt(t4, null, l5, n5);
    }
    if (null !== e4.memoizedState) {
      if (l5 = (e4 = e4.child).sibling, u4) {
        if (i2 = i2.fallback, (n5 = Al(e4, e4.pendingProps)).return = t4, 0 == (2 & t4.mode) && (u4 = null !== t4.memoizedState ? t4.child.child : t4.child) !== e4.child) for (n5.child = u4; null !== u4; ) u4.return = n5, u4 = u4.sibling;
        return (l5 = Al(l5, i2, l5.expirationTime)).return = t4, n5.sibling = l5, n5.childExpirationTime = 0, t4.memoizedState = er, t4.child = n5, l5;
      }
      return n5 = Ot(t4, e4.child, i2.children, n5), t4.memoizedState = null, t4.child = n5;
    }
    if (e4 = e4.child, u4) {
      if (u4 = i2.fallback, (i2 = $l(null, l5, 0, null)).return = t4, i2.child = e4, null !== e4 && (e4.return = i2), 0 == (2 & t4.mode)) for (e4 = null !== t4.memoizedState ? t4.child.child : t4.child, i2.child = e4; null !== e4; ) e4.return = i2, e4 = e4.sibling;
      return (n5 = $l(u4, l5, n5, null)).return = t4, i2.sibling = n5, n5.effectTag |= 2, i2.childExpirationTime = 0, t4.memoizedState = er, t4.child = i2, n5;
    }
    return t4.memoizedState = null, t4.child = Ot(t4, e4, i2.children, n5);
  }
  __name(tr, "tr");
  function nr(e4, t4) {
    e4.expirationTime < t4 && (e4.expirationTime = t4);
    var n5 = e4.alternate;
    null !== n5 && n5.expirationTime < t4 && (n5.expirationTime = t4), pt(e4.return, t4);
  }
  __name(nr, "nr");
  function rr(e4, t4, n5, r6, l5, i2) {
    var a5 = e4.memoizedState;
    null === a5 ? e4.memoizedState = { isBackwards: t4, rendering: null, last: r6, tail: n5, tailExpiration: 0, tailMode: l5, lastEffect: i2 } : (a5.isBackwards = t4, a5.rendering = null, a5.last = r6, a5.tail = n5, a5.tailExpiration = 0, a5.tailMode = l5, a5.lastEffect = i2);
  }
  __name(rr, "rr");
  function lr(e4, t4, n5) {
    var r6 = t4.pendingProps, l5 = r6.revealOrder, i2 = r6.tail;
    if (Bn(e4, t4, r6.children, n5), 0 != (2 & (r6 = Jt.current))) r6 = 1 & r6 | 2, t4.effectTag |= 64;
    else {
      if (null !== e4 && 0 != (64 & e4.effectTag)) e: for (e4 = t4.child; null !== e4; ) {
        if (13 === e4.tag) null !== e4.memoizedState && nr(e4, n5);
        else if (19 === e4.tag) nr(e4, n5);
        else if (null !== e4.child) {
          e4.child.return = e4, e4 = e4.child;
          continue;
        }
        if (e4 === t4) break e;
        for (; null === e4.sibling; ) {
          if (null === e4.return || e4.return === t4) break e;
          e4 = e4.return;
        }
        e4.sibling.return = e4.return, e4 = e4.sibling;
      }
      r6 &= 1;
    }
    if (he(Jt, r6), 0 == (2 & t4.mode)) t4.memoizedState = null;
    else switch (l5) {
      case "forwards":
        for (n5 = t4.child, l5 = null; null !== n5; ) null !== (e4 = n5.alternate) && null === Xt(e4) && (l5 = n5), n5 = n5.sibling;
        null === (n5 = l5) ? (l5 = t4.child, t4.child = null) : (l5 = n5.sibling, n5.sibling = null), rr(t4, false, l5, n5, i2, t4.lastEffect);
        break;
      case "backwards":
        for (n5 = null, l5 = t4.child, t4.child = null; null !== l5; ) {
          if (null !== (e4 = l5.alternate) && null === Xt(e4)) {
            t4.child = l5;
            break;
          }
          e4 = l5.sibling, l5.sibling = n5, n5 = l5, l5 = e4;
        }
        rr(t4, true, n5, null, i2, t4.lastEffect);
        break;
      case "together":
        rr(t4, false, null, null, void 0, t4.lastEffect);
        break;
      default:
        t4.memoizedState = null;
    }
    return t4.child;
  }
  __name(lr, "lr");
  function ir(e4, t4, n5) {
    null !== e4 && (t4.dependencies = e4.dependencies);
    var r6 = t4.expirationTime;
    if (0 !== r6 && kl(r6), t4.childExpirationTime < n5) return null;
    if (null !== e4 && t4.child !== e4.child) throw Error(f4(153));
    if (null !== t4.child) {
      for (n5 = Al(e4 = t4.child, e4.pendingProps, e4.expirationTime), t4.child = n5, n5.return = t4; null !== e4.sibling; ) e4 = e4.sibling, (n5 = n5.sibling = Al(e4, e4.pendingProps, e4.expirationTime)).return = t4;
      n5.sibling = null;
    }
    return t4.child;
  }
  __name(ir, "ir");
  function ar(e4) {
    e4.effectTag |= 4;
  }
  __name(ar, "ar");
  function ur(e4, t4) {
    switch (e4.tailMode) {
      case "hidden":
        t4 = e4.tail;
        for (var n5 = null; null !== t4; ) null !== t4.alternate && (n5 = t4), t4 = t4.sibling;
        null === n5 ? e4.tail = null : n5.sibling = null;
        break;
      case "collapsed":
        n5 = e4.tail;
        for (var r6 = null; null !== n5; ) null !== n5.alternate && (r6 = n5), n5 = n5.sibling;
        null === r6 ? t4 || null === e4.tail ? e4.tail = null : e4.tail.sibling = null : r6.sibling = null;
    }
  }
  __name(ur, "ur");
  function or(e4) {
    switch (e4.tag) {
      case 1:
        xe(e4.type) && Ee();
        var t4 = e4.effectTag;
        return 4096 & t4 ? (e4.effectTag = -4097 & t4 | 64, e4) : null;
      case 3:
        if (Kt(), ke(), 0 != (64 & (t4 = e4.effectTag))) throw Error(f4(285));
        return e4.effectTag = -4097 & t4 | 64, e4;
      case 5:
        return Yt(e4), null;
      case 13:
        return me(Jt), 4096 & (t4 = e4.effectTag) ? (e4.effectTag = -4097 & t4 | 64, e4) : null;
      case 19:
        return me(Jt), null;
      case 4:
        return Kt(), null;
      case 10:
        return dt(e4), null;
      default:
        return null;
    }
  }
  __name(or, "or");
  function fr(e4, t4) {
    return { value: e4, source: t4, stack: se(t4) };
  }
  __name(fr, "fr");
  Yn = /* @__PURE__ */ __name(function(e4, t4) {
    for (var n5 = t4.child; null !== n5; ) {
      if (5 === n5.tag || 6 === n5.tag) W(e4, n5.stateNode);
      else if (4 !== n5.tag && null !== n5.child) {
        n5.child.return = n5, n5 = n5.child;
        continue;
      }
      if (n5 === t4) break;
      for (; null === n5.sibling; ) {
        if (null === n5.return || n5.return === t4) return;
        n5 = n5.return;
      }
      n5.sibling.return = n5.return, n5 = n5.sibling;
    }
  }, "Yn"), Jn = /* @__PURE__ */ __name(function() {
  }, "Jn"), Xn = /* @__PURE__ */ __name(function(e4, t4, n5, r6, l5) {
    if ((e4 = e4.memoizedProps) !== r6) {
      var i2 = t4.stateNode, a5 = qt(At.current);
      n5 = O(i2, n5, e4, r6, l5, a5), (t4.updateQueue = n5) && ar(t4);
    }
  }, "Xn"), Zn = /* @__PURE__ */ __name(function(e4, t4, n5, r6) {
    n5 !== r6 && ar(t4);
  }, "Zn");
  var cr = "function" == typeof WeakSet ? WeakSet : Set;
  function sr(e4, t4) {
    var n5 = t4.source, r6 = t4.stack;
    null === r6 && null !== n5 && (r6 = se(n5)), null !== n5 && z(n5.type), t4 = t4.value, null !== e4 && 1 === e4.tag && z(e4.type);
    try {
      console.error(t4);
    } catch (e5) {
      setTimeout(function() {
        throw e5;
      });
    }
  }
  __name(sr, "sr");
  function dr(e4) {
    var t4 = e4.ref;
    if (null !== t4) if ("function" == typeof t4) try {
      t4(null);
    } catch (t5) {
      Fl(e4, t5);
    }
    else t4.current = null;
  }
  __name(dr, "dr");
  function pr(e4, t4) {
    switch (t4.tag) {
      case 0:
      case 11:
      case 15:
        mr(2, 0, t4);
        break;
      case 1:
        if (256 & t4.effectTag && null !== e4) {
          var n5 = e4.memoizedProps, r6 = e4.memoizedState;
          t4 = (e4 = t4.stateNode).getSnapshotBeforeUpdate(t4.elementType === t4.type ? n5 : it(t4.type, n5), r6), e4.__reactInternalSnapshotBeforeUpdate = t4;
        }
        break;
      case 3:
      case 5:
      case 6:
      case 4:
      case 17:
        break;
      default:
        throw Error(f4(163));
    }
  }
  __name(pr, "pr");
  function mr(e4, t4, n5) {
    if (null !== (n5 = null !== (n5 = n5.updateQueue) ? n5.lastEffect : null)) {
      var r6 = n5 = n5.next;
      do {
        if (0 != (r6.tag & e4)) {
          var l5 = r6.destroy;
          r6.destroy = void 0, void 0 !== l5 && l5();
        }
        0 != (r6.tag & t4) && (l5 = r6.create, r6.destroy = l5()), r6 = r6.next;
      } while (r6 !== n5);
    }
  }
  __name(mr, "mr");
  function hr(e4, t4, n5) {
    switch ("function" == typeof jl && jl(t4), t4.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (null !== (e4 = t4.updateQueue) && null !== (e4 = e4.lastEffect)) {
          var r6 = e4.next;
          Ge(97 < n5 ? 97 : n5, function() {
            var e5 = r6;
            do {
              var n6 = e5.destroy;
              if (void 0 !== n6) {
                var l5 = t4;
                try {
                  n6();
                } catch (e6) {
                  Fl(l5, e6);
                }
              }
              e5 = e5.next;
            } while (e5 !== r6);
          });
        }
        break;
      case 1:
        dr(t4), "function" == typeof (n5 = t4.stateNode).componentWillUnmount && function(e5, t5) {
          try {
            t5.props = e5.memoizedProps, t5.state = e5.memoizedState, t5.componentWillUnmount();
          } catch (t6) {
            Fl(e5, t6);
          }
        }(t4, n5);
        break;
      case 5:
        dr(t4);
        break;
      case 4:
        Tr(e4, t4, n5);
    }
  }
  __name(hr, "hr");
  function gr(e4, t4, n5) {
    for (var r6 = t4; ; ) if (hr(e4, r6, n5), null === r6.child || 4 === r6.tag) {
      if (r6 === t4) break;
      for (; null === r6.sibling; ) {
        if (null === r6.return || r6.return === t4) return;
        r6 = r6.return;
      }
      r6.sibling.return = r6.return, r6 = r6.sibling;
    } else r6.child.return = r6, r6 = r6.child;
  }
  __name(gr, "gr");
  function br(e4) {
    var t4 = e4.alternate;
    e4.return = null, e4.child = null, e4.memoizedState = null, e4.updateQueue = null, e4.dependencies = null, e4.alternate = null, e4.firstEffect = null, e4.lastEffect = null, e4.pendingProps = null, e4.memoizedProps = null, null !== t4 && br(t4);
  }
  __name(br, "br");
  function yr(e4) {
    return 5 === e4.tag || 3 === e4.tag || 4 === e4.tag;
  }
  __name(yr, "yr");
  function vr(e4) {
    e: {
      for (var t4 = e4.return; null !== t4; ) {
        if (yr(t4)) {
          var n5 = t4;
          break e;
        }
        t4 = t4.return;
      }
      throw Error(f4(160));
    }
    switch (t4 = n5.stateNode, n5.tag) {
      case 5:
        var r6 = false;
        break;
      case 3:
      case 4:
        t4 = t4.containerInfo, r6 = true;
        break;
      default:
        throw Error(f4(161));
    }
    16 & n5.effectTag && (re(t4), n5.effectTag &= -17);
    e: t: for (n5 = e4; ; ) {
      for (; null === n5.sibling; ) {
        if (null === n5.return || yr(n5.return)) {
          n5 = null;
          break e;
        }
        n5 = n5.return;
      }
      for (n5.sibling.return = n5.return, n5 = n5.sibling; 5 !== n5.tag && 6 !== n5.tag && 18 !== n5.tag; ) {
        if (2 & n5.effectTag) continue t;
        if (null === n5.child || 4 === n5.tag) continue t;
        n5.child.return = n5, n5 = n5.child;
      }
      if (!(2 & n5.effectTag)) {
        n5 = n5.stateNode;
        break e;
      }
    }
    for (var l5 = e4; ; ) {
      var i2 = 5 === l5.tag || 6 === l5.tag;
      if (i2) i2 = i2 ? l5.stateNode : l5.stateNode.instance, n5 ? r6 ? ee(t4, i2, n5) : Z(t4, i2, n5) : r6 ? G2(t4, i2) : K(t4, i2);
      else if (4 !== l5.tag && null !== l5.child) {
        l5.child.return = l5, l5 = l5.child;
        continue;
      }
      if (l5 === e4) break;
      for (; null === l5.sibling; ) {
        if (null === l5.return || l5.return === e4) return;
        l5 = l5.return;
      }
      l5.sibling.return = l5.return, l5 = l5.sibling;
    }
  }
  __name(vr, "vr");
  function Tr(e4, t4, n5) {
    for (var r6, l5, i2 = t4, a5 = false; ; ) {
      if (!a5) {
        a5 = i2.return;
        e: for (; ; ) {
          if (null === a5) throw Error(f4(160));
          switch (r6 = a5.stateNode, a5.tag) {
            case 5:
              l5 = false;
              break e;
            case 3:
            case 4:
              r6 = r6.containerInfo, l5 = true;
              break e;
          }
          a5 = a5.return;
        }
        a5 = true;
      }
      if (5 === i2.tag || 6 === i2.tag) gr(e4, i2, n5), l5 ? ne(r6, i2.stateNode) : te(r6, i2.stateNode);
      else if (4 === i2.tag) {
        if (null !== i2.child) {
          r6 = i2.stateNode.containerInfo, l5 = true, i2.child.return = i2, i2 = i2.child;
          continue;
        }
      } else if (hr(e4, i2, n5), null !== i2.child) {
        i2.child.return = i2, i2 = i2.child;
        continue;
      }
      if (i2 === t4) break;
      for (; null === i2.sibling; ) {
        if (null === i2.return || i2.return === t4) return;
        4 === (i2 = i2.return).tag && (a5 = false);
      }
      i2.sibling.return = i2.return, i2 = i2.sibling;
    }
  }
  __name(Tr, "Tr");
  function xr(e4, t4) {
    switch (t4.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        mr(4, 8, t4);
        break;
      case 1:
      case 3:
      case 12:
      case 17:
      case 20:
      case 21:
        break;
      case 5:
        var n5 = t4.stateNode;
        if (null != n5) {
          var r6 = t4.memoizedProps;
          e4 = null !== e4 ? e4.memoizedProps : r6;
          var l5 = t4.type, i2 = t4.updateQueue;
          t4.updateQueue = null, null !== i2 && X(n5, i2, l5, e4, r6, t4);
        }
        break;
      case 6:
        if (null === t4.stateNode) throw Error(f4(162));
        n5 = t4.memoizedProps, Y(t4.stateNode, null !== e4 ? e4.memoizedProps : n5, n5);
        break;
      case 13:
        !function(e5) {
          var t5 = e5;
          if (null === e5.memoizedState) var n6 = false;
          else n6 = true, t5 = e5.child, Jr = qe();
          if (null !== t5) {
            e: if (e5 = t5, q) for (t5 = e5; ; ) {
              if (5 === t5.tag) {
                var r7 = t5.stateNode;
                n6 ? le(r7) : ae(t5.stateNode, t5.memoizedProps);
              } else if (6 === t5.tag) r7 = t5.stateNode, n6 ? ie(r7) : ue(r7, t5.memoizedProps);
              else {
                if (13 === t5.tag && null !== t5.memoizedState && null === t5.memoizedState.dehydrated) {
                  (r7 = t5.child.sibling).return = t5, t5 = r7;
                  continue;
                }
                if (null !== t5.child) {
                  t5.child.return = t5, t5 = t5.child;
                  continue;
                }
              }
              if (t5 === e5) break e;
              for (; null === t5.sibling; ) {
                if (null === t5.return || t5.return === e5) break e;
                t5 = t5.return;
              }
              t5.sibling.return = t5.return, t5 = t5.sibling;
            }
          }
        }(t4), Er(t4);
        break;
      case 19:
        Er(t4);
        break;
      default:
        throw Error(f4(163));
    }
  }
  __name(xr, "xr");
  function Er(e4) {
    var t4 = e4.updateQueue;
    if (null !== t4) {
      e4.updateQueue = null;
      var n5 = e4.stateNode;
      null === n5 && (n5 = e4.stateNode = new cr()), t4.forEach(function(t5) {
        var r6 = Dl.bind(null, e4, t5);
        n5.has(t5) || (n5.add(t5), t5.then(r6, r6));
      });
    }
  }
  __name(Er, "Er");
  var kr = "function" == typeof WeakMap ? WeakMap : Map;
  function Sr(e4, t4, n5) {
    (n5 = vt(n5, null)).tag = 3, n5.payload = { element: null };
    var r6 = t4.value;
    return n5.callback = function() {
      el || (el = true, tl = r6), sr(e4, t4);
    }, n5;
  }
  __name(Sr, "Sr");
  function Cr(e4, t4, n5) {
    (n5 = vt(n5, null)).tag = 3;
    var r6 = e4.type.getDerivedStateFromError;
    if ("function" == typeof r6) {
      var l5 = t4.value;
      n5.payload = function() {
        return sr(e4, t4), r6(l5);
      };
    }
    var i2 = e4.stateNode;
    return null !== i2 && "function" == typeof i2.componentDidCatch && (n5.callback = function() {
      "function" != typeof r6 && (null === nl ? nl = /* @__PURE__ */ new Set([this]) : nl.add(this), sr(e4, t4));
      var n6 = t4.stack;
      this.componentDidCatch(t4.value, { componentStack: null !== n6 ? n6 : "" });
    }), n5;
  }
  __name(Cr, "Cr");
  var wr, zr = Math.ceil, Pr = c2.ReactCurrentDispatcher, _r = c2.ReactCurrentOwner, Nr = 0, Ur = 8, Rr = 16, Ir = 32, Mr = 0, Fr = 1, Qr = 2, Dr = 3, Wr = 4, jr = 5, Or = Nr, Br = null, Hr = null, Ar = 0, Lr = Mr, $r = null, qr = 1073741823, Vr = 1073741823, Kr = null, Gr = 0, Yr = false, Jr = 0, Xr = 500, Zr = null, el = false, tl = null, nl = null, rl = false, ll = null, il = 90, al = null, ul = 0, ol = null, fl = 0;
  function cl() {
    return (Or & (Rr | Ir)) !== Nr ? 1073741821 - (qe() / 10 | 0) : 0 !== fl ? fl : fl = 1073741821 - (qe() / 10 | 0);
  }
  __name(cl, "cl");
  function sl(e4, t4, n5) {
    if (0 == (2 & (t4 = t4.mode))) return 1073741823;
    var r6 = Ve();
    if (0 == (4 & t4)) return 99 === r6 ? 1073741823 : 1073741822;
    if ((Or & Rr) !== Nr) return Ar;
    if (null !== n5) e4 = tt(e4, 0 | n5.timeoutMs || 5e3, 250);
    else switch (r6) {
      case 99:
        e4 = 1073741823;
        break;
      case 98:
        e4 = tt(e4, 150, 100);
        break;
      case 97:
      case 96:
        e4 = tt(e4, 5e3, 250);
        break;
      case 95:
        e4 = 2;
        break;
      default:
        throw Error(f4(326));
    }
    return null !== Br && e4 === Ar && --e4, e4;
  }
  __name(sl, "sl");
  function dl(e4, t4) {
    if (50 < ul) throw ul = 0, ol = null, Error(f4(185));
    if (null !== (e4 = pl(e4, t4))) {
      var n5 = Ve();
      1073741823 === t4 ? (Or & Ur) !== Nr && (Or & (Rr | Ir)) === Nr ? bl(e4) : (hl(e4), Or === Nr && Xe()) : hl(e4), (4 & Or) === Nr || 98 !== n5 && 99 !== n5 || (null === al ? al = /* @__PURE__ */ new Map([[e4, t4]]) : (void 0 === (n5 = al.get(e4)) || n5 > t4) && al.set(e4, t4));
    }
  }
  __name(dl, "dl");
  function pl(e4, t4) {
    e4.expirationTime < t4 && (e4.expirationTime = t4);
    var n5 = e4.alternate;
    null !== n5 && n5.expirationTime < t4 && (n5.expirationTime = t4);
    var r6 = e4.return, l5 = null;
    if (null === r6 && 3 === e4.tag) l5 = e4.stateNode;
    else for (; null !== r6; ) {
      if (n5 = r6.alternate, r6.childExpirationTime < t4 && (r6.childExpirationTime = t4), null !== n5 && n5.childExpirationTime < t4 && (n5.childExpirationTime = t4), null === r6.return && 3 === r6.tag) {
        l5 = r6.stateNode;
        break;
      }
      r6 = r6.return;
    }
    return null !== l5 && (Br === l5 && (kl(t4), Lr === Wr && Yl(l5, Ar)), Jl(l5, t4)), l5;
  }
  __name(pl, "pl");
  function ml(e4) {
    var t4 = e4.lastExpiredTime;
    return 0 !== t4 ? t4 : Gl(e4, t4 = e4.firstPendingTime) ? (t4 = e4.lastPingedTime) > (e4 = e4.nextKnownPendingLevel) ? t4 : e4 : t4;
  }
  __name(ml, "ml");
  function hl(e4) {
    if (0 !== e4.lastExpiredTime) e4.callbackExpirationTime = 1073741823, e4.callbackPriority = 99, e4.callbackNode = Je(bl.bind(null, e4));
    else {
      var t4 = ml(e4), n5 = e4.callbackNode;
      if (0 === t4) null !== n5 && (e4.callbackNode = null, e4.callbackExpirationTime = 0, e4.callbackPriority = 90);
      else {
        var r6 = cl();
        if (r6 = 1073741823 === t4 ? 99 : 1 === t4 || 2 === t4 ? 95 : 0 >= (r6 = 10 * (1073741821 - t4) - 10 * (1073741821 - r6)) ? 99 : 250 >= r6 ? 98 : 5250 >= r6 ? 97 : 95, null !== n5) {
          var l5 = e4.callbackPriority;
          if (e4.callbackExpirationTime === t4 && l5 >= r6) return;
          n5 !== Oe && Ne(n5);
        }
        e4.callbackExpirationTime = t4, e4.callbackPriority = r6, t4 = 1073741823 === t4 ? Je(bl.bind(null, e4)) : Ye(r6, gl.bind(null, e4), { timeout: 10 * (1073741821 - t4) - qe() }), e4.callbackNode = t4;
      }
    }
  }
  __name(hl, "hl");
  function gl(e4, t4) {
    if (fl = 0, t4) return Xl(e4, t4 = cl()), hl(e4), null;
    var n5 = ml(e4);
    if (0 !== n5) {
      if (t4 = e4.callbackNode, (Or & (Rr | Ir)) !== Nr) throw Error(f4(327));
      if (Rl(), e4 === Br && n5 === Ar || vl(e4, n5), null !== Hr) {
        var r6 = Or;
        Or |= Rr;
        for (var l5 = xl(); ; ) try {
          Cl();
          break;
        } catch (t5) {
          Tl(e4, t5);
        }
        if (ct(), Or = r6, Pr.current = l5, Lr === Fr) throw t4 = $r, vl(e4, n5), Yl(e4, n5), hl(e4), t4;
        if (null === Hr) switch (l5 = e4.finishedWork = e4.current.alternate, e4.finishedExpirationTime = n5, r6 = Lr, Br = null, r6) {
          case Mr:
          case Fr:
            throw Error(f4(345));
          case Qr:
            Xl(e4, 2 < n5 ? 2 : n5);
            break;
          case Dr:
            if (Yl(e4, n5), n5 === (r6 = e4.lastSuspendedTime) && (e4.nextKnownPendingLevel = Pl(l5)), 1073741823 === qr && 10 < (l5 = Jr + Xr - qe())) {
              if (Yr) {
                var i2 = e4.lastPingedTime;
                if (0 === i2 || i2 >= n5) {
                  e4.lastPingedTime = n5, vl(e4, n5);
                  break;
                }
              }
              if (0 !== (i2 = ml(e4)) && i2 !== n5) break;
              if (0 !== r6 && r6 !== n5) {
                e4.lastPingedTime = r6;
                break;
              }
              e4.timeoutHandle = A(_l.bind(null, e4), l5);
              break;
            }
            _l(e4);
            break;
          case Wr:
            if (Yl(e4, n5), n5 === (r6 = e4.lastSuspendedTime) && (e4.nextKnownPendingLevel = Pl(l5)), Yr && (0 === (l5 = e4.lastPingedTime) || l5 >= n5)) {
              e4.lastPingedTime = n5, vl(e4, n5);
              break;
            }
            if (0 !== (l5 = ml(e4)) && l5 !== n5) break;
            if (0 !== r6 && r6 !== n5) {
              e4.lastPingedTime = r6;
              break;
            }
            if (1073741823 !== Vr ? r6 = 10 * (1073741821 - Vr) - qe() : 1073741823 === qr ? r6 = 0 : (r6 = 10 * (1073741821 - qr) - 5e3, 0 > (r6 = (l5 = qe()) - r6) && (r6 = 0), (n5 = 10 * (1073741821 - n5) - l5) < (r6 = (120 > r6 ? 120 : 480 > r6 ? 480 : 1080 > r6 ? 1080 : 1920 > r6 ? 1920 : 3e3 > r6 ? 3e3 : 4320 > r6 ? 4320 : 1960 * zr(r6 / 1960)) - r6) && (r6 = n5)), 10 < r6) {
              e4.timeoutHandle = A(_l.bind(null, e4), r6);
              break;
            }
            _l(e4);
            break;
          case jr:
            if (1073741823 !== qr && null !== Kr) {
              i2 = qr;
              var a5 = Kr;
              if (0 >= (r6 = 0 | a5.busyMinDurationMs) ? r6 = 0 : (l5 = 0 | a5.busyDelayMs, r6 = (i2 = qe() - (10 * (1073741821 - i2) - (0 | a5.timeoutMs || 5e3))) <= l5 ? 0 : l5 + r6 - i2), 10 < r6) {
                Yl(e4, n5), e4.timeoutHandle = A(_l.bind(null, e4), r6);
                break;
              }
            }
            _l(e4);
            break;
          default:
            throw Error(f4(329));
        }
        if (hl(e4), e4.callbackNode === t4) return gl.bind(null, e4);
      }
    }
    return null;
  }
  __name(gl, "gl");
  function bl(e4) {
    var t4 = e4.lastExpiredTime;
    if (t4 = 0 !== t4 ? t4 : 1073741823, e4.finishedExpirationTime === t4) _l(e4);
    else {
      if ((Or & (Rr | Ir)) !== Nr) throw Error(f4(327));
      if (Rl(), e4 === Br && t4 === Ar || vl(e4, t4), null !== Hr) {
        var n5 = Or;
        Or |= Rr;
        for (var r6 = xl(); ; ) try {
          Sl();
          break;
        } catch (t5) {
          Tl(e4, t5);
        }
        if (ct(), Or = n5, Pr.current = r6, Lr === Fr) throw n5 = $r, vl(e4, t4), Yl(e4, t4), hl(e4), n5;
        if (null !== Hr) throw Error(f4(261));
        e4.finishedWork = e4.current.alternate, e4.finishedExpirationTime = t4, Br = null, _l(e4), hl(e4);
      }
    }
    return null;
  }
  __name(bl, "bl");
  function yl(e4, t4) {
    if ((Or & (Rr | Ir)) !== Nr) throw Error(f4(187));
    var n5 = Or;
    Or |= 1;
    try {
      return Ge(99, e4.bind(null, t4));
    } finally {
      Or = n5, Xe();
    }
  }
  __name(yl, "yl");
  function vl(e4, t4) {
    e4.finishedWork = null, e4.finishedExpirationTime = 0;
    var n5 = e4.timeoutHandle;
    if (n5 !== $ && (e4.timeoutHandle = $, L(n5)), null !== Hr) for (n5 = Hr.return; null !== n5; ) {
      var r6 = n5;
      switch (r6.tag) {
        case 1:
          var l5 = r6.type.childContextTypes;
          null != l5 && Ee();
          break;
        case 3:
          Kt(), ke();
          break;
        case 5:
          Yt(r6);
          break;
        case 4:
          Kt();
          break;
        case 13:
        case 19:
          me(Jt);
          break;
        case 10:
          dt(r6);
      }
      n5 = n5.return;
    }
    Br = e4, Hr = Al(e4.current, null), Ar = t4, Lr = Mr, $r = null, Vr = qr = 1073741823, Kr = null, Gr = 0, Yr = false;
  }
  __name(vl, "vl");
  function Tl(e4, t4) {
    for (; ; ) {
      try {
        if (ct(), vn(), null === Hr || null === Hr.return) return Lr = Fr, $r = t4, null;
        e: {
          var n5 = e4, r6 = Hr.return, l5 = Hr, i2 = t4;
          if (t4 = Ar, l5.effectTag |= 2048, l5.firstEffect = l5.lastEffect = null, null !== i2 && "object" == typeof i2 && "function" == typeof i2.then) {
            var a5 = i2, u4 = 0 != (1 & Jt.current), o5 = r6;
            do {
              var f5;
              if (f5 = 13 === o5.tag) {
                var c3 = o5.memoizedState;
                if (null !== c3) f5 = null !== c3.dehydrated;
                else {
                  var s5 = o5.memoizedProps;
                  f5 = void 0 !== s5.fallback && (true !== s5.unstable_avoidThisFallback || !u4);
                }
              }
              if (f5) {
                var d4 = o5.updateQueue;
                if (null === d4) {
                  var p4 = /* @__PURE__ */ new Set();
                  p4.add(a5), o5.updateQueue = p4;
                } else d4.add(a5);
                if (0 == (2 & o5.mode)) {
                  if (o5.effectTag |= 64, l5.effectTag &= -2981, 1 === l5.tag) if (null === l5.alternate) l5.tag = 17;
                  else {
                    var m4 = vt(1073741823, null);
                    m4.tag = 2, xt(l5, m4);
                  }
                  l5.expirationTime = 1073741823;
                  break e;
                }
                i2 = void 0, l5 = t4;
                var h2 = n5.pingCache;
                if (null === h2 ? (h2 = n5.pingCache = new kr(), i2 = /* @__PURE__ */ new Set(), h2.set(a5, i2)) : void 0 === (i2 = h2.get(a5)) && (i2 = /* @__PURE__ */ new Set(), h2.set(a5, i2)), !i2.has(l5)) {
                  i2.add(l5);
                  var g2 = Ql.bind(null, n5, a5, l5);
                  a5.then(g2, g2);
                }
                o5.effectTag |= 4096, o5.expirationTime = t4;
                break e;
              }
              o5 = o5.return;
            } while (null !== o5);
            i2 = Error((z(l5.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + se(l5));
          }
          Lr !== jr && (Lr = Qr), i2 = fr(i2, l5), o5 = r6;
          do {
            switch (o5.tag) {
              case 3:
                a5 = i2, o5.effectTag |= 4096, o5.expirationTime = t4, Et(o5, Sr(o5, a5, t4));
                break e;
              case 1:
                a5 = i2;
                var b4 = o5.type, y4 = o5.stateNode;
                if (0 == (64 & o5.effectTag) && ("function" == typeof b4.getDerivedStateFromError || null !== y4 && "function" == typeof y4.componentDidCatch && (null === nl || !nl.has(y4)))) {
                  o5.effectTag |= 4096, o5.expirationTime = t4, Et(o5, Cr(o5, a5, t4));
                  break e;
                }
            }
            o5 = o5.return;
          } while (null !== o5);
        }
        Hr = zl(Hr);
      } catch (e5) {
        t4 = e5;
        continue;
      }
      break;
    }
  }
  __name(Tl, "Tl");
  function xl() {
    var e4 = Pr.current;
    return Pr.current = Qn, null === e4 ? Qn : e4;
  }
  __name(xl, "xl");
  function El(e4, t4) {
    e4 < qr && 2 < e4 && (qr = e4), null !== t4 && e4 < Vr && 2 < e4 && (Vr = e4, Kr = t4);
  }
  __name(El, "El");
  function kl(e4) {
    e4 > Gr && (Gr = e4);
  }
  __name(kl, "kl");
  function Sl() {
    for (; null !== Hr; ) Hr = wl(Hr);
  }
  __name(Sl, "Sl");
  function Cl() {
    for (; null !== Hr && !Ue(); ) Hr = wl(Hr);
  }
  __name(Cl, "Cl");
  function wl(e4) {
    var t4 = wr(e4.alternate, e4, Ar);
    return e4.memoizedProps = e4.pendingProps, null === t4 && (t4 = zl(e4)), _r.current = null, t4;
  }
  __name(wl, "wl");
  function zl(e4) {
    Hr = e4;
    do {
      var t4 = Hr.alternate;
      if (e4 = Hr.return, 0 == (2048 & Hr.effectTag)) {
        e: {
          var n5 = t4, r6 = Ar, l5 = (t4 = Hr).pendingProps;
          switch (t4.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
            case 20:
            case 21:
              break;
            case 1:
            case 17:
              xe(t4.type) && Ee();
              break;
            case 3:
              Kt(), ke(), (l5 = t4.stateNode).pendingContext && (l5.context = l5.pendingContext, l5.pendingContext = null), null === n5 || n5.child, Jn(t4);
              break;
            case 5:
              Yt(t4);
              var i2 = qt($t.current);
              if (r6 = t4.type, null !== n5 && null != t4.stateNode) Xn(n5, t4, r6, l5, i2), n5.ref !== t4.ref && (t4.effectTag |= 128);
              else if (l5) {
                n5 = qt(At.current);
                var a5 = D(r6, l5, i2, n5, t4);
                Yn(a5, t4, false, false), t4.stateNode = a5, j(a5, r6, l5, i2, n5) && ar(t4), null !== t4.ref && (t4.effectTag |= 128);
              } else if (null === t4.stateNode) throw Error(f4(166));
              break;
            case 6:
              if (n5 && null != t4.stateNode) Zn(n5, t4, n5.memoizedProps, l5);
              else {
                if ("string" != typeof l5 && null === t4.stateNode) throw Error(f4(166));
                n5 = qt($t.current), i2 = qt(At.current), t4.stateNode = H(l5, n5, i2, t4);
              }
              break;
            case 13:
              if (me(Jt), l5 = t4.memoizedState, 0 != (64 & t4.effectTag)) {
                t4.expirationTime = r6;
                break e;
              }
              l5 = null !== l5, i2 = false, null === n5 ? t4.memoizedProps.fallback : (i2 = null !== (r6 = n5.memoizedState), l5 || null === r6 || null !== (r6 = n5.child.sibling) && (null !== (a5 = t4.firstEffect) ? (t4.firstEffect = r6, r6.nextEffect = a5) : (t4.firstEffect = t4.lastEffect = r6, r6.nextEffect = null), r6.effectTag = 8)), l5 && !i2 && 0 != (2 & t4.mode) && (null === n5 && true !== t4.memoizedProps.unstable_avoidThisFallback || 0 != (1 & Jt.current) ? Lr === Mr && (Lr = Dr) : (Lr !== Mr && Lr !== Dr || (Lr = Wr), 0 !== Gr && null !== Br && (Yl(Br, Ar), Jl(Br, Gr)))), (l5 || i2) && (t4.effectTag |= 4);
              break;
            case 4:
              Kt(), Jn(t4);
              break;
            case 10:
              dt(t4);
              break;
            case 19:
              if (me(Jt), null === (l5 = t4.memoizedState)) break;
              if (i2 = 0 != (64 & t4.effectTag), null === (a5 = l5.rendering)) {
                if (i2) ur(l5, false);
                else if (Lr !== Mr || null !== n5 && 0 != (64 & n5.effectTag)) for (n5 = t4.child; null !== n5; ) {
                  if (null !== (a5 = Xt(n5))) {
                    for (t4.effectTag |= 64, ur(l5, false), null !== (n5 = a5.updateQueue) && (t4.updateQueue = n5, t4.effectTag |= 4), null === l5.lastEffect && (t4.firstEffect = null), t4.lastEffect = l5.lastEffect, n5 = r6, l5 = t4.child; null !== l5; ) r6 = n5, (i2 = l5).effectTag &= 2, i2.nextEffect = null, i2.firstEffect = null, i2.lastEffect = null, null === (a5 = i2.alternate) ? (i2.childExpirationTime = 0, i2.expirationTime = r6, i2.child = null, i2.memoizedProps = null, i2.memoizedState = null, i2.updateQueue = null, i2.dependencies = null) : (i2.childExpirationTime = a5.childExpirationTime, i2.expirationTime = a5.expirationTime, i2.child = a5.child, i2.memoizedProps = a5.memoizedProps, i2.memoizedState = a5.memoizedState, i2.updateQueue = a5.updateQueue, r6 = a5.dependencies, i2.dependencies = null === r6 ? null : { expirationTime: r6.expirationTime, firstContext: r6.firstContext, responders: r6.responders }), l5 = l5.sibling;
                    he(Jt, 1 & Jt.current | 2), t4 = t4.child;
                    break e;
                  }
                  n5 = n5.sibling;
                }
              } else {
                if (!i2) if (null !== (n5 = Xt(a5))) {
                  if (t4.effectTag |= 64, i2 = true, null !== (n5 = n5.updateQueue) && (t4.updateQueue = n5, t4.effectTag |= 4), ur(l5, true), null === l5.tail && "hidden" === l5.tailMode) {
                    null !== (t4 = t4.lastEffect = l5.lastEffect) && (t4.nextEffect = null);
                    break;
                  }
                } else qe() > l5.tailExpiration && 1 < r6 && (t4.effectTag |= 64, i2 = true, ur(l5, false), t4.expirationTime = t4.childExpirationTime = r6 - 1);
                l5.isBackwards ? (a5.sibling = t4.child, t4.child = a5) : (null !== (n5 = l5.last) ? n5.sibling = a5 : t4.child = a5, l5.last = a5);
              }
              if (null !== l5.tail) {
                0 === l5.tailExpiration && (l5.tailExpiration = qe() + 500), n5 = l5.tail, l5.rendering = n5, l5.tail = n5.sibling, l5.lastEffect = t4.lastEffect, n5.sibling = null, l5 = Jt.current, he(Jt, l5 = i2 ? 1 & l5 | 2 : 1 & l5), t4 = n5;
                break e;
              }
              break;
            default:
              throw Error(f4(156, t4.tag));
          }
          t4 = null;
        }
        if (n5 = Hr, 1 === Ar || 1 !== n5.childExpirationTime) {
          for (l5 = 0, i2 = n5.child; null !== i2; ) (r6 = i2.expirationTime) > l5 && (l5 = r6), (a5 = i2.childExpirationTime) > l5 && (l5 = a5), i2 = i2.sibling;
          n5.childExpirationTime = l5;
        }
        if (null !== t4) return t4;
        null !== e4 && 0 == (2048 & e4.effectTag) && (null === e4.firstEffect && (e4.firstEffect = Hr.firstEffect), null !== Hr.lastEffect && (null !== e4.lastEffect && (e4.lastEffect.nextEffect = Hr.firstEffect), e4.lastEffect = Hr.lastEffect), 1 < Hr.effectTag && (null !== e4.lastEffect ? e4.lastEffect.nextEffect = Hr : e4.firstEffect = Hr, e4.lastEffect = Hr));
      } else {
        if (null !== (t4 = or(Hr))) return t4.effectTag &= 2047, t4;
        null !== e4 && (e4.firstEffect = e4.lastEffect = null, e4.effectTag |= 2048);
      }
      if (null !== (t4 = Hr.sibling)) return t4;
      Hr = e4;
    } while (null !== Hr);
    return Lr === Mr && (Lr = jr), null;
  }
  __name(zl, "zl");
  function Pl(e4) {
    var t4 = e4.expirationTime;
    return t4 > (e4 = e4.childExpirationTime) ? t4 : e4;
  }
  __name(Pl, "Pl");
  function _l(e4) {
    var t4 = Ve();
    return Ge(99, Nl.bind(null, e4, t4)), null;
  }
  __name(_l, "_l");
  function Nl(e4, t4) {
    if (Rl(), (Or & (Rr | Ir)) !== Nr) throw Error(f4(327));
    var n5 = e4.finishedWork, r6 = e4.finishedExpirationTime;
    if (null === n5) return null;
    if (e4.finishedWork = null, e4.finishedExpirationTime = 0, n5 === e4.current) throw Error(f4(177));
    e4.callbackNode = null, e4.callbackExpirationTime = 0, e4.callbackPriority = 90, e4.nextKnownPendingLevel = 0;
    var l5 = Pl(n5);
    if (e4.firstPendingTime = l5, r6 <= e4.lastSuspendedTime ? e4.firstSuspendedTime = e4.lastSuspendedTime = e4.nextKnownPendingLevel = 0 : r6 <= e4.firstSuspendedTime && (e4.firstSuspendedTime = r6 - 1), r6 <= e4.lastPingedTime && (e4.lastPingedTime = 0), r6 <= e4.lastExpiredTime && (e4.lastExpiredTime = 0), e4 === Br && (Hr = Br = null, Ar = 0), 1 < n5.effectTag ? null !== n5.lastEffect ? (n5.lastEffect.nextEffect = n5, l5 = n5.firstEffect) : l5 = n5 : l5 = n5.firstEffect, null !== l5) {
      var i2 = Or;
      Or |= Ir, _r.current = null, F(e4.containerInfo), Zr = l5;
      do {
        try {
          Ul();
        } catch (e5) {
          if (null === Zr) throw Error(f4(330));
          Fl(Zr, e5), Zr = Zr.nextEffect;
        }
      } while (null !== Zr);
      Zr = l5;
      do {
        try {
          for (var a5 = e4, u4 = t4; null !== Zr; ) {
            var o5 = Zr.effectTag;
            if (16 & o5 && q && re(Zr.stateNode), 128 & o5) {
              var c3 = Zr.alternate;
              if (null !== c3) {
                var s5 = c3.ref;
                null !== s5 && ("function" == typeof s5 ? s5(null) : s5.current = null);
              }
            }
            switch (1038 & o5) {
              case 2:
                vr(Zr), Zr.effectTag &= -3;
                break;
              case 6:
                vr(Zr), Zr.effectTag &= -3, xr(Zr.alternate, Zr);
                break;
              case 1024:
                Zr.effectTag &= -1025;
                break;
              case 1028:
                Zr.effectTag &= -1025, xr(Zr.alternate, Zr);
                break;
              case 4:
                xr(Zr.alternate, Zr);
                break;
              case 8:
                var d4 = a5, p4 = Zr, m4 = u4;
                q ? Tr(d4, p4, m4) : gr(d4, p4, m4), br(p4);
            }
            Zr = Zr.nextEffect;
          }
        } catch (e5) {
          if (null === Zr) throw Error(f4(330));
          Fl(Zr, e5), Zr = Zr.nextEffect;
        }
      } while (null !== Zr);
      Q(e4.containerInfo), e4.current = n5, Zr = l5;
      do {
        try {
          for (o5 = r6; null !== Zr; ) {
            var h2 = Zr.effectTag;
            if (36 & h2) {
              var g2 = Zr.alternate;
              switch (s5 = o5, (c3 = Zr).tag) {
                case 0:
                case 11:
                case 15:
                  mr(16, 32, c3);
                  break;
                case 1:
                  var b4 = c3.stateNode;
                  if (4 & c3.effectTag) if (null === g2) b4.componentDidMount();
                  else {
                    var y4 = c3.elementType === c3.type ? g2.memoizedProps : it(c3.type, g2.memoizedProps);
                    b4.componentDidUpdate(y4, g2.memoizedState, b4.__reactInternalSnapshotBeforeUpdate);
                  }
                  var v4 = c3.updateQueue;
                  null !== v4 && wt(0, v4, b4);
                  break;
                case 3:
                  var T2 = c3.updateQueue;
                  if (null !== T2) {
                    if (a5 = null, null !== c3.child) switch (c3.child.tag) {
                      case 5:
                        a5 = R(c3.child.stateNode);
                        break;
                      case 1:
                        a5 = c3.child.stateNode;
                    }
                    wt(0, T2, a5);
                  }
                  break;
                case 5:
                  var x2 = c3.stateNode;
                  null === g2 && 4 & c3.effectTag && J(x2, c3.type, c3.memoizedProps, c3);
                  break;
                case 6:
                case 4:
                case 12:
                case 19:
                case 17:
                case 20:
                case 21:
                  break;
                case 13:
                  V && c3.memoizedState;
                  break;
                default:
                  throw Error(f4(163));
              }
            }
            if (128 & h2) {
              c3 = void 0;
              var E2 = Zr.ref;
              if (null !== E2) {
                var k4 = Zr.stateNode;
                c3 = 5 === Zr.tag ? R(k4) : k4, "function" == typeof E2 ? E2(c3) : E2.current = c3;
              }
            }
            Zr = Zr.nextEffect;
          }
        } catch (e5) {
          if (null === Zr) throw Error(f4(330));
          Fl(Zr, e5), Zr = Zr.nextEffect;
        }
      } while (null !== Zr);
      Zr = null, Be(), Or = i2;
    } else e4.current = n5;
    if (rl) rl = false, ll = e4, il = t4;
    else for (Zr = l5; null !== Zr; ) t4 = Zr.nextEffect, Zr.nextEffect = null, Zr = t4;
    if (0 === (t4 = e4.firstPendingTime) && (nl = null), 1073741823 === t4 ? e4 === ol ? ul++ : (ul = 0, ol = e4) : ul = 0, "function" == typeof Wl && Wl(n5.stateNode, r6), hl(e4), el) throw el = false, e4 = tl, tl = null, e4;
    return (Or & Ur) !== Nr || Xe(), null;
  }
  __name(Nl, "Nl");
  function Ul() {
    for (; null !== Zr; ) {
      var e4 = Zr.effectTag;
      0 != (256 & e4) && pr(Zr.alternate, Zr), 0 == (512 & e4) || rl || (rl = true, Ye(97, function() {
        return Rl(), null;
      })), Zr = Zr.nextEffect;
    }
  }
  __name(Ul, "Ul");
  function Rl() {
    if (90 !== il) {
      var e4 = 97 < il ? 97 : il;
      return il = 90, Ge(e4, Il);
    }
  }
  __name(Rl, "Rl");
  function Il() {
    if (null === ll) return false;
    var e4 = ll;
    if (ll = null, (Or & (Rr | Ir)) !== Nr) throw Error(f4(331));
    var t4 = Or;
    for (Or |= Ir, e4 = e4.current.firstEffect; null !== e4; ) {
      try {
        var n5 = e4;
        if (0 != (512 & n5.effectTag)) switch (n5.tag) {
          case 0:
          case 11:
          case 15:
            mr(128, 0, n5), mr(0, 64, n5);
        }
      } catch (t5) {
        if (null === e4) throw Error(f4(330));
        Fl(e4, t5);
      }
      n5 = e4.nextEffect, e4.nextEffect = null, e4 = n5;
    }
    return Or = t4, Xe(), true;
  }
  __name(Il, "Il");
  function Ml(e4, t4, n5) {
    xt(e4, t4 = Sr(e4, t4 = fr(n5, t4), 1073741823)), null !== (e4 = pl(e4, 1073741823)) && hl(e4);
  }
  __name(Ml, "Ml");
  function Fl(e4, t4) {
    if (3 === e4.tag) Ml(e4, e4, t4);
    else for (var n5 = e4.return; null !== n5; ) {
      if (3 === n5.tag) {
        Ml(n5, e4, t4);
        break;
      }
      if (1 === n5.tag) {
        var r6 = n5.stateNode;
        if ("function" == typeof n5.type.getDerivedStateFromError || "function" == typeof r6.componentDidCatch && (null === nl || !nl.has(r6))) {
          xt(n5, e4 = Cr(n5, e4 = fr(t4, e4), 1073741823)), null !== (n5 = pl(n5, 1073741823)) && hl(n5);
          break;
        }
      }
      n5 = n5.return;
    }
  }
  __name(Fl, "Fl");
  function Ql(e4, t4, n5) {
    var r6 = e4.pingCache;
    null !== r6 && r6.delete(t4), Br === e4 && Ar === n5 ? Lr === Wr || Lr === Dr && 1073741823 === qr && qe() - Jr < Xr ? vl(e4, Ar) : Yr = true : Gl(e4, n5) && (0 !== (t4 = e4.lastPingedTime) && t4 < n5 || (e4.lastPingedTime = n5, e4.finishedExpirationTime === n5 && (e4.finishedExpirationTime = 0, e4.finishedWork = null), hl(e4)));
  }
  __name(Ql, "Ql");
  function Dl(e4, t4) {
    var n5 = e4.stateNode;
    null !== n5 && n5.delete(t4), 0 == (t4 = 0) && (t4 = sl(t4 = cl(), e4, null)), null !== (e4 = pl(e4, t4)) && hl(e4);
  }
  __name(Dl, "Dl");
  wr = /* @__PURE__ */ __name(function(e4, t4, n5) {
    var r6 = t4.expirationTime;
    if (null !== e4) {
      var l5 = t4.pendingProps;
      if (e4.memoizedProps !== l5 || ye.current) On = true;
      else {
        if (r6 < n5) {
          switch (On = false, t4.tag) {
            case 3:
              Gn(t4);
              break;
            case 5:
              if (Gt(t4), 4 & t4.mode && 1 !== n5 && null(t4.type, l5)) return t4.expirationTime = t4.childExpirationTime = 1, null;
              break;
            case 1:
              xe(t4.type) && we(t4);
              break;
            case 4:
              Vt(t4, t4.stateNode.containerInfo);
              break;
            case 10:
              st(t4, t4.memoizedProps.value);
              break;
            case 13:
              if (null !== t4.memoizedState) return 0 !== (r6 = t4.child.childExpirationTime) && r6 >= n5 ? tr(e4, t4, n5) : (he(Jt, 1 & Jt.current), null !== (t4 = ir(e4, t4, n5)) ? t4.sibling : null);
              he(Jt, 1 & Jt.current);
              break;
            case 19:
              if (r6 = t4.childExpirationTime >= n5, 0 != (64 & e4.effectTag)) {
                if (r6) return lr(e4, t4, n5);
                t4.effectTag |= 64;
              }
              if (null !== (l5 = t4.memoizedState) && (l5.rendering = null, l5.tail = null), he(Jt, Jt.current), !r6) return null;
          }
          return ir(e4, t4, n5);
        }
        On = false;
      }
    } else On = false;
    switch (t4.expirationTime = 0, t4.tag) {
      case 2:
        if (r6 = t4.type, null !== e4 && (e4.alternate = null, t4.alternate = null, t4.effectTag |= 2), e4 = t4.pendingProps, l5 = Te(t4, be.current), mt(t4, n5), l5 = yn(null, t4, r6, e4, l5, n5), t4.effectTag |= 1, "object" == typeof l5 && null !== l5 && "function" == typeof l5.render && void 0 === l5.$$typeof) {
          if (t4.tag = 1, vn(), xe(r6)) {
            var i2 = true;
            we(t4);
          } else i2 = false;
          t4.memoizedState = null !== l5.state && void 0 !== l5.state ? l5.state : null;
          var a5 = r6.getDerivedStateFromProps;
          "function" == typeof a5 && Nt(t4, r6, a5, e4), l5.updater = Ut, t4.stateNode = l5, l5._reactInternalFiber = t4, Ft(t4, r6, e4, n5), t4 = Kn(null, t4, r6, true, i2, n5);
        } else t4.tag = 0, Bn(null, t4, l5, n5), t4 = t4.child;
        return t4;
      case 16:
        if (l5 = t4.elementType, null !== e4 && (e4.alternate = null, t4.alternate = null, t4.effectTag |= 2), e4 = t4.pendingProps, function(e5) {
          if (-1 === e5._status) {
            e5._status = 0;
            var t5 = e5._ctor;
            t5 = t5(), e5._result = t5, t5.then(function(t6) {
              0 === e5._status && (t6 = t6.default, e5._status = 1, e5._result = t6);
            }, function(t6) {
              0 === e5._status && (e5._status = 2, e5._result = t6);
            });
          }
        }(l5), 1 !== l5._status) throw l5._result;
        switch (l5 = l5._result, t4.type = l5, i2 = t4.tag = function(e5) {
          if ("function" == typeof e5) return Hl(e5) ? 1 : 0;
          if (null != e5) {
            if ((e5 = e5.$$typeof) === T) return 11;
            if (e5 === k3) return 14;
          }
          return 2;
        }(l5), e4 = it(l5, e4), i2) {
          case 0:
            t4 = qn(null, t4, l5, e4, n5);
            break;
          case 1:
            t4 = Vn(null, t4, l5, e4, n5);
            break;
          case 11:
            t4 = Hn(null, t4, l5, e4, n5);
            break;
          case 14:
            t4 = An(null, t4, l5, it(l5.type, e4), r6, n5);
            break;
          default:
            throw Error(f4(306, l5, ""));
        }
        return t4;
      case 0:
        return r6 = t4.type, l5 = t4.pendingProps, qn(e4, t4, r6, l5 = t4.elementType === r6 ? l5 : it(r6, l5), n5);
      case 1:
        return r6 = t4.type, l5 = t4.pendingProps, Vn(e4, t4, r6, l5 = t4.elementType === r6 ? l5 : it(r6, l5), n5);
      case 3:
        if (Gn(t4), null === (r6 = t4.updateQueue)) throw Error(f4(282));
        if (l5 = null !== (l5 = t4.memoizedState) ? l5.element : null, Ct(t4, r6, t4.pendingProps, null, n5), (r6 = t4.memoizedState.element) === l5) t4 = ir(e4, t4, n5);
        else {
          if ((l5 = t4.stateNode.hydrate) && (l5 = false), l5) for (n5 = Bt(t4, null, r6, n5), t4.child = n5; n5; ) n5.effectTag = -3 & n5.effectTag | 1024, n5 = n5.sibling;
          else Bn(e4, t4, r6, n5);
          t4 = t4.child;
        }
        return t4;
      case 5:
        return Gt(t4), r6 = t4.type, l5 = t4.pendingProps, i2 = null !== e4 ? e4.memoizedProps : null, a5 = l5.children, B(r6, l5) ? a5 = null : null !== i2 && B(r6, i2) && (t4.effectTag |= 16), $n(e4, t4), 4 & t4.mode && 1 !== n5 && null(r6, l5) ? (t4.expirationTime = t4.childExpirationTime = 1, t4 = null) : (Bn(e4, t4, a5, n5), t4 = t4.child), t4;
      case 6:
        return null;
      case 13:
        return tr(e4, t4, n5);
      case 4:
        return Vt(t4, t4.stateNode.containerInfo), r6 = t4.pendingProps, null === e4 ? t4.child = Ot(t4, null, r6, n5) : Bn(e4, t4, r6, n5), t4.child;
      case 11:
        return r6 = t4.type, l5 = t4.pendingProps, Hn(e4, t4, r6, l5 = t4.elementType === r6 ? l5 : it(r6, l5), n5);
      case 7:
        return Bn(e4, t4, t4.pendingProps, n5), t4.child;
      case 8:
      case 12:
        return Bn(e4, t4, t4.pendingProps.children, n5), t4.child;
      case 10:
        e: {
          if (r6 = t4.type._context, l5 = t4.pendingProps, a5 = t4.memoizedProps, st(t4, i2 = l5.value), null !== a5) {
            var u4 = a5.value;
            if (0 == (i2 = nt(u4, i2) ? 0 : 0 | ("function" == typeof r6._calculateChangedBits ? r6._calculateChangedBits(u4, i2) : 1073741823))) {
              if (a5.children === l5.children && !ye.current) {
                t4 = ir(e4, t4, n5);
                break e;
              }
            } else for (null !== (u4 = t4.child) && (u4.return = t4); null !== u4; ) {
              var o5 = u4.dependencies;
              if (null !== o5) {
                a5 = u4.child;
                for (var c3 = o5.firstContext; null !== c3; ) {
                  if (c3.context === r6 && 0 != (c3.observedBits & i2)) {
                    1 === u4.tag && ((c3 = vt(n5, null)).tag = 2, xt(u4, c3)), u4.expirationTime < n5 && (u4.expirationTime = n5), null !== (c3 = u4.alternate) && c3.expirationTime < n5 && (c3.expirationTime = n5), pt(u4.return, n5), o5.expirationTime < n5 && (o5.expirationTime = n5);
                    break;
                  }
                  c3 = c3.next;
                }
              } else a5 = 10 === u4.tag && u4.type === t4.type ? null : u4.child;
              if (null !== a5) a5.return = u4;
              else for (a5 = u4; null !== a5; ) {
                if (a5 === t4) {
                  a5 = null;
                  break;
                }
                if (null !== (u4 = a5.sibling)) {
                  u4.return = a5.return, a5 = u4;
                  break;
                }
                a5 = a5.return;
              }
              u4 = a5;
            }
          }
          Bn(e4, t4, l5.children, n5), t4 = t4.child;
        }
        return t4;
      case 9:
        return l5 = t4.type, r6 = (i2 = t4.pendingProps).children, mt(t4, n5), r6 = r6(l5 = ht(l5, i2.unstable_observedBits)), t4.effectTag |= 1, Bn(e4, t4, r6, n5), t4.child;
      case 14:
        return i2 = it(l5 = t4.type, t4.pendingProps), An(e4, t4, l5, i2 = it(l5.type, i2), r6, n5);
      case 15:
        return Ln(e4, t4, t4.type, t4.pendingProps, r6, n5);
      case 17:
        return r6 = t4.type, l5 = t4.pendingProps, l5 = t4.elementType === r6 ? l5 : it(r6, l5), null !== e4 && (e4.alternate = null, t4.alternate = null, t4.effectTag |= 2), t4.tag = 1, xe(r6) ? (e4 = true, we(t4)) : e4 = false, mt(t4, n5), It(t4, r6, l5), Ft(t4, r6, l5, n5), Kn(null, t4, r6, true, e4, n5);
      case 19:
        return lr(e4, t4, n5);
    }
    throw Error(f4(156, t4.tag));
  }, "wr");
  var Wl = null, jl = null;
  function Ol(e4, t4, n5, r6) {
    this.tag = e4, this.key = n5, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t4, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r6, this.effectTag = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.childExpirationTime = this.expirationTime = 0, this.alternate = null;
  }
  __name(Ol, "Ol");
  function Bl(e4, t4, n5, r6) {
    return new Ol(e4, t4, n5, r6);
  }
  __name(Bl, "Bl");
  function Hl(e4) {
    return !(!(e4 = e4.prototype) || !e4.isReactComponent);
  }
  __name(Hl, "Hl");
  function Al(e4, t4) {
    var n5 = e4.alternate;
    return null === n5 ? ((n5 = Bl(e4.tag, t4, e4.key, e4.mode)).elementType = e4.elementType, n5.type = e4.type, n5.stateNode = e4.stateNode, n5.alternate = e4, e4.alternate = n5) : (n5.pendingProps = t4, n5.effectTag = 0, n5.nextEffect = null, n5.firstEffect = null, n5.lastEffect = null), n5.childExpirationTime = e4.childExpirationTime, n5.expirationTime = e4.expirationTime, n5.child = e4.child, n5.memoizedProps = e4.memoizedProps, n5.memoizedState = e4.memoizedState, n5.updateQueue = e4.updateQueue, t4 = e4.dependencies, n5.dependencies = null === t4 ? null : { expirationTime: t4.expirationTime, firstContext: t4.firstContext, responders: t4.responders }, n5.sibling = e4.sibling, n5.index = e4.index, n5.ref = e4.ref, n5;
  }
  __name(Al, "Al");
  function Ll(e4, t4, n5, r6, l5, i2) {
    var a5 = 2;
    if (r6 = e4, "function" == typeof e4) Hl(e4) && (a5 = 1);
    else if ("string" == typeof e4) a5 = 5;
    else e: switch (e4) {
      case m3:
        return $l(n5.children, l5, i2, t4);
      case v3:
        a5 = 8, l5 |= 7;
        break;
      case h:
        a5 = 8, l5 |= 1;
        break;
      case g:
        return (e4 = Bl(12, n5, t4, 8 | l5)).elementType = g, e4.type = g, e4.expirationTime = i2, e4;
      case x:
        return (e4 = Bl(13, n5, t4, l5)).type = x, e4.elementType = x, e4.expirationTime = i2, e4;
      case E:
        return (e4 = Bl(19, n5, t4, l5)).elementType = E, e4.expirationTime = i2, e4;
      default:
        if ("object" == typeof e4 && null !== e4) switch (e4.$$typeof) {
          case b3:
            a5 = 10;
            break e;
          case y3:
            a5 = 9;
            break e;
          case T:
            a5 = 11;
            break e;
          case k3:
            a5 = 14;
            break e;
          case S3:
            a5 = 16, r6 = null;
            break e;
        }
        throw Error(f4(130, null == e4 ? e4 : typeof e4, ""));
    }
    return (t4 = Bl(a5, n5, t4, l5)).elementType = e4, t4.type = r6, t4.expirationTime = i2, t4;
  }
  __name(Ll, "Ll");
  function $l(e4, t4, n5, r6) {
    return (e4 = Bl(7, e4, r6, t4)).expirationTime = n5, e4;
  }
  __name($l, "$l");
  function ql(e4, t4, n5) {
    return (e4 = Bl(6, e4, null, t4)).expirationTime = n5, e4;
  }
  __name(ql, "ql");
  function Vl(e4, t4, n5) {
    return (t4 = Bl(4, null !== e4.children ? e4.children : [], e4.key, t4)).expirationTime = n5, t4.stateNode = { containerInfo: e4.containerInfo, pendingChildren: null, implementation: e4.implementation }, t4;
  }
  __name(Vl, "Vl");
  function Kl(e4, t4, n5) {
    this.tag = t4, this.current = null, this.containerInfo = e4, this.pingCache = this.pendingChildren = null, this.finishedExpirationTime = 0, this.finishedWork = null, this.timeoutHandle = $, this.pendingContext = this.context = null, this.hydrate = n5, this.callbackNode = null, this.callbackPriority = 90, this.lastExpiredTime = this.lastPingedTime = this.nextKnownPendingLevel = this.lastSuspendedTime = this.firstSuspendedTime = this.firstPendingTime = 0;
  }
  __name(Kl, "Kl");
  function Gl(e4, t4) {
    var n5 = e4.firstSuspendedTime;
    return e4 = e4.lastSuspendedTime, 0 !== n5 && n5 >= t4 && e4 <= t4;
  }
  __name(Gl, "Gl");
  function Yl(e4, t4) {
    var n5 = e4.firstSuspendedTime, r6 = e4.lastSuspendedTime;
    n5 < t4 && (e4.firstSuspendedTime = t4), (r6 > t4 || 0 === n5) && (e4.lastSuspendedTime = t4), t4 <= e4.lastPingedTime && (e4.lastPingedTime = 0), t4 <= e4.lastExpiredTime && (e4.lastExpiredTime = 0);
  }
  __name(Yl, "Yl");
  function Jl(e4, t4) {
    t4 > e4.firstPendingTime && (e4.firstPendingTime = t4);
    var n5 = e4.firstSuspendedTime;
    0 !== n5 && (t4 >= n5 ? e4.firstSuspendedTime = e4.lastSuspendedTime = e4.nextKnownPendingLevel = 0 : t4 >= e4.lastSuspendedTime && (e4.lastSuspendedTime = t4 + 1), t4 > e4.nextKnownPendingLevel && (e4.nextKnownPendingLevel = t4));
  }
  __name(Jl, "Jl");
  function Xl(e4, t4) {
    var n5 = e4.lastExpiredTime;
    (0 === n5 || n5 > t4) && (e4.lastExpiredTime = t4);
  }
  __name(Xl, "Xl");
  function Zl(e4) {
    var t4 = e4._reactInternalFiber;
    if (void 0 === t4) {
      if ("function" == typeof e4.render) throw Error(f4(188));
      throw Error(f4(268, Object.keys(e4)));
    }
    return null === (e4 = U(t4)) ? null : e4.stateNode;
  }
  __name(Zl, "Zl");
  function ei(e4, t4) {
    null !== (e4 = e4.memoizedState) && null !== e4.dehydrated && e4.retryTime < t4 && (e4.retryTime = t4);
  }
  __name(ei, "ei");
  function ti(e4, t4) {
    ei(e4, t4), (e4 = e4.alternate) && ei(e4, t4);
  }
  __name(ti, "ti");
  var ni = { createContainer: /* @__PURE__ */ __name(function(e4, t4, n5) {
    return e4 = new Kl(e4, t4, n5), t4 = Bl(3, null, null, 2 === t4 ? 7 : 1 === t4 ? 3 : 0), e4.current = t4, t4.stateNode = e4;
  }, "createContainer"), updateContainer: /* @__PURE__ */ __name(function(e4, t4, n5, r6) {
    var l5 = t4.current, i2 = cl(), a5 = Pt.suspense;
    i2 = sl(i2, l5, a5);
    e: if (n5) {
      t: {
        if (P(n5 = n5._reactInternalFiber) !== n5 || 1 !== n5.tag) throw Error(f4(170));
        var u4 = n5;
        do {
          switch (u4.tag) {
            case 3:
              u4 = u4.stateNode.context;
              break t;
            case 1:
              if (xe(u4.type)) {
                u4 = u4.stateNode.__reactInternalMemoizedMergedChildContext;
                break t;
              }
          }
          u4 = u4.return;
        } while (null !== u4);
        throw Error(f4(171));
      }
      if (1 === n5.tag) {
        var o5 = n5.type;
        if (xe(o5)) {
          n5 = Ce(n5, o5, u4);
          break e;
        }
      }
      n5 = u4;
    } else n5 = ge;
    return null === t4.context ? t4.context = n5 : t4.pendingContext = n5, (t4 = vt(i2, a5)).payload = { element: e4 }, null !== (r6 = void 0 === r6 ? null : r6) && (t4.callback = r6), xt(l5, t4), dl(l5, i2), i2;
  }, "updateContainer"), batchedEventUpdates: /* @__PURE__ */ __name(function(e4, t4) {
    var n5 = Or;
    Or |= 2;
    try {
      return e4(t4);
    } finally {
      (Or = n5) === Nr && Xe();
    }
  }, "batchedEventUpdates"), batchedUpdates: /* @__PURE__ */ __name(function(e4, t4) {
    var n5 = Or;
    Or |= 1;
    try {
      return e4(t4);
    } finally {
      (Or = n5) === Nr && Xe();
    }
  }, "batchedUpdates"), unbatchedUpdates: /* @__PURE__ */ __name(function(e4, t4) {
    var n5 = Or;
    Or &= -2, Or |= Ur;
    try {
      return e4(t4);
    } finally {
      (Or = n5) === Nr && Xe();
    }
  }, "unbatchedUpdates"), deferredUpdates: /* @__PURE__ */ __name(function(e4) {
    return Ge(97, e4);
  }, "deferredUpdates"), syncUpdates: /* @__PURE__ */ __name(function(e4, t4, n5, r6) {
    return Ge(99, e4.bind(null, t4, n5, r6));
  }, "syncUpdates"), discreteUpdates: /* @__PURE__ */ __name(function(e4, t4, n5, r6) {
    var l5 = Or;
    Or |= 4;
    try {
      return Ge(98, e4.bind(null, t4, n5, r6));
    } finally {
      (Or = l5) === Nr && Xe();
    }
  }, "discreteUpdates"), flushDiscreteUpdates: /* @__PURE__ */ __name(function() {
    (Or & (1 | Rr | Ir)) === Nr && (function() {
      if (null !== al) {
        var e4 = al;
        al = null, e4.forEach(function(e5, t4) {
          Xl(t4, e5), hl(t4);
        }), Xe();
      }
    }(), Rl());
  }, "flushDiscreteUpdates"), flushControlled: /* @__PURE__ */ __name(function(e4) {
    var t4 = Or;
    Or |= 1;
    try {
      Ge(99, e4);
    } finally {
      (Or = t4) === Nr && Xe();
    }
  }, "flushControlled"), flushSync: yl, flushPassiveEffects: Rl, IsThisRendererActing: { current: false }, getPublicRootInstance: /* @__PURE__ */ __name(function(e4) {
    return (e4 = e4.current).child ? 5 === e4.child.tag ? R(e4.child.stateNode) : e4.child.stateNode : null;
  }, "getPublicRootInstance"), attemptSynchronousHydration: /* @__PURE__ */ __name(function(e4) {
    switch (e4.tag) {
      case 3:
        var t4 = e4.stateNode;
        t4.hydrate && function(e5, t5) {
          Xl(e5, t5), hl(e5), (Or & (Rr | Ir)) === Nr && Xe();
        }(t4, t4.firstPendingTime);
        break;
      case 13:
        yl(function() {
          return dl(e4, 1073741823);
        }), t4 = tt(cl(), 150, 100), ti(e4, t4);
    }
  }, "attemptSynchronousHydration"), attemptUserBlockingHydration: /* @__PURE__ */ __name(function(e4) {
    if (13 === e4.tag) {
      var t4 = tt(cl(), 150, 100);
      dl(e4, t4), ti(e4, t4);
    }
  }, "attemptUserBlockingHydration"), attemptContinuousHydration: /* @__PURE__ */ __name(function(e4) {
    if (13 === e4.tag) {
      cl();
      var t4 = et++;
      dl(e4, t4), ti(e4, t4);
    }
  }, "attemptContinuousHydration"), attemptHydrationAtCurrentPriority: /* @__PURE__ */ __name(function(e4) {
    if (13 === e4.tag) {
      var t4 = cl();
      dl(e4, t4 = sl(t4, e4, null)), ti(e4, t4);
    }
  }, "attemptHydrationAtCurrentPriority"), findHostInstance: Zl, findHostInstanceWithWarning: /* @__PURE__ */ __name(function(e4) {
    return Zl(e4);
  }, "findHostInstanceWithWarning"), findHostInstanceWithNoPortals: /* @__PURE__ */ __name(function(e4) {
    return null === (e4 = function(e5) {
      if (!(e5 = N(e5))) return null;
      for (var t4 = e5; ; ) {
        if (5 === t4.tag || 6 === t4.tag) return t4;
        if (t4.child && 4 !== t4.tag) t4.child.return = t4, t4 = t4.child;
        else {
          if (t4 === e5) break;
          for (; !t4.sibling; ) {
            if (!t4.return || t4.return === e5) return null;
            t4 = t4.return;
          }
          t4.sibling.return = t4.return, t4 = t4.sibling;
        }
      }
      return null;
    }(e4)) ? null : 20 === e4.tag ? e4.stateNode.instance : e4.stateNode;
  }, "findHostInstanceWithNoPortals"), shouldSuspend: /* @__PURE__ */ __name(function() {
    return false;
  }, "shouldSuspend"), injectIntoDevTools: /* @__PURE__ */ __name(function(e4) {
    var t4 = e4.findFiberByHostInstance;
    return function(e5) {
      if ("undefined" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
      var t5 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (t5.isDisabled || !t5.supportsFiber) return true;
      try {
        var n5 = t5.inject(e5);
        Wl = /* @__PURE__ */ __name(function(e6) {
          try {
            t5.onCommitFiberRoot(n5, e6, void 0, 64 == (64 & e6.current.effectTag));
          } catch (e7) {
          }
        }, "Wl"), jl = /* @__PURE__ */ __name(function(e6) {
          try {
            t5.onCommitFiberUnmount(n5, e6);
          } catch (e7) {
          }
        }, "jl");
      } catch (e6) {
      }
      return true;
    }(l4({}, e4, { overrideHookState: null, overrideProps: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: c2.ReactCurrentDispatcher, findHostInstanceByFiber: /* @__PURE__ */ __name(function(e5) {
      return null === (e5 = U(e5)) ? null : e5.stateNode;
    }, "findHostInstanceByFiber"), findFiberByHostInstance: /* @__PURE__ */ __name(function(e5) {
      return t4 ? t4(e5) : null;
    }, "findFiberByHostInstance"), findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null }));
  }, "injectIntoDevTools") };
  i.exports = ni.default || ni;
  var ri = i.exports;
  return i.exports = n4, ri;
}, "n");
var o3 = r4(a3.exports);
var f3 = /* @__PURE__ */ __name((e4, t4) => {
  const n5 = Object.keys(e4), r5 = Object.keys(t4);
  if (n5.length !== r5.length) return false;
  for (let r6 = 0; r6 < n5.length; r6 += 1) {
    const l4 = n5[r6];
    if ("render" === l4 && !e4[l4] != !t4[l4]) return false;
    if ("children" !== l4 && e4[l4] !== t4[l4]) {
      if ("object" == typeof e4[l4] && "object" == typeof t4[l4] && f3(e4[l4], t4[l4])) continue;
      return false;
    }
    if ("children" === l4 && ("string" == typeof e4[l4] || "string" == typeof t4[l4])) return e4[l4] === t4[l4];
  }
  return true;
}, "f");
var c = {};
var s3 = /* @__PURE__ */ __name(({ appendChild: e4, appendChildToContainer: t4, commitTextUpdate: n5, commitUpdate: r5, createInstance: l4, createTextInstance: i2, insertBefore: a4, removeChild: u4, removeChildFromContainer: s4, resetAfterCommit: d3 }) => o3({ appendChild: e4, appendChildToContainer: t4, appendInitialChild: e4, createInstance: l4, createTextInstance: i2, insertBefore: a4, commitUpdate: r5, commitTextUpdate: n5, removeChild: u4, removeChildFromContainer: s4, resetAfterCommit: d3, shouldSetTextContent: /* @__PURE__ */ __name(() => false, "shouldSetTextContent"), finalizeInitialChildren: /* @__PURE__ */ __name(() => false, "finalizeInitialChildren"), getPublicInstance: /* @__PURE__ */ __name((e5) => e5, "getPublicInstance"), getRootHostContext: /* @__PURE__ */ __name(() => c, "getRootHostContext"), getChildHostContext: /* @__PURE__ */ __name(() => c, "getChildHostContext"), prepareForCommit() {
}, clearContainer() {
}, resetTextContent() {
}, prepareUpdate: /* @__PURE__ */ __name((e5, t5, n6, r6) => !f3(n6, r6), "prepareUpdate") }), "s");

// ../../node_modules/.pnpm/@react-pdf+reconciler@2.0.0_react@19.2.0/node_modules/@react-pdf/reconciler/lib/index.js
var [major, minor] = import_react4.default.version.split(".").map((v3) => parseInt(v3, 10));
var renderer;
if (major >= 20 || major === 19 && minor >= 2) {
  renderer = k2;
} else if (major === 19) {
  renderer = k;
} else {
  renderer = s3;
}
var renderer$1 = renderer;

// ../../node_modules/.pnpm/@react-pdf+renderer@4.3.2_react@19.2.0/node_modules/@react-pdf/renderer/lib/react-pdf.browser.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var omitNils = /* @__PURE__ */ __name((object) => Object.fromEntries(Object.entries(object).filter((_ref) => {
  let [, value2] = _ref;
  return value2 !== void 0;
})), "omitNils");
var createInstance = /* @__PURE__ */ __name((type2, _ref) => {
  let {
    style,
    children,
    ...props
  } = _ref;
  return {
    type: type2,
    box: {},
    style: style || {},
    props: props || {},
    children: []
  };
}, "createInstance");
var createTextInstance = /* @__PURE__ */ __name((text) => ({
  type: "TEXT_INSTANCE",
  value: text
}), "createTextInstance");
var appendChild = /* @__PURE__ */ __name((parent, child) => {
  const isParentText = parent.type === "TEXT" || parent.type === "LINK" || parent.type === "TSPAN" || parent.type === "NOTE";
  const isChildTextInstance = child.type === "TEXT_INSTANCE";
  const isOrphanTextInstance = isChildTextInstance && !isParentText;
  if (isOrphanTextInstance) {
    console.warn(`Invalid '${child.value}' string child outside <Text> component`);
    return;
  }
  parent.children.push(child);
}, "appendChild");
var appendChildToContainer = /* @__PURE__ */ __name((parentInstance, child) => {
  if (parentInstance.type === "ROOT") {
    parentInstance.document = child;
  } else {
    appendChild(parentInstance, child);
  }
}, "appendChildToContainer");
var insertBefore = /* @__PURE__ */ __name((parentInstance, child, beforeChild) => {
  var _parentInstance$child;
  const index2 = (_parentInstance$child = parentInstance.children) === null || _parentInstance$child === void 0 ? void 0 : _parentInstance$child.indexOf(beforeChild);
  if (index2 === void 0) return;
  if (index2 !== -1 && child) parentInstance.children.splice(index2, 0, child);
}, "insertBefore");
var removeChild = /* @__PURE__ */ __name((parentInstance, child) => {
  var _parentInstance$child2;
  const index2 = (_parentInstance$child2 = parentInstance.children) === null || _parentInstance$child2 === void 0 ? void 0 : _parentInstance$child2.indexOf(child);
  if (index2 === void 0) return;
  if (index2 !== -1) parentInstance.children.splice(index2, 1);
}, "removeChild");
var removeChildFromContainer = /* @__PURE__ */ __name((parentInstance, child) => {
  var _parentInstance$child3;
  const index2 = (_parentInstance$child3 = parentInstance.children) === null || _parentInstance$child3 === void 0 ? void 0 : _parentInstance$child3.indexOf(child);
  if (index2 === void 0) return;
  if (index2 !== -1) parentInstance.children.splice(index2, 1);
}, "removeChildFromContainer");
var commitTextUpdate = /* @__PURE__ */ __name((textInstance, oldText, newText) => {
  textInstance.value = newText;
}, "commitTextUpdate");
var commitUpdate = /* @__PURE__ */ __name((instance, updatePayload, type2, oldProps, newProps) => {
  const {
    style,
    ...props
  } = newProps;
  instance.props = props;
  instance.style = style;
}, "commitUpdate");
var createRenderer = /* @__PURE__ */ __name((_ref2) => {
  let {
    onChange = /* @__PURE__ */ __name(() => {
    }, "onChange")
  } = _ref2;
  return renderer$1({
    appendChild,
    appendChildToContainer,
    commitTextUpdate,
    commitUpdate,
    createInstance,
    createTextInstance,
    insertBefore,
    removeChild,
    removeChildFromContainer,
    resetAfterCommit: onChange
  });
}, "createRenderer");
var version$1 = "4.3.2";
var packageJson = {
  version: version$1
};
var {
  version: version4
} = packageJson;
var fontStore = new FontStore();
var renderer2;
var events = {};
var pdf = /* @__PURE__ */ __name((initialValue) => {
  const onChange = /* @__PURE__ */ __name(() => {
    var _events$change;
    const listeners4 = ((_events$change = events.change) === null || _events$change === void 0 ? void 0 : _events$change.slice()) || [];
    for (let i2 = 0; i2 < listeners4.length; i2 += 1) listeners4[i2]();
  }, "onChange");
  const container = {
    type: "ROOT",
    document: null
  };
  renderer2 = renderer2 || createRenderer({
    onChange
  });
  const mountNode = renderer2.createContainer(container);
  const updateContainer = /* @__PURE__ */ __name((doc, callback) => {
    renderer2.updateContainer(doc, mountNode, null, callback);
  }, "updateContainer");
  if (initialValue) updateContainer(initialValue);
  const render3 = /* @__PURE__ */ __name(async function(compress) {
    if (compress === void 0) {
      compress = true;
    }
    const props = container.document.props || {};
    const {
      pdfVersion,
      language,
      pageLayout,
      pageMode,
      title: title4,
      author,
      subject,
      keyboards,
      creator = "react-pdf",
      producer = "react-pdf",
      creationDate = /* @__PURE__ */ new Date(),
      modificationDate
    } = props;
    const ctx = new PDFDocument({
      compress,
      pdfVersion,
      lang: language,
      displayTitle: true,
      autoFirstPage: false,
      info: omitNils({
        Title: title4,
        Author: author,
        Subject: subject,
        Keywords: keyboards,
        Creator: creator,
        Producer: producer,
        CreationDate: creationDate,
        ModificationDate: modificationDate
      })
    });
    if (pageLayout) {
      ctx._root.data.PageLayout = upperFirst(pageLayout);
    }
    if (pageMode) {
      ctx._root.data.PageMode = upperFirst(pageMode);
    }
    const layout2 = await layout(container.document, fontStore);
    const fileStream = render(ctx, layout2);
    return {
      layout: layout2,
      fileStream
    };
  }, "render");
  const callOnRender = /* @__PURE__ */ __name(function(params) {
    if (params === void 0) {
      params = {};
    }
    if (container.document.props.onRender) {
      container.document.props.onRender(params);
    }
  }, "callOnRender");
  const toBlob = /* @__PURE__ */ __name(async () => {
    const chunks = [];
    const {
      layout: _INTERNAL__LAYOUT__DATA_,
      fileStream: instance
    } = await render3();
    return new Promise((resolve3, reject) => {
      instance.on("data", (chunk) => {
        chunks.push(chunk instanceof Uint8Array ? chunk : new Uint8Array(chunk));
      });
      instance.on("end", () => {
        try {
          const blob = new Blob(chunks, {
            type: "application/pdf"
          });
          callOnRender({
            blob,
            _INTERNAL__LAYOUT__DATA_
          });
          resolve3(blob);
        } catch (error3) {
          reject(error3);
        }
      });
    });
  }, "toBlob");
  const toBuffer = /* @__PURE__ */ __name(async () => {
    const {
      layout: _INTERNAL__LAYOUT__DATA_,
      fileStream
    } = await render3();
    callOnRender({
      _INTERNAL__LAYOUT__DATA_
    });
    return fileStream;
  }, "toBuffer");
  const toString7 = /* @__PURE__ */ __name(async () => {
    if (false) {
      console.warn("`toString` is deprecated and will be removed in next major release");
    }
    let result = "";
    const {
      fileStream: instance
    } = await render3(false);
    return new Promise((resolve3, reject) => {
      try {
        instance.on("data", (buffer) => {
          result += buffer;
        });
        instance.on("end", () => {
          callOnRender();
          resolve3(result);
        });
      } catch (error3) {
        reject(error3);
      }
    });
  }, "toString");
  const on4 = /* @__PURE__ */ __name((event, listener) => {
    if (!events[event]) events[event] = [];
    events[event].push(listener);
  }, "on");
  const removeListener6 = /* @__PURE__ */ __name((event, listener) => {
    if (!events[event]) return;
    const idx = events[event].indexOf(listener);
    if (idx > -1) events[event].splice(idx, 1);
  }, "removeListener");
  return {
    on: on4,
    container,
    toBlob,
    toBuffer,
    toString: toString7,
    removeListener: removeListener6,
    updateContainer
  };
}, "pdf");
var Font = fontStore;
var StyleSheet = {
  create: /* @__PURE__ */ __name((s4) => s4, "create")
};
var usePDF = /* @__PURE__ */ __name(function(_temp) {
  let {
    document: document2
  } = _temp === void 0 ? {} : _temp;
  const pdfInstance = (0, import_react5.useRef)(null);
  const [state2, setState] = (0, import_react5.useState)({
    url: null,
    blob: null,
    error: null,
    loading: !!document2
  });
  (0, import_react5.useEffect)(() => {
    const renderQueue = (0, import_queue.default)({
      autostart: true,
      concurrency: 1
    });
    const queueDocumentRender = /* @__PURE__ */ __name(() => {
      setState((prev) => ({
        ...prev,
        loading: true
      }));
      renderQueue.splice(0, renderQueue.length, () => state2.error ? Promise.resolve() : pdfInstance.current.toBlob());
    }, "queueDocumentRender");
    const onRenderFailed = /* @__PURE__ */ __name((error3) => {
      console.error(error3);
      setState((prev) => ({
        ...prev,
        loading: false,
        error: error3
      }));
    }, "onRenderFailed");
    const onRenderSuccessful = /* @__PURE__ */ __name((blob) => {
      setState({
        blob,
        error: null,
        loading: false,
        url: URL.createObjectURL(blob)
      });
    }, "onRenderSuccessful");
    pdfInstance.current = pdf();
    pdfInstance.current.on("change", queueDocumentRender);
    if (document2) {
      pdfInstance.current.updateContainer(document2);
    }
    renderQueue.on("error", onRenderFailed);
    renderQueue.on("success", onRenderSuccessful);
    return () => {
      renderQueue.end();
      pdfInstance.current.removeListener("change", queueDocumentRender);
    };
  }, []);
  (0, import_react5.useEffect)(() => {
    return () => {
      if (state2.url) {
        URL.revokeObjectURL(state2.url);
      }
    };
  }, [state2.url]);
  const update = (0, import_react5.useCallback)((newDoc) => {
    pdfInstance.current.updateContainer(newDoc);
  }, []);
  return [state2, update];
}, "usePDF");
var PDFViewer = /* @__PURE__ */ __name((_ref) => {
  let {
    title: title4,
    style,
    className,
    children,
    innerRef,
    showToolbar = true,
    ...props
  } = _ref;
  const [instance, updateInstance] = usePDF();
  (0, import_react5.useEffect)(() => updateInstance(children), [children]);
  const src = instance.url ? `${instance.url}#toolbar=${showToolbar ? 1 : 0}` : null;
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("iframe", {
    src,
    title: title4,
    ref: innerRef,
    style,
    className,
    ...props
  });
}, "PDFViewer");
var BlobProvider = /* @__PURE__ */ __name((_ref) => {
  let {
    document: doc,
    children
  } = _ref;
  const [instance, updateInstance] = usePDF();
  (0, import_react5.useEffect)(() => updateInstance(doc), [doc]);
  if (!doc) {
    console.warn("You should pass a valid document to BlobProvider");
    return null;
  }
  return children(instance);
}, "BlobProvider");
var PDFDownloadLinkBase = /* @__PURE__ */ __name((_ref, ref2) => {
  let {
    fileName = "document.pdf",
    document: doc,
    children,
    onClick,
    href,
    ...rest
  } = _ref;
  const [instance, updateInstance] = usePDF();
  (0, import_react5.useEffect)(() => updateInstance(doc), [doc]);
  if (!doc) {
    console.warn("You should pass a valid document to PDFDownloadLink");
    return null;
  }
  const handleDownloadIE = /* @__PURE__ */ __name(() => {
    if (instance && window.navigator.msSaveBlob) {
      window.navigator.msSaveBlob(instance.blob, fileName);
    }
  }, "handleDownloadIE");
  const handleClick = /* @__PURE__ */ __name((event) => {
    handleDownloadIE();
    if (typeof onClick === "function") onClick(event, instance);
  }, "handleClick");
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
    href: instance.url,
    download: fileName,
    onClick: handleClick,
    ref: ref2,
    ...rest,
    children: typeof children === "function" ? children(instance) : children
  });
}, "PDFDownloadLinkBase");
var PDFDownloadLink = /* @__PURE__ */ (0, import_react5.forwardRef)(PDFDownloadLinkBase);
var throwEnvironmentError = /* @__PURE__ */ __name((name) => {
  throw new Error(`${name} is a Node specific API. You're either using this method in a browser, or your bundler is not loading react-pdf from the appropriate web build.`);
}, "throwEnvironmentError");
var renderToStream = /* @__PURE__ */ __name(() => {
  throwEnvironmentError("renderToStream");
}, "renderToStream");
var renderToString = /* @__PURE__ */ __name(() => {
  throwEnvironmentError("renderToString");
}, "renderToString");
var renderToFile = /* @__PURE__ */ __name(() => {
  throwEnvironmentError("renderToFile");
}, "renderToFile");
var render2 = /* @__PURE__ */ __name(() => {
  throwEnvironmentError("render");
}, "render");
var index = {
  pdf,
  usePDF,
  Font,
  version: version4,
  StyleSheet,
  PDFViewer,
  BlobProvider,
  PDFDownloadLink,
  renderToStream,
  renderToString,
  renderToFile,
  render: render2,
  ...lib_exports
};

// src/routes/print.ts
var import_qrcode = __toESM(require_browser(), 1);

// ../../packages/capabilities/src/index.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../packages/capabilities/src/types.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../packages/capabilities/src/services/index.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../packages/capabilities/src/services/github.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../packages/capabilities/src/utils/index.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../packages/capabilities/src/utils/dithering.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_sharp = __toESM(require_lib(), 1);
function floydSteinbergDither(input) {
  const { width, height: height2, data: data2 } = input;
  const output = new Uint8ClampedArray(data2);
  for (let y3 = 0; y3 < height2; y3++) {
    for (let x = 0; x < width; x++) {
      const idx = (y3 * width + x) * 4;
      for (let c2 = 0; c2 < 3; c2++) {
        const oldPixel = output[idx + c2] ?? 0;
        const newPixel = oldPixel < 128 ? 0 : 255;
        output[idx + c2] = newPixel;
        const quantError = oldPixel - newPixel;
        if (x + 1 < width) {
          output[idx + 4 + c2] = Math.min(255, Math.max(0, (output[idx + 4 + c2] ?? 0) + quantError * 7 / 16));
        }
        if (y3 + 1 < height2) {
          if (x > 0) {
            output[idx + width * 4 - 4 + c2] = Math.min(255, Math.max(0, (output[idx + width * 4 - 4 + c2] ?? 0) + quantError * 3 / 16));
          }
          output[idx + width * 4 + c2] = Math.min(255, Math.max(0, (output[idx + width * 4 + c2] ?? 0) + quantError * 5 / 16));
          if (x + 1 < width) {
            output[idx + width * 4 + 4 + c2] = Math.min(255, Math.max(0, (output[idx + width * 4 + 4 + c2] ?? 0) + quantError * 1 / 16));
          }
        }
      }
    }
  }
  return { width, height: height2, data: output };
}
__name(floydSteinbergDither, "floydSteinbergDither");
async function ditherImage(imageUrl, width, height2) {
  try {
    const response = await fetch(imageUrl);
    const arrayBuffer = await response.arrayBuffer();
    const inputBuffer = Buffer.from(arrayBuffer);
    const { data: data2, info: info3 } = await (0, import_sharp.default)(inputBuffer).resize(width, height2).modulate({ brightness: 1.2 }).ensureAlpha().raw().toBuffer({ resolveWithObject: true });
    const dithered = floydSteinbergDither({
      width: info3.width,
      height: info3.height,
      data: new Uint8ClampedArray(data2)
    });
    const outputBuffer = await (0, import_sharp.default)(Buffer.from(dithered.data), {
      raw: {
        width: info3.width,
        height: info3.height,
        channels: 4
      }
    }).png().toBuffer();
    return `data:image/png;base64,${outputBuffer.toString("base64")}`;
  } catch (error3) {
    console.error("Error dithering image:", error3);
    return imageUrl;
  }
}
__name(ditherImage, "ditherImage");
async function createDitheredBackground(hexColor, width = 32, height2 = 32) {
  try {
    const { data: data2, info: info3 } = await (0, import_sharp.default)({
      create: {
        width,
        height: height2,
        channels: 4,
        background: hexColor
      }
    }).linear(0.3, 178).ensureAlpha().raw().toBuffer({ resolveWithObject: true });
    const dithered = floydSteinbergDither({
      width: info3.width,
      height: info3.height,
      data: new Uint8ClampedArray(data2)
    });
    const outputBuffer = await (0, import_sharp.default)(Buffer.from(dithered.data), {
      raw: {
        width: info3.width,
        height: info3.height,
        channels: 4
      }
    }).png().toBuffer();
    return `data:image/png;base64,${outputBuffer.toString("base64")}`;
  } catch (error3) {
    console.error("Error creating dithered background:", error3);
    return "";
  }
}
__name(createDitheredBackground, "createDitheredBackground");

// ../../packages/capabilities/src/services/github.ts
async function fetchGithubIssue(url) {
  const regex4 = /github\.com\/([^\/]+)\/([^\/]+)\/issues\/(\d+)/;
  const match2 = url.match(regex4);
  if (!match2) {
    throw new Error("Invalid GitHub issue URL");
  }
  const [, owner, repo, issueNumber] = match2;
  const apiUrl = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}`;
  const token = process.env.GITHUB_TOKEN;
  const headers = {
    "User-Agent": "printy-mobile",
    Accept: "application/vnd.github.v3+json"
  };
  if (token) {
    headers.Authorization = `Bearer ${token}`;
  }
  const res = await fetch(apiUrl, { headers });
  if (!res.ok) {
    throw new Error(`Failed to fetch GitHub issue: ${res.statusText}`);
  }
  const data2 = await res.json();
  const user = data2.user;
  const ditheredAvatar = user?.avatar_url ? await ditherImage(user.avatar_url, 60, 60) : void 0;
  const statusColor = data2.state === "open" ? "#2da44e" : "#8250df";
  const statusDitheredBg = await createDitheredBackground(statusColor, 100, 50);
  const rawLabels = data2.labels || [];
  const labels = await Promise.all(
    rawLabels.map(async (l4) => ({
      name: l4.name,
      color: l4.color,
      ditheredBackground: await createDitheredBackground(
        `#${l4.color}`,
        100,
        50
      )
    }))
  );
  const rawAssignees = data2.assignees || [];
  const assignees = rawAssignees.map((a4) => ({
    login: a4.login,
    avatarUrl: a4.avatar_url
  }));
  const reactions = data2.reactions;
  return {
    title: data2.title,
    number: data2.number,
    status: data2.state,
    statusDitheredBackground: statusDitheredBg,
    author: user?.login,
    authorAvatarUrl: ditheredAvatar,
    repo: `${owner}/${repo}`,
    url,
    createdAt: new Date(data2.created_at).toLocaleDateString(),
    labels,
    assignees,
    commentsCount: data2.comments,
    reactions: reactions ? {
      total_count: reactions.total_count ?? 0,
      "+1": reactions["+1"] ?? 0,
      "-1": reactions["-1"] ?? 0,
      laugh: reactions.laugh ?? 0,
      hooray: reactions.hooray ?? 0,
      confused: reactions.confused ?? 0,
      heart: reactions.heart ?? 0,
      rocket: reactions.rocket ?? 0,
      eyes: reactions.eyes ?? 0
    } : void 0,
    body: data2.body
  };
}
__name(fetchGithubIssue, "fetchGithubIssue");

// ../../packages/capabilities/src/services/linear.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function fetchLinearIssue(url) {
  const idMatch = url.match(/([A-Z]+-\d+)/);
  const id = idMatch ? idMatch[1] : "UNKNOWN";
  const urlParts = url.split("/");
  const lastPart = urlParts[urlParts.length - 1] || "issue";
  const titleGuess = lastPart.replace(/-/g, " ");
  const apiKey = process.env.LINEAR_API_KEY;
  if (apiKey) {
    try {
      const queryByRef = `
        query Issues($filter: IssueFilter) {
          issues(filter: $filter) {
            nodes {
              title
              number
              identifier
              description
              state {
                name
                color
              }
              creator {
                name
                avatarUrl
              }
              assignee {
                name
                avatarUrl
              }
              labels {
                nodes {
                  name
                  color
                }
              }
              createdAt
              url
            }
          }
        }
      `;
      const response = await fetch("https://api.linear.app/graphql", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: apiKey
        },
        body: JSON.stringify({
          query: queryByRef,
          variables: {
            filter: {
              identifier: {
                eq: id
              }
            }
          }
        })
      });
      const result = await response.json();
      const data2 = result.data;
      const issues = data2?.issues;
      const nodes = issues?.nodes;
      const issue = nodes?.[0];
      if (issue) {
        const labelsData = issue.labels;
        const labelNodes = labelsData?.nodes || [];
        const labels = await Promise.all(
          labelNodes.map(async (l4) => {
            const color = l4.color;
            const colorHex = color?.startsWith("#") ? color : `#${color || "cccccc"}`;
            return {
              name: l4.name,
              color: color || "cccccc",
              ditheredBackground: await createDitheredBackground(colorHex, 100, 50)
            };
          })
        );
        const state2 = issue.state;
        const statusColor = state2?.color || "#5e6ad2";
        const statusColorHex = statusColor.startsWith("#") ? statusColor : `#${statusColor}`;
        const statusDitheredBg = await createDitheredBackground(statusColorHex, 100, 50);
        const creator = issue.creator;
        const authorAvatar = creator?.avatarUrl ? await ditherImage(creator.avatarUrl, 60, 60) : void 0;
        const assignee = issue.assignee;
        const assigneeAvatar = assignee?.avatarUrl ? await ditherImage(assignee.avatarUrl, 60, 60) : void 0;
        const assignees = assignee ? [{ login: assignee.name, avatarUrl: assigneeAvatar || "" }] : [];
        return {
          title: String(issue.title || "Linear Issue"),
          number: String(issue.identifier || "UNKNOWN"),
          status: String(state2?.name || ""),
          statusDitheredBackground: statusDitheredBg,
          author: String(creator?.name || ""),
          authorAvatarUrl: authorAvatar,
          repo: "Linear",
          url: String(issue.url || url),
          createdAt: new Date(issue.createdAt).toLocaleDateString(),
          labels,
          body: issue.description,
          assignees,
          commentsCount: 0
        };
      }
    } catch (e4) {
      console.error("Failed to fetch from Linear API, falling back to URL parsing", e4);
    }
  }
  return {
    title: String(titleGuess || "Linear Issue"),
    number: String(id),
    status: "Unknown",
    repo: "Linear",
    url: String(url),
    createdAt: (/* @__PURE__ */ new Date()).toLocaleDateString()
  };
}
__name(fetchLinearIssue, "fetchLinearIssue");

// ../../packages/capabilities/src/services/recipe.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../packages/capabilities/src/services/coloring.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var GENERATION_CONFIG_SCHEMA_RANDOM = {
  type: "object",
  properties: {
    title: { type: "string", description: "The short title of the drawing." },
    drawing_prompt: { type: "string", description: "The drawing prompt." },
    suggested_colors: {
      type: "array",
      items: { type: "string" },
      description: "List of 5 suggested colors for the drawing."
    }
  },
  required: ["title", "drawing_prompt", "suggested_colors"]
};
var GENERATION_CONFIG_SCHEMA_METADATA = {
  type: "object",
  properties: {
    title: { type: "string", description: "The short title of the drawing." },
    suggested_colors: {
      type: "array",
      items: { type: "string" },
      description: "List of 5 suggested colors for the drawing."
    }
  },
  required: ["title", "suggested_colors"]
};
async function getRandomPrompt() {
  const systemPrompt = `You are a children's colouring book author, your job is to come up with ideas/scenes as prompts for another ai to generate the colouring book image. You will not be producing the drawing yourself, just the prompt. It is on a 4x6 inch page so it cannot be too detailed or have too much going on. Just a simple prompt like "A smiling unicorn on a cloud" will do. But you have to be random with it, every time. You have to be very imaginative and random. Please come up with 1 random one now. Seed: ${Math.floor(Math.random() * 1e6)}`;
  const apiKey = process.env.GEMINI_API_KEY || process.env.NANOBANANA_API_KEY;
  if (!apiKey) {
    return {
      title: "Random Surprise",
      drawing_prompt: "a cute robot playing with a butterfly",
      suggested_colors: ["silver", "blue", "orange", "yellow", "green"]
    };
  }
  try {
    const response = await fetch(
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-goog-api-key": apiKey
        },
        body: JSON.stringify({
          contents: [{ parts: [{ text: systemPrompt }] }],
          generationConfig: {
            responseMimeType: "application/json",
            responseJsonSchema: GENERATION_CONFIG_SCHEMA_RANDOM
          }
        })
      }
    );
    const data2 = await response.json();
    const candidates = data2.candidates;
    const content = candidates?.[0]?.content;
    const parts = content?.parts;
    const textValue = parts?.[0]?.text;
    if (typeof textValue !== "string") {
      throw new Error("Missing text in response");
    }
    const result = JSON.parse(textValue);
    return result;
  } catch {
    return {
      title: "Random Surprise",
      drawing_prompt: "a happy dinosaur eating ice cream",
      suggested_colors: ["green", "pink", "brown", "white", "red"]
    };
  }
}
__name(getRandomPrompt, "getRandomPrompt");
async function getMetadataForPrompt(prompt) {
  const systemPrompt = `You are a children's colouring book editor. The user has provided a prompt for a coloring page: "${prompt}". Please generate a short, catchy title for this page and list 5 suggested colors that would be appropriate for coloring it. The colors should be simple names suitable for children (e.g. Red, Blue, Forest Green).`;
  const apiKey = process.env.GEMINI_API_KEY || process.env.NANOBANANA_API_KEY;
  if (!apiKey) {
    return {
      title: "Coloring Page",
      suggested_colors: ["red", "blue", "green", "yellow", "orange"]
    };
  }
  try {
    const response = await fetch(
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-goog-api-key": apiKey
        },
        body: JSON.stringify({
          contents: [{ parts: [{ text: systemPrompt }] }],
          generationConfig: {
            responseMimeType: "application/json",
            responseJsonSchema: GENERATION_CONFIG_SCHEMA_METADATA
          }
        })
      }
    );
    const data2 = await response.json();
    const candidates = data2.candidates;
    const content = candidates?.[0]?.content;
    const parts = content?.parts;
    const textValue = parts?.[0]?.text;
    if (typeof textValue !== "string") {
      throw new Error("Missing text in response");
    }
    const result = JSON.parse(textValue);
    return result;
  } catch {
    return {
      title: "Coloring Page",
      suggested_colors: ["red", "blue", "green", "yellow", "purple"]
    };
  }
}
__name(getMetadataForPrompt, "getMetadataForPrompt");
async function generateColoringPage(userPrompt) {
  const apiKey = process.env.GEMINI_API_KEY || process.env.NANOBANANA_API_KEY;
  let title4 = "";
  let basePrompt = userPrompt?.trim() || "";
  let suggestedColors = [];
  if (!basePrompt) {
    const autogen = await getRandomPrompt();
    title4 = autogen.title;
    basePrompt = autogen.drawing_prompt;
    suggestedColors = autogen.suggested_colors;
  } else {
    const metadata = await getMetadataForPrompt(basePrompt);
    title4 = metadata.title;
    suggestedColors = metadata.suggested_colors;
  }
  const styleDirectives = [
    "Generate a coloring page image.",
    "Style: Strict black and white line art suitable for children.",
    "Content: High contrast, thick distinct outlines, white background.",
    "Constraints: NO grayscale, NO shading, NO colors, NO complex cross-hatching.",
    "This is for a children's colouring-in book, so it has to be simple, playful, and easy to colour with at most 4 colours. No hyperrealism or intricate details.",
    "Subject:"
  ];
  const finalPrompt = `${styleDirectives.join(" ")} ${basePrompt}`;
  const model = "gemini-3-pro-image-preview";
  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
  let imageUrl = "https://placehold.co/512x512/png?text=Mock+Coloring+Page";
  if (apiKey) {
    try {
      const payload = {
        contents: [{ parts: [{ text: finalPrompt }] }],
        generationConfig: {
          responseModalities: ["IMAGE"],
          imageConfig: { aspectRatio: "4:5" }
        }
      };
      const response = await fetch(apiUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-goog-api-key": apiKey
        },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        const errText = await response.text();
        throw new Error(`Gemini API Error: ${response.status} ${response.statusText} - ${errText}`);
      }
      const data2 = await response.json();
      const candidates = data2.candidates;
      const content = candidates?.[0]?.content;
      const parts = content?.parts;
      const inlineData = parts?.[0]?.inlineData;
      if (inlineData?.data) {
        const mime = inlineData.mimeType || "image/jpeg";
        const base64 = inlineData.data;
        imageUrl = `data:${mime};base64,${base64}`;
      }
    } catch (error3) {
      console.error("Failed to generate image via Gemini API:", error3);
    }
  }
  return {
    title: title4 || "Coloring Page",
    imageUrl,
    description: basePrompt,
    suggestedColors
  };
}
__name(generateColoringPage, "generateColoringPage");

// ../../packages/capabilities/src/templates/index.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../packages/capabilities/src/templates/GithubIssueLabel.tsx
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var SHOW_QR_CODE_TOP_RIGHT_CORNER = true;
Font.register({
  family: "Fira Code",
  src: "https://cdn.jsdelivr.net/npm/@fontsource/fira-code@4.5.12/files/fira-code-latin-400-normal.woff"
});
Font.register({
  family: "Inter",
  src: "https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff"
});
var styles = StyleSheet.create({
  page: {
    flexDirection: "column",
    backgroundColor: "#ffffff",
    padding: 15,
    fontFamily: "Inter"
  },
  headerRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#eaeaea",
    paddingBottom: 10
  },
  repoName: {
    fontSize: 10,
    color: "#666",
    marginBottom: 2,
    textTransform: "uppercase",
    letterSpacing: 1
  },
  issueNumber: {
    fontSize: 24,
    fontWeight: "bold",
    color: "#000"
  },
  statusBadge: {
    backgroundColor: "#2da44e",
    // Green for open usually, but static here
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12
  },
  statusText: {
    color: "#fff",
    fontSize: 10,
    fontWeight: "bold",
    textTransform: "capitalize",
    // border: "1px",
    borderRadius: 4,
    padding: 2
  },
  title: {
    fontSize: 16,
    fontWeight: "bold",
    marginBottom: 12,
    lineHeight: 1.3
  },
  authorRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 15
  },
  avatar: {
    width: 20,
    height: 20,
    borderRadius: 10,
    marginRight: 6,
    backgroundColor: "#eee"
  },
  authorName: {
    fontSize: 10,
    color: "#444"
  },
  dateText: {
    fontSize: 10,
    color: "#888",
    marginLeft: "auto"
  },
  bodyContainer: {
    backgroundColor: "#f6f8fa",
    padding: 10,
    borderRadius: 6,
    marginBottom: 15,
    flexGrow: 1,
    borderWidth: 1,
    borderColor: "#000000"
  },
  bodyText: {
    fontSize: 9,
    fontFamily: "Fira Code",
    color: "#24292f",
    lineHeight: 1.4
  },
  footer: {
    marginTop: "auto"
  },
  metaRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
    flexWrap: "wrap"
  },
  labelChip: {
    backgroundColor: "#ddf4ff",
    color: "#0969da",
    fontSize: 8,
    paddingHorizontal: 6,
    paddingVertical: 3,
    borderRadius: 10,
    marginRight: 4,
    marginBottom: 4
  },
  statRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginTop: 5,
    borderTopWidth: 1,
    borderTopColor: "#eaeaea",
    paddingTop: 8
  },
  statItem: {
    flexDirection: "row",
    alignItems: "center",
    marginRight: 20
  },
  statIcon: {
    width: 12,
    height: 12,
    marginRight: 4
  },
  statText: {
    fontSize: 9,
    color: "#57606a"
  },
  assigneeStack: {
    flexDirection: "row"
  },
  assigneeAvatar: {
    width: 16,
    height: 16,
    borderRadius: 8,
    marginLeft: -4,
    borderWidth: 1,
    borderColor: "#fff",
    backgroundColor: "#ddd"
  },
  qrCode: {
    width: 60,
    height: 60
  },
  watermark: {
    position: "absolute",
    bottom: 5,
    right: 5,
    fontSize: 6,
    color: "#ccc"
  }
});
var CommentIcon = /* @__PURE__ */ __name(() => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Svg, { viewBox: "0 0 16 16", style: styles.statIcon, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
  Path,
  {
    d: "M1 2.75C1 1.784 1.784 1 2.75 1h10.5c.966 0 1.75.784 1.75 1.75v7.5A1.75 1.75 0 0 1 13.25 12H9.06l-2.573 2.573A1.458 1.458 0 0 1 4 13.543V12H2.75A1.75 1.75 0 0 1 1 10.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.75.75 0 0 1 .53-.22h4.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z",
    fill: "#57606a"
  }
) }), "CommentIcon");
var ReactionIcon = /* @__PURE__ */ __name(() => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Svg, { width: "16", height: "16", viewBox: "0 0 122.88 122.88", style: styles.statIcon, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
  Path,
  {
    d: "M45.54,2.1A61.48,61.48,0,1,1,8.25,30.74,61.26,61.26,0,0,1,45.54,2.1ZM30.61,70.3a38,38,0,0,0,8.34,8,40.39,40.39,0,0,0,23.58,7.1A38.05,38.05,0,0,0,85.3,77.68a33.56,33.56,0,0,0,7.08-7.42.22.22,0,0,1,.3-.06L95,72.49a.21.21,0,0,1,0,.27A43.47,43.47,0,0,1,81.7,87.08a35.7,35.7,0,0,1-19,6,36.82,36.82,0,0,1-19.53-5.25A47.5,47.5,0,0,1,27.87,72.9a.23.23,0,0,1,0-.27l2.38-2.36a.22.22,0,0,1,.3,0l0,0ZM76.23,33.89c4.06,0,7.35,4.77,7.35,10.65s-3.29,10.64-7.35,10.64-7.35-4.77-7.35-10.64,3.29-10.65,7.35-10.65Zm-29.58,0c4.06,0,7.35,4.77,7.35,10.65s-3.29,10.64-7.35,10.64S39.3,50.41,39.3,44.54s3.29-10.65,7.35-10.65Zm42.1-19.75A54.64,54.64,0,1,0,114.18,47.3,54.46,54.46,0,0,0,88.75,14.14Z",
    fill: "#000000"
  }
) }), "ReactionIcon");
var GithubIssueLabel = /* @__PURE__ */ __name(({ issue }) => {
  const MAX_LEN = 500;
  const bodyText = issue.body?.slice(0, MAX_LEN) + (issue.body && issue.body.length > MAX_LEN ? "..." : "") || "No description provided.";
  const statusColor = issue.status === "open" ? "#2da44e" : "#8250df";
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Document, { children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(Page, { size: [288, 432], style: styles.page, children: [
    /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(View, { style: styles.headerRow, children: [
      /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(View, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Text, { style: styles.repoName, children: issue.repo }),
        /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(Text, { style: styles.issueNumber, children: [
          "#",
          issue.number
        ] })
      ] }),
      SHOW_QR_CODE_TOP_RIGHT_CORNER ? issue.qrCodeDataUrl && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
        Image,
        {
          style: [styles.qrCode, { marginLeft: 10 }],
          src: issue.qrCodeDataUrl
        }
      ) : /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
        View,
        {
          style: [
            styles.statusBadge,
            { backgroundColor: "black", position: "relative", border: "1" }
          ],
          children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            View,
            {
              style: {
                position: "relative",
                zIndex: 100,
                backgroundColor: "rgba(255, 255, 255, 0.01)",
                paddingHorizontal: 4,
                paddingVertical: 1,
                borderRadius: 4
              },
              children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                Text,
                {
                  style: [styles.statusText, { color: issue.statusDitheredBackground ? "#FFF" : "#000" }],
                  children: issue.status
                }
              )
            }
          )
        }
      )
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Text, { style: styles.title, children: issue.title }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(View, { style: styles.authorRow, children: [
      issue.authorAvatarUrl && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Image, { style: styles.avatar, src: issue.authorAvatarUrl }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Text, { style: styles.authorName, children: issue.author }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Text, { style: styles.dateText, children: issue.createdAt })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(View, { style: styles.bodyContainer, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Text, { style: styles.bodyText, children: bodyText }) }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(View, { style: styles.footer, children: [
      issue.labels && issue.labels.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(View, { style: styles.metaRow, children: issue.labels.map((label, i2) => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
        View,
        {
          style: [
            styles.labelChip,
            { backgroundColor: "transparent", position: "relative", border: "1" }
          ],
          children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            View,
            {
              style: {
                position: "relative",
                zIndex: 100,
                backgroundColor: "rgba(255, 255, 255, 0.9)",
                paddingHorizontal: 4,
                paddingVertical: 1,
                borderRadius: 4
              },
              children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                Text,
                {
                  style: {
                    color: "#000",
                    fontSize: 8,
                    zIndex: 100,
                    fontWeight: "bold"
                  },
                  children: label.name
                }
              )
            }
          )
        },
        i2
      )) }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(View, { style: styles.statRow, children: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(View, { style: { flexDirection: "row" }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(View, { style: styles.statItem, children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(CommentIcon, {}),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Text, { style: styles.statText, children: issue.commentsCount || 0 })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(View, { style: styles.statItem, children: [
            (issue.reactions?.["+1"] || 0) > 0 ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(ReactionIcon, {}) : /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(ReactionIcon, {}),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Text, { style: {
              ...styles.statText,
              marginLeft: 8
            }, children: (issue.reactions?.["+1"] || 0) > 0 ? issue.reactions?.["+1"] : issue.reactions?.total_count || 0 })
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(View, { style: { flexDirection: "row", alignItems: "center" }, children: issue.assignees && issue.assignees.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(View, { style: styles.assigneeStack, children: issue.assignees.map((assignee, i2) => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
          Image,
          {
            style: [
              styles.assigneeAvatar,
              { marginLeft: i2 === 0 ? 0 : -6 }
            ],
            src: assignee.avatarUrl
          },
          i2
        )) }) })
      ] })
    ] })
  ] }) });
}, "GithubIssueLabel");

// ../../packages/capabilities/src/templates/LinearIssueLabel.tsx
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_react7 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var SHOW_QR_CODE_TOP_RIGHT_CORNER2 = true;
Font.register({
  family: "Fira Code",
  src: "https://cdn.jsdelivr.net/npm/@fontsource/fira-code@4.5.12/files/fira-code-latin-400-normal.woff"
});
Font.register({
  family: "Inter",
  src: "https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff"
});
var styles2 = StyleSheet.create({
  page: {
    flexDirection: "column",
    backgroundColor: "#ffffff",
    padding: 15,
    fontFamily: "Inter"
  },
  headerRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#eaeaea",
    paddingBottom: 10
  },
  repoName: {
    fontSize: 10,
    color: "#666",
    marginBottom: 2,
    textTransform: "uppercase",
    letterSpacing: 1
  },
  issueNumber: {
    fontSize: 24,
    fontWeight: "bold",
    color: "#000"
  },
  statusBadge: {
    backgroundColor: "#5e6ad2",
    // Default Linear color
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12
  },
  statusText: {
    color: "#fff",
    fontSize: 10,
    fontWeight: "bold",
    textTransform: "capitalize",
    borderRadius: 4,
    padding: 2
  },
  title: {
    fontSize: 16,
    fontWeight: "bold",
    marginBottom: 12,
    lineHeight: 1.3
  },
  authorRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 15
  },
  avatar: {
    width: 20,
    height: 20,
    borderRadius: 10,
    marginRight: 6,
    backgroundColor: "#eee"
  },
  authorName: {
    fontSize: 10,
    color: "#444"
  },
  dateText: {
    fontSize: 10,
    color: "#888",
    marginLeft: "auto"
  },
  bodyContainer: {
    backgroundColor: "#f6f8fa",
    padding: 10,
    borderRadius: 6,
    marginBottom: 15,
    flexGrow: 1,
    borderWidth: 1,
    borderColor: "#000000"
  },
  bodyText: {
    fontSize: 9,
    fontFamily: "Fira Code",
    color: "#24292f",
    lineHeight: 1.4
  },
  footer: {
    marginTop: "auto"
  },
  metaRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
    flexWrap: "wrap"
  },
  labelChip: {
    backgroundColor: "#ddf4ff",
    color: "#0969da",
    fontSize: 8,
    paddingHorizontal: 6,
    paddingVertical: 3,
    borderRadius: 10,
    marginRight: 4,
    marginBottom: 4
  },
  statRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginTop: 5,
    borderTopWidth: 1,
    borderTopColor: "#eaeaea",
    paddingTop: 8
  },
  statItem: {
    flexDirection: "row",
    alignItems: "center",
    marginRight: 20
  },
  statIcon: {
    width: 12,
    height: 12,
    marginRight: 4
  },
  statText: {
    fontSize: 9,
    color: "#57606a"
  },
  assigneeStack: {
    flexDirection: "row"
  },
  assigneeAvatar: {
    width: 16,
    height: 16,
    borderRadius: 8,
    marginLeft: -4,
    borderWidth: 1,
    borderColor: "#fff",
    backgroundColor: "#ddd"
  },
  qrCode: {
    width: 60,
    height: 60
  }
});
var CommentIcon2 = /* @__PURE__ */ __name(() => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Svg, { viewBox: "0 0 16 16", style: styles2.statIcon, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
  Path,
  {
    d: "M1 2.75C1 1.784 1.784 1 2.75 1h10.5c.966 0 1.75.784 1.75 1.75v7.5A1.75 1.75 0 0 1 13.25 12H9.06l-2.573 2.573A1.458 1.458 0 0 1 4 13.543V12H2.75A1.75 1.75 0 0 1 1 10.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.75.75 0 0 1 .53-.22h4.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z",
    fill: "#57606a"
  }
) }), "CommentIcon");
var LinearIssueLabel = /* @__PURE__ */ __name(({ issue }) => {
  const MAX_LEN = 500;
  const bodyText = issue.body?.slice(0, MAX_LEN) + (issue.body && issue.body.length > MAX_LEN ? "..." : "") || "No description provided.";
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Document, { children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(Page, { size: [288, 432], style: styles2.page, children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(View, { style: styles2.headerRow, children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(View, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Text, { style: styles2.repoName, children: issue.repo || "LINEAR" }),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Text, { style: styles2.issueNumber, children: issue.number })
      ] }),
      SHOW_QR_CODE_TOP_RIGHT_CORNER2 ? issue.qrCodeDataUrl && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        Image,
        {
          style: [styles2.qrCode, { marginLeft: 10 }],
          src: issue.qrCodeDataUrl
        }
      ) : /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        View,
        {
          style: [
            styles2.statusBadge,
            { backgroundColor: "black", position: "relative", border: "1" }
          ],
          children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
            View,
            {
              style: {
                position: "relative",
                zIndex: 100,
                backgroundColor: "rgba(255, 255, 255, 0.01)",
                paddingHorizontal: 4,
                paddingVertical: 1,
                borderRadius: 4
              },
              children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
                Text,
                {
                  style: [
                    styles2.statusText,
                    { color: issue.statusDitheredBackground ? "#FFF" : "#000" }
                  ],
                  children: issue.status
                }
              )
            }
          )
        }
      )
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Text, { style: styles2.title, children: issue.title }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(View, { style: styles2.authorRow, children: [
      issue.authorAvatarUrl && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Image, { style: styles2.avatar, src: issue.authorAvatarUrl }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Text, { style: styles2.authorName, children: issue.author }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Text, { style: styles2.dateText, children: issue.createdAt })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(View, { style: styles2.bodyContainer, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Text, { style: styles2.bodyText, children: bodyText }) }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(View, { style: styles2.footer, children: [
      issue.labels && issue.labels.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(View, { style: styles2.metaRow, children: issue.labels.map((label, i2) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        View,
        {
          style: [
            styles2.labelChip,
            { backgroundColor: "transparent", position: "relative", border: "1" }
          ],
          children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
            View,
            {
              style: {
                position: "relative",
                zIndex: 100,
                backgroundColor: "rgba(255, 255, 255, 0.9)",
                paddingHorizontal: 4,
                paddingVertical: 1,
                borderRadius: 4
              },
              children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
                Text,
                {
                  style: {
                    color: "#000",
                    fontSize: 8,
                    zIndex: 100,
                    fontWeight: "bold"
                  },
                  children: label.name
                }
              )
            }
          )
        },
        i2
      )) }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(View, { style: styles2.statRow, children: [
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(View, { style: { flexDirection: "row" }, children: typeof issue.commentsCount === "number" && /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(View, { style: styles2.statItem, children: [
          /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(CommentIcon2, {}),
          /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Text, { style: styles2.statText, children: issue.commentsCount })
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(View, { style: { flexDirection: "row", alignItems: "center" }, children: issue.assignees && issue.assignees.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(View, { style: styles2.assigneeStack, children: issue.assignees.map((assignee, i2) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
          Image,
          {
            style: [
              styles2.assigneeAvatar,
              { marginLeft: i2 === 0 ? 0 : -6 }
            ],
            src: assignee.avatarUrl
          },
          i2
        )) }) })
      ] })
    ] })
  ] }) });
}, "LinearIssueLabel");

// ../../packages/capabilities/src/templates/PullRequestBoardingPass.tsx
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_react8 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
Font.register({
  family: "Fira Code",
  src: "https://cdn.jsdelivr.net/npm/@fontsource/fira-code@4.5.12/files/fira-code-latin-400-normal.woff"
});
Font.register({
  family: "Inter",
  src: "https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff"
});
var styles3 = StyleSheet.create({
  page: {
    flexDirection: "column",
    backgroundColor: "#ffffff",
    padding: 15,
    fontFamily: "Inter",
    position: "relative"
  },
  boardingPassHeader: {
    backgroundColor: "#000",
    color: "#fff",
    padding: 8,
    borderRadius: 4,
    marginBottom: 10,
    textAlign: "center"
  },
  headerText: {
    fontSize: 12,
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: 2
  },
  prInfo: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 12,
    borderBottomWidth: 2,
    borderBottomColor: "#000",
    paddingBottom: 8
  },
  prNumber: {
    fontSize: 20,
    fontWeight: "bold",
    color: "#000"
  },
  statusBadge: {
    backgroundColor: "#2da44e",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12
  },
  statusText: {
    color: "#fff",
    fontSize: 8,
    fontWeight: "bold",
    textTransform: "uppercase"
  },
  title: {
    fontSize: 14,
    fontWeight: "bold",
    marginBottom: 10,
    lineHeight: 1.3
  },
  branchInfo: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "#f6f8fa",
    padding: 8,
    borderRadius: 4,
    marginBottom: 10
  },
  arrowIcon: {
    fontSize: 16,
    marginHorizontal: 8,
    color: "#666"
  },
  branchText: {
    fontSize: 10,
    fontFamily: "Fira Code",
    color: "#24292f"
  },
  diffStats: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 12
  },
  diffAdded: {
    color: "#2da44e",
    fontSize: 10,
    fontWeight: "bold",
    marginRight: 10
  },
  diffRemoved: {
    color: "#cf222e",
    fontSize: 10,
    fontWeight: "bold"
  },
  reviewersSection: {
    marginBottom: 12
  },
  sectionTitle: {
    fontSize: 10,
    fontWeight: "bold",
    marginBottom: 6,
    textTransform: "uppercase",
    color: "#666"
  },
  reviewersRow: {
    flexDirection: "row",
    alignItems: "center"
  },
  reviewerAvatar: {
    width: 24,
    height: 24,
    borderRadius: 12,
    marginRight: 6,
    backgroundColor: "#eee"
  },
  reviewerName: {
    fontSize: 9,
    color: "#444"
  },
  ciStatus: {
    flexDirection: "row",
    alignItems: "center",
    padding: 8,
    borderRadius: 4,
    marginBottom: 10
  },
  ciStatusPassing: {
    backgroundColor: "#dafbe1",
    borderWidth: 1,
    borderColor: "#2da44e"
  },
  ciStatusFailing: {
    backgroundColor: "#ffebe9",
    borderWidth: 1,
    borderColor: "#cf222e"
  },
  ciStatusIcon: {
    width: 12,
    height: 12,
    marginRight: 6
  },
  ciStatusText: {
    fontSize: 9,
    fontWeight: "bold"
  },
  ciStatusTextPassing: {
    color: "#2da44e"
  },
  ciStatusTextFailing: {
    color: "#cf222e"
  },
  qrCode: {
    width: 50,
    height: 50,
    position: "absolute",
    top: 15,
    right: 15
  },
  barcode: {
    height: 30,
    marginVertical: 10
  },
  footer: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    borderTopWidth: 1,
    borderTopColor: "#eaeaea",
    paddingTop: 8,
    marginTop: "auto"
  },
  footerText: {
    fontSize: 8,
    color: "#666"
  }
});
var CheckIcon = /* @__PURE__ */ __name(() => /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Svg, { viewBox: "0 0 16 16", style: styles3.ciStatusIcon, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
  Path,
  {
    d: "M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.75.75 0 0 1 0-1.06l.72-.72a.75.75 0 0 1 1.06 0L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0l.72.72Z",
    fill: "#2da44e"
  }
) }), "CheckIcon");
var XIcon = /* @__PURE__ */ __name(() => /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Svg, { viewBox: "0 0 16 16", style: styles3.ciStatusIcon, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
  Path,
  {
    d: "M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z",
    fill: "#cf222e"
  }
) }), "XIcon");
var PullRequestBoardingPass = /* @__PURE__ */ __name(({ pr }) => {
  const statusColor = pr.status === "open" ? "#2da44e" : pr.status === "merged" ? "#8250df" : "#6e7781";
  const ciStatusClass = pr.ciStatus === "passing" ? styles3.ciStatusPassing : pr.ciStatus === "failing" ? styles3.ciStatusFailing : styles3.ciStatusPassing;
  const ciStatusTextClass = pr.ciStatus === "passing" ? styles3.ciStatusTextPassing : pr.ciStatus === "failing" ? styles3.ciStatusTextFailing : styles3.ciStatusTextPassing;
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Document, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(Page, { size: [288, 432], style: styles3.page, children: [
    pr.qrCodeDataUrl && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Image, { style: styles3.qrCode, src: pr.qrCodeDataUrl }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(View, { style: styles3.boardingPassHeader, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { style: styles3.headerText, children: "Boarding Pass" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(View, { style: styles3.prInfo, children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(Text, { style: styles3.prNumber, children: [
        "#",
        pr.number
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(View, { style: [styles3.statusBadge, { backgroundColor: statusColor }], children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { style: styles3.statusText, children: pr.status }) })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { style: styles3.title, children: pr.title }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(View, { style: styles3.branchInfo, children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { style: styles3.branchText, children: pr.sourceBranch }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { style: styles3.arrowIcon, children: "\u2192" }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { style: styles3.branchText, children: pr.targetBranch })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(View, { style: styles3.diffStats, children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(Text, { style: styles3.diffAdded, children: [
        "+",
        pr.additions
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(Text, { style: styles3.diffRemoved, children: [
        "-",
        pr.deletions
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(View, { style: styles3.reviewersSection, children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { style: styles3.sectionTitle, children: "Reviewers" }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(View, { style: styles3.reviewersRow, children: pr.reviewers.slice(0, 3).map((reviewer, i2) => /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(View, { style: { flexDirection: "row", alignItems: "center", marginRight: 8 }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Image, { style: styles3.reviewerAvatar, src: reviewer.avatarUrl }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { style: styles3.reviewerName, children: reviewer.login })
      ] }, i2)) })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(View, { style: [styles3.ciStatus, ciStatusClass], children: [
      pr.ciStatus === "passing" ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(CheckIcon, {}) : pr.ciStatus === "failing" ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(XIcon, {}) : /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(CheckIcon, {}),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(Text, { style: [styles3.ciStatusText, ciStatusTextClass], children: [
        "CI ",
        pr.ciStatus === "passing" ? "Passed" : pr.ciStatus === "failing" ? "Failed" : "Pending"
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(View, { style: styles3.footer, children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(Text, { style: styles3.footerText, children: [
        "Author: ",
        pr.author
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(Text, { style: styles3.footerText, children: [
        "PR #",
        pr.number
      ] })
    ] })
  ] }) });
}, "PullRequestBoardingPass");

// ../../packages/capabilities/src/templates/ReleaseDeploymentTag.tsx
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
Font.register({
  family: "Inter",
  src: "https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff"
});
Font.register({
  family: "Fira Code",
  src: "https://cdn.jsdelivr.net/npm/@fontsource/fira-code@4.5.12/files/fira-code-latin-400-normal.woff"
});
var styles4 = StyleSheet.create({
  page: {
    flexDirection: "column",
    backgroundColor: "#ffffff",
    padding: 20,
    fontFamily: "Inter",
    position: "relative",
    border: "2pt solid #000"
  },
  header: {
    textAlign: "center",
    marginBottom: 20
  },
  title: {
    fontSize: 16,
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: 1,
    marginBottom: 5
  },
  subtitle: {
    fontSize: 10,
    color: "#666",
    textTransform: "uppercase",
    letterSpacing: 0.5
  },
  versionSection: {
    textAlign: "center",
    marginBottom: 15,
    backgroundColor: "#f6f8fa",
    padding: 15,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: "#000"
  },
  versionNumber: {
    fontSize: 32,
    fontWeight: "bold",
    color: "#000",
    marginBottom: 5
  },
  commitHash: {
    fontSize: 12,
    fontFamily: "Fira Code",
    color: "#666",
    marginBottom: 8
  },
  dateTime: {
    fontSize: 11,
    color: "#444",
    marginBottom: 3
  },
  deployerSection: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 20
  },
  deployerLabel: {
    fontSize: 10,
    color: "#666",
    marginRight: 8,
    textTransform: "uppercase"
  },
  deployerName: {
    fontSize: 12,
    fontWeight: "bold",
    color: "#000"
  },
  qrSection: {
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
    marginTop: "auto",
    paddingTop: 20,
    borderTopWidth: 1,
    borderTopColor: "#eaeaea"
  },
  qrCode: {
    width: 60,
    height: 60,
    marginRight: 15
  },
  qrLabel: {
    fontSize: 8,
    color: "#666",
    textAlign: "center",
    maxWidth: 80
  },
  tagCorner: {
    position: "absolute",
    width: 40,
    height: 40,
    backgroundColor: "#000"
  },
  topLeftCorner: {
    top: 0,
    left: 0,
    borderBottomRightRadius: 20
  },
  topRightCorner: {
    top: 0,
    right: 0,
    borderBottomLeftRadius: 20
  },
  bottomLeftCorner: {
    bottom: 0,
    left: 0,
    borderTopRightRadius: 20
  },
  bottomRightCorner: {
    bottom: 0,
    right: 0,
    borderTopLeftRadius: 20
  },
  innerCutout: {
    position: "absolute",
    width: 30,
    height: 30,
    backgroundColor: "#fff"
  },
  innerTopLeft: {
    top: 5,
    left: 5,
    borderBottomRightRadius: 15
  },
  innerTopRight: {
    top: 5,
    right: 5,
    borderBottomLeftRadius: 15
  },
  innerBottomLeft: {
    bottom: 5,
    left: 5,
    borderTopRightRadius: 15
  },
  innerBottomRight: {
    bottom: 5,
    right: 5,
    borderTopLeftRadius: 15
  }
});
var ReleaseDeploymentTag = /* @__PURE__ */ __name(({ release: release5 }) => {
  const formatDate = /* @__PURE__ */ __name((dateString) => {
    return new Date(dateString).toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  }, "formatDate");
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Document, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Page, { size: [288, 432], style: styles4.page, children: [
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(View, { style: [styles4.tagCorner, styles4.topLeftCorner] }),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(View, { style: [styles4.tagCorner, styles4.topRightCorner] }),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(View, { style: [styles4.tagCorner, styles4.bottomLeftCorner] }),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(View, { style: [styles4.tagCorner, styles4.bottomRightCorner] }),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(View, { style: [styles4.innerCutout, styles4.innerTopLeft] }),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(View, { style: [styles4.innerCutout, styles4.innerTopRight] }),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(View, { style: [styles4.innerCutout, styles4.innerBottomLeft] }),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(View, { style: [styles4.innerCutout, styles4.innerBottomRight] }),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(View, { style: styles4.header, children: [
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { style: styles4.title, children: "Release Tag" }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { style: styles4.subtitle, children: "Currently Deployed" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(View, { style: styles4.versionSection, children: [
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { style: styles4.versionNumber, children: release5.version }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { style: styles4.commitHash, children: release5.commitHash }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { style: styles4.dateTime, children: formatDate(release5.deploymentTime) })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(View, { style: styles4.deployerSection, children: [
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { style: styles4.deployerLabel, children: "Deployed by:" }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { style: styles4.deployerName, children: release5.deployer })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(View, { style: styles4.qrSection, children: release5.qrCodeDataUrl && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Image, { style: styles4.qrCode, src: release5.qrCodeDataUrl }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { style: styles4.qrLabel, children: "Scan for release notes" })
    ] }) })
  ] }) });
}, "ReleaseDeploymentTag");

// ../../packages/capabilities/src/templates/BuildReceipt.tsx
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
Font.register({
  family: "Fira Code",
  src: "https://cdn.jsdelivr.net/npm/@fontsource/fira-code@4.5.12/files/fira-code-latin-400-normal.woff"
});
Font.register({
  family: "Inter",
  src: "https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff"
});
var styles5 = StyleSheet.create({
  page: {
    flexDirection: "column",
    backgroundColor: "#ffffff",
    padding: 15,
    fontFamily: "Inter",
    border: "1pt dashed #666"
  },
  header: {
    textAlign: "center",
    marginBottom: 15,
    borderBottomWidth: 2,
    borderBottomColor: "#000",
    paddingBottom: 10
  },
  title: {
    fontSize: 18,
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: 1,
    marginBottom: 5
  },
  subtitle: {
    fontSize: 10,
    color: "#666",
    fontStyle: "italic"
  },
  buildInfo: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 12,
    padding: 8,
    backgroundColor: "#f8f9fa",
    borderRadius: 4
  },
  buildInfoItem: {
    flexDirection: "column"
  },
  buildInfoLabel: {
    fontSize: 8,
    color: "#666",
    textTransform: "uppercase",
    marginBottom: 2
  },
  buildInfoValue: {
    fontSize: 12,
    fontWeight: "bold",
    color: "#000"
  },
  statusSection: {
    textAlign: "center",
    marginBottom: 15
  },
  statusBadge: {
    backgroundColor: "#2da44e",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 20,
    alignSelf: "center"
  },
  statusBadgeFailing: {
    backgroundColor: "#cf222e"
  },
  statusText: {
    color: "#fff",
    fontSize: 14,
    fontWeight: "bold",
    textTransform: "uppercase"
  },
  progressBarContainer: {
    height: 8,
    backgroundColor: "#e1e4e8",
    borderRadius: 4,
    marginBottom: 10,
    overflow: "hidden"
  },
  progressBarFill: {
    height: "100%",
    backgroundColor: "#2da44e",
    borderRadius: 4
  },
  progressBarFillFailing: {
    backgroundColor: "#cf222e"
  },
  durationSection: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 12
  },
  clockIcon: {
    width: 12,
    height: 12,
    marginRight: 6
  },
  durationText: {
    fontSize: 11,
    color: "#444"
  },
  stagesSection: {
    marginBottom: 12
  },
  stagesTitle: {
    fontSize: 10,
    fontWeight: "bold",
    marginBottom: 6,
    textTransform: "uppercase",
    color: "#666"
  },
  stageRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 4,
    padding: 4
  },
  stageStatusIcon: {
    width: 8,
    height: 8,
    marginRight: 8
  },
  stageName: {
    fontSize: 9,
    color: "#444",
    flex: 1
  },
  stageDuration: {
    fontSize: 8,
    color: "#666",
    marginLeft: "auto"
  },
  errorLogSection: {
    backgroundColor: "#ffebe9",
    borderWidth: 1,
    borderColor: "#cf222e",
    borderRadius: 4,
    padding: 8,
    marginBottom: 12
  },
  errorLogTitle: {
    fontSize: 9,
    fontWeight: "bold",
    color: "#cf222e",
    marginBottom: 4,
    textTransform: "uppercase"
  },
  errorLogContent: {
    fontSize: 7,
    fontFamily: "Fira Code",
    color: "#444",
    whiteSpace: "pre-wrap"
  },
  footer: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: "auto",
    paddingTop: 10,
    borderTopWidth: 1,
    borderTopColor: "#eaeaea"
  },
  footerText: {
    fontSize: 8,
    color: "#666"
  },
  receiptDots: {
    flex: 1,
    flexDirection: "row",
    justifyContent: "space-between",
    paddingHorizontal: 5,
    marginHorizontal: 10
  },
  dot: {
    width: 2,
    height: 2,
    backgroundColor: "#ccc",
    borderRadius: 1
  }
});
var CheckIcon2 = /* @__PURE__ */ __name(() => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Svg, { viewBox: "0 0 16 16", style: styles5.stageStatusIcon, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
  Path,
  {
    d: "M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.75.75 0 0 1 0-1.06l.72-.72a.75.75 0 0 1 1.06 0L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0l.72.72Z",
    fill: "#2da44e"
  }
) }), "CheckIcon");
var XIcon2 = /* @__PURE__ */ __name(() => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Svg, { viewBox: "0 0 16 16", style: styles5.stageStatusIcon, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
  Path,
  {
    d: "M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z",
    fill: "#cf222e"
  }
) }), "XIcon");
var ClockIcon = /* @__PURE__ */ __name(() => /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(Svg, { viewBox: "0 0 16 16", style: styles5.clockIcon, children: [
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    Path,
    {
      d: "M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z",
      fill: "#666"
    }
  ),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    Path,
    {
      d: "M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z",
      fill: "#666"
    }
  )
] }), "ClockIcon");
var ReceiptDots = /* @__PURE__ */ __name(() => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(View, { style: styles5.receiptDots, children: [...Array(20)].map((_, i2) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(View, { style: styles5.dot }, i2)) }), "ReceiptDots");
var formatDuration = /* @__PURE__ */ __name((seconds) => {
  if (seconds < 60) return `${seconds}s`;
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return remainingSeconds > 0 ? `${minutes}m ${remainingSeconds}s` : `${minutes}m`;
}, "formatDuration");
var BuildReceipt = /* @__PURE__ */ __name(({ build }) => {
  const isSuccess = build.status === "success";
  const statusBadgeClass = isSuccess ? styles5.statusBadge : styles5.statusBadgeFailing;
  const progressFillClass = isSuccess ? styles5.progressBarFill : styles5.progressBarFillFailing;
  const progressWidth = isSuccess ? 100 : 75;
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Document, { children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(Page, { size: [288, 432], style: styles5.page, children: [
    /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(View, { style: styles5.header, children: [
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Text, { style: styles5.title, children: "Build Receipt" }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Text, { style: styles5.subtitle, children: "CI Pipeline Summary" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(View, { style: styles5.buildInfo, children: [
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(View, { style: styles5.buildInfoItem, children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Text, { style: styles5.buildInfoLabel, children: "Build ID" }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(Text, { style: styles5.buildInfoValue, children: [
          "#",
          build.buildId
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(View, { style: styles5.buildInfoItem, children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Text, { style: styles5.buildInfoLabel, children: "Time" }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Text, { style: styles5.buildInfoValue, children: new Date(build.startTime).toLocaleTimeString() })
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(View, { style: styles5.statusSection, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(View, { style: [styles5.statusBadge, statusBadgeClass], children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Text, { style: styles5.statusText, children: build.status === "success" ? "Success" : build.status === "failure" ? "Failed" : "Running" }) }) }),
    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(View, { style: styles5.progressBarContainer, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(View, { style: [styles5.progressBarFill, progressFillClass, { width: `${progressWidth}%` }] }) }),
    /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(View, { style: styles5.durationSection, children: [
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ClockIcon, {}),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(Text, { style: styles5.durationText, children: [
        "Duration: ",
        formatDuration(build.duration)
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(View, { style: styles5.stagesSection, children: [
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Text, { style: styles5.stagesTitle, children: "Pipeline Stages" }),
      build.stages.slice(0, 5).map((stage, i2) => /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(View, { style: styles5.stageRow, children: [
        stage.status === "success" ? /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CheckIcon2, {}) : stage.status === "failure" ? /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(XIcon2, {}) : /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(View, { style: styles5.stageStatusIcon }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Text, { style: styles5.stageName, children: stage.name }),
        stage.duration && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Text, { style: styles5.stageDuration, children: formatDuration(stage.duration) })
      ] }, i2))
    ] }),
    !isSuccess && build.errorLog && /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(View, { style: styles5.errorLogSection, children: [
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Text, { style: styles5.errorLogTitle, children: "Error Log" }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(Text, { style: styles5.errorLogContent, children: [
        build.errorLog.slice(0, 200),
        build.errorLog.length > 200 && "..."
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(View, { style: styles5.footer, children: [
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(Text, { style: styles5.footerText, children: [
        "Printed: ",
        (/* @__PURE__ */ new Date()).toLocaleDateString()
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ReceiptDots, {}),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(Text, { style: styles5.footerText, children: [
        "Build #",
        build.buildId
      ] })
    ] })
  ] }) });
}, "BuildReceipt");

// ../../packages/capabilities/src/templates/WifiAccessCard.tsx
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
Font.register({
  family: "Inter",
  src: "https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff"
});
Font.register({
  family: "Fira Code",
  src: "https://cdn.jsdelivr.net/npm/@fontsource/fira-code@4.5.12/files/fira-code-latin-400-normal.woff"
});
var styles6 = StyleSheet.create({
  page: {
    flexDirection: "column",
    backgroundColor: "#ffffff",
    padding: 20,
    fontFamily: "Inter",
    position: "relative",
    border: "2pt solid #333",
    borderRadius: 8
  },
  header: {
    textAlign: "center",
    marginBottom: 20
  },
  title: {
    fontSize: 20,
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: 2,
    marginBottom: 5,
    color: "#333"
  },
  subtitle: {
    fontSize: 10,
    color: "#666",
    textTransform: "uppercase",
    letterSpacing: 1
  },
  wifiIconContainer: {
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
    marginBottom: 25
  },
  wifiIcon: {
    fontSize: 40,
    color: "#333"
  },
  qrSection: {
    flexDirection: "row",
    justifyContent: "center",
    marginBottom: 25
  },
  qrCode: {
    width: 120,
    height: 120,
    borderWidth: 2,
    borderColor: "#333",
    borderRadius: 8
  },
  networkInfo: {
    backgroundColor: "#f8f9fa",
    padding: 15,
    borderRadius: 8,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: "#ddd"
  },
  infoRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 12
  },
  infoLabel: {
    fontSize: 10,
    fontWeight: "bold",
    textTransform: "uppercase",
    color: "#666",
    width: 60
  },
  infoValue: {
    fontSize: 14,
    fontWeight: "bold",
    color: "#000",
    flex: 1
  },
  passwordContainer: {
    backgroundColor: "#fff",
    padding: 8,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: "#333",
    borderStyle: "dashed"
  },
  passwordText: {
    fontSize: 16,
    fontFamily: "Fira Code",
    color: "#000",
    textAlign: "center",
    letterSpacing: 2
  },
  instructions: {
    textAlign: "center",
    marginTop: "auto",
    paddingTop: 20,
    borderTopWidth: 1,
    borderTopColor: "#eaeaea"
  },
  instructionText: {
    fontSize: 9,
    color: "#666",
    marginBottom: 5,
    lineHeight: 1.4
  },
  footer: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: 15
  },
  footerText: {
    fontSize: 8,
    color: "#999"
  },
  cornerDecoration: {
    position: "absolute",
    width: 20,
    height: 20
  },
  topLeft: {
    top: 10,
    left: 10,
    borderTopWidth: 2,
    borderLeftWidth: 2,
    borderTopColor: "#333",
    borderLeftColor: "#333"
  },
  topRight: {
    top: 10,
    right: 10,
    borderTopWidth: 2,
    borderRightWidth: 2,
    borderTopColor: "#333",
    borderRightColor: "#333"
  },
  bottomLeft: {
    bottom: 10,
    left: 10,
    borderBottomWidth: 2,
    borderLeftWidth: 2,
    borderBottomColor: "#333",
    borderLeftColor: "#333"
  },
  bottomRight: {
    bottom: 10,
    right: 10,
    borderBottomWidth: 2,
    borderRightWidth: 2,
    borderBottomColor: "#333",
    borderRightColor: "#333"
  }
});
var WifiIcon = /* @__PURE__ */ __name(() => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(View, { style: styles6.wifiIconContainer, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Text, { style: styles6.wifiIcon, children: "\u{1F4F6}" }) }), "WifiIcon");
var WifiAccessCard = /* @__PURE__ */ __name(({ wifi }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Document, { children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(Page, { size: [288, 432], style: styles6.page, children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(View, { style: [styles6.cornerDecoration, styles6.topLeft] }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(View, { style: [styles6.cornerDecoration, styles6.topRight] }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(View, { style: [styles6.cornerDecoration, styles6.bottomLeft] }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(View, { style: [styles6.cornerDecoration, styles6.bottomRight] }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(View, { style: styles6.header, children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Text, { style: styles6.title, children: "Wi-Fi Access" }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Text, { style: styles6.subtitle, children: "Guest Network" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(WifiIcon, {}),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(View, { style: styles6.qrSection, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Image, { style: styles6.qrCode, src: wifi.qrCodeDataUrl }) }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(View, { style: styles6.networkInfo, children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(View, { style: styles6.infoRow, children: [
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Text, { style: styles6.infoLabel, children: "Network:" }),
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Text, { style: styles6.infoValue, children: wifi.ssid })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(View, { style: styles6.infoRow, children: [
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Text, { style: styles6.infoLabel, children: "Security:" }),
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Text, { style: styles6.infoValue, children: wifi.security })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(View, { style: styles6.infoRow, children: [
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Text, { style: styles6.infoLabel, children: "Password:" }),
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(View, { style: styles6.passwordContainer, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Text, { style: styles6.passwordText, children: wifi.password }) })
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(View, { style: styles6.instructions, children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Text, { style: styles6.instructionText, children: "Scan QR code to connect automatically" }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Text, { style: styles6.instructionText, children: "Or select network manually and enter password" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(View, { style: styles6.footer, children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(Text, { style: styles6.footerText, children: [
        "Generated: ",
        (/* @__PURE__ */ new Date()).toLocaleDateString()
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Text, { style: styles6.footerText, children: "Guest Access" })
    ] })
  ] }) });
}, "WifiAccessCard");

// ../../packages/capabilities/src/templates/AssetDeviceTag.tsx
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
Font.register({
  family: "Inter",
  src: "https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff"
});
Font.register({
  family: "Fira Code",
  src: "https://cdn.jsdelivr.net/npm/@fontsource/fira-code@4.5.12/files/fira-code-latin-400-normal.woff"
});
var styles7 = StyleSheet.create({
  page: {
    flexDirection: "column",
    backgroundColor: "#ffffff",
    padding: 15,
    fontFamily: "Inter",
    position: "relative",
    border: "2pt solid #000"
  },
  header: {
    textAlign: "center",
    marginBottom: 12,
    borderBottomWidth: 2,
    borderBottomColor: "#000",
    paddingBottom: 8
  },
  propertyLabel: {
    fontSize: 12,
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: 1,
    marginBottom: 4,
    color: "#000"
  },
  propertySubtitle: {
    fontSize: 8,
    color: "#666",
    fontStyle: "italic"
  },
  deviceInfo: {
    marginBottom: 15
  },
  deviceName: {
    fontSize: 16,
    fontWeight: "bold",
    marginBottom: 4,
    color: "#000"
  },
  deviceModel: {
    fontSize: 12,
    color: "#666",
    marginBottom: 8
  },
  assetSection: {
    backgroundColor: "#f8f9fa",
    padding: 12,
    borderRadius: 4,
    marginBottom: 15,
    borderWidth: 1,
    borderColor: "#ddd"
  },
  assetIdRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8
  },
  assetIdLabel: {
    fontSize: 10,
    fontWeight: "bold",
    textTransform: "uppercase",
    color: "#666",
    width: 60
  },
  assetIdValue: {
    fontSize: 14,
    fontFamily: "Fira Code",
    color: "#000",
    flex: 1,
    fontWeight: "bold"
  },
  barcodeContainer: {
    alignItems: "center",
    marginVertical: 10
  },
  barcode: {
    height: 40,
    width: "100%"
  },
  contactSection: {
    marginBottom: 15
  },
  sectionTitle: {
    fontSize: 10,
    fontWeight: "bold",
    textTransform: "uppercase",
    color: "#666",
    marginBottom: 6
  },
  contactInfo: {
    backgroundColor: "#fff3cd",
    padding: 8,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: "#ffeaa7"
  },
  contactText: {
    fontSize: 9,
    color: "#856404",
    lineHeight: 1.3
  },
  returnInstructions: {
    fontSize: 9,
    color: "#666",
    lineHeight: 1.3,
    fontStyle: "italic"
  },
  warningBorder: {
    borderWidth: 2,
    borderColor: "#dc3545",
    borderRadius: 4,
    padding: 2
  },
  qrSection: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: "auto",
    paddingTop: 15,
    borderTopWidth: 1,
    borderTopColor: "#eaeaea"
  },
  qrCode: {
    width: 50,
    height: 50
  },
  qrLabel: {
    fontSize: 8,
    color: "#666",
    textAlign: "center",
    flex: 1,
    marginLeft: 10
  },
  companyInfo: {
    alignItems: "flex-end"
  },
  companyName: {
    fontSize: 10,
    fontWeight: "bold",
    color: "#000"
  },
  tagDate: {
    fontSize: 8,
    color: "#666"
  },
  holePunch: {
    position: "absolute",
    top: 10,
    left: 15,
    width: 8,
    height: 8,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: "#000",
    backgroundColor: "#fff"
  }
});
var AssetDeviceTag = /* @__PURE__ */ __name(({ asset }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Document, { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(Page, { size: [288, 432], style: styles7.page, children: [
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(View, { style: styles7.holePunch }),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(View, { style: styles7.header, children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(Text, { style: styles7.propertyLabel, children: [
        "Property of ",
        asset.companyName
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Text, { style: styles7.propertySubtitle, children: "Company Asset - Do Not Remove" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(View, { style: styles7.deviceInfo, children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Text, { style: styles7.deviceName, children: asset.deviceName }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Text, { style: styles7.deviceModel, children: asset.deviceModel })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(View, { style: styles7.assetSection, children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(View, { style: styles7.assetIdRow, children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Text, { style: styles7.assetIdLabel, children: "Asset ID:" }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Text, { style: styles7.assetIdValue, children: asset.assetId })
      ] }),
      asset.barcodeDataUrl && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(View, { style: styles7.barcodeContainer, children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Image, { style: styles7.barcode, src: asset.barcodeDataUrl }) })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(View, { style: styles7.contactSection, children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Text, { style: styles7.sectionTitle, children: "Return Instructions" }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(View, { style: [styles7.warningBorder, styles7.contactInfo], children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(Text, { style: styles7.contactText, children: [
          "If found, please return to ",
          asset.contactName
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(Text, { style: styles7.contactText, children: [
          "Email: ",
          asset.contactEmail
        ] }),
        asset.contactPhone && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(Text, { style: styles7.contactText, children: [
          "Phone: ",
          asset.contactPhone
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Text, { style: styles7.returnInstructions, children: "This device is company property. Unauthorized removal is prohibited." })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(View, { style: styles7.qrSection, children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(View, { style: { flexDirection: "row", alignItems: "center" }, children: [
        asset.qrCodeDataUrl && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Image, { style: styles7.qrCode, src: asset.qrCodeDataUrl }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Text, { style: styles7.qrLabel, children: "Scan for asset information" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(View, { style: styles7.companyInfo, children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Text, { style: styles7.companyName, children: asset.companyName }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(Text, { style: styles7.tagDate, children: [
          "Tagged: ",
          (/* @__PURE__ */ new Date()).toLocaleDateString()
        ] })
      ] })
    ] })
  ] }) });
}, "AssetDeviceTag");

// ../../packages/capabilities/src/templates/DailyTodoList.tsx
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
Font.register({
  family: "Inter",
  src: "https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff"
});
Font.register({
  family: "Fira Code",
  src: "https://cdn.jsdelivr.net/npm/@fontsource/fira-code@4.5.12/files/fira-code-latin-400-normal.woff"
});
var styles8 = StyleSheet.create({
  page: {
    flexDirection: "column",
    backgroundColor: "#ffffff",
    padding: 20,
    fontFamily: "Inter",
    position: "relative",
    border: "1pt solid #ddd"
  },
  header: {
    textAlign: "center",
    marginBottom: 20,
    borderBottomWidth: 2,
    borderBottomColor: "#000",
    paddingBottom: 12
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: 2,
    marginBottom: 5,
    color: "#000"
  },
  date: {
    fontSize: 14,
    color: "#666",
    fontWeight: "normal"
  },
  quoteSection: {
    backgroundColor: "#f8f9fa",
    padding: 12,
    borderRadius: 8,
    marginBottom: 20,
    borderLeftWidth: 4,
    borderLeftColor: "#6c757d"
  },
  quoteText: {
    fontSize: 11,
    color: "#495057",
    lineHeight: 1.4,
    marginBottom: 4
  },
  quoteAuthor: {
    fontSize: 9,
    color: "#6c757d",
    textAlign: "right",
    fontWeight: "bold"
  },
  todoSection: {
    flex: 1
  },
  sectionTitle: {
    fontSize: 12,
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: 1,
    marginBottom: 15,
    color: "#000",
    borderBottomWidth: 1,
    borderBottomColor: "#ddd",
    paddingBottom: 5
  },
  todoItem: {
    flexDirection: "row",
    alignItems: "flex-start",
    marginBottom: 12,
    padding: 8,
    borderRadius: 4,
    backgroundColor: "#fafafa",
    borderWidth: 1,
    borderColor: "#e9ecef"
  },
  checkbox: {
    width: 16,
    height: 16,
    borderWidth: 2,
    borderColor: "#000",
    borderRadius: 3,
    marginRight: 12,
    marginTop: 1
  },
  todoNumber: {
    position: "absolute",
    top: -2,
    left: -2,
    width: 20,
    height: 20,
    alignItems: "center",
    justifyContent: "center",
    fontSize: 8,
    fontWeight: "bold",
    color: "#666"
  },
  todoContent: {
    flex: 1,
    minHeight: 30
  },
  todoLine: {
    width: "100%",
    height: 1,
    backgroundColor: "#ccc",
    marginTop: 8
  },
  footer: {
    marginTop: 20,
    paddingTop: 15,
    borderTopWidth: 1,
    borderTopColor: "#eaeaea",
    alignItems: "center"
  },
  footerText: {
    fontSize: 8,
    color: "#999",
    textAlign: "center"
  },
  motivationalSection: {
    backgroundColor: "#e7f5ff",
    padding: 8,
    borderRadius: 4,
    marginTop: 10,
    border: "1pt solid #74c0fc"
  },
  motivationalText: {
    fontSize: 9,
    color: "#1864ab",
    textAlign: "center",
    fontWeight: "bold"
  }
});
var CheckboxWithNumber = /* @__PURE__ */ __name(({ number: number3 }) => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(View, { style: styles8.checkbox, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(View, { style: styles8.todoNumber, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Text, { children: number3 }) }) }), "CheckboxWithNumber");
var TodoItem = /* @__PURE__ */ __name(({ number: number3 }) => /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(View, { style: styles8.todoItem, children: [
  /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(CheckboxWithNumber, { number: number3 }),
  /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(View, { style: styles8.todoContent, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(View, { style: styles8.todoLine }) })
] }), "TodoItem");
var quotes = [
  { text: "The secret of getting ahead is getting started.", author: "Mark Twain" },
  { text: "It always seems impossible until it's done.", author: "Nelson Mandela" },
  { text: "Don't watch the clock; do what it does. Keep going.", author: "Sam Levenson" },
  { text: "The future depends on what you do today.", author: "Mahatma Gandhi" },
  { text: "Success is not final, failure is not fatal.", author: "Winston Churchill" }
];
var getRandomQuote = /* @__PURE__ */ __name(() => {
  return quotes[Math.floor(Math.random() * quotes.length)];
}, "getRandomQuote");
var DailyTodoList = /* @__PURE__ */ __name(({ todo }) => {
  const quote = todo.quote || getRandomQuote();
  const itemCount = todo.itemCount || 10;
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Document, { children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(Page, { size: [288, 432], style: styles8.page, children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(View, { style: styles8.header, children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Text, { style: styles8.title, children: "Daily Todo" }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Text, { style: styles8.date, children: todo.date })
    ] }),
    quote && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(View, { style: styles8.quoteSection, children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(Text, { style: styles8.quoteText, children: [
        '"',
        quote.text,
        '"'
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(Text, { style: styles8.quoteAuthor, children: [
        "\u2014 ",
        quote.author
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(View, { style: styles8.todoSection, children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Text, { style: styles8.sectionTitle, children: "Today's Tasks" }),
      [...Array(itemCount)].map((_, i2) => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(TodoItem, { number: i2 + 1 }, i2))
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(View, { style: styles8.motivationalSection, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Text, { style: styles8.motivationalText, children: "Make today count! \u2728" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(View, { style: styles8.footer, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(Text, { style: styles8.footerText, children: [
      "Printed on ",
      (/* @__PURE__ */ new Date()).toLocaleDateString(),
      " \u2022 Daily Todo List"
    ] }) })
  ] }) });
}, "DailyTodoList");

// ../../packages/capabilities/src/templates/Recipe.tsx
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_react10 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
Font.register({
  family: "Fira Code",
  src: "https://cdn.jsdelivr.net/npm/@fontsource/fira-code@4.5.12/files/fira-code-latin-400-normal.woff"
});
Font.register({
  family: "Inter",
  src: "https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff"
});
var PAGE_WIDTH = 288;
var PAGE_HEIGHT = 432;
var CONTENT_MARGIN = 10;
var styles9 = StyleSheet.create({
  page: {
    fontFamily: "Inter",
    width: PAGE_WIDTH,
    height: PAGE_HEIGHT,
    padding: 0,
    backgroundColor: "#fff"
  },
  borderWrapper: {
    margin: 8,
    border: "2pt solid #000",
    height: "96%",
    display: "flex",
    flexDirection: "column",
    justifyContent: "space-between"
  },
  content: {
    padding: CONTENT_MARGIN,
    flexGrow: 1
  },
  header: {
    flexDirection: "row",
    justifyContent: "space-between",
    borderBottomWidth: 1.5,
    borderBottomColor: "#000",
    paddingBottom: 8,
    marginBottom: 8
  },
  headerText: {
    flex: 1,
    paddingRight: 10
  },
  title: {
    fontSize: 14,
    fontWeight: "bold",
    marginBottom: 4,
    textTransform: "uppercase"
  },
  metadata: {
    fontSize: 8,
    fontFamily: "Fira Code",
    color: "#000",
    marginBottom: 1
  },
  qrCode: {
    width: 60,
    height: 60
  },
  sectionTitle: {
    fontSize: 10,
    fontWeight: "bold",
    marginTop: 6,
    marginBottom: 4,
    backgroundColor: "#000",
    color: "#fff",
    padding: "2 4",
    alignSelf: "flex-start",
    textTransform: "uppercase"
  },
  row: {
    flexDirection: "row",
    marginBottom: 2,
    alignItems: "flex-start"
  },
  ingredient: {
    fontSize: 9,
    fontFamily: "Fira Code",
    flex: 1
  },
  stepContainer: {
    flexDirection: "row",
    marginBottom: 5
  },
  stepIndex: {
    fontSize: 9,
    fontFamily: "Fira Code",
    fontWeight: "bold",
    width: 18,
    marginRight: 2
  },
  step: {
    fontSize: 9,
    lineHeight: 1.3,
    flex: 1,
    textAlign: "left"
  },
  image: {
    marginBottom: 8,
    height: 90,
    objectFit: "cover",
    borderWidth: 1,
    borderColor: "#000"
  },
  footer: {
    borderTopWidth: 1,
    borderTopColor: "#000",
    paddingTop: 4,
    paddingHorizontal: 10,
    paddingBottom: 6,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center"
  },
  footerText: {
    fontSize: 7,
    fontFamily: "Fira Code"
  }
});
var Recipe = /* @__PURE__ */ __name(({ recipe }) => {
  const sourceKeys = ["source", "url", "link"];
  const sourceKey = Object.keys(recipe.metadata || {}).find((k3) => sourceKeys.includes(k3.toLowerCase()));
  const sourceUrl = sourceKey && recipe.metadata ? recipe.metadata[sourceKey] : null;
  const displayMetadata = Object.entries(recipe.metadata || {}).filter(([k3]) => k3 !== sourceKey);
  const MAX_CONTENT_HEIGHT = 260;
  const stepFontSize = 9;
  const stepLineHeight = 1.3;
  const stepMargin = 5;
  const charsPerLine = 36;
  const stepChunks = [];
  let currentChunk = [];
  let currentHeight = 0;
  recipe.steps.forEach((step) => {
    const lines = Math.ceil(step.length / charsPerLine) || 1;
    const stepHeight = lines * stepFontSize * stepLineHeight + stepMargin;
    if (currentHeight + stepHeight > MAX_CONTENT_HEIGHT && currentChunk.length > 0) {
      stepChunks.push(currentChunk);
      currentChunk = [];
      currentHeight = 0;
    }
    currentChunk.push(step);
    currentHeight += stepHeight;
  });
  if (currentChunk.length > 0) {
    stepChunks.push(currentChunk);
  }
  if (stepChunks.length === 0) stepChunks.push([]);
  const chunkStartIndices = [];
  let runningTotal = 0;
  for (const chunk of stepChunks) {
    chunkStartIndices.push(runningTotal);
    runningTotal += chunk.length;
  }
  const hasImage = !!recipe.image;
  const ingLimit = hasImage ? 12 : 18;
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(Document, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Page, { size: [PAGE_WIDTH, PAGE_HEIGHT], style: styles9.page, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(View, { style: styles9.borderWrapper, children: [
      /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(View, { style: styles9.content, children: [
        /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(View, { style: styles9.header, children: [
          /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(View, { style: styles9.headerText, children: [
            /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Text, { style: styles9.title, children: recipe.title }),
            displayMetadata.map(([key, val]) => /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(Text, { style: styles9.metadata, children: [
              key.toUpperCase(),
              ": ",
              val
            ] }, key))
          ] }),
          sourceUrl && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
            Image,
            {
              src: `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(sourceUrl)}`,
              style: styles9.qrCode
            }
          )
        ] }),
        recipe.image && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Image, { src: recipe.image, style: styles9.image }),
        /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(View, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Text, { style: styles9.sectionTitle, children: "Ingredients" }),
          recipe.ingredients.slice(0, ingLimit).map((ing, i2) => /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(View, { style: styles9.row, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(Text, { style: styles9.ingredient, children: [
            ing.quantity,
            " ",
            ing.unit,
            " ",
            ing.name
          ] }) }, i2)),
          recipe.ingredients.length > ingLimit && /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(Text, { style: { fontSize: 8, fontStyle: "italic", marginTop: 4 }, children: [
            "...and ",
            recipe.ingredients.length - ingLimit,
            " more"
          ] })
        ] }),
        recipe.cookware.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(View, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Text, { style: styles9.sectionTitle, children: "Cookware" }),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(View, { style: { flexDirection: "row", flexWrap: "wrap" }, children: recipe.cookware.slice(0, 6).map((c2, i2) => /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(Text, { style: [styles9.ingredient, { marginRight: 8, marginBottom: 4, flexGrow: 0, flexShrink: 0, flexBasis: "auto" }], children: [
            "\u2022 ",
            c2.name
          ] }, i2)) })
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(View, { style: styles9.footer, children: [
        /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Text, { style: styles9.footerText, children: "PRINTY \u2022 RECIPE" }),
        /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(Text, { style: styles9.footerText, children: [
          "1 / ",
          1 + stepChunks.length
        ] })
      ] })
    ] }) }),
    stepChunks.map((chunk, pageIndex) => {
      const startIndex = chunkStartIndices[pageIndex] ?? 0;
      const endIndex = startIndex + chunk.length;
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Page, { size: [PAGE_WIDTH, PAGE_HEIGHT], style: styles9.page, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(View, { style: styles9.borderWrapper, children: [
        /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(View, { style: styles9.content, children: [
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(View, { style: styles9.header, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Text, { style: styles9.title, children: recipe.title }) }),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Text, { style: [styles9.sectionTitle, { marginBottom: 10 }], children: startIndex + 1 === endIndex ? `Step ${startIndex + 1}` : `Steps (${startIndex + 1}-${endIndex})` }),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(View, { children: chunk.map((step, i2) => /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(View, { style: [styles9.stepContainer, { marginBottom: stepMargin }], children: [
            /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(Text, { style: [styles9.stepIndex, { fontSize: stepFontSize }], children: [
              startIndex + i2 + 1,
              "."
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Text, { style: [styles9.step, { fontSize: stepFontSize, lineHeight: stepLineHeight }], children: step })
          ] }, i2)) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(View, { style: styles9.footer, children: [
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Text, { style: styles9.footerText, children: "PRINTY \u2022 RECIPE" }),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(Text, { style: styles9.footerText, children: [
            pageIndex + 2,
            " / ",
            1 + stepChunks.length
          ] })
        ] })
      ] }) }, pageIndex);
    })
  ] });
}, "Recipe");

// ../../packages/capabilities/src/templates/ColoringPage.tsx
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_react11 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
Font.register({
  family: "Fira Code",
  src: "https://cdn.jsdelivr.net/npm/@fontsource/fira-code@4.5.12/files/fira-code-latin-400-normal.woff"
});
Font.register({
  family: "Inter",
  src: "https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff"
});
var PAGE_WIDTH2 = 288;
var PAGE_HEIGHT2 = 432;
var MARGIN = 15;
var styles10 = StyleSheet.create({
  page: {
    fontFamily: "Inter",
    width: PAGE_WIDTH2,
    height: PAGE_HEIGHT2,
    padding: MARGIN,
    backgroundColor: "#fff"
  },
  border: {
    border: "3pt dashed #000",
    height: "100%",
    padding: 10,
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "space-between"
  },
  header: {
    width: "100%",
    marginBottom: 10,
    alignItems: "center"
  },
  title: {
    fontSize: 16,
    fontWeight: "bold",
    textAlign: "center",
    textTransform: "uppercase"
  },
  imageContainer: {
    flexGrow: 1,
    width: "100%",
    justifyContent: "center",
    alignItems: "center",
    border: "1pt solid #ccc",
    marginBottom: 10
  },
  image: {
    width: "100%",
    height: "100%",
    objectFit: "contain"
  },
  infoSection: {
    width: "100%",
    marginBottom: 10
  },
  infoText: {
    fontSize: 9,
    textAlign: "center",
    marginBottom: 5
  },
  colorsSection: {
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
    gap: 8
  },
  colorBubble: {
    width: 20,
    height: 20,
    borderRadius: 10,
    border: "1pt solid #000"
  },
  footer: {
    marginTop: 5,
    borderTop: "1pt solid #000",
    width: "100%",
    paddingTop: 4,
    flexDirection: "row",
    justifyContent: "space-between"
  },
  footerText: {
    fontSize: 6,
    fontFamily: "Fira Code",
    color: "#666"
  }
});
var ColoringPage = /* @__PURE__ */ __name(({ data: data2 }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Document, { children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Page, { size: [PAGE_WIDTH2, PAGE_HEIGHT2], style: styles10.page, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(View, { style: styles10.border, children: [
    /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(View, { style: styles10.header, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Text, { style: styles10.title, children: data2.title }) }),
    /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(View, { style: styles10.imageContainer, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Image, { src: data2.imageUrl, style: styles10.image }) }),
    /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(View, { style: styles10.infoSection, children: [
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Text, { style: styles10.infoText, children: data2.description || "Color this in!" }),
      /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(View, { style: { alignItems: "center", marginTop: 8 }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Text, { style: { fontSize: 8, marginBottom: 4, fontWeight: "bold" }, children: "Suggested Colors:" }),
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(View, { style: styles10.colorsSection, children: data2.suggestedColors.map((color, i2) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(View, { style: { alignItems: "center", marginRight: 5 }, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Text, { style: { fontSize: 6, marginTop: 2 }, children: color }) }, i2)) })
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(View, { style: styles10.footer, children: [
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Text, { style: styles10.footerText, children: "PRINTY \u2022 COLORING" }),
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Text, { style: styles10.footerText, children: (/* @__PURE__ */ new Date()).toLocaleDateString() })
    ] })
  ] }) }) });
}, "ColoringPage");

// src/routes/print.ts
var printRoutes = new Hono2();
async function renderPdfResponse(element) {
  const stream2 = await index.renderToStream(element);
  return new Response(stream2, {
    headers: { "Content-Type": "application/pdf" }
  });
}
__name(renderPdfResponse, "renderPdfResponse");
printRoutes.post("/github", async (c2) => {
  try {
    const body = await c2.req.json();
    const data2 = await fetchGithubIssue(body.url);
    data2.qrCodeDataUrl = await import_qrcode.default.toDataURL(data2.url);
    const element = import_react12.default.createElement(GithubIssueLabel, { issue: data2 });
    return renderPdfResponse(element);
  } catch (error3) {
    const message = error3 instanceof Error ? error3.message : "Unknown error";
    return c2.json({ error: message }, 500);
  }
});
printRoutes.post("/linear", async (c2) => {
  try {
    const body = await c2.req.json();
    const data2 = await fetchLinearIssue(body.url);
    data2.qrCodeDataUrl = await import_qrcode.default.toDataURL(data2.url);
    const element = import_react12.default.createElement(LinearIssueLabel, { issue: data2 });
    return renderPdfResponse(element);
  } catch (error3) {
    const message = error3 instanceof Error ? error3.message : "Unknown error";
    return c2.json({ error: message }, 500);
  }
});
printRoutes.post("/recipe", async (c2) => {
  try {
    const body = await c2.req.json();
    let recipeData;
    if (body.data) {
      recipeData = body.data;
    } else {
      recipeData = {
        title: body.name,
        ingredients: [{ name: "Mock Ingredient", quantity: "1", unit: "unit" }],
        cookware: [],
        steps: ["Mock Step 1", "Mock Step 2"]
      };
    }
    const element = import_react12.default.createElement(Recipe, { recipe: recipeData });
    return renderPdfResponse(element);
  } catch (error3) {
    const message = error3 instanceof Error ? error3.message : "Unknown error";
    return c2.json({ error: message }, 500);
  }
});
printRoutes.post("/coloring", async (c2) => {
  try {
    const body = await c2.req.json();
    const data2 = await generateColoringPage(body.prompt);
    const element = import_react12.default.createElement(ColoringPage, { data: data2 });
    return renderPdfResponse(element);
  } catch (error3) {
    const message = error3 instanceof Error ? error3.message : "Unknown error";
    return c2.json({ error: message }, 500);
  }
});
printRoutes.post("/wifi", async (c2) => {
  try {
    const body = await c2.req.json();
    const wifiString = `WIFI:T:${body.security};S:${body.ssid};P:${body.password};;`;
    const qrCodeDataUrl = await import_qrcode.default.toDataURL(wifiString);
    const data2 = { ...body, qrCodeDataUrl };
    const element = import_react12.default.createElement(WifiAccessCard, { wifi: data2 });
    return renderPdfResponse(element);
  } catch (error3) {
    const message = error3 instanceof Error ? error3.message : "Unknown error";
    return c2.json({ error: message }, 500);
  }
});
printRoutes.post("/asset", async (c2) => {
  try {
    const body = await c2.req.json();
    const assetUrl = `https://inventory.printy.mobile/asset/${body.assetId}`;
    const qrCodeDataUrl = await import_qrcode.default.toDataURL(assetUrl);
    const data2 = { ...body, qrCodeDataUrl };
    const element = import_react12.default.createElement(AssetDeviceTag, { asset: data2 });
    return renderPdfResponse(element);
  } catch (error3) {
    const message = error3 instanceof Error ? error3.message : "Unknown error";
    return c2.json({ error: message }, 500);
  }
});
printRoutes.post("/pr", async (c2) => {
  try {
    const body = await c2.req.json();
    let qrCodeDataUrl = body.qrCodeDataUrl;
    if (body.url && !qrCodeDataUrl) {
      qrCodeDataUrl = await import_qrcode.default.toDataURL(body.url);
    }
    const data2 = { ...body, qrCodeDataUrl };
    const element = import_react12.default.createElement(PullRequestBoardingPass, { pr: data2 });
    return renderPdfResponse(element);
  } catch (error3) {
    const message = error3 instanceof Error ? error3.message : "Unknown error";
    return c2.json({ error: message }, 500);
  }
});
printRoutes.post("/release", async (c2) => {
  try {
    const body = await c2.req.json();
    let qrCodeDataUrl = body.qrCodeDataUrl;
    if (body.releaseNotesUrl && !qrCodeDataUrl) {
      qrCodeDataUrl = await import_qrcode.default.toDataURL(body.releaseNotesUrl);
    }
    const data2 = { ...body, qrCodeDataUrl };
    const element = import_react12.default.createElement(ReleaseDeploymentTag, { release: data2 });
    return renderPdfResponse(element);
  } catch (error3) {
    const message = error3 instanceof Error ? error3.message : "Unknown error";
    return c2.json({ error: message }, 500);
  }
});
printRoutes.post("/build", async (c2) => {
  try {
    const body = await c2.req.json();
    const element = import_react12.default.createElement(BuildReceipt, { build: body });
    return renderPdfResponse(element);
  } catch (error3) {
    const message = error3 instanceof Error ? error3.message : "Unknown error";
    return c2.json({ error: message }, 500);
  }
});
printRoutes.post("/todo", async (c2) => {
  try {
    const body = await c2.req.json();
    const element = import_react12.default.createElement(DailyTodoList, { todo: body });
    return renderPdfResponse(element);
  } catch (error3) {
    const message = error3 instanceof Error ? error3.message : "Unknown error";
    return c2.json({ error: message }, 500);
  }
});
var print_default = printRoutes;

// src/app.ts
var app = new Hono2();
app.use(
  "*",
  cors({
    origin: [
      "http://localhost:8930",
      "http://localhost:8931",
      "http://localhost:8932",
      "http://localhost:3000",
      "https://printy.mobile",
      "https://api.printy.mobile"
    ],
    allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowHeaders: ["Content-Type", "Authorization"],
    credentials: true
  })
);
app.get("/", (c2) => {
  return c2.json({
    name: "Printy Mobile Printer API",
    version: "1.0.0",
    endpoints: [
      "POST /print/github",
      "POST /print/linear",
      "POST /print/recipe",
      "POST /print/coloring",
      "POST /print/wifi",
      "POST /print/asset",
      "POST /print/pr",
      "POST /print/release",
      "POST /print/build",
      "POST /print/todo"
    ]
  });
});
app.get("/health", (c2) => {
  return c2.json({ status: "ok", timestamp: (/* @__PURE__ */ new Date()).toISOString() });
});
app.route("/print", print_default);
var app_default = app;

// src/index.ts
var src_default2 = app_default;

// ../../node_modules/.pnpm/wrangler@4.49.0_@cloudflare+workers-types@4.20250906.0/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var drainBody = /* @__PURE__ */ __name(async (request, env4, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env4);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e4) {
      console.error("Failed to drain the unused request body.", e4);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// ../../node_modules/.pnpm/wrangler@4.49.0_@cloudflare+workers-types@4.20250906.0/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function reduceError(e4) {
  return {
    name: e4?.name,
    message: e4?.message ?? String(e4),
    stack: e4?.stack,
    cause: e4?.cause === void 0 ? void 0 : reduceError(e4.cause)
  };
}
__name(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name(async (request, env4, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env4);
  } catch (e4) {
    const error3 = reduceError(e4);
    return Response.json(error3, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-ub9Yx7/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = src_default2;

// ../../node_modules/.pnpm/wrangler@4.49.0_@cloudflare+workers-types@4.20250906.0/node_modules/wrangler/templates/middleware/common.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request, env4, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env4, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request, env4, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env4, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-ub9Yx7/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request, env4, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env4, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request, env4, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type2, init4) {
        if (type2 === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init4.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env4, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request, env4, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request, env4, ctx) => {
      this.env = env4;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type2, init4) => {
      if (type2 === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init4.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    }, "#dispatcher");
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
/*! Bundled license information:

react/cjs/react.production.js:
  (**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

crypto-js/ripemd160.js:
  (** @preserve
  	(c) 2012 by Cdric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)

crypto-js/mode-ctr-gladman.js:
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)

scheduler/cjs/scheduler.production.js:
  (**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

react/cjs/react-jsx-runtime.production.js:
  (**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

sharp/lib/is.js:
sharp/lib/libvips.js:
sharp/lib/sharp.js:
sharp/lib/constructor.js:
sharp/lib/input.js:
sharp/lib/resize.js:
sharp/lib/composite.js:
sharp/lib/operation.js:
sharp/lib/colour.js:
sharp/lib/channel.js:
sharp/lib/output.js:
sharp/lib/utility.js:
sharp/lib/index.js:
  (*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  *)

@react-pdf/png-js/lib/png-js.browser.js:
@react-pdf/pdfkit/lib/pdfkit.browser.js:
@react-pdf/image/lib/index.browser.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

@react-pdf/textkit/lib/textkit.js:
  (**
   * @param nodes
   * @param availableWidths
   * @param tolerance
   * @preserve Knuth and Plass line breaking algorithm in JavaScript
   *)

@react-pdf/reconciler/lib/reconciler-31.js:
@react-pdf/reconciler/lib/reconciler-33.js:
  (**
   * @license React
   * react-reconciler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@react-pdf/reconciler/lib/reconciler-31.js:
@react-pdf/reconciler/lib/reconciler-33.js:
  (**
   * @license React
   * react-reconciler-constants.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=index.js.map
