# **The Twelve-Factor App Manifesto**

The Twelve-Factor App is a methodology for building scalable and maintainable software-as-a-service (SaaS) applications that are suitable for modern cloud platforms.1 It was created by Adam Wiggins from observations on the development and operation of thousands of applications on the Heroku platform.3 The principles are applicable to any programming language and backing services.2

**The 12 Factors:**

1. **Codebase:** One codebase, tracked in revision control, with many deploys.1 This ensures a single source of truth for the application.4 All code, configuration files, and provisioning scripts should be in this repository.5
2. **Dependencies:** Explicitly declare and isolate dependencies.1 An application should not rely on system-wide dependencies.4 Dependencies are listed in a manifest file like  
   pom.xml for Maven or package.json for Node.js, allowing for deterministic and portable builds.6
3. **Config:** Store configuration in the environment.1 This separates environment-specific settings (e.g., database credentials, API keys) from the code, enhancing security and portability.5 Environment variables are the preferred method for storing config.4
4. **Backing Services:** Treat backing services as attached resources.1 Services like databases, caches, and message queues are consumed over the network.6 The application should access them via credentials in environment variables, promoting loose coupling and easy replacement.5
5. **Build, Release, Run:** Strictly separate build and run stages.1 This creates a repeatable and auditable deployment process.4 The build stage converts source code into a bundle, the release stage combines this bundle with configuration, and the run stage executes the application.5
6. **Processes:** Execute the application as one or more stateless processes.1 Processes should be "share-nothing" and stateless to enable horizontal scaling and resilience.4 Any data that needs to persist must be stored in a backing service.6
7. **Port Binding:** Export services via port binding.1 The application becomes a self-contained network service by binding to a specified port (e.g.,  
   $PORT).7 This allows it to be easily injected into an environment and receive traffic.6
8. **Concurrency:** Scale out via the process model.1 The unit of scaling is the process.7 The application achieves horizontal scalability by running multiple identical process instances to handle increased load.7
9. **Disposability:** Maximize robustness with fast startup and graceful shutdown.1 This enables rapid elastic scaling and improves fault tolerance.7 Processes should start quickly and handle termination signals to finish in-flight requests before shutting down.6
10. **Dev/Prod Parity:** Keep development, staging, and production as similar as possible.1 This minimizes the risk of bugs and deployment surprises.7 Using containers like Docker is an effective way to achieve parity across environments.6
11. **Logs:** Treat logs as event streams.1 The application should write logs to standard output (  
    stdout).7 The execution environment then handles the aggregation, routing, and long-term storage of these logs.7
12. **Admin Processes:** Run admin/management tasks as one-off processes.1 Administrative tasks like database migrations should be run using the same codebase and environment as the main application to ensure consistency.7
